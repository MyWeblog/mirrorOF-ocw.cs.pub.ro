    
    

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"
 lang="en" dir="ltr">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>
    Laborator 8: Drumuri minime    [CS Open CourseWare]
  </title>

  <meta name="generator" content="DokuWiki"/>
<meta name="robots" content="index,follow"/>
<meta name="date" content="2016-04-17T18:12:02+0300"/>
<meta name="keywords" content="pa,laboratoare,laborator-08"/>
<link rel="search" type="application/opensearchdescription+xml" href="../../lib/exe/opensearch.php" title="CS Open CourseWare"/>
<link rel="start" href="../../../courses.1.html"/>
<link rel="alternate" type="application/rss+xml" title="Recent Changes" href="../../feed.php"/>
<link rel="alternate" type="application/rss+xml" title="Current Namespace" href="../../feed.php%3Fmode=list&amp;ns=pa:laboratoare"/>
<link rel="alternate" type="text/html" title="Plain HTML" href="../../_export/xhtml/pa/laboratoare/laborator-08.html"/>
<link rel="canonical" href="laborator-08.html"/>
<link rel="stylesheet" type="text/css" href="../../lib/exe/css.php%3Ft=arctic&amp;tseed=1476798676.css"/>
<script type="text/javascript">/*<![CDATA[*/var NS='pa:laboratoare';var JSINFO = {"id":"pa:laboratoare:laborator-08","namespace":"pa:laboratoare","isadmin":0,"isauth":0};
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="../../lib/exe/js.php%3Ftseed=1476798676"></script>
<script type="text/x-mathjax-config">/*<![CDATA[*/MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ["$","$"], ["\\(","\\)"] ],
        displayMath: [ ["$$","$$"], ["\\[","\\]"] ],
        processEscapes: true
    }
});
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
<script type="text/javascript">/*<![CDATA[*/
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
		  
/*!]]>*/</script>
<script type="text/javascript">/*<![CDATA[*/
var pageTracker = _gat._getTracker("UA-38383934-1");
pageTracker._initData();
pageTracker._trackPageview();
		  
/*!]]>*/</script>

  <link rel="shortcut icon" href="../../lib/tpl/arctic/images/favicon.ico" />

  
</head>
<body>
<div id="wrapper" class='show'>
  <div class="dokuwiki">

    
    <div class="stylehead">
      <div class="header">
        <div class="pagename">
          <a href="../index.html"><img height="70" src="../../res/sigla_cs.png"/> </a>        </div>
        <div class="logo">
          <a style="color: #AAA !important;" href="../../../courses.1.html"/>Open CourseWare</a>        </div>
      </div>
    
       
      <div class="breadcrumbs">
              </div>
      
            </div>

                  <div class="bar" id="bar__top">
        <div class="bar-left">
                  </div>
        <div class="bar-right">
          <a href="laborator-08%3Fdo=recent.html"  class="action recent" accesskey="r" rel="nofollow" title="Recent changes [R]">Recent changes</a><a href="laborator-08%3Fdo=login&amp;sectok=f62420cf5b01253da4b50505d148181b.html"  class="action login" rel="nofollow" title="Login">Login</a>        </div>
    </div>
        
    
    
    
              <div class="left_page">
          
<h1 class="sectionedit1" id="laborator_8drumuri_minime">Laborator 8: Drumuri minime</h1>
<div class="level1">

</div>

<h2 class="sectionedit2" id="obiective_laborator">Obiective laborator</h2>
<div class="level2">
<ul>
<li class="level1"><div class="li">Înțelegerea conceptelor de cost, relaxare a unei muchii, drum minim</div>
</li>
<li class="level1"><div class="li">Prezentarea si asimilarea algoritmilor pentru calculul drumurilor minime</div>
</li>
</ul>

</div>

<h2 class="sectionedit3" id="importanta_aplicatii_practice">Importanţă – aplicaţii practice</h2>
<div class="level2">

<p>
Algoritmii pentru determinarea drumurilor minime au multiple aplicații practice si reprezintă clasa de algoritmi pe grafuri cel mai des utilizata:
</p>
<ul>
<li class="level1"><div class="li">Rutare in cadrul unei rețele (telefonice, de calculatoare etc.)</div>
</li>
<li class="level1"><div class="li">Găsirea drumului minim dintre doua locații (Google Maps, GPS etc.)</div>
</li>
<li class="level1"><div class="li">Stabilirea unei agende de zbor in vederea asigurării unor conexiuni optime</div>
</li>
<li class="level1"><div class="li">Asignarea unui peer / server de fișiere in funcție de metricile definite pe fiecare linie de comunicație</div>
</li>
</ul>

</div>

<h2 class="sectionedit4" id="concepte">Concepte</h2>
<div class="level2">

</div>

<h3 class="sectionedit5" id="costul_unei_muchii_si_al_unui_drum">Costul unei muchii si al unui drum</h3>
<div class="level3">

<p>
Fiind dat un graf orientat G = (V, E), se considera funcția w: E → W, numita funcție de cost, care asociază fiecărei muchii o valoare numerica. Domeniul funcției poate fi extins, pentru a include si perechile de noduri intre care nu exista muchie directa, caz in care valoarea este +∞ . Costul unui drum format din muchiile p12 p23 … p(n-1)n, având costurile w12, w23, …, w(n-1)n, este suma w = w12 + w23 + … + w(n-1)n.
</p>

<p>
In exemplul alăturat, costul drumului de la nodul 1 la 5 este:
</p>

<p>
drumul 1: w14 + w45 = 30 + 20 = 50
</p>

<p>
drumul 2: w12 + w23 + w35 = 10 + 20 + 10 = 40
</p>

<p>
drumul 3: w13 + w35 = 50 + 10 = 60
</p>

<p>
<a href="../../_detail/pa/laboratoare/8_1.png%3Fid=pa%253Alaboratoare%253Alaborator-08.html" class="media" title="pa:laboratoare:8_1.png"><img src="../../_media/pa/laboratoare/8_1.png%3Fw=300&amp;tok=727e4b" class="media" alt="" width="300" /></a>
</p>

</div>

<h3 class="sectionedit6" id="drumul_de_cost_minim">Drumul de cost minim</h3>
<div class="level3">

<p>
Costul minim al drumului dintre doua noduri este minimul dintre costurile drumurilor existente intre cele doua noduri. In exemplul de mai sus, drumul de cost minim de la nodul 1 la 5 este prin nodurile 2 si 3.
Deși, in cele mai multe cazuri, costul este o funcție cu valori nenegative, exista situații in care un graf cu muchii de cost negativ are relevanta practica. O parte din algoritmi pot determina drumul corect de cost minim inclusiv pe astfel de grafuri. Totuși, nu are sens căutarea drumului minim in cazurile in care graful conține cicluri de cost negativ – un drum minim ar avea lungimea infinita, intrucat costul sau s-ar reduce la fiecare reparcurgere a ciclului:
</p>

<p>
In exemplul alăturat, ciclul 1 → 2 → 3 → 1 are costul -20.        <a href="../../_detail/pa/laboratoare/8_2.png%3Fid=pa%253Alaboratoare%253Alaborator-08.html" class="media" title="pa:laboratoare:8_2.png"><img src="../../_media/pa/laboratoare/8_2.png%3Fw=200&amp;tok=a742f7" class="media" alt="" width="200" /></a>
</p>

<p>
drumul 1: w12 + w23 + w35 = 10 + 20 + 10 = 40 
</p>

<p>
drumul 2: (w12 + w23 + w31) + w12 + w23 + w35 = -20 + 10 + 20 + 10 = 20 
</p>

<p>
drumul 3: (w12 + w23 + w31) + (w12 + w23 + w31) + w12 + w23 + w35 = -20 + (-20) + 10 + 20 + 10 = 0 
</p>

</div>

<h3 class="sectionedit7" id="relaxarea_unei_muchii">Relaxarea unei muchii</h3>
<div class="level3">

<p>
Relaxarea unei muchii v1 - v2 consta in a testa daca se poate reduce costul ei, trecând printr-un nod intermediar u. Fie w12 costul inițial al muchiei de la v1 la v2, w1u costul muchiei de la v1 la u, si wu2 costul muchiei de la u la v2. Daca w &gt; w1u + wu2, muchia directa este înlocuita cu succesiunea de muchii v1 - u, u - v2.
</p>

<p>
In exemplul alăturat, muchia de la 1 la 3, de cost w13 = 50, poate fi relaxata la costul 30, prin nodul intermediar u = 2, fiind înlocuita cu succesiunea w12, w23.
</p>

<p>
Toți algoritmii prezentați in continuare se bazează pe relaxare pentru a determina drumul minim.
<a href="../../_detail/pa/laboratoare/8_3.png%3Fid=pa%253Alaboratoare%253Alaborator-08.html" class="media" title="pa:laboratoare:8_3.png"><img src="../../_media/pa/laboratoare/8_3.png%3Fw=200&amp;tok=ed8c88" class="media" alt="" width="200" /></a>
</p>

</div>

<h2 class="sectionedit8" id="drumuri_minime_de_sursa_unica">Drumuri minime de sursa unica</h2>
<div class="level2">

<p>
Algoritmii din aceasta secțiune determina drumul de cost minim de la un nod sursa, la restul nodurilor din graf, pe baza de relaxări repetate.
</p>

</div>

<h3 class="sectionedit9" id="algoritmul_lui_dijkstra">Algoritmul lui Dijkstra</h3>
<div class="level3">

<p>
Dijkstra poate fi folosit doar in grafuri care au toate muchiile nenegative.
</p>

<p>
Algoritmul este de tip Greedy: <br/>

optimul local căutat este reprezentat de costul drumului dintre nodul sursa s si un nod v. Pentru fiecare nod se retine un cost estimat d[v], inițializat la început cu costul muchiei s → v, sau cu +∞, daca nu exista muchie.
</p>

<p>
In exemplul următor, sursa s este nodul 1. Inițializarea va fi: <br/>
<br/>

 <a href="../../_detail/pa/laboratoare/8_4.png%3Fid=pa%253Alaboratoare%253Alaborator-08.html" class="media" title="pa:laboratoare:8_4.png"><img src="../../_media/pa/laboratoare/8_4.png%3Fw=500&amp;tok=cd331a" class="media" alt="" width="500" /></a> <br/>
<br/>

Aceste drumuri sunt îmbunătățite la fiecare pas, pe baza celorlalte costuri estimate.
</p>

<p>
Algoritmul selectează, in mod repetat, nodul u care are, la momentul respectiv, costul estimat minim (fata de nodul sursa). In continuare, se încearcă sa se relaxeze restul costurilor d[v]. Daca d[v] &gt;= d[u] + wuv , d[v] ia valoarea d[u] + wuv.
</p>

<p>
Pentru a tine evidenta muchiilor care trebuie relaxate, se folosesc doua structuri: S (mulțimea de vârfuri deja vizitate) si Q (o coada cu priorități, in care nodurile se afla ordonate după distanta fata de sursa) din care este mereu extras nodul aflat la distanta minima. In S se afla inițial doar sursa, iar in Q doar nodurile spre care exista muchie directa de la sursa, deci care au d[nod] &lt; +∞.
</p>

<p>
In exemplul de mai sus, vom inițializa S = {1} si Q = {2, 4, 3}.
</p>

<p>
La primul pas este selectat nodul 2, care are d[2] = 10. <br/>

Singurul nod pentru care d[nod] poate fi relaxat este 3 : d[3] = 50 &gt; d[2] + w23 = 10 + 20 = 30 <br/>
<br/>

 <a href="../../_detail/pa/laboratoare/8_5.png%3Fid=pa%253Alaboratoare%253Alaborator-08.html" class="media" title="pa:laboratoare:8_5.png"><img src="../../_media/pa/laboratoare/8_5.png%3Fw=500&amp;tok=e2ca4c" class="media" alt="" width="500" /></a> <br/>
<br/>

După primul pas, S = {1, 2} si Q = {4, 3}.
</p>

<p>
La următorul pas este selectat nodul 4, care are d[4] = 30. <br/>

Pe baza lui, se poate modifica d[5] : d[5] = +∞ &gt; d[4] + w45 = 30 + 20 = 50 <br/>
<br/>

 <a href="../../_detail/pa/laboratoare/8_6.png%3Fid=pa%253Alaboratoare%253Alaborator-08.html" class="media" title="pa:laboratoare:8_6.png"><img src="../../_media/pa/laboratoare/8_6.png%3Fw=500&amp;tok=48efeb" class="media" alt="" width="500" /></a> <br/>
<br/>

După al doilea pas, S = {1, 2, 4} si Q = {3, 5}.
</p>

<p>
La următorul pas este selectat nodul 3, care are d[3] = 30, si se modifica din nou d[5]:
d[5] = 50 &gt; d[3] + w35 = 30 + 10 = 40.
</p>

<p>
Algoritmul se încheie când coada Q devine vida, sau când S conține toate nodurile. Pentru a putea determina si muchiile din care este alcătuit drumul minim căutat, nu doar costul sau final, este necesar sa reținem un vector de părinți P. Pentru nodurile care au muchie directa de la sursa, P[nod] este inițializat cu sursa, pentru restul cu null.
</p>

<p>
Pseudocodul pentru determinarea drumului minim de la o sursa către celelalte noduri utilizând algoritmul lui Dijkstra este:
</p>
<pre class="code cpp">Dijkstra<span class="br0">&#40;</span>sursa, dest<span class="br0">&#41;</span><span class="sy4">:</span>
selectat<span class="br0">&#40;</span>sursa<span class="br0">&#41;</span> <span class="sy1">=</span> <span class="kw2">true</span>
foreach nod in V <span class="co1">// V = multimea nodurilor</span>
    daca exista muchie<span class="br0">&#91;</span>sursa, nod<span class="br0">&#93;</span>
        <span class="co1">// initializam distanta pana la nodul respectiv</span>
        d<span class="br0">&#91;</span>nod<span class="br0">&#93;</span> <span class="sy1">=</span> w<span class="br0">&#91;</span>sursa, nod<span class="br0">&#93;</span>
        introdu nod in Q
        <span class="co1">// parintele nodului devine sursa</span>
        P<span class="br0">&#91;</span>nod<span class="br0">&#93;</span> <span class="sy1">=</span> sursa
    altfel
        d<span class="br0">&#91;</span>nod<span class="br0">&#93;</span> <span class="sy1">=</span> <span class="sy2">+</span>∞ <span class="co1">// distanta infinita</span>
        P<span class="br0">&#91;</span>nod<span class="br0">&#93;</span> <span class="sy1">=</span> null <span class="co1">// nu are parinte</span>
&nbsp;
<span class="co1">// relaxari succesive</span>
cat timp Q nu e vida
    u <span class="sy1">=</span> extrage_min <span class="br0">&#40;</span>Q<span class="br0">&#41;</span>
    selectat<span class="br0">&#40;</span>u<span class="br0">&#41;</span> <span class="sy1">=</span> <span class="kw2">true</span>
    foreach nod in vecini<span class="br0">&#91;</span>u<span class="br0">&#93;</span> <span class="co1">// (*)</span>
        <span class="coMULTI">/* daca drumul de la sursa la nod prin u este mai mic decat cel curent */</span>
        daca not selectat<span class="br0">&#40;</span>nod<span class="br0">&#41;</span> si d<span class="br0">&#91;</span>nod<span class="br0">&#93;</span> <span class="sy1">&gt;</span> d<span class="br0">&#91;</span>u<span class="br0">&#93;</span> <span class="sy2">+</span> w<span class="br0">&#91;</span>u, nod<span class="br0">&#93;</span>
	    <span class="co1">// actualizeaza distanta si parinte</span>
            d<span class="br0">&#91;</span>nod<span class="br0">&#93;</span> <span class="sy1">=</span> d<span class="br0">&#91;</span>u<span class="br0">&#93;</span> <span class="sy2">+</span> w<span class="br0">&#91;</span>u, nod<span class="br0">&#93;</span>
            P<span class="br0">&#91;</span>nod<span class="br0">&#93;</span> <span class="sy1">=</span> u
            <span class="coMULTI">/* actualizeaza pozitia nodului in coada prioritara */</span>
            actualizeaza <span class="br0">&#40;</span>Q,nod<span class="br0">&#41;</span>
&nbsp;
<span class="co1">// gasirea drumului efectiv</span>
Initializeaza Drum <span class="sy1">=</span> <span class="br0">&#123;</span><span class="br0">&#125;</span>
nod <span class="sy1">=</span> P<span class="br0">&#91;</span>dest<span class="br0">&#93;</span>
cat timp nod <span class="sy3">!</span><span class="sy1">=</span> null
    insereaza nod la inceputul lui Drum
    nod <span class="sy1">=</span> P<span class="br0">&#91;</span>nod<span class="br0">&#93;</span></pre>

<p>
Reprezentarea grafului ca matrice de adiacenta duce la o implementare ineficienta pentru orice graf care nu este complet, datorita parcurgerii vecinilor nodului u, din linia (*), care se va executa în |V| pași pentru fiecare extragere din Q, iar pe întreg algoritmul vor rezulta |V|^2 pași. Este preferata reprezentarea grafului cu liste de adiacenta, pentru care numărul total de operații cauzate de linia (*) va fi egal cu |E|.
Complexitatea algoritmului este O(|V|^2+|E|) în cazul în care coada cu priorități este implementata ca o căutare liniara. În acest caz funcția extrage_min se executa în timp O(|V|), iar actualizează(Q) in timp O(1).
</p>

<p>
O varianta mai eficienta este implementarea cozii ca heap binar. Funcția extrage_min se va executa în timp O(lg|V|); funcția actualizează(Q) se va executa tot în timp O(lg|V|), dar trebuie cunoscuta poziția cheii nod în heap, adică heapul trebuie sa fie indexat. Complexitatea obținută este O(|E|lg|V|) pentru un graf conex.
</p>

<p>
Cea mai eficienta implementare se obține folosind un heap Fibonacci pentru coada cu priorități:
</p>

<p>
Aceasta este o structura de date complexa, dezvoltata în mod special pentru optimizarea algoritmului Dijkstra, caracterizata de un timp amortizat de O(lg|V|) pentru operația extrage_min si numai O(1) pentru actualizeaza(Q). Complexitatea obținută este O(|V|lg|V| + |E|), foarte bună pentru grafuri rare.
</p>

</div>

<h3 class="sectionedit10" id="algoritmul_bellman_ford">Algoritmul Bellman – Ford</h3>
<div class="level3">

<p>
Algoritmul Bellman Ford poate fi folosit si pentru grafuri ce conțin muchii de cost negativ, dar nu poate fi folosit pentru grafuri ce conțin cicluri de cost negativ (când căutarea unui drum minim nu are sens). <br/>

Cu ajutorul sau putem afla daca un graf conține cicluri.
Algoritmul folosește același mecanism de relaxare ca si Dijkstra, dar, spre deosebire de acesta, nu optimizează o soluție folosind un criteriu de optim local, ci parcurge fiecare muchie de un număr de ori egal cu numărul de noduri si încearcă sa o relaxeze de fiecare data, pentru a îmbunătăți distanta până la nodul destinație al muchiei curente.
</p>

<p>
Motivul pentru care se face acest lucru este ca drumul minim dintre sursa si orice nod destinație poate sa treacă prin maximum |V| noduri (adică toate nodurile grafului), respectiv |V|-1 muchii; prin urmare, relaxarea tuturor muchiilor de |V|-1 ori este suficienta pentru a propaga până la toate nodurile informația despre distanta minima de la sursa.
</p>

<p>
Daca, la sfârșitul acestor |E|*(|V|-1) relaxări, mai poate fi îmbunătățită o distanță, atunci graful are un ciclu de cost negativ si problema nu are soluție.
</p>

<p>
Menținând notațiile anterioare, pseudocodul algoritmului este:
</p>
<pre class="code cpp">BellmanFord<span class="br0">&#40;</span>sursa<span class="br0">&#41;</span><span class="sy4">:</span>
<span class="co1">// initializari</span>
foreach nod in V <span class="co1">// V = multimea nodurilor</span>
    daca muchie<span class="br0">&#91;</span>sursa, nod<span class="br0">&#93;</span>
        d<span class="br0">&#91;</span>nod<span class="br0">&#93;</span> <span class="sy1">=</span> w<span class="br0">&#91;</span>sursa, nod<span class="br0">&#93;</span>
        P<span class="br0">&#91;</span>nod<span class="br0">&#93;</span> <span class="sy1">=</span> sursa
    altfel
        d<span class="br0">&#91;</span>nod<span class="br0">&#93;</span> <span class="sy1">=</span> <span class="sy2">+</span>∞
        P<span class="br0">&#91;</span>nod<span class="br0">&#93;</span> <span class="sy1">=</span> null
d<span class="br0">&#91;</span>sursa<span class="br0">&#93;</span> <span class="sy1">=</span> <span class="nu0">0</span>
p<span class="br0">&#91;</span>sursa<span class="br0">&#93;</span> <span class="sy1">=</span> null
&nbsp;
<span class="co1">// relaxari succesive</span>
<span class="co1">// cum in initializare se face o relaxare (daca exista drum direct de la sursa la nod =&gt; </span>
<span class="co1">// d[nod] = w[sursa, nod]) mai sunt necesare |V-2| relaxari </span>
<span class="kw1">for</span> i <span class="sy1">=</span> <span class="nu0">1</span> to <span class="sy3">|</span>V<span class="sy3">|</span><span class="sy2">-</span><span class="nu0">2</span> 
    foreach <span class="br0">&#40;</span>u, v<span class="br0">&#41;</span> in E  <span class="co1">// E = multimea muchiilor</span>
        daca d<span class="br0">&#91;</span>v<span class="br0">&#93;</span> <span class="sy1">&gt;</span> d<span class="br0">&#91;</span>u<span class="br0">&#93;</span> <span class="sy2">+</span> w<span class="br0">&#40;</span>u,v<span class="br0">&#41;</span>
            d<span class="br0">&#91;</span>v<span class="br0">&#93;</span> <span class="sy1">=</span> d<span class="br0">&#91;</span>u<span class="br0">&#93;</span> <span class="sy2">+</span> w<span class="br0">&#40;</span>u,v<span class="br0">&#41;</span>
            p<span class="br0">&#91;</span>v<span class="br0">&#93;</span> <span class="sy1">=</span> u<span class="sy4">;</span>
&nbsp;
<span class="co1">// daca se mai pot relaxa muchii</span>
foreach <span class="br0">&#40;</span>u, v<span class="br0">&#41;</span> in E
    daca d<span class="br0">&#91;</span>v<span class="br0">&#93;</span> <span class="sy1">&gt;</span> d<span class="br0">&#91;</span>u<span class="br0">&#93;</span> <span class="sy2">+</span> w<span class="br0">&#40;</span>u,v<span class="br0">&#41;</span>
        fail <span class="br0">&#40;</span>”exista cicluri negativ”<span class="br0">&#41;</span></pre>

<p>
Complexitatea algoritmului este O(|E|*|V|).
</p>

</div>

<h2 class="sectionedit11" id="drumuri_minime_intre_oricare_doua_noduri">Drumuri minime intre oricare doua noduri</h2>
<div class="level2">

</div>

<h3 class="sectionedit12" id="floyd-warshall">Floyd-Warshall</h3>
<div class="level3">

<p>
Algoritmii din aceasta secțiune determina drumul de cost minim dintre oricare doua noduri dintr-un graf. Pentru a rezolva aceasta problema s-ar putea aplica unul din algoritmii de mai sus, considerând ca sursa fiecare nod, pe rând, dar o astfel de abordare ar fi ineficienta.
</p>

<p>
Algoritmul Floyd-Warshall(intalnit si sub numele de Roy-Floyd) compara toate drumurile posibile din graf dintre fiecare 2 noduri, si poate fi utilizat si in grafuri cu muchii de cost negativ.
</p>

<p>
Estimarea drumului optim poate fi reținut intr-o structura tridimensionala d[v1, v2, k], cu semnificația – costul minim al drumului de la v1 la v2, folosind ca noduri intermediare doar noduri pana la nodul k. Daca nodurile sunt numerotate de la 1, atunci d[v1, v2, 0] reprezintă costul muchiei directe de la v1 la v2, considerând +∞ daca aceasta nu exista. Exemplu, pentru v1 = 1, respectiv 2: <br/>
<br/>

 <a href="../../_detail/pa/laboratoare/8_7.png%3Fid=pa%253Alaboratoare%253Alaborator-08.html" class="media" title="pa:laboratoare:8_7.png"><img src="../../_media/pa/laboratoare/8_7.png%3Fw=500&amp;tok=23dcd9" class="media" alt="" width="500" /></a> <br/>
<br/>

Pornind cu valori ale lui k de la 1 la |V|, ne interesează să găsim cea mai scurta cale de la fiecare v1 la fiecare v2 folosind doar noduri intermedire din mulțimea {1, …, k}. De fiecare data, comparam costul deja estimat al drumului de la v1 la v2, deci d[v1, v2,   k-1] obținut la pasul anterior, cu costul drumurilor de la v1 la k si de la k la v2, adică d[v1, k, k-1] + d[k, v2, k-1], obținutae la pasul anterior.
Atunci, d[v1, v2, |V|] va conține costul drumului minim de la v1 la v2.
</p>

<p>
Pseudocodul acestui algoritm este:
</p>
<pre class="code cpp">FloydWarshall<span class="br0">&#40;</span>G<span class="br0">&#41;</span><span class="sy4">:</span>
n <span class="sy1">=</span> <span class="sy3">|</span>V<span class="sy3">|</span>
<span class="kw4">int</span> d<span class="br0">&#91;</span>n, n, n<span class="br0">&#93;</span>
foreach <span class="br0">&#40;</span>i, j<span class="br0">&#41;</span> in <span class="br0">&#40;</span><span class="nu0">1</span>..<span class="me1">n</span>,<span class="nu0">1</span>..<span class="me1">n</span><span class="br0">&#41;</span>
    d<span class="br0">&#91;</span>i, j, <span class="nu0">0</span><span class="br0">&#93;</span> <span class="sy1">=</span> w<span class="br0">&#91;</span>i,j<span class="br0">&#93;</span> <span class="co1">// costul muchiei, sau infinit</span>
<span class="kw1">for</span> k <span class="sy1">=</span> <span class="nu0">1</span> to n
    foreach <span class="br0">&#40;</span>i,j<span class="br0">&#41;</span> in <span class="br0">&#40;</span><span class="nu0">1</span>..<span class="me1">n</span>,<span class="nu0">1</span>..<span class="me1">n</span><span class="br0">&#41;</span>
        d<span class="br0">&#91;</span>i, j, k<span class="br0">&#93;</span> <span class="sy1">=</span> min<span class="br0">&#40;</span>d<span class="br0">&#91;</span>i, j, k<span class="sy2">-</span><span class="nu0">1</span><span class="br0">&#93;</span>, d<span class="br0">&#91;</span>i, k, k<span class="sy2">-</span><span class="nu0">1</span><span class="br0">&#93;</span> <span class="sy2">+</span> d<span class="br0">&#91;</span>k, j, k<span class="sy2">-</span><span class="nu0">1</span><span class="br0">&#93;</span><span class="br0">&#41;</span></pre>

<p>
Complexitatea temporala este O(|V|^3), iar cea spațială este tot O(|V|^3).
O complexitate spațială cu un ordin mai mic se obține observând ca la un pas nu este nevoie decât de matricea de la pasul precedent d[i, j, k-1] si cea de la pasul curent d[i, j, k]. O observație și mai bună este că, de la un pas k-1 la k, estimările lungimilor nu pot decât sa scadă, deci putem sa lucram pe o singura matrice. Deci, spațiul de memorie necesar este de dimensiune |V|^2.
</p>

<p>
Rescris, pseudocodul algoritmului arata astfel:
</p>
<pre class="code cpp">FloydWarshall<span class="br0">&#40;</span>G<span class="br0">&#41;</span><span class="sy4">:</span>
n <span class="sy1">=</span> <span class="sy3">|</span>V<span class="sy3">|</span>
<span class="kw4">int</span> d<span class="br0">&#91;</span>n, n<span class="br0">&#93;</span>
foreach <span class="br0">&#40;</span>i, j<span class="br0">&#41;</span> in <span class="br0">&#40;</span><span class="nu0">1</span>..<span class="me1">n</span>,<span class="nu0">1</span>..<span class="me1">n</span><span class="br0">&#41;</span>
    d<span class="br0">&#91;</span>i, j<span class="br0">&#93;</span> <span class="sy1">=</span> w<span class="br0">&#91;</span>i,j<span class="br0">&#93;</span> <span class="co1">// costul muchiei, sau infinit</span>
<span class="kw1">for</span> k <span class="sy1">=</span> <span class="nu0">1</span> to n
    foreach <span class="br0">&#40;</span>i,j<span class="br0">&#41;</span> in <span class="br0">&#40;</span><span class="nu0">1</span>..<span class="me1">n</span>,<span class="nu0">1</span>..<span class="me1">n</span><span class="br0">&#41;</span>
        d<span class="br0">&#91;</span>i, j<span class="br0">&#93;</span> <span class="sy1">=</span> min<span class="br0">&#40;</span>d<span class="br0">&#91;</span>i, j<span class="br0">&#93;</span>, d<span class="br0">&#91;</span>i, k<span class="br0">&#93;</span> <span class="sy2">+</span> d<span class="br0">&#91;</span>k, j<span class="br0">&#93;</span><span class="br0">&#41;</span></pre>

<p>
Pentru a determina drumul efectiv, nu doar costul acestuia, avem doua variante:
</p>

<p>
1.	Se retine o structura de părinți, similara cu cea de la Dijkstra, dar, bineînțeles, bidimensionala. <br/>

2.	Se folosește divide et impera astfel:
</p>

<p>
- se caută un pivot k astfel încât cost[i][j] = cost[i][k] + cost[j][k] <br/>

- se apelează funcția recursiv pentru ambele drumuri → (i,k),(k,j) <br/>

- dacă pivotul nu poate fi găsit, afișăm i <br/>

- după terminarea funcției recursie afișăm extremitatea dreapta a drumului <br/>

</p>

</div>

<h2 class="sectionedit13" id="cazuri_speciale">Cazuri speciale</h2>
<div class="level2">

<p>
1. Daca avem un graf <strong>neorientat</strong>, <strong>fara cicluri</strong> (un arbore), exista un singur
drum intre oricare doua noduri, care poate fi aflat printr-o simpla parcurgere DFS.
Folosind diferite preprocesari [8],[9], putem calcula distanta intre oricare doua noduri
in timp constant, O(1).
</p>

<p>
2. Daca avem un graf <strong>orientat</strong>, <strong>fara cicluri</strong> (un DAG [10]), putem sa sa relaxam muchiile nodurilor, parcurgandu-le pe acestea in ordinea data de sortarea topologica. O(|V|+|E|)
</p>

<p>
3. Daca avem un graf unde toate muchiile au <strong>cost egal</strong>, putem afla distanta minima de la
un nod sursa la orice alt nod printr-o parcurgere BFS. (de asemenea, tinand cont de faptul ca 
pot exista mai multe drumuri pana la un anumit nod). O(|V|+|E|)
</p>

<p>
4. Pentru grafuri orientate, <strong>rare</strong> (relativ putine muchii), putem folosi algoritmul lui Johnson([11]) pentru 
calcularea distantei minime de la un nod, la oricare alt nod. O(|V|^2log|V| + |V||E|)
</p>

</div>

<h2 class="sectionedit14" id="concluzii">Concluzii</h2>
<div class="level2">
<ul>
<li class="level1"><div class="li"><strong>Dijkstra</strong>*</div>
</li>
</ul>

<p>
–	calculează drumurile minime de la o sursa către celelalte noduri <br/>

–	nu poate fi folosit daca exista muchii de cost negativ <br/>

–	complexitate minima O(|V|lg|V| + |E|) utilizând heapuri Fibonacci;<br/>

</p>
<ul>
<li class="level1"><div class="li"><strong>Bellman – Ford</strong></div>
</li>
</ul>

<p>
–	calculează drumurile minime de la o sursă către celelalte noduri <br/>

–	detectează existența ciclurilor de cost negativ <br/>

–	complexitate O(|V| * |E|) <br/>

</p>
<ul>
<li class="level1"><div class="li"><strong>Floyd – Warshall</strong></div>
</li>
</ul>

<p>
–	calculează drumurile minime intre oricare doua noduri din graf <br/>

–	poate fi folosit in grafuri cu cicluri de cost negativ, dar nu le detectează <br/>

–	complexitate O(|V|^3) <br/>

</p>

</div>

<h2 class="sectionedit15" id="referinte">Referinţe:</h2>
<div class="level2">

<p>
[1] <a href="http://en.wikipedia.org/wiki/Dijkstra's_algorithm" class="urlextern" title="http://en.wikipedia.org/wiki/Dijkstra&#039;s_algorithm"  rel="nofollow">http://en.wikipedia.org/wiki/Dijkstra&#039;s_algorithm</a>
</p>

<p>
[2] <a href="http://en.wikipedia.org/wiki/Bellman-Ford_algorithm" class="urlextern" title="http://en.wikipedia.org/wiki/Bellman-Ford_algorithm"  rel="nofollow">http://en.wikipedia.org/wiki/Bellman-Ford_algorithm</a>
</p>

<p>
[3] <a href="http://www.algorithmist.com/index.php/Floyd-Warshall's_Algorithm" class="urlextern" title="http://www.algorithmist.com/index.php/Floyd-Warshall&#039;s_Algorithm"  rel="nofollow">http://www.algorithmist.com/index.php/Floyd-Warshall&#039;s_Algorithm</a>
</p>

<p>
[4] <a href="http://en.wikipedia.org/wiki/Binary_heap" class="urlextern" title="http://en.wikipedia.org/wiki/Binary_heap"  rel="nofollow">http://en.wikipedia.org/wiki/Binary_heap</a>
</p>

<p>
[5] <a href="http://en.wikipedia.org/wiki/Fibonacci_heap" class="urlextern" title="http://en.wikipedia.org/wiki/Fibonacci_heap"  rel="nofollow">http://en.wikipedia.org/wiki/Fibonacci_heap</a>
</p>

<p>
[6] T. Cormen, C. Leiserson, R. Rivest, C. Stein – Introducere în Algoritmi
</p>

<p>
[7] C. Giumale – Introducere în analiza algoritmilor
</p>

<p>
[8] <a href="http://en.wikipedia.org/wiki/Range_Minimum_Query" class="urlextern" title="http://en.wikipedia.org/wiki/Range_Minimum_Query"  rel="nofollow">http://en.wikipedia.org/wiki/Range_Minimum_Query</a>
</p>

<p>
[9] <a href="http://en.wikipedia.org/wiki/Lowest_common_ancestor" class="urlextern" title="http://en.wikipedia.org/wiki/Lowest_common_ancestor"  rel="nofollow">http://en.wikipedia.org/wiki/Lowest_common_ancestor</a>
</p>

<p>
[10] <a href="http://en.wikipedia.org/wiki/Directed_acyclic_graph" class="urlextern" title="http://en.wikipedia.org/wiki/Directed_acyclic_graph"  rel="nofollow">http://en.wikipedia.org/wiki/Directed_acyclic_graph</a>
</p>

<p>
[11] <a href="http://en.wikipedia.org/wiki/Johnson%27s_algorithm" class="urlextern" title="http://en.wikipedia.org/wiki/Johnson%27s_algorithm"  rel="nofollow">http://en.wikipedia.org/wiki/Johnson%27s_algorithm</a>
</p>

</div>

<h2 class="sectionedit16" id="resurse">Resurse</h2>
<div class="level2">
<ul>
<li class="level1"><div class="li"> <a href="http://cs.curs.pub.ro/2015/pluginfile.php/32415/mod_resource/content/1/Lab%208%20Drumuri%20minime.pdf" class="urlextern" title="http://cs.curs.pub.ro/2015/pluginfile.php/32415/mod_resource/content/1/Lab%208%20Drumuri%20minime.pdf"  rel="nofollow">Varianta PDF a laboratorului</a></div>
</li>
</ul>

</div>

<h2 class="sectionedit17" id="probleme">Probleme</h2>
<div class="level2">

<p>
<p><div class="noteimportant">
La finalul laboratorului, încărcați soluțiile <a href="http://cs.curs.pub.ro/2015/mod/assign/view.php?id=5466" class="urlextern" title="http://cs.curs.pub.ro/2015/mod/assign/view.php?id=5466"  rel="nofollow">aici</a>.

</div></p>
</p>

<p>
1) Andrei primește o hartă a Europei pe care sunt marcate toate zborurile posibile de la o localitate la alta, respectiv costurile acestora. Ca primă evaluare, Andrei își dorește să afle dacă două localități sunt conectate, indiferent de numărul de escale sau de linia aeriană. (hint: închidere tranzitivă - alg. Floyd-Warshall) <strong>[3p]</strong>
</p>

<p>
2) Ulterior, Andrei își dorește să afle toate localitățiile aflate pe drumul optim de la un oras la altul. (hint: Floyd-Warshall cu păstrarea părintelui) <strong>[2p]</strong>
</p>

<p>
3) Întrucât Andrei se simte depășit de numărul foarte mare de localități de pe hartă, vă rugăm să identificați costul unei rute optime de la o singura localitate (cea în care se află Andrei) la oricare altă localitate. (hint: Dijkstra) <strong>[5p]</strong>
</p>

<p>
4) Discutând cu un prieten, Andrei descoperă că pe anumite rute companiile oferă reduceri semnificative, clienții fideli primind chiar recompense financiare dacă aleg anumite rute. Determinați în aceste circumstanțe costul optim de la localitatea curentă la oricare altă localitate. <strong>[1p]</strong>
În final, lui Andrei îi vine o idee ingenioasă și vă rugăm îl ajutați să descopere dacă există posibilitatea de a specula recompensele liniilor aeriere pentru a circula la infinit între două localități, fără a plăti. În cazul identificării unei astfel de rute, vă rugăm să o şi afișați. (hint: Bellman-Ford și identificarea ciclurilor de cost negativ) <strong>[1p]</strong>
</p>

</div>

        </div>
        <div class="right_sidebar">
          <form action="../../start.html" accept-charset="utf-8" class="search" id="dw__search" method="get"><div class="no"><input type="hidden" name="do" value="search" /><input type="text" id="qsearch__in" accesskey="f" name="id" class="edit" title="[F]" /><input type="submit" value="Search" class="button" title="Search" /><div id="qsearch__out" class="ajax_qsearch JSpopup"></div></div></form>          <div class="namespace_sidebar sidebar_box">

<h2 class="sectionedit1" id="diverse">Diverse</h2>
<div class="level2">
<ul>
<li class="level1"><div class="li"> <a href="../echipa-pa-2006-2012.html" class="wikilink1" title="pa:echipa-pa-2006-2012">Hall of PA</a></div>
</li>
<li class="level1"><div class="li"> <a href="../regulamente.html" class="wikilink1" title="pa:regulamente">Regulamente PA 2016</a></div>
</li>
<li class="level1"><div class="li"> <a href="../proiect.html" class="wikilink1" title="pa:proiect">Proiect</a></div>
</li>
<li class="level1"><div class="li"> <a href="../catalog.html" class="wikilink1" title="pa:catalog">Catalog</a></div>
</li>
<li class="level1"><div class="li"> <a href="../test_practic.html" class="wikilink1" title="pa:test_practic">Test practic</a></div>
</li>
</ul>

</div>
<!-- EDIT1 SECTION "Diverse" [1-254] -->
<h2 class="sectionedit2" id="schelet_cod">Schelet Cod</h2>
<div class="level2">
<ul>
<li class="level1"><div class="li"> <a href="../../_media/pa/lab00.zip" class="media mediafile mf_zip" title="pa:lab00.zip (8.4 KB)">Laborator 0: Introducere și Relaxare</a></div>
</li>
<li class="level1"><div class="li"> <a href="../../_media/pa/schelete/2015/lab01.zip" class="media mediafile mf_zip" title="pa:schelete:2015:lab01.zip (35.5 KB)">Laborator 1: Divide et Impera</a></div>
</li>
<li class="level1"><div class="li"> <a href="../../_media/pa/schelete/2016/lab02-skel.zip" class="media mediafile mf_zip" title="pa:schelete:2016:lab02-skel.zip (53.5 KB)">Laborator 2: Greedy</a></div>
</li>
<li class="level1"><div class="li"> <a href="../../_media/pa/schelete/2016/lab03.zip" class="media mediafile mf_zip" title="pa:schelete:2016:lab03.zip (6.3 KB)">Laborator 3: Programare Dinamică</a></div>
</li>
<li class="level1"><div class="li"> <a href="../../_media/pa/schelete/2014/lab04.zip" class="media mediafile mf_zip" title="pa:schelete:2014:lab04.zip (23.2 KB)">Laborator 4: Backtracking și optimizări</a></div>
</li>
<li class="level1"><div class="li"> <a href="../../_media/pa/schelete/lab05.zip" class="media mediafile mf_zip" title="pa:schelete:lab05.zip (10.8 KB)">Laborator 5: Minimax</a></div>
</li>
<li class="level1"><div class="li"> <a href="../../_media/pa/schelete/2016/lab06.zip" class="media mediafile mf_zip" title="pa:schelete:2016:lab06.zip (37.7 KB)">Laborator 6: Parcurgerea Grafurilor. Sortare Topologică</a></div>
</li>
<li class="level1"><div class="li"> <a href="../../_media/pa/schelete/2016/lab07.zip" class="media mediafile mf_zip" title="pa:schelete:2016:lab07.zip (14.2 KB)"> Laborator 7: Aplicații DFS</a></div>
</li>
<li class="level1"><div class="li"> <a href="../../_media/pa/schelete/2016/lab08.zip" class="media mediafile mf_zip" title="pa:schelete:2016:lab08.zip (20.7 KB)">Laborator 8: Drumuri minime</a></div>
</li>
<li class="level1"><div class="li"> <a href="../../_media/pa/schelete/2016/lab09.zip" class="media mediafile mf_zip" title="pa:schelete:2016:lab09.zip (6.4 KB)">Laborator 9: Arbori minimi de acoperire</a></div>
</li>
<li class="level1"><div class="li"> <a href="../../_media/pa/schelete/2014/lab10.zip" class="media mediafile mf_zip" title="pa:schelete:2014:lab10.zip (29.4 KB)">Laborator 10: Flux Maxim</a></div>
</li>
<li class="level1"><div class="li"> <a href="../../_media/pa/schelete/2014/lab11.zip" class="media mediafile mf_zip" title="pa:schelete:2014:lab11.zip (38.1 KB)">Laborator 11: A*</a></div>
</li>
<li class="level1"><div class="li"> <a href="../../_media/pa/lab12.zip" class="media mediafile mf_zip" title="pa:lab12.zip (10.9 KB)">Laborator 12: Algoritmi Aleatori</a></div>
</li>
</ul>
<ul>
<li class="level1"><div class="li"> <a href="https://github.com/laurentiustamate94/laboratoare-pa-c-sharp" class="urlextern" title="https://github.com/laurentiustamate94/laboratoare-pa-c-sharp"  rel="nofollow">Schelete de cod in C# pentru 2014-2015</a></div>
</li>
</ul>

</div>
<!-- EDIT2 SECTION "Schelet Cod" [255-1244] -->
<h2 class="sectionedit3" id="laboratoare">Laboratoare</h2>
<div class="level2">
<ul>
<li class="level1"><div class="li"> <a href="laborator-00.html" class="wikilink1" title="pa:laboratoare:laborator-00">Laborator 0: Introducere și Relaxare</a></div>
</li>
<li class="level1"><div class="li"> <a href="laborator-01.html" class="wikilink1" title="pa:laboratoare:laborator-01">Laborator 1: Divide et Impera</a> </div>
</li>
<li class="level1"><div class="li"> <a href="laborator-02.html" class="wikilink1" title="pa:laboratoare:laborator-02">Laborator 2 &amp; 3: Greedy și Programare Dinamică</a></div>
</li>
<li class="level1"><div class="li"> <a href="laborator-04.html" class="wikilink1" title="pa:laboratoare:laborator-04">Laborator 4: Backtracking și optimizări</a></div>
</li>
<li class="level1"><div class="li"> <a href="laborator-05.html" class="wikilink1" title="pa:laboratoare:laborator-05">Laborator 5: Minimax</a></div>
</li>
<li class="level1"><div class="li"> <a href="laborator-06.html" class="wikilink1" title="pa:laboratoare:laborator-06">Laborator 6: Parcurgerea Grafurilor. Sortare Topologică</a></div>
</li>
<li class="level1"><div class="li"> <a href="laborator-07.html" class="wikilink1" title="pa:laboratoare:laborator-07">Laborator 7: Aplicații DFS</a></div>
</li>
<li class="level1"><div class="li"> <span class="curid"><a href="laborator-08.html" class="wikilink1" title="pa:laboratoare:laborator-08">Laborator 8: Drumuri minime</a></span></div>
</li>
<li class="level1"><div class="li"> <a href="laborator-09.html" class="wikilink1" title="pa:laboratoare:laborator-09">Laborator 9: Arbori minimi de acoperire</a></div>
</li>
<li class="level1"><div class="li"> <a href="laborator-10.html" class="wikilink1" title="pa:laboratoare:laborator-10">Laborator 10: Flux Maxim</a></div>
</li>
<li class="level1"><div class="li"> <a href="laborator-11.html" class="wikilink1" title="pa:laboratoare:laborator-11">Laborator 11: A*</a></div>
</li>
<li class="level1"><div class="li"> <a href="laborator-12.html" class="wikilink1" title="pa:laboratoare:laborator-12">Laborator 12: Algoritmi Aleatori</a> </div>
</li>
</ul>

</div>
<!-- EDIT3 SECTION "Laboratoare" [1245-2123] -->
<h2 class="sectionedit4" id="materiale_suplimentare_test_practic">Materiale Suplimentare Test Practic</h2>
<div class="level2">
<ul>
<li class="level1"><div class="li"> <a href="../materiale_test_practic/articole.html" class="wikilink1" title="pa:materiale_test_practic:articole">Articole</a></div>
</li>
<li class="level1"><div class="li"> <a href="../materiale_test_practic/probleme.html" class="wikilink1" title="pa:materiale_test_practic:probleme">Probleme</a></div>
</li>
</ul>

</div>
<!-- EDIT4 SECTION "Materiale Suplimentare Test Practic" [2124-2278] -->
<h2 class="sectionedit5" id="crash-course_optional">Crash-course Opțional</h2>
<div class="level2">
<ul>
<li class="level1"><div class="li"> <a href="../curs-optional/sd-si-debugging.html" class="wikilink1" title="pa:curs-optional:sd-si-debugging">Debugging și Structuri de Date</a></div>
</li>
<li class="level1"><div class="li"> <a href="../../_media/pa/workshop.zip" class="media mediafile mf_zip" title="pa:workshop.zip (36.9 KB)">Schelet: Debugging și Structuri de Date</a></div>
</li>
</ul>

</div>
<!-- EDIT5 SECTION "Crash-course Opțional" [2279-] -->
</div>
<div class="toc_sidebar sidebar_box">
<!-- TOC START -->
<div id="sb__right__dw__toc">
<h3 class="toggle">Table of Contents</h3>
<div>

<ul class="toc">
<li class="level1"><div class="li"><a href="laborator-08.html#laborator_8drumuri_minime">Laborator 8: Drumuri minime</a></div>
<ul class="toc">
<li class="level2"><div class="li"><a href="laborator-08.html#obiective_laborator">Obiective laborator</a></div></li>
<li class="level2"><div class="li"><a href="laborator-08.html#importanta_aplicatii_practice">Importanţă – aplicaţii practice</a></div></li>
<li class="level2"><div class="li"><a href="laborator-08.html#concepte">Concepte</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="laborator-08.html#costul_unei_muchii_si_al_unui_drum">Costul unei muchii si al unui drum</a></div></li>
<li class="level3"><div class="li"><a href="laborator-08.html#drumul_de_cost_minim">Drumul de cost minim</a></div></li>
<li class="level3"><div class="li"><a href="laborator-08.html#relaxarea_unei_muchii">Relaxarea unei muchii</a></div></li>
</ul>
</li>
<li class="level2"><div class="li"><a href="laborator-08.html#drumuri_minime_de_sursa_unica">Drumuri minime de sursa unica</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="laborator-08.html#algoritmul_lui_dijkstra">Algoritmul lui Dijkstra</a></div></li>
<li class="level3"><div class="li"><a href="laborator-08.html#algoritmul_bellman_ford">Algoritmul Bellman – Ford</a></div></li>
</ul>
</li>
<li class="level2"><div class="li"><a href="laborator-08.html#drumuri_minime_intre_oricare_doua_noduri">Drumuri minime intre oricare doua noduri</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="laborator-08.html#floyd-warshall">Floyd-Warshall</a></div></li>
</ul>
</li>
<li class="level2"><div class="li"><a href="laborator-08.html#cazuri_speciale">Cazuri speciale</a></div></li>
<li class="level2"><div class="li"><a href="laborator-08.html#concluzii">Concluzii</a></div></li>
<li class="level2"><div class="li"><a href="laborator-08.html#referinte">Referinţe:</a></div></li>
<li class="level2"><div class="li"><a href="laborator-08.html#resurse">Resurse</a></div></li>
<li class="level2"><div class="li"><a href="laborator-08.html#probleme">Probleme</a></div></li>
</ul></li>
</ul>
</div>
</div>
<!-- TOC END -->
</div>
        </div>
      
    
      <div class="stylefoot">
        <div class="meta">
          <div class="user">
                    </div>
          <div class="doc">
          pa/laboratoare/laborator-08.txt · Last modified: 2016/04/17 18:12 by andrei_mario.dinu          </div>
        </div>
      </div>

    <div class="clearer"></div>

    
                <div class="bar" id="bar__bottom">
      <div class="bar-left">
              </div>
      <div class="bar-right">
        <a href="laborator-08%3Fdo=media&amp;ns=pa%253Alaboratoare.html"  class="action media" rel="nofollow" title="Media Manager">Media Manager</a><a href="laborator-08.html#dokuwiki__top"  class="action top" accesskey="t" rel="nofollow" title="Back to top [T]">Back to top</a>      </div>
    </div>
    <div class="clearer"></div>
            
    <div align="center" class="footerinc">
  <div class="license"><a href="http://creativecommons.org/licenses/by-sa/3.0/" rel="license"><img src="../../lib/images/license/button/cc-by-sa.png" alt="CC Attribution-Share Alike 3.0 Unported" /></a></div>
  <a target="_blank" href="http://www.chimeric.de" title="www.chimeric.de"><img src="../../lib/tpl/arctic/images/button-chimeric-de.png" width="80" height="15" alt="www.chimeric.de" border="0" /></a>

  <a target="_blank" href="http://jigsaw.w3.org/css-validator/check/referer" title="Valid CSS"><img src="../../lib/tpl/arctic/images/button-css.png" width="80" height="15" alt="Valid CSS" border="0" /></a>

  <a target="_blank" href="http://wiki.splitbrain.org/wiki:dokuwiki" title="Driven by DokuWiki"><img src="../../lib/tpl/arctic/images/button-dw.png" width="80" height="15" alt="Driven by DokuWiki" border="0" /></a>

  <a target="_blank" href="http://www.firefox-browser.de" title="do yourself a favour and use a real browser - get firefox"><img src="../../lib/tpl/arctic/images/button-firefox.png" width="80" height="15" alt="do yourself a favour and use a real browser - get firefox!!" border="0" /></a>
  
  <a target="_blank" href="../../feed.php" title="Recent changes RSS feed"><img src="../../lib/tpl/arctic/images/button-rss.png" width="80" height="15" alt="Recent changes RSS feed" border="0" /></a>

  <a target="_blank" href="http://validator.w3.org/check/referer" title="Valid XHTML 1.0"><img src="../../lib/tpl/arctic/images/button-xhtml.png" width="80" height="15" alt="Valid XHTML 1.0" border="0" /></a>
</div>

  </div>
</div>

<div class="no"><img src="../../lib/exe/indexer.php%3Fid=pa%253Alaboratoare%253Alaborator-08&amp;1479891581" width="2" height="1" alt="" /></div>
</body>
</html>
