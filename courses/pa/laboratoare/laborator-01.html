    
    

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"
 lang="en" dir="ltr">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>
    Laborator 1: Divide et Impera    [CS Open CourseWare]
  </title>

  <meta name="generator" content="DokuWiki"/>
<meta name="robots" content="index,follow"/>
<meta name="date" content="2016-03-03T11:54:55+0200"/>
<meta name="keywords" content="pa,laboratoare,laborator-01"/>
<link rel="search" type="application/opensearchdescription+xml" href="../../lib/exe/opensearch.php" title="CS Open CourseWare"/>
<link rel="start" href="../../../courses.1.html"/>
<link rel="alternate" type="application/rss+xml" title="Recent Changes" href="../../feed.php"/>
<link rel="alternate" type="application/rss+xml" title="Current Namespace" href="../../feed.php%3Fmode=list&amp;ns=pa:laboratoare"/>
<link rel="alternate" type="text/html" title="Plain HTML" href="../../_export/xhtml/pa/laboratoare/laborator-01.html"/>
<link rel="canonical" href="laborator-01.html"/>
<link rel="stylesheet" type="text/css" href="../../lib/exe/css.php%3Ft=arctic&amp;tseed=1476798676.css"/>
<script type="text/javascript">/*<![CDATA[*/var NS='pa:laboratoare';var JSINFO = {"id":"pa:laboratoare:laborator-01","namespace":"pa:laboratoare","isadmin":0,"isauth":0};
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="../../lib/exe/js.php%3Ftseed=1476798676"></script>
<script type="text/x-mathjax-config">/*<![CDATA[*/MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ["$","$"], ["\\(","\\)"] ],
        displayMath: [ ["$$","$$"], ["\\[","\\]"] ],
        processEscapes: true
    }
});
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
<script type="text/javascript">/*<![CDATA[*/
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
		  
/*!]]>*/</script>
<script type="text/javascript">/*<![CDATA[*/
var pageTracker = _gat._getTracker("UA-38383934-1");
pageTracker._initData();
pageTracker._trackPageview();
		  
/*!]]>*/</script>

  <link rel="shortcut icon" href="../../lib/tpl/arctic/images/favicon.ico" />

  
</head>
<body>
<div id="wrapper" class='show'>
  <div class="dokuwiki">

    
    <div class="stylehead">
      <div class="header">
        <div class="pagename">
          <a href="../index.html"><img height="70" src="../../res/sigla_cs.png"/> </a>        </div>
        <div class="logo">
          <a style="color: #AAA !important;" href="../../../courses.1.html"/>Open CourseWare</a>        </div>
      </div>
    
       
      <div class="breadcrumbs">
              </div>
      
            </div>

                  <div class="bar" id="bar__top">
        <div class="bar-left">
                  </div>
        <div class="bar-right">
          <a href="laborator-01%3Fdo=recent.html"  class="action recent" accesskey="r" rel="nofollow" title="Recent changes [R]">Recent changes</a><a href="laborator-01%3Fdo=login&amp;sectok=f62420cf5b01253da4b50505d148181b.html"  class="action login" rel="nofollow" title="Login">Login</a>        </div>
    </div>
        
    
    
    
              <div class="left_page">
          
<h1 class="sectionedit1" id="laborator_1divide_et_impera">Laborator 1: Divide et Impera</h1>
<div class="level1">

</div>

<h2 class="sectionedit2" id="obiective_laborator">Obiective laborator</h2>
<div class="level2">
<ul>
<li class="level1"><div class="li"> Înțelegerea conceptului teoretic din spatele descompunerii</div>
</li>
<li class="level1"><div class="li"> Rezolvarea de probleme abordabile folosind conceptul  de Divide et Impera</div>
</li>
</ul>

</div>

<h2 class="sectionedit3" id="importanta_aplicatii_practice">Importanţă – aplicaţii practice</h2>
<div class="level2">

<p>
Paradigma Divide et Impera stă la baza construirii de algoritmi eficienți pentru diverse probleme:
</p>
<ul>
<li class="level1"><div class="li"> Sortări (ex: MergeSort <a href="http://www.sorting-algorithms.com/merge-sort" class="urlextern" title="http://www.sorting-algorithms.com/merge-sort"  rel="nofollow">[1]</a>, QuickSort <a href="http://www.sorting-algorithms.com/quick-sort" class="urlextern" title="http://www.sorting-algorithms.com/quick-sort"  rel="nofollow">[2]</a>)</div>
</li>
<li class="level1"><div class="li"> Înmulțirea numerelor mari (ex: Karatsuba <a href="http://en.wikipedia.org/wiki/Karatsuba_algorithm" class="urlextern" title="http://en.wikipedia.org/wiki/Karatsuba_algorithm"  rel="nofollow">[3]</a>)</div>
</li>
<li class="level1"><div class="li"> Analiza sintactică (ex: parsere top-down <a href="http://en.wikipedia.org/wiki/Top-down_parser" class="urlextern" title="http://en.wikipedia.org/wiki/Top-down_parser"  rel="nofollow">[4]</a>)</div>
</li>
<li class="level1"><div class="li"> Calcularea transformatei Fourier discretă (ex: FFT <a href="http://en.wikipedia.org/wiki/Fast_Fourier_transform" class="urlextern" title="http://en.wikipedia.org/wiki/Fast_Fourier_transform"  rel="nofollow">[5]</a>)</div>
</li>
</ul>

<p>
Un alt domeniu de utilizare a tehnicii divide et impera este programarea paralelă pe mai multe procesoare, sub-problemele fiind executate pe mașini diferite.
</p>

</div>

<h2 class="sectionedit4" id="prezentarea_generala_a_problemei">Prezentarea generală a problemei</h2>
<div class="level2">

<p>
O descriere a tehnicii D&amp;I: “Divide and Conquer algorithms break the problem into several sub-problems that are similar to the original problem but smaller in size, solve the sub-problems recursively, and then combine these solutions to create a solution to the original problem.” [7]
</p>

<p>
Deci un algoritm D&amp;I <strong>împarte problema</strong> în mai multe subprobleme similare cu problema inițială şi de dimensiuni mai mici, <strong>rezolva sub-problemele</strong> recursiv şi apoi <strong>combina soluțiile</strong> obţinute pentru a obține soluția problemei inițiale.
</p>

<p>
Sunt trei pași pentru aplicarea algoritmului D&amp;I:
</p>
<ul>
<li class="level1"><div class="li"> <strong>Divide</strong>: împarte problema în una sau mai multe <em>probleme similare de dimensiuni mai mici</em>.</div>
</li>
<li class="level1"><div class="li"> <strong>Impera</strong> (stăpânește): rezolva subprobleme recursiv; dacă dimensiunea sub-problemelor este mica se rezolva iterativ.</div>
</li>
<li class="level1"><div class="li"> <strong>Combină</strong>: combină soluțiile sub-problemelor pentru a obține soluția problemei inițiale.</div>
</li>
</ul>

<p>
Complexitatea algoritmilor D&amp;I se calculează după formula:
</p>

<p>
T(n) = D(n) + S(n) + C(n),
</p>

<p>
unde D(n), S(n) şi C(n) reprezintă complexitățile celor 3 pași descriși mai sus: divide, stăpânește respectiv combină.
</p>

</div>

<h2 class="sectionedit5" id="probleme_clasice">Probleme clasice</h2>
<div class="level2">

</div>

<h3 class="sectionedit6" id="sortarea_prin_interclasare">1. Sortarea prin interclasare</h3>
<div class="level3">

<p>
Sortarea prin interclasare (MergeSort <a href="http://www.sorting-algorithms.com/merge-sort" class="urlextern" title="http://www.sorting-algorithms.com/merge-sort"  rel="nofollow">[1]</a>) este un algoritm de sortare de vectori ce folosește paradigma D&amp;I:
</p>
<ul>
<li class="level1"><div class="li"> <strong>Divide</strong>: împarte vectorul inițial în doi sub-vectori de dimensiune n/2.</div>
</li>
<li class="level1"><div class="li"> <strong>Stăpânește</strong>: sortează cei doi sub-vectori recursiv folosind sortarea prin interclasare; recursivitatea se oprește când dimensiunea unui sub-vector este 1 (deja sortat).</div>
</li>
<li class="level1"><div class="li"> <strong>Combina</strong>: Interclasează cei doi sub-vectori sortați pentru a obține vectorul inițial sortat.</div>
</li>
</ul>

<p>
Pseudocod:
</p>
<pre class="code cpp">MergeSort<span class="br0">&#40;</span>v, start, end<span class="br0">&#41;</span>		<span class="co1">// v – vector, start – limită inferioră, end – limită superioară</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span>start <span class="sy1">==</span> end<span class="br0">&#41;</span> <span class="kw1">return</span><span class="sy4">;</span>	<span class="co1">// condiția de oprire</span>
	mid <span class="sy1">=</span> <span class="br0">&#40;</span>start <span class="sy2">+</span> end<span class="br0">&#41;</span> <span class="sy2">/</span> <span class="nu0">2</span><span class="sy4">;</span>	<span class="co1">// etapa divide</span>
	MergeSort<span class="br0">&#40;</span>v, start, mid<span class="br0">&#41;</span><span class="sy4">;</span>	<span class="co1">// etapa stăpânește</span>
	MergeSort<span class="br0">&#40;</span>v, mid<span class="sy2">+</span><span class="nu0">1</span>, end<span class="br0">&#41;</span><span class="sy4">;</span>
	Merge<span class="br0">&#40;</span>v, start, end<span class="br0">&#41;</span><span class="sy4">;</span>		<span class="co1">// etapa combină</span>
&nbsp;
Merge<span class="br0">&#40;</span>v, start, end<span class="br0">&#41;</span>			<span class="co1">// interclasare sub-vectori</span>
	mid <span class="sy1">=</span> <span class="br0">&#40;</span>start <span class="sy2">+</span> end<span class="br0">&#41;</span> <span class="sy2">/</span> <span class="nu0">2</span><span class="sy4">;</span>
	i <span class="sy1">=</span> start<span class="sy4">;</span>
	j <span class="sy1">=</span> mid <span class="sy2">+</span> <span class="nu0">1</span><span class="sy4">;</span>
	k <span class="sy1">=</span> <span class="nu0">1</span><span class="sy4">;</span>
	<span class="kw1">while</span> <span class="br0">&#40;</span>i <span class="sy1">&lt;=</span> mid <span class="sy3">&amp;&amp;</span> j <span class="sy1">&lt;=</span> end<span class="br0">&#41;</span> 
		<span class="kw1">if</span> <span class="br0">&#40;</span>v<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy1">&lt;=</span> v<span class="br0">&#91;</span>j<span class="br0">&#93;</span><span class="br0">&#41;</span> u<span class="br0">&#91;</span>k<span class="sy2">++</span><span class="br0">&#93;</span> <span class="sy1">=</span> v<span class="br0">&#91;</span>i<span class="sy2">++</span><span class="br0">&#93;</span><span class="sy4">;</span>
		<span class="kw1">else</span> u<span class="br0">&#91;</span>k<span class="sy2">++</span><span class="br0">&#93;</span> <span class="sy1">=</span> v<span class="br0">&#91;</span>j<span class="sy2">++</span><span class="br0">&#93;</span><span class="sy4">;</span>
&nbsp;
	<span class="kw1">while</span> <span class="br0">&#40;</span>i <span class="sy1">&lt;=</span> mid<span class="br0">&#41;</span> 
		u<span class="br0">&#91;</span>k<span class="sy2">++</span><span class="br0">&#93;</span> <span class="sy1">=</span> v<span class="br0">&#91;</span>i<span class="sy2">++</span><span class="br0">&#93;</span><span class="sy4">;</span>
&nbsp;
	<span class="kw1">while</span> <span class="br0">&#40;</span>j <span class="sy1">&lt;=</span> end<span class="br0">&#41;</span> 
		u<span class="br0">&#91;</span>k<span class="sy2">++</span><span class="br0">&#93;</span> <span class="sy1">=</span> v<span class="br0">&#91;</span>j<span class="sy2">++</span><span class="br0">&#93;</span><span class="sy4">;</span>
&nbsp;
	copy<span class="br0">&#40;</span>v<span class="br0">&#91;</span>start..<span class="me1">end</span><span class="br0">&#93;</span>, u<span class="br0">&#91;</span><span class="nu0">1</span>..<span class="me1">k</span><span class="sy2">-</span><span class="nu0">1</span><span class="br0">&#93;</span><span class="br0">&#41;</span><span class="sy4">;</span></pre>

<p>
Complexitatea algoritmului este dată de formula: T(n) = D(n) + S(n) + C(n), unde D(n)=O(1), S(n) = 2*T(n/2) și C(n) = O(n), rezulta T(n) = 2 * T(n/2) + O(n).
</p>

<p>
Folosind teorema Master <a href="http://people.csail.mit.edu/thies/6.046-web/master.pdf" class="urlextern" title="http://people.csail.mit.edu/thies/6.046-web/master.pdf"  rel="nofollow">[8]</a> găsim complexitatea algoritmului: <strong>T(n) = O(n * lg n)</strong>.
</p>

</div>

<h3 class="sectionedit7" id="cautarea_binara">2. Căutarea binară</h3>
<div class="level3">

<p>
Se dă un <strong>vector sortat crescător</strong> (v[1..n]) ce conține valori reale distincte și o valoare x. Sa se găsească la ce poziție apare x în vectorul dat.
</p>

<p>
Pentru rezolvarea acestei probleme folosim un algoritm D&amp;I:
</p>
<ul>
<li class="level1"><div class="li"> <strong>Divide</strong>: împărțim vectorul în doi sub-vectori de dimensiune n/2.</div>
</li>
<li class="level1"><div class="li"> <strong>Stăpânește</strong>: aplicăm algoritmul de căutare binară pe sub-vectorul care conține valoarea căutată.</div>
</li>
<li class="level1"><div class="li"> <strong>Combină</strong>: soluția sub-problemei devine soluția problemei inițiale, motiv pentru care nu mai este nevoie de etapa de combinare.</div>
</li>
</ul>

<p>
Pseudocod:
</p>
<pre class="code cpp">BinarySearch<span class="br0">&#40;</span>v, start, end, x<span class="br0">&#41;</span> 
	<span class="kw1">if</span> <span class="br0">&#40;</span>start <span class="sy1">&gt;</span> end<span class="br0">&#41;</span> <span class="kw1">return</span><span class="sy4">;</span>	<span class="co1">// condiția de oprire (x nu se află în v)</span>
	mid <span class="sy1">=</span> <span class="br0">&#40;</span>start <span class="sy2">+</span> end<span class="br0">&#41;</span> <span class="sy2">/</span> <span class="nu0">2</span><span class="sy4">;</span>	<span class="co1">// etapa divide</span>
	<span class="co1">// etapa stăpânește</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span>v<span class="br0">&#91;</span>mid<span class="br0">&#93;</span> <span class="sy1">==</span> x<span class="br0">&#41;</span> <span class="kw1">return</span> mid
	<span class="kw1">if</span> <span class="br0">&#40;</span>v<span class="br0">&#91;</span>mid<span class="br0">&#93;</span> <span class="sy1">&gt;</span> x<span class="br0">&#41;</span> <span class="kw1">return</span> BinarySearch<span class="br0">&#40;</span>v, start, mid<span class="sy2">-</span><span class="nu0">1</span>, x<span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span>v<span class="br0">&#91;</span>mid<span class="br0">&#93;</span> <span class="sy1">&lt;</span> x<span class="br0">&#41;</span> <span class="kw1">return</span> BinarySearch<span class="br0">&#40;</span>v, mid<span class="sy2">+</span><span class="nu0">1</span>, end, x<span class="br0">&#41;</span><span class="sy4">;</span></pre>

<p>
Complexitatea algoritmului este data de relația T(n) = T(n/2) + O(1), ceea ce implica: <strong>T(n) = O(lg n)</strong>.
</p>

</div>

<h3 class="sectionedit8" id="turnurile_din_hanoi">3. Turnurile din Hanoi</h3>
<div class="level3">

<p>
Se considera 3 tije A, B, C şi n discuri de dimensiuni distincte (1, 2.. n ordinea crescătoare a dimensiunilor) situate inițial toate pe tija A în ordinea 1,2..n (de la vârf către baza). Singura operație care se poate efectua este de a selecta un disc ce se află în vârful unei tije şi plasarea lui în vârful altei tije astfel încât să fie așezat deasupra unui disc de dimensiune mai mare decât a sa. Sa se găsească un algoritm prin care se mută toate discurile pe tija B (problema turnurilor din Hanoi).
</p>

<p>
Pentru rezolvarea problemei folosim următoarea strategie <a href="http://www.mathcs.org/java/programs/Hanoi/index.html" class="urlextern" title="http://www.mathcs.org/java/programs/Hanoi/index.html"  rel="nofollow">[9]</a>:
</p>
<ul>
<li class="level1"><div class="li"> mutam primele n-1 discuri de pe tija A pe tija C folosindu-ne de tija B.</div>
</li>
<li class="level1"><div class="li"> mutam discul n pe tija B.</div>
</li>
<li class="level1"><div class="li"> mutam apoi cele n-1 discuri de pe tija C pe tija B folosindu-ne de tija A.</div>
</li>
</ul>

<p>
Pseudocod [10]:
</p>
<pre class="code cpp">Hanoi<span class="br0">&#40;</span>n, A, B, C<span class="br0">&#41;</span>	<span class="co1">// mută n discuri de pe tija A pe tija B fol tija C</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span>n <span class="sy1">&gt;=</span> <span class="nu0">1</span><span class="br0">&#41;</span>
		Hanoi<span class="br0">&#40;</span>n<span class="sy2">-</span><span class="nu0">1</span>, A, C, B<span class="br0">&#41;</span><span class="sy4">;</span>
		Muta_disc<span class="br0">&#40;</span>A, B<span class="br0">&#41;</span><span class="sy4">;</span>
		Hanoi<span class="br0">&#40;</span>n<span class="sy2">-</span><span class="nu0">1</span>, C, B, A<span class="br0">&#41;</span><span class="sy4">;</span></pre>

<p>
Complexitatea: T(n) = 2*T(n-1) + O(1), recurenta ce conduce la <strong>T(n) = O(2<sup>n</sup>)</strong>. 
</p>

</div>

<h3 class="sectionedit9" id="cautare_numar_lipsa">4. Cautare număr lipsă</h3>
<div class="level3">

<p>
Se dă un șir neordonat <strong>S</strong> cu <code>n - 1</code> numere distincte, selectate dintre cele <code>n</code> numere de la <code>0</code> la <code>n - 1</code>. Toate sunt numere întregi, reprezentate pe 32 de biti. Folosind metoda <code>getBit(int i, int j)</code> care intoarce al j-lea bit din reprezentarea binara a lui <code>S[i]</code>, determinati numarul lipsă.
</p>

<p>
Pentru un număr dat <code>n</code>, fie <code>m = 2<sup>k</sup></code> primul număr mai mare decât <code>n</code> care este o putere a lui <code>2</code>. Atunci, în șirul numerelor de la <code>0</code> până la <code>n - 1</code> vor exista <code>2<sup>k - 1</sup></code> numere cu bitul numărul <code>k - 1</code> egal cu <code>0</code>.
</p>

<p>
Pentru <code>n = 7</code>, <code>m = 8</code> și <code>k = 3</code>. Drept urmare, vor fi <code>2<sup>k-1</sup> = 2<sup>2</sup> = 4</code> numere între <code>0</code> și <code>7</code> cu bitul <code>2</code> egal cu <code>0</code>. Dacă numărul care lipsește din șirul din problemă va avea bitul <code>2</code> egal cu <code>0</code>, atunci vor fi <code>2<sup>2</sup> - 1</code> numere în șir cu bitul zero. Altfel, înseamnă că numărul care lipsește are bitul <code>2</code> egal cu <code>1</code>. După ce determinăm în care “jumătate” se află numărul lipsă, continuăm căutarea mai departe folosind-o doar pe aceea.
</p>

<p>
Reprezentarea în binar a numerelor întregi din intervalul <code>[0, 7)</code>:
</p>
<div class="table sectionedit10"><table class="inline">
	<tr class="row0">
		<td class="col0"> </td><td class="col1"> </td><td class="col2"> <strong>2</strong> </td><td class="col3"> <strong>1</strong> </td><td class="col4"> <strong>0</strong> </td>
	</tr>
	<tr class="row1">
		<td class="col0"> <strong>0</strong> </td><td class="col1"> = </td><td class="col2"> 0 </td><td class="col3"> 0 </td><td class="col4"> 0 </td>
	</tr>
	<tr class="row2">
		<td class="col0"> <strong>1</strong> </td><td class="col1"> = </td><td class="col2"> 0 </td><td class="col3"> 0 </td><td class="col4"> 1 </td>
	</tr>
	<tr class="row3">
		<td class="col0"> <strong>2</strong> </td><td class="col1"> = </td><td class="col2"> 0 </td><td class="col3"> 1 </td><td class="col4"> 0 </td>
	</tr>
	<tr class="row4">
		<td class="col0"> <strong>3</strong> </td><td class="col1"> = </td><td class="col2"> 0 </td><td class="col3"> 1 </td><td class="col4"> 1 </td>
	</tr>
	<tr class="row5">
		<td class="col0"> <strong>4</strong> </td><td class="col1"> = </td><td class="col2"> 1 </td><td class="col3"> 0 </td><td class="col4"> 0 </td>
	</tr>
	<tr class="row6">
		<td class="col0"> <strong>5</strong> </td><td class="col1"> = </td><td class="col2"> 1 </td><td class="col3"> 0 </td><td class="col4"> 1 </td>
	</tr>
	<tr class="row7">
		<td class="col0"> <strong>6</strong> </td><td class="col1"> = </td><td class="col2"> 1 </td><td class="col3"> 1 </td><td class="col4"> 0 </td>
	</tr>
</table></div>

<p>
Putem să aplicăm această regulă ca să determinăm elementul lipsă din șir, iterând de la cel mai semnificativ bit spre cel mai nesemnificativ.
</p>

<p>
<p><div class="notetip">
Exemplu:
</p>
<ul>
<li class="level1"><div class="li"> pentru șirul {0 1 9 4 5 7 6 8 2} lipsește numarul 3</div>
</li>
<li class="level1"><div class="li"> <code>getBit(7,3)</code> întoarce al treilea bit din <code>S[7]</code>. S[7] este 8, în binar: 1000, deci bit-ul 3 este 1.</div>
</li>
<li class="level1"><div class="li"> La un prim pas, se observă că bitul 3 este 0 pentru doar 7 numere din șir, deși între 0 și 9 sunt 8 numere care ar trebui să aibă bitul 3 egal cu 0, respectiv numerele de la 0 la 7. Prin urmare, la primul pas ne dăm seama că numărul căutat este între 0 si 7.</div>
</li>
</ul>

<p>

</div></p>
</p>

<p>
Pseudocod:
</p>
<pre class="code cpp">getMissing<span class="br0">&#40;</span>V, n<span class="br0">&#41;</span><span class="sy4">:</span>
    current_vec <span class="sy1">=</span> V
    current_bit <span class="sy1">=</span> <span class="nu0">31</span>
    result <span class="sy1">=</span> <span class="nu0">0</span>
&nbsp;
    <span class="kw1">while</span> <span class="br0">&#40;</span>getBit<span class="br0">&#40;</span>n <span class="sy2">-</span> <span class="nu0">1</span>, current_bit<span class="br0">&#41;</span> <span class="sy1">==</span> <span class="nu0">0</span><span class="br0">&#41;</span>
        current_bit<span class="sy2">--</span>
&nbsp;
    <span class="kw1">while</span> <span class="br0">&#40;</span>current_bit <span class="sy1">&gt;=</span> <span class="nu0">0</span><span class="br0">&#41;</span>
        setBit0 <span class="sy1">=</span> <span class="br0">&#123;</span><span class="br0">&#125;</span>
        setBit1 <span class="sy1">=</span> <span class="br0">&#123;</span><span class="br0">&#125;</span>
&nbsp;
        <span class="kw1">for</span> <span class="br0">&#40;</span>element <span class="sy4">:</span> current_vec<span class="br0">&#41;</span>
            <span class="kw1">if</span> <span class="br0">&#40;</span>getBit<span class="br0">&#40;</span>element, current_bit<span class="br0">&#41;</span> <span class="sy1">==</span> <span class="nu0">0</span><span class="br0">&#41;</span>
                setBit0.<span class="me1">add</span><span class="br0">&#40;</span>element<span class="br0">&#41;</span>
            <span class="kw1">else</span>
                setBit1.<span class="me1">add</span><span class="br0">&#40;</span>element<span class="br0">&#41;</span>
&nbsp;
        <span class="kw1">if</span> <span class="br0">&#40;</span>setBit0.<span class="me1">size</span> <span class="sy3">!</span><span class="sy1">=</span> <span class="br0">&#40;</span><span class="nu0">1</span> <span class="sy1">&lt;&lt;</span> current_bit<span class="br0">&#41;</span><span class="br0">&#41;</span>
            result <span class="sy3">|</span><span class="sy1">=</span> <span class="br0">&#40;</span><span class="nu0">1</span> <span class="sy1">&lt;&lt;</span> current_bit<span class="br0">&#41;</span>
            current_vec <span class="sy1">=</span> setBit1
        <span class="kw1">else</span>
            current_vec <span class="sy1">=</span> setBit0
&nbsp;
    <span class="kw1">return</span> result</pre>

<p>
O altă soluție se bazează pe aflarea elementului median din vector - elementul care se află la jumătatea intervalului, de exemplu pentru [5 6 7 8 9] elementul median este 7, adică (9+5)/2. Dacă elementul median nu se afla în vector atunci acesta egale cu elementul median, iar în cel de-al doilea toate elementele sunt mai mari decât cel median. Calculam suma elementelor din fiecare vector, și în cazul în care suma nu coincide cu cea pe care o calculam din formula (b*(b+1)/2-(a-1)*a/2, este elementul lipsa. Altfel, se partiționează vectorul în 2 noi vectori: în primul vector toate elementele sunt mai mici sau presupunând ca vectorul are elemente intre a si b) înseamnă ca elementul lipsă se afla în jumătatea respectivă și ne poziționăm în acea parte. 
</p>
<pre class="code cpp"><span class="kw4">int</span> find<span class="br0">&#40;</span>vector<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> V, <span class="kw4">int</span> a, <span class="kw4">int</span> b<span class="br0">&#41;</span> <span class="co1">// vectorul V cuprinde numerele intre a si b, mai putin unul</span>
<span class="br0">&#123;</span>
      <span class="kw4">int</span> median <span class="sy1">=</span> <span class="br0">&#40;</span>a<span class="sy2">+</span>b<span class="br0">&#41;</span><span class="sy2">/</span><span class="nu0">2</span><span class="sy4">;</span>
      <span class="kw4">int</span> find <span class="sy1">=</span> <span class="nu0">0</span><span class="sy4">;</span>
      <span class="kw1">for</span> <span class="br0">&#40;</span>vector<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">iterator</span> it<span class="sy1">=</span> V.<span class="me1">begin</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy4">;</span> it<span class="sy3">!</span><span class="sy1">=</span>V.<span class="me1">end</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy4">;</span> it<span class="sy2">++</span><span class="br0">&#41;</span>
            <span class="kw1">if</span> <span class="br0">&#40;</span><span class="sy2">*</span>it <span class="sy1">==</span> median<span class="br0">&#41;</span>
             <span class="br0">&#123;</span>
                find <span class="sy1">=</span><span class="nu0">1</span><span class="sy4">;</span>
                <span class="kw1">break</span><span class="sy4">;</span>
              <span class="br0">&#125;</span>
      <span class="kw1">if</span> <span class="br0">&#40;</span>find <span class="sy1">==</span> <span class="nu0">0</span><span class="br0">&#41;</span>
          <span class="kw1">return</span> median<span class="sy4">;</span> <span class="co1">// acesta este elementul lipsa</span>
      vector<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> V1,V2<span class="sy4">;</span>
      <span class="kw4">int</span> s1<span class="sy1">=</span><span class="nu0">0</span>, s2<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span>
      <span class="kw1">for</span> <span class="br0">&#40;</span>vector<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">iterator</span> it<span class="sy1">=</span> V.<span class="me1">begin</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy4">;</span> it<span class="sy3">!</span><span class="sy1">=</span>V.<span class="me1">end</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy4">;</span> it<span class="sy2">++</span><span class="br0">&#41;</span>
            <span class="kw1">if</span> <span class="br0">&#40;</span><span class="sy2">*</span>it <span class="sy1">&lt;=</span> median<span class="br0">&#41;</span>
                 V1.<span class="me1">push_back</span><span class="br0">&#40;</span><span class="sy2">*</span>it<span class="br0">&#41;</span>, s1<span class="sy2">+</span><span class="sy1">=</span><span class="sy2">*</span>it<span class="sy4">;</span>
            <span class="kw1">else</span> 
                 V2.<span class="me1">push_back</span><span class="br0">&#40;</span><span class="sy2">*</span>it<span class="br0">&#41;</span>, s2<span class="sy2">+</span><span class="sy1">=</span><span class="sy2">*</span>it<span class="sy4">;</span>
       <span class="kw1">if</span> <span class="br0">&#40;</span>s1 <span class="sy3">!</span><span class="sy1">=</span> <span class="br0">&#40;</span>median<span class="sy2">*</span><span class="br0">&#40;</span>median<span class="sy2">+</span><span class="nu0">1</span><span class="br0">&#41;</span><span class="sy2">/</span><span class="nu0">2</span> <span class="sy2">-</span> <span class="br0">&#40;</span>a<span class="sy2">-</span><span class="nu0">1</span><span class="br0">&#41;</span><span class="sy2">*</span>a<span class="sy2">/</span><span class="nu0">2</span><span class="br0">&#41;</span> <span class="br0">&#41;</span>
             <span class="kw1">return</span> find<span class="br0">&#40;</span>V1, a, median<span class="br0">&#41;</span><span class="sy4">;</span>
        <span class="kw1">else</span>
             <span class="kw1">return</span> find<span class="br0">&#40;</span>V2, median<span class="sy2">+</span><span class="nu0">1</span>, b<span class="br0">&#41;</span><span class="sy4">;</span>
  <span class="br0">&#125;</span></pre>

</div>

<h3 class="sectionedit11" id="inmultire_de_polinoame">5. Înmulțire de polinoame</h3>
<div class="level3">

<p>
Dacă avem două polinoame, P(x)=a0+a1*x+…an*<code>x<sup>n</sup></code> si Q(x)=b0+b1*x+….bn*<code>x<sup>n</sup></code>, și vrem să calculăm P*Q, în mod normal complexitatea este O(<code>n<sup>2</sup></code>) - fiecare termen al produsului va fi obținut ca o suma intre coeficienții ai și bi. De exemplu, pentru coeficientul cn,cn = a0*bn+a1*bn-1+….an*b0. 
</p>

<p>
O metodă mai rapidă, de complexitate O(n*log n) este să folosim transformata Fourier rapidă (FFT) și cea inversă. Transformata Fourier rapidă calculează valoarea unui polinom in N puncte (rădăcinile de ordin N ale lui 1, mai exact). Dacă avem coeficienții x0, x1… xn-1, transformata Fourier va găsi valorile în cele N puncte. Fie Xk valoarea transformatei în punctul k. Folosind proprietăți matematice, se observă că Xk si Xk+n/2 se pot calcula folosind aceleași valori,  (mai exact sumele parțiale pentru termenii pari și termenii impari ai sumei în punctul k). Pornind de la această idee, se calculează recursiv, folosind divide et impera, termenii pari respectiv termenii impari ai sumei, pentru fiecare punct x0..xn-1. Cei n termeni se calculează apelând recursiv pentru termenii pari și pentru cei impari, iar etapa de combinare are complexitate O(n), în final complexitatea fiind de O(n * log n). 
</p>

<p>
Transformata Fourier inversă calculează coeficienții unui polinom plecând de la valorile pe care le are în N puncte. Calculul acesteia nu diferă mult de cel al transformatei Fourier.
Calculul produsului de polinoame se face în felul următor: se evaluează funcțiile în 2*n puncte (sau n+m, daca au grade diferite polinoamele), folosind FFT (complexitate O(n* logn). În pasul următor se calculează valorile pentru P(k)*Q(k), pentru punctele n care am aplicat FFT, și în ultimul pas se calculează coeficienții folosind transformata Fourier inversă. În final, complexitatea este O(n*log n).
</p>

<p>
Mai multe informații găsiti la <a href="http://en.wikipedia.org/wiki/Cooley%E2%80%93Tukey_FFT_algorithm" class="urlextern" title="http://en.wikipedia.org/wiki/Cooley%E2%80%93Tukey_FFT_algorithm"  rel="nofollow">http://en.wikipedia.org/wiki/Cooley%E2%80%93Tukey_FFT_algorithm</a> și la <a href="https://www.cs.iastate.edu/~cs577/handouts/polymultiply.pdf" class="urlextern" title="https://www.cs.iastate.edu/~cs577/handouts/polymultiply.pdf"  rel="nofollow">https://www.cs.iastate.edu/~cs577/handouts/polymultiply.pdf</a>.
</p>

</div>

<h2 class="sectionedit12" id="concluzii">Concluzii</h2>
<div class="level2">

<p>
Divide et impera este o tehnică folosită pentru a realiza algoritmi eficienți pentru diverse probleme. În cadrul acestei tehnici se disting trei etape: divide, stăpânește și combină.
</p>

<p>
Mai multe exemple de algoritmi care folosesc tehnica divide et impera puteți găsi la <a href="http://www.cs.berkeley.edu/~vazirani/algorithms/chap2.pdf" class="urlextern" title="http://www.cs.berkeley.edu/~vazirani/algorithms/chap2.pdf"  rel="nofollow">[11]</a>.
</p>

</div>

<h1 class="sectionedit13" id="probleme_laborator">Probleme laborator</h1>
<div class="level1">

<p>
<p><div class="noteimportant">
Pentru punctaj maxim, <strong>asistentul va alege</strong> un subpunct pentru fiecare problemă.

</div></p>
</p>

<p>
<p><div class="noteimportant">
La finalul laboratorului, încărcați soluțiile <a href="http://cs.curs.pub.ro/2015/mod/assign/view.php?id=4649" class="urlextern" title="http://cs.curs.pub.ro/2015/mod/assign/view.php?id=4649"  rel="nofollow">aici</a>.

</div></p>
</p>

</div>

<h2 class="sectionedit14" id="problema_1_3p">Problema 1 [3p]</h2>
<div class="level2">
<ul>
<li class="level1"><div class="li"> <strong>1.1</strong> Se da un sir sortat. Gasiti numarul de elemente egale cu x din sir.</div>
</li>
</ul>

<p>
<p><div class="notetip">
Exemplu: pentru sirul <code>{1 2 4 4 10 10 20}</code> si <code>x = 10</code>, x apare de 2 ori in sir.

</div></p>
</p>
<ul>
<li class="level1"><div class="li"> <strong>1.2</strong> Se da un numar natural n. Scrieti un algoritm de complexitate <strong>O(log n)</strong> care sa calculeze √n cu o precizie de 0.001.</div>
</li>
</ul>

<p>
<p><div class="notetip">
Exemplu: pentru 0.25 algoritmul poate da orice valoare intre 0.499 si 0.501 inclusiv.

</div></p>
</p>
<ul>
<li class="level1"><div class="li"> <strong>1.3</strong> Fie o valoare întreagă necunoscută, pe care o denumim <code>unknown</code>. Gasiți valoarea lui <code>unknown</code> prin <strong>Divide et Impera</strong>, folosind metoda <code>isInBounds(int x)</code> pentru Java și <code>is_in_bounds(int x)</code> pentru C++ care întoarce:</div>
<ul>
<li class="level2"><div class="li"> true, dacă <code>x &lt; = unknown</code></div>
</li>
<li class="level2"><div class="li"> false, dacă <code>x &gt; unknown</code></div>
</li>
</ul>
</li>
</ul>

</div>

<h2 class="sectionedit15" id="problema_2_3p">Problema 2 [3p]</h2>
<div class="level2">
<ul>
<li class="level1"><div class="li"> <strong>2.1</strong> <strong>Statistici de ordine:</strong> se dă un vector de numere întregi neordonate. Scriind o funcție de partitionare, folosiți <strong>Divide et Impera</strong> pentru</div>
<ul>
<li class="level2"><div class="li"> a determina a k-lea element ca mărime din vector</div>
</li>
<li class="level2"><div class="li"> a sorta vectorii prin QuickSort</div>
</li>
</ul>
</li>
</ul>

<p>
<p><div class="notetip">
 Exemplu: pentru vectorul <code>{0 1 2 4 5 7 6 8 9}</code>, al 3-lea element ca ordine este 2, iar vectorul sortat este {0 1 2 4 5 6 7 8 9}

</div></p>
</p>
<ul>
<li class="level1"><div class="li"> <strong>2.2</strong> Se da un sir <strong>S</strong> de n numere intregi. Sa se detemine cate inversiuni sunt in sirul dat. Numim inversiune o pereche de indici <code>1 &lt; = i &lt; j &lt; = n</code> astfel incat <code>S[i] &gt; S[j]</code></div>
</li>
</ul>

<p>
<p><div class="notetip">
 Exemplu: in sirul <code>{0 1 9 4 5 7 6 8 2}</code> sunt 12 inversiuni.

</div></p>
</p>
<ul>
<li class="level1"><div class="li"> <strong>2.3</strong> Se dau <code>n - 1</code> numere naturale distincte intre <code>0</code> si <code>n - 1</code>. Scriind o functie de partitionare, determinati numarul lipsa.</div>
</li>
</ul>

<p>
<p><div class="notetip">
 Exemplu: pentru <code>n = 9</code> si vectorul <code>{0 1 9 4 5 7 6 8 2}</code>, numarul lipsa este <code>3</code>.

</div></p>
</p>

</div>

<h2 class="sectionedit16" id="problema_3_4p">Problema 3 [4p]</h2>
<div class="level2">

<p>
<p><div class="notewarning">
Această problema nu are schelet de cod.

</div></p>
</p>
<ul>
<li class="level1"><div class="li"> Calculați subsecvența de sumă maximă pentru un vector <code>A</code> de <code>n</code> numere reale folosind o abordare de tip divide și stăpânește.</div>
</li>
</ul>

<p>
<p><div class="noteimportant">
O subsecvență a unui vector <code>A[1..n]</code> se definește ca o secvența continuă de elemente din <code>A</code>. De exemplu, <code>A[i..j]</code> (pentru orice <code>1 &lt; = i &lt; = j &lt; = n</code>) reprezintă o subsecvență a lui <code>A</code>. Această problemă se numește <strong>problema subsecvenței de sumă maximă</strong> și acceptă mai multe rezolvări. O rezolvare mai eficientă poate fi făcută prin programare dinamică.

</div></p>
</p>

<p>
<p><div class="notetip">
Exemplu (preluat de pe Wikipedia): Pentru <code>A = {−2, 1, −3, 4, −1, 2, 1, −5, 4}</code>, subsecvența de sumă maximă este <code>{4, −1, 2, 1}</code> de sumă <code>6</code>.

</div></p>
</p>

</div>

<h2 class="sectionedit17" id="referinte">Referinţe</h2>
<div class="level2">

<p>
[1] <a href="http://www.sorting-algorithms.com/merge-sort" class="urlextern" title="http://www.sorting-algorithms.com/merge-sort"  rel="nofollow">MergeSort</a>
</p>

<p>
[2] <a href="http://www.sorting-algorithms.com/quick-sort" class="urlextern" title="http://www.sorting-algorithms.com/quick-sort"  rel="nofollow">QuickSort</a>
</p>

<p>
[3] <a href="http://en.wikipedia.org/wiki/Karatsuba_algorithm" class="urlextern" title="http://en.wikipedia.org/wiki/Karatsuba_algorithm"  rel="nofollow">Karatsuba</a>
</p>

<p>
[4] <a href="http://en.wikipedia.org/wiki/Top-down_parser" class="urlextern" title="http://en.wikipedia.org/wiki/Top-down_parser"  rel="nofollow">Top down parser</a>
</p>

<p>
[5] <a href="http://en.wikipedia.org/wiki/Fast_Fourier_transform" class="urlextern" title="http://en.wikipedia.org/wiki/Fast_Fourier_transform"  rel="nofollow">Fast Fourier Transform</a>
</p>

<p>
[6] <a href="http://en.wikipedia.org/wiki/Divide_and_rule" class="urlextern" title="http://en.wikipedia.org/wiki/Divide_and_rule"  rel="nofollow">Divide et impera</a>
</p>

<p>
[7] T. H. Cormen, C. E. Leiserson, R. L. Rivest, C. Stein, Introduction to Algorithms
</p>

<p>
[8] <a href="http://people.csail.mit.edu/thies/6.046-web/master.pdf" class="urlextern" title="http://people.csail.mit.edu/thies/6.046-web/master.pdf"  rel="nofollow">Teorema Master</a>
</p>

<p>
[9] <a href="http://www.mathcs.org/java/programs/Hanoi/index.html" class="urlextern" title="http://www.mathcs.org/java/programs/Hanoi/index.html"  rel="nofollow">Hanoi Applet</a>
</p>

<p>
[10] Cristian A. Giumale, Introducere in Analiza Algoritmilor (cap. 2.5.1)
</p>

<p>
[11] <a href="http://www.cs.berkeley.edu/~vazirani/algorithms/chap2.pdf" class="urlextern" title="http://www.cs.berkeley.edu/~vazirani/algorithms/chap2.pdf"  rel="nofollow">Chapter 2, Divide-and-conquer algorithms, Berkeley University</a>
</p>

</div>

        </div>
        <div class="right_sidebar">
          <form action="../../start.html" accept-charset="utf-8" class="search" id="dw__search" method="get"><div class="no"><input type="hidden" name="do" value="search" /><input type="text" id="qsearch__in" accesskey="f" name="id" class="edit" title="[F]" /><input type="submit" value="Search" class="button" title="Search" /><div id="qsearch__out" class="ajax_qsearch JSpopup"></div></div></form>          <div class="namespace_sidebar sidebar_box">

<h2 class="sectionedit1" id="diverse">Diverse</h2>
<div class="level2">
<ul>
<li class="level1"><div class="li"> <a href="../echipa-pa-2006-2012.html" class="wikilink1" title="pa:echipa-pa-2006-2012">Hall of PA</a></div>
</li>
<li class="level1"><div class="li"> <a href="../regulamente.html" class="wikilink1" title="pa:regulamente">Regulamente PA 2016</a></div>
</li>
<li class="level1"><div class="li"> <a href="../proiect.html" class="wikilink1" title="pa:proiect">Proiect</a></div>
</li>
<li class="level1"><div class="li"> <a href="../catalog.html" class="wikilink1" title="pa:catalog">Catalog</a></div>
</li>
<li class="level1"><div class="li"> <a href="../test_practic.html" class="wikilink1" title="pa:test_practic">Test practic</a></div>
</li>
</ul>

</div>
<!-- EDIT1 SECTION "Diverse" [1-254] -->
<h2 class="sectionedit2" id="schelet_cod">Schelet Cod</h2>
<div class="level2">
<ul>
<li class="level1"><div class="li"> <a href="../../_media/pa/lab00.zip" class="media mediafile mf_zip" title="pa:lab00.zip (8.4 KB)">Laborator 0: Introducere și Relaxare</a></div>
</li>
<li class="level1"><div class="li"> <a href="../../_media/pa/schelete/2015/lab01.zip" class="media mediafile mf_zip" title="pa:schelete:2015:lab01.zip (35.5 KB)">Laborator 1: Divide et Impera</a></div>
</li>
<li class="level1"><div class="li"> <a href="../../_media/pa/schelete/2016/lab02-skel.zip" class="media mediafile mf_zip" title="pa:schelete:2016:lab02-skel.zip (53.5 KB)">Laborator 2: Greedy</a></div>
</li>
<li class="level1"><div class="li"> <a href="../../_media/pa/schelete/2016/lab03.zip" class="media mediafile mf_zip" title="pa:schelete:2016:lab03.zip (6.3 KB)">Laborator 3: Programare Dinamică</a></div>
</li>
<li class="level1"><div class="li"> <a href="../../_media/pa/schelete/2014/lab04.zip" class="media mediafile mf_zip" title="pa:schelete:2014:lab04.zip (23.2 KB)">Laborator 4: Backtracking și optimizări</a></div>
</li>
<li class="level1"><div class="li"> <a href="../../_media/pa/schelete/lab05.zip" class="media mediafile mf_zip" title="pa:schelete:lab05.zip (10.8 KB)">Laborator 5: Minimax</a></div>
</li>
<li class="level1"><div class="li"> <a href="../../_media/pa/schelete/2016/lab06.zip" class="media mediafile mf_zip" title="pa:schelete:2016:lab06.zip (37.7 KB)">Laborator 6: Parcurgerea Grafurilor. Sortare Topologică</a></div>
</li>
<li class="level1"><div class="li"> <a href="../../_media/pa/schelete/2016/lab07.zip" class="media mediafile mf_zip" title="pa:schelete:2016:lab07.zip (14.2 KB)"> Laborator 7: Aplicații DFS</a></div>
</li>
<li class="level1"><div class="li"> <a href="../../_media/pa/schelete/2016/lab08.zip" class="media mediafile mf_zip" title="pa:schelete:2016:lab08.zip (20.7 KB)">Laborator 8: Drumuri minime</a></div>
</li>
<li class="level1"><div class="li"> <a href="../../_media/pa/schelete/2016/lab09.zip" class="media mediafile mf_zip" title="pa:schelete:2016:lab09.zip (6.4 KB)">Laborator 9: Arbori minimi de acoperire</a></div>
</li>
<li class="level1"><div class="li"> <a href="../../_media/pa/schelete/2014/lab10.zip" class="media mediafile mf_zip" title="pa:schelete:2014:lab10.zip (29.4 KB)">Laborator 10: Flux Maxim</a></div>
</li>
<li class="level1"><div class="li"> <a href="../../_media/pa/schelete/2014/lab11.zip" class="media mediafile mf_zip" title="pa:schelete:2014:lab11.zip (38.1 KB)">Laborator 11: A*</a></div>
</li>
<li class="level1"><div class="li"> <a href="../../_media/pa/lab12.zip" class="media mediafile mf_zip" title="pa:lab12.zip (10.9 KB)">Laborator 12: Algoritmi Aleatori</a></div>
</li>
</ul>
<ul>
<li class="level1"><div class="li"> <a href="https://github.com/laurentiustamate94/laboratoare-pa-c-sharp" class="urlextern" title="https://github.com/laurentiustamate94/laboratoare-pa-c-sharp"  rel="nofollow">Schelete de cod in C# pentru 2014-2015</a></div>
</li>
</ul>

</div>
<!-- EDIT2 SECTION "Schelet Cod" [255-1244] -->
<h2 class="sectionedit3" id="laboratoare">Laboratoare</h2>
<div class="level2">
<ul>
<li class="level1"><div class="li"> <a href="laborator-00.html" class="wikilink1" title="pa:laboratoare:laborator-00">Laborator 0: Introducere și Relaxare</a></div>
</li>
<li class="level1"><div class="li"> <span class="curid"><a href="laborator-01.html" class="wikilink1" title="pa:laboratoare:laborator-01">Laborator 1: Divide et Impera</a></span> </div>
</li>
<li class="level1"><div class="li"> <a href="laborator-02.html" class="wikilink1" title="pa:laboratoare:laborator-02">Laborator 2 &amp; 3: Greedy și Programare Dinamică</a></div>
</li>
<li class="level1"><div class="li"> <a href="laborator-04.html" class="wikilink1" title="pa:laboratoare:laborator-04">Laborator 4: Backtracking și optimizări</a></div>
</li>
<li class="level1"><div class="li"> <a href="laborator-05.html" class="wikilink1" title="pa:laboratoare:laborator-05">Laborator 5: Minimax</a></div>
</li>
<li class="level1"><div class="li"> <a href="laborator-06.html" class="wikilink1" title="pa:laboratoare:laborator-06">Laborator 6: Parcurgerea Grafurilor. Sortare Topologică</a></div>
</li>
<li class="level1"><div class="li"> <a href="laborator-07.html" class="wikilink1" title="pa:laboratoare:laborator-07">Laborator 7: Aplicații DFS</a></div>
</li>
<li class="level1"><div class="li"> <a href="laborator-08.html" class="wikilink1" title="pa:laboratoare:laborator-08">Laborator 8: Drumuri minime</a></div>
</li>
<li class="level1"><div class="li"> <a href="laborator-09.html" class="wikilink1" title="pa:laboratoare:laborator-09">Laborator 9: Arbori minimi de acoperire</a></div>
</li>
<li class="level1"><div class="li"> <a href="laborator-10.html" class="wikilink1" title="pa:laboratoare:laborator-10">Laborator 10: Flux Maxim</a></div>
</li>
<li class="level1"><div class="li"> <a href="laborator-11.html" class="wikilink1" title="pa:laboratoare:laborator-11">Laborator 11: A*</a></div>
</li>
<li class="level1"><div class="li"> <a href="laborator-12.html" class="wikilink1" title="pa:laboratoare:laborator-12">Laborator 12: Algoritmi Aleatori</a> </div>
</li>
</ul>

</div>
<!-- EDIT3 SECTION "Laboratoare" [1245-2123] -->
<h2 class="sectionedit4" id="materiale_suplimentare_test_practic">Materiale Suplimentare Test Practic</h2>
<div class="level2">
<ul>
<li class="level1"><div class="li"> <a href="../materiale_test_practic/articole.html" class="wikilink1" title="pa:materiale_test_practic:articole">Articole</a></div>
</li>
<li class="level1"><div class="li"> <a href="../materiale_test_practic/probleme.html" class="wikilink1" title="pa:materiale_test_practic:probleme">Probleme</a></div>
</li>
</ul>

</div>
<!-- EDIT4 SECTION "Materiale Suplimentare Test Practic" [2124-2278] -->
<h2 class="sectionedit5" id="crash-course_optional">Crash-course Opțional</h2>
<div class="level2">
<ul>
<li class="level1"><div class="li"> <a href="../curs-optional/sd-si-debugging.html" class="wikilink1" title="pa:curs-optional:sd-si-debugging">Debugging și Structuri de Date</a></div>
</li>
<li class="level1"><div class="li"> <a href="../../_media/pa/workshop.zip" class="media mediafile mf_zip" title="pa:workshop.zip (36.9 KB)">Schelet: Debugging și Structuri de Date</a></div>
</li>
</ul>

</div>
<!-- EDIT5 SECTION "Crash-course Opțional" [2279-] -->
</div>
<div class="toc_sidebar sidebar_box">
<!-- TOC START -->
<div id="sb__right__dw__toc">
<h3 class="toggle">Table of Contents</h3>
<div>

<ul class="toc">
<li class="level1"><div class="li"><a href="laborator-01.html#laborator_1divide_et_impera">Laborator 1: Divide et Impera</a></div>
<ul class="toc">
<li class="level2"><div class="li"><a href="laborator-01.html#obiective_laborator">Obiective laborator</a></div></li>
<li class="level2"><div class="li"><a href="laborator-01.html#importanta_aplicatii_practice">Importanţă – aplicaţii practice</a></div></li>
<li class="level2"><div class="li"><a href="laborator-01.html#prezentarea_generala_a_problemei">Prezentarea generală a problemei</a></div></li>
<li class="level2"><div class="li"><a href="laborator-01.html#probleme_clasice">Probleme clasice</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="laborator-01.html#sortarea_prin_interclasare">1. Sortarea prin interclasare</a></div></li>
<li class="level3"><div class="li"><a href="laborator-01.html#cautarea_binara">2. Căutarea binară</a></div></li>
<li class="level3"><div class="li"><a href="laborator-01.html#turnurile_din_hanoi">3. Turnurile din Hanoi</a></div></li>
<li class="level3"><div class="li"><a href="laborator-01.html#cautare_numar_lipsa">4. Cautare număr lipsă</a></div></li>
<li class="level3"><div class="li"><a href="laborator-01.html#inmultire_de_polinoame">5. Înmulțire de polinoame</a></div></li>
</ul>
</li>
<li class="level2"><div class="li"><a href="laborator-01.html#concluzii">Concluzii</a></div></li>
</ul>
</li>
<li class="level1"><div class="li"><a href="laborator-01.html#probleme_laborator">Probleme laborator</a></div>
<ul class="toc">
<li class="level2"><div class="li"><a href="laborator-01.html#problema_1_3p">Problema 1 [3p]</a></div></li>
<li class="level2"><div class="li"><a href="laborator-01.html#problema_2_3p">Problema 2 [3p]</a></div></li>
<li class="level2"><div class="li"><a href="laborator-01.html#problema_3_4p">Problema 3 [4p]</a></div></li>
<li class="level2"><div class="li"><a href="laborator-01.html#referinte">Referinţe</a></div></li>
</ul></li>
</ul>
</div>
</div>
<!-- TOC END -->
</div>
        </div>
      
    
      <div class="stylefoot">
        <div class="meta">
          <div class="user">
                    </div>
          <div class="doc">
          pa/laboratoare/laborator-01.txt · Last modified: 2016/03/03 11:54 by radu.iacob          </div>
        </div>
      </div>

    <div class="clearer"></div>

    
                <div class="bar" id="bar__bottom">
      <div class="bar-left">
              </div>
      <div class="bar-right">
        <a href="laborator-01%3Fdo=media&amp;ns=pa%253Alaboratoare.html"  class="action media" rel="nofollow" title="Media Manager">Media Manager</a><a href="laborator-01.html#dokuwiki__top"  class="action top" accesskey="t" rel="nofollow" title="Back to top [T]">Back to top</a>      </div>
    </div>
    <div class="clearer"></div>
            
    <div align="center" class="footerinc">
  <div class="license"><a href="http://creativecommons.org/licenses/by-sa/3.0/" rel="license"><img src="../../lib/images/license/button/cc-by-sa.png" alt="CC Attribution-Share Alike 3.0 Unported" /></a></div>
  <a target="_blank" href="http://www.chimeric.de" title="www.chimeric.de"><img src="../../lib/tpl/arctic/images/button-chimeric-de.png" width="80" height="15" alt="www.chimeric.de" border="0" /></a>

  <a target="_blank" href="http://jigsaw.w3.org/css-validator/check/referer" title="Valid CSS"><img src="../../lib/tpl/arctic/images/button-css.png" width="80" height="15" alt="Valid CSS" border="0" /></a>

  <a target="_blank" href="http://wiki.splitbrain.org/wiki:dokuwiki" title="Driven by DokuWiki"><img src="../../lib/tpl/arctic/images/button-dw.png" width="80" height="15" alt="Driven by DokuWiki" border="0" /></a>

  <a target="_blank" href="http://www.firefox-browser.de" title="do yourself a favour and use a real browser - get firefox"><img src="../../lib/tpl/arctic/images/button-firefox.png" width="80" height="15" alt="do yourself a favour and use a real browser - get firefox!!" border="0" /></a>
  
  <a target="_blank" href="../../feed.php" title="Recent changes RSS feed"><img src="../../lib/tpl/arctic/images/button-rss.png" width="80" height="15" alt="Recent changes RSS feed" border="0" /></a>

  <a target="_blank" href="http://validator.w3.org/check/referer" title="Valid XHTML 1.0"><img src="../../lib/tpl/arctic/images/button-xhtml.png" width="80" height="15" alt="Valid XHTML 1.0" border="0" /></a>
</div>

  </div>
</div>

<div class="no"><img src="../../lib/exe/indexer.php%3Fid=pa%253Alaboratoare%253Alaborator-01&amp;1479891577" width="2" height="1" alt="" /></div>
</body>
</html>
