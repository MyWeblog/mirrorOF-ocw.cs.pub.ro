    
    

<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
  <meta charset="utf-8" />
  <title>sd-ca:2013:laboratoare:laborator-01</title>
<meta name="generator" content="DokuWiki"/>
<meta name="robots" content="index,follow"/>
<meta name="date" content="2014-02-17T22:54:18+0200"/>
<meta name="keywords" content="sd-ca,2013,laboratoare,laborator-01"/>
<link rel="search" type="application/opensearchdescription+xml" href="../../../../../lib/exe/opensearch.php" title="CS Open CourseWare"/>
<link rel="start" href="../../../../../../courses.1.html"/>
<link rel="alternate" type="application/rss+xml" title="Recent Changes" href="../../../../../feed.php"/>
<link rel="alternate" type="application/rss+xml" title="Current Namespace" href="../../../../../feed.php%3Fmode=list&amp;ns=sd-ca:2013:laboratoare"/>
<link rel="alternate" type="text/html" title="Plain HTML" href="laborator-01.html"/>
<link rel="canonical" href="../../../../../sd-ca/2013/laboratoare/laborator-01.html"/>
<link rel="stylesheet" type="text/css" href="../../../../../lib/exe/css.php%3Ft=arctic&amp;tseed=1476798676.css"/>
<script type="text/javascript">/*<![CDATA[*/var NS='sd-ca:2013:laboratoare';var JSINFO = {"id":"sd-ca:2013:laboratoare:laborator-01","namespace":"sd-ca:2013:laboratoare","isadmin":0,"isauth":0};
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="../../../../../lib/exe/js.php%3Ftseed=1476798676"></script>
<script type="text/x-mathjax-config">/*<![CDATA[*/MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ["$","$"], ["\\(","\\)"] ],
        displayMath: [ ["$$","$$"], ["\\[","\\]"] ],
        processEscapes: true
    }
});
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
<script type="text/javascript">/*<![CDATA[*/
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
		  
/*!]]>*/</script>
<script type="text/javascript">/*<![CDATA[*/
var pageTracker = _gat._getTracker("UA-38383934-1");
pageTracker._initData();
pageTracker._trackPageview();
		  
/*!]]>*/</script>
</head>
<body>
<div class="dokuwiki export">
<!-- TOC START -->
<div id="dw__toc">
<h3 class="toggle">Table of Contents</h3>
<div>

<ul class="toc">
<li class="level1"><div class="li"><a href="laborator-01.html#laborator_01_-_introducere_in_c">Laborator 01 - Introducere in C++</a></div>
<ul class="toc">
<li class="level2"><div class="li"><a href="laborator-01.html#obiective">Obiective</a></div></li>
<li class="level2"><div class="li"><a href="laborator-01.html#de_ce_c">De ce C++?</a></div></li>
<li class="level2"><div class="li"><a href="laborator-01.html#sintaxa_c">Sintaxa C++</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="laborator-01.html#de_la_structuri_c_la_clase_c">De la structuri C la clase C++</a></div></li>
<li class="level3"><div class="li"><a href="laborator-01.html#definirea_structurii">Definirea structurii</a></div></li>
<li class="level3"><div class="li"><a href="laborator-01.html#accesarea_membrilor">Accesarea membrilor</a></div></li>
<li class="level3"><div class="li"><a href="laborator-01.html#functii_specifice_structurii">Funcții specifice structurii</a></div></li>
<li class="level3"><div class="li"><a href="laborator-01.html#metode">Metode</a></div></li>
<li class="level3"><div class="li"><a href="laborator-01.html#clase">Clase</a></div></li>
<li class="level3"><div class="li"><a href="laborator-01.html#keyword-ul_class_vs_struct">Keyword-ul &quot;class&quot; vs. &quot;struct&quot;</a></div></li>
<li class="level3"><div class="li"><a href="laborator-01.html#compilare">Compilare</a></div></li>
<li class="level3"><div class="li"><a href="laborator-01.html#specificatori_de_acces">Specificatori de acces</a></div></li>
<li class="level3"><div class="li"><a href="laborator-01.html#constructori_si_destructori">Constructori și destructori</a></div></li>
<li class="level3"><div class="li"><a href="laborator-01.html#constructor">Constructor</a></div></li>
<li class="level3"><div class="li"><a href="laborator-01.html#destructor">Destructor</a></div></li>
<li class="level3"><div class="li"><a href="laborator-01.html#alocareadealocarea_dinamica">Alocarea / Dealocarea dinamică</a></div></li>
<li class="level3"><div class="li"><a href="laborator-01.html#templates">Templates</a></div></li>
<li class="level3"><div class="li"><a href="laborator-01.html#function_template">Function Template</a></div></li>
<li class="level3"><div class="li"><a href="laborator-01.html#class_template">Class Template</a></div></li>
<li class="level3"><div class="li"><a href="laborator-01.html#where_s_the_magic_happening">Where&#039;s the magic happening?</a></div></li>
<li class="level3"><div class="li"><a href="laborator-01.html#guideline-uri_implementare">Guideline-uri implementare</a></div></li>
<li class="level3"><div class="li"><a href="laborator-01.html#clasa_keystorage">Clasa KeyStorage</a></div></li>
</ul>
</li>
<li class="level2"><div class="li"><a href="laborator-01.html#exercitii">Exercitii</a></div></li>
<li class="level2"><div class="li"><a href="laborator-01.html#interviu">Interviu</a></div></li>
<li class="level2"><div class="li"><a href="laborator-01.html#bibliografie_obligatorie">Bibliografie obligatorie</a></div></li>
<li class="level2"><div class="li"><a href="laborator-01.html#bibliografie_recomandata">Bibliografie recomandată</a></div></li>
</ul></li>
</ul>
</div>
</div>
<!-- TOC END -->

<h1 class="sectionedit1" id="laborator_01_-_introducere_in_c">Laborator 01 - Introducere in C++</h1>
<div class="level1">

<p>
Responsabili
</p>
<ul>
<li class="level1"><div class="li"> <a href="mailto:&#x6d;&#x61;&#x69;&#x6c;&#x74;&#x6f;&#x3a;&#x6f;&#x63;&#x74;&#x61;&#x76;&#x69;&#x61;&#x6e;&#x2e;&#x72;&#x69;&#x6e;&#x63;&#x69;&#x6f;&#x67;&#x40;&#x63;&#x73;&#x2e;&#x70;&#x75;&#x62;&#x2e;&#x72;&#x6f;" class="mail" title="&#x6d;&#x61;&#x69;&#x6c;&#x74;&#x6f;&#x3a;&#x6f;&#x63;&#x74;&#x61;&#x76;&#x69;&#x61;&#x6e;&#x2e;&#x72;&#x69;&#x6e;&#x63;&#x69;&#x6f;&#x67;&#x40;&#x63;&#x73;&#x2e;&#x70;&#x75;&#x62;&#x2e;&#x72;&#x6f;"> Octavian Rînciog</a> (2013)</div>
</li>
<li class="level1"><div class="li"> <a href="mailto:&#x6d;&#x61;&#x69;&#x6c;&#x74;&#x6f;&#x3a;&#x76;&#x69;&#x63;&#x74;&#x6f;&#x72;&#x2e;&#x63;&#x61;&#x72;&#x62;&#x75;&#x6e;&#x65;&#x40;&#x63;&#x74;&#x69;&#x2e;&#x70;&#x75;&#x62;&#x2e;&#x72;&#x6f;" class="mail" title="&#x6d;&#x61;&#x69;&#x6c;&#x74;&#x6f;&#x3a;&#x76;&#x69;&#x63;&#x74;&#x6f;&#x72;&#x2e;&#x63;&#x61;&#x72;&#x62;&#x75;&#x6e;&#x65;&#x40;&#x63;&#x74;&#x69;&#x2e;&#x70;&#x75;&#x62;&#x2e;&#x72;&#x6f;"> Victor Cărbune</a> (2012)</div>
</li>
</ul>

<p>
În cadrul acestui laborator ne propunem să ilustrăm conceptele din C++ cu care veți lucra pe parcursul acestui semestru.
</p>

<p>
Într-un mod extrem de simplist spus C++ este un superset al limbajului C, iar tot ceea ce ați învățat în C la <a href="../../../../../programare-ca.html" class="urlextern" title="http://ocw.cs.pub.ro/courses/programare-ca"  rel="nofollow"> PC</a> se poate compila cu un compilator pentru limbajul C++, funcționalitatea rămânând aceeași.
</p>

</div>
<!-- EDIT1 SECTION "Laborator 01 - Introducere in C++" [1-587] -->
<h2 class="sectionedit2" id="obiective">Obiective</h2>
<div class="level2">

<p>
Ne dorim să:
</p>
<ul>
<li class="level1"><div class="li">Realizăm tranziția de la C la C++</div>
</li>
<li class="level1"><div class="li">Înțelegem ce presupune definirea unei clase</div>
</li>
<li class="level1"><div class="li">Învățăm ce înseamnă constructor / destructor</div>
</li>
<li class="level1"><div class="li">Folosim template-uri</div>
</li>
</ul>

</div>
<!-- EDIT2 SECTION "Obiective" [588-790] -->
<h2 class="sectionedit3" id="de_ce_c">De ce C++?</h2>
<div class="level2">

<p>
Pentru că C++ permite implementarea structurilor de date cu tipuri de date generice, prin intermediul template-urilor.
</p>

<p>
În cadrul acestui laborator nu ne așteptăm să dobândiți cunoștințe (elementare sau avansate) legate de programarea pe obiecte, întrucât în anul II există un curs dedicat acestui lucru.
</p>

<p>
Vă încurajăm însă să citiți cât mai multe despre C++ pe parcurs și să cereți lămuriri suplimentare din partea asistenților de la laborator.
</p>

</div>
<!-- EDIT3 SECTION "De ce C++?" [791-1285] -->
<h2 class="sectionedit4" id="sintaxa_c">Sintaxa C++</h2>
<div class="level2">

</div>
<!-- EDIT4 SECTION "Sintaxa C++" [1286-1310] -->
<h3 class="sectionedit5" id="de_la_structuri_c_la_clase_c">De la structuri C la clase C++</h3>
<div class="level3">

</div>
<!-- EDIT5 SECTION "De la structuri C la clase C++" [1311-1352] -->
<h3 class="sectionedit6" id="definirea_structurii">Definirea structurii</h3>
<div class="level3">

<p>
În cadrul laboratorului de Programarea Calculatoarelor am învățat să declarăm și să folosim tipuri de date complexe, <a href="../../../../../programare-ca/laboratoare/lab10.html" class="urlextern" title="http://ocw.cs.pub.ro/courses/programare-ca/laboratoare/lab10"  rel="nofollow"> structuri</a> în limbajul C. Pentru a recapitula, iată mai jos un exemplu simplu de astfel de structură, pentru a reprezenta un număr complex.
</p>
<table class="columns-plugin" style="width:400px">
<tr><td class="columns-plugin first" style="width:100%;">
<dl class="code">
<dt><a href="../../../../code/sd-ca/2013/laboratoare/laborator-01%3Fcodeblock=0" title="Download Snippet" class="mediafile mf_h">complex.h</a></dt>
<dd><pre class="code c++"><span class="co2">#ifndef __COMPLEX_H</span>
<span class="co2">#define __COMPLEX_H</span>
&nbsp;
<span class="kw4">struct</span> complex <span class="br0">&#123;</span>
    <span class="kw4">double</span> re<span class="sy0">;</span>
    <span class="kw4">double</span> im<span class="sy0">;</span>
<span class="br0">&#125;</span><span class="sy0">;</span>
&nbsp;
<span class="co2">#endif // __COMPLEX_H</span></pre>
</dd></dl>
<!-- EDIT6 SECTION "Definirea structurii" [1353-1898] --></td></tr></table>

</div>

<h3 class="sectionedit7" id="accesarea_membrilor">Accesarea membrilor</h3>
<div class="level3">

<p>
Tipul de date definit mai sus, ca orice alt tip de date, poate fi folosit drept:
</p>
<ul>
<li class="level1"><div class="li">o variabilă locală (<a href="http://en.wikipedia.org/wiki/Automatic_variable" class="urlextern" title="http://en.wikipedia.org/wiki/Automatic_variable"  rel="nofollow"> automată</a>), alocată pe <a href="http://en.wikipedia.org/wiki/Stack-based_memory_allocation" class="urlextern" title="http://en.wikipedia.org/wiki/Stack-based_memory_allocation"  rel="nofollow"> stivă</a></div>
<ul>
<li class="level2"><div class="li">accesarea membrilor se face cu operatorul <strong>.</strong> (referențierea structurii)</div>
</li>
<li class="level2"><div class="li">number.re (membrul <em>re</em> al obiectul <em>number</em>)</div>
</li>
</ul>
</li>
</ul>
<ul>
<li class="level1"><div class="li">un pointer către o zonă alocată dinamic, pe <a href="http://en.wikipedia.org/wiki/Heap-based_memory_allocation#Dynamic_memory_allocation" class="urlextern" title="http://en.wikipedia.org/wiki/Heap-based_memory_allocation#Dynamic_memory_allocation"  rel="nofollow"> heap</a>.</div>
<ul>
<li class="level2"><div class="li">accesarea membrilor se face cu operatorul <strong>→</strong> (dereferențierea structurii)</div>
</li>
<li class="level2"><div class="li">pNumber→re (membrul <em>re</em> al obiectul indicat de <em>pNumber</em>)</div>
</li>
</ul>
</li>
</ul>

<p>
Mai jos puteți urmări un exemplu în acest sens:
</p>
<table class="columns-plugin" style="width:400px">
<tr><td class="columns-plugin first" style="width:100%;">
<dl class="code">
<dt><a href="../../../../code/sd-ca/2013/laboratoare/laborator-01%3Fcodeblock=1" title="Download Snippet" class="mediafile mf_cc">main.cc</a></dt>
<dd><pre class="code c++"><span class="co2">#include &lt;stdio.h&gt;</span>
<span class="co2">#include &lt;stdlib.h&gt;</span>
<span class="co2">#include &quot;complex.h&quot;</span>
&nbsp;
<span class="kw4">int</span> main<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
    <span class="co1">// variabila locala de tip struct complex</span>
    <span class="kw4">struct</span> complex number<span class="sy0">;</span>
    number.<span class="me1">re</span> <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
    number.<span class="me1">im</span> <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span>
&nbsp;
    <span class="co1">// variabila de tip pointer, catre o zona de memorie alocata dinamic</span>
    <span class="kw4">struct</span> complex <span class="sy0">*</span>pNumber <span class="sy0">=</span> <span class="br0">&#40;</span><span class="kw4">struct</span> complex <span class="sy0">*</span><span class="br0">&#41;</span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/malloc.html"><span class="kw3">malloc</span></a><span class="br0">&#40;</span><span class="kw4">sizeof</span><span class="br0">&#40;</span><span class="kw4">struct</span> complex<span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy0">;</span>
    pNumber<span class="sy0">-&gt;</span>re <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span>
    pNumber<span class="sy0">-&gt;</span>im <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
&nbsp;
    <a href="http://www.opengroup.org/onlinepubs/009695399/functions/free.html"><span class="kw3">free</span></a><span class="br0">&#40;</span>pNumber<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
    <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">&#125;</span></pre>
</dd></dl>
<!-- EDIT7 SECTION "Accesarea membrilor" [1899-3166] --></td></tr></table>

</div>

<h3 class="sectionedit8" id="functii_specifice_structurii">Funcții specifice structurii</h3>
<div class="level3">

<p>
Dându-se o variabilă de tip <em>struct complex</em> vom dori să efectuăm diferite operații asupra acesteia.
</p>
<dl class="code">
<dt><a href="../../../../code/sd-ca/2013/laboratoare/laborator-01%3Fcodeblock=2" title="Download Snippet" class="mediafile mf_h">complex.h</a></dt>
<dd><pre class="code c++"><span class="co2">#ifndef __COMPLEX_H</span>
<span class="co2">#define __COMPLEX_H</span>
&nbsp;
<span class="kw4">struct</span> complex <span class="br0">&#123;</span>
    <span class="kw4">double</span> re<span class="sy0">;</span>
    <span class="kw4">double</span> im<span class="sy0">;</span>
<span class="br0">&#125;</span><span class="sy0">;</span>
&nbsp;
<span class="co1">// Initializeaza campurile unei structuri date.</span>
<span class="kw4">void</span> complex_initialize<span class="br0">&#40;</span><span class="kw4">struct</span> complex <span class="sy0">*</span>number<span class="sy0">,</span> <span class="kw4">double</span> re<span class="sy0">,</span> <span class="kw4">double</span> im<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
<span class="co1">// Intoarce o structura ce contine numarul complex conjugat.</span>
<span class="kw4">struct</span> complex complex_conjugate<span class="br0">&#40;</span><span class="kw4">struct</span> complex <span class="sy0">*</span>number<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
<span class="co2">#endif // __COMPLEX_H</span></pre>
</dd></dl>

<p>
Ce observăm că au în comun cele două funcții?
Hint: primul parametru, care reprezintă un pointer către o zonă de memorie care reține tipul <em>struct complex</em>
</p>

</div>
<!-- EDIT8 SECTION "Funcții specifice structurii" [3167-3867] -->
<h3 class="sectionedit9" id="metode">Metode</h3>
<div class="level3">

<p>
Acest pattern de a defini funcții specifice unui anumit tip de date este extrem de întâlnit.
De asemenea, se observă că aceste funcții nu ar putea fi folosite în combinație cu alte structuri de date, ele fiind specifice <em>struct complex</em>.
</p>

<p>
Așadar, iată cum o structură poate să capete metode specifice (codul de mai jos este specific C++):
</p>
<dl class="code">
<dt><a href="../../../../code/sd-ca/2013/laboratoare/laborator-01%3Fcodeblock=3" title="Download Snippet" class="mediafile mf_h">complex.h</a></dt>
<dd><pre class="code c++"><span class="co2">#ifndef __COMPLEX_H</span>
<span class="co2">#define __COMPLEX_H</span>
&nbsp;
<span class="kw4">struct</span> complex <span class="br0">&#123;</span>
    <span class="kw4">double</span> re<span class="sy0">;</span>
    <span class="kw4">double</span> im<span class="sy0">;</span>
&nbsp;
    <span class="kw4">void</span> complex_initialize<span class="br0">&#40;</span><span class="kw4">double</span> re<span class="sy0">,</span> <span class="kw4">double</span> im<span class="br0">&#41;</span><span class="sy0">;</span>
    <span class="kw4">struct</span> complex complex_conjugate<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
<span class="br0">&#125;</span><span class="sy0">;</span>
<span class="co2">#endif // __COMPLEX_H</span></pre>
</dd></dl>

<p>
Astfel, avem definite metode, care operează pe tipul de date respectiv, și care pot fi apelate întocmai cum se realiza accesarea membrilor de date. Observăm însă că a dispărut primul parametru! De ce?
</p>

<p>
Întrucât metodele definite mai sus pot fi apelate numai pe o variabilă de tip <em>struct complex</em>,
C++ transmite ascuns în spate un pointer <strong>struct complex *this</strong> care poate fi folosit pentru a accesa câmpurile variabilei date.
</p>

<p>
Iată implementarea metodelor în antetul definit mai sus.
</p>

<p>
Compilați și rulați codul de mai jos cu <strong>g++</strong>.
</p>
<dl class="code">
<dt><a href="../../../../code/sd-ca/2013/laboratoare/laborator-01%3Fcodeblock=4" title="Download Snippet" class="mediafile mf_h">complex.h</a></dt>
<dd><pre class="code c++"><span class="co2">#ifndef __COMPLEX_H</span>
<span class="co2">#define __COMPLEX_H</span>
&nbsp;
<span class="kw4">struct</span> complex <span class="br0">&#123;</span>
    <span class="kw4">double</span> re<span class="sy0">;</span>
    <span class="kw4">double</span> im<span class="sy0">;</span>
&nbsp;
    <span class="kw4">void</span> complex_initialize<span class="br0">&#40;</span><span class="kw4">double</span> re<span class="sy0">,</span> <span class="kw4">double</span> im<span class="br0">&#41;</span> <span class="br0">&#123;</span>
        this<span class="sy0">-&gt;</span>re <span class="sy0">=</span> re<span class="sy0">;</span>
        this<span class="sy0">-&gt;</span>im <span class="sy0">=</span> im<span class="sy0">;</span>
    <span class="br0">&#125;</span>
&nbsp;
    <span class="kw4">struct</span> complex complex_conjugate<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        <span class="kw4">struct</span> complex conjugate<span class="sy0">;</span>
        conjugate.<span class="me1">complex_initialize</span><span class="br0">&#40;</span>this<span class="sy0">-&gt;</span>re<span class="sy0">,</span> <span class="sy0">-</span><span class="br0">&#40;</span>this<span class="sy0">-&gt;</span>im<span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
        <span class="kw1">return</span> conjugate<span class="sy0">;</span>
    <span class="br0">&#125;</span>
<span class="br0">&#125;</span><span class="sy0">;</span>
<span class="co2">#endif // __COMPLEX_H</span></pre>
</dd></dl>
<dl class="code">
<dt><a href="../../../../code/sd-ca/2013/laboratoare/laborator-01%3Fcodeblock=5" title="Download Snippet" class="mediafile mf_cc">main.cc</a></dt>
<dd><pre class="code c++"><span class="co2">#include &lt;stdio.h&gt;</span>
<span class="co2">#include &quot;complex.h&quot;</span>
&nbsp;
<span class="kw4">int</span> main<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
    <span class="kw4">struct</span> complex number<span class="sy0">;</span>
&nbsp;
    number.<span class="me1">complex_initialize</span><span class="br0">&#40;</span><span class="nu0">2</span><span class="sy0">,</span> <span class="nu0">3</span><span class="br0">&#41;</span><span class="sy0">;</span>
    <a href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span class="kw3">printf</span></a><span class="br0">&#40;</span><span class="st0">&quot;%.2lf %.2lf<span class="es1">\n</span>&quot;</span><span class="sy0">,</span> number.<span class="me1">re</span><span class="sy0">,</span> number.<span class="me1">im</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
    number.<span class="me1">complex_initialize</span><span class="br0">&#40;</span><span class="nu0">5</span><span class="sy0">,</span> <span class="nu0">6</span><span class="br0">&#41;</span><span class="sy0">;</span>
    <a href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span class="kw3">printf</span></a><span class="br0">&#40;</span><span class="st0">&quot;%.2lf %.2lf<span class="es1">\n</span>&quot;</span><span class="sy0">,</span> number.<span class="me1">re</span><span class="sy0">,</span> number.<span class="me1">im</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
    <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">&#125;</span></pre>
</dd></dl>

</div>
<!-- EDIT9 SECTION "Metode" [3868-5787] -->
<h3 class="sectionedit10" id="clase">Clase</h3>
<div class="level3">

<p>
Formal am făcut deja primii pași mai sus pentru a implementa o clasă în C++, utilizând keyword-ul <em>struct</em>.
</p>

<p>
Dar totuși, ce înseamnă o clasă? Și aici nu trebuie decât să ne gândim la ce am făcut mai sus pentru a implementa o clasă:
</p>
<ul>
<li class="level1"><div class="li">am adăugat atribute (am definit ce proprietăți caracterizează clasa: partea reală și partea imaginară)</div>
</li>
<li class="level1"><div class="li">am adăugat metode (am definit cum se comportă clasă: inițializarea și conjugarea)</div>
</li>
</ul>

<p>
Cu această adăugare menționată, putem să ne referim la ceea ce înseamnă o <strong>clasă</strong>, respectiv un <strong>obiect</strong>.
</p>

<p>
Ne referim la o <strong>clasă</strong> ca fiind o amprentă sau descriere generală.
Un <strong>obiect</strong> este o instanță a clasei respective - o variabilă concretă ce este de tipul clasei.
</p>

<p>
Vom numi <strong>clasă</strong> tipul de date definit de <em>struct complex</em> sau <em>class complex</em> și <strong>obiect</strong> o instanțiere (o alocare dinamică sau locală) a tipului de date.
</p>

<p>
Când discutăm despre tipul de date <em>complex</em> ne referim la clasă.
Când discutăm despre variabila <em>number</em> ne referim la un obiect, o instanță a clasei.
</p>

</div>
<!-- EDIT10 SECTION "Clase" [5788-6886] -->
<h3 class="sectionedit11" id="keyword-ul_class_vs_struct">Keyword-ul &quot;class&quot; vs. &quot;struct&quot;</h3>
<div class="level3">

<p>
Și totuși, C++ adăugă keyword-ul <em>class</em>. Care este diferența între <em>class</em> și <em>struct</em>?
Iată cum definim complet clasa de mai sus, separând antetul de implementare și de programul principal.
</p>
<table class="columns-plugin" style="width:100%">
<tr><td class="columns-plugin first" style="width:100%;">
<dl class="code">
<dt><a href="../../../../code/sd-ca/2013/laboratoare/laborator-01%3Fcodeblock=6" title="Download Snippet" class="mediafile mf_h">complex.h</a></dt>
<dd><pre class="code c++">class Complex <span class="br0">&#123;</span>
    <span class="kw4">double</span> re<span class="sy0">;</span>
    <span class="kw4">double</span> im<span class="sy0">;</span>
&nbsp;
    Complex conjugate<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span> 
<span class="br0">&#125;</span><span class="sy0">;</span></pre>
</dd></dl>
</td><td class="columns-plugin">
<dl class="code">
<dt><a href="../../../../code/sd-ca/2013/laboratoare/laborator-01%3Fcodeblock=7" title="Download Snippet" class="mediafile mf_cc">complex.cc</a></dt>
<dd><pre class="code c++"><span class="co2">#include &quot;complex.h&quot;</span>
Complex Complex<span class="sy0">::</span><span class="me2">conjugate</span><span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
    Complex conjugate<span class="sy0">;</span>
    conjugate.<span class="me1">re</span> <span class="sy0">=</span> this<span class="sy0">-&gt;</span>re<span class="sy0">;</span>
    conjugate.<span class="me1">im</span> <span class="sy0">=</span> <span class="sy0">-</span><span class="br0">&#40;</span>this<span class="sy0">-&gt;</span>im<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
    <span class="kw1">return</span> conjugate<span class="sy0">;</span>
<span class="br0">&#125;</span></pre>
</dd></dl>
</td><td class="columns-plugin last">
<dl class="code">
<dt><a href="../../../../code/sd-ca/2013/laboratoare/laborator-01%3Fcodeblock=8" title="Download Snippet" class="mediafile mf_cc">main.cc</a></dt>
<dd><pre class="code c++"><span class="co2">#include &lt;stdio.h&gt;</span>
<span class="co2">#include &quot;complex.h&quot;</span>
&nbsp;
<span class="kw4">int</span> main<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
    Complex number<span class="sy0">;</span>
    number.<span class="me1">re</span> <span class="sy0">=</span> <span class="nu0">2</span><span class="sy0">;</span>
    number.<span class="me1">im</span> <span class="sy0">=</span> <span class="nu0">4</span><span class="sy0">;</span>
&nbsp;
    <a href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span class="kw3">printf</span></a><span class="br0">&#40;</span><span class="st0">&quot;%.2lf %.2lf<span class="es1">\n</span>&quot;</span><span class="sy0">,</span> number.<span class="me1">re</span><span class="sy0">,</span> number.<span class="me1">im</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
    <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">&#125;</span></pre>
</dd></dl>
<!-- EDIT11 SECTION "Keyword-ul class vs. struct" [6887-7721] --></td></tr></table>

</div>

<h3 class="sectionedit12" id="compilare">Compilare</h3>
<div class="level3">

<p>
Sursele C++ se compilează folosind compilatorul <strong>g++</strong>. Acesta permite exact aceleași opțiuni de bază ca și <strong>gcc</strong>, compilatorul utilizat pentru sursele de C.
</p>
<ul>
<li class="level1"><div class="li"> Încercați să compilați și să rulați codul din cele 3 fișiere de mai sus.</div>
</li>
</ul>
<pre class="code bash"><span class="kw2">g++</span> complex.cc main.cc <span class="re5">-o</span> exemplu</pre>

<p>
Ce observați?
</p>

<p>
Înlocuiți acum keyword-ul <em>class</em> cu keyword-ul <em>struct</em> și compilați din nou.
</p>

</div>
<!-- EDIT12 SECTION "Compilare" [7722-8151] -->
<h3 class="sectionedit13" id="specificatori_de_acces">Specificatori de acces</h3>
<div class="level3">

<p>
Am observat mesajul de eroare în urma compilării fișierelor de mai sus.
</p>

<p>
Astfel, <strong>singura diferență</strong> folosirea celor două keyword-ul este nivelul implicit de vizibilitate a metodelor și atributelor.
</p>
<ul>
<li class="level1"><div class="li"><strong>private</strong> - pentru clasele declarate cu <strong>class</strong></div>
</li>
<li class="level1"><div class="li"><strong>public</strong>  - pentru clasele declarate cu <strong>struct</strong></div>
</li>
</ul>

<p>
Membri precedați de label-ul <strong>private</strong> pot fi folosiți numai în interiorul clasei, în cadrul metodelor acesteia.
Ei nu pot fi citiți sau modificați din afara clasei.
</p>

<p>
Iată cum puteam remedia soluția:
</p>
<dl class="code">
<dt><a href="../../../../code/sd-ca/2013/laboratoare/laborator-01%3Fcodeblock=10" title="Download Snippet" class="mediafile mf_h">complex.h</a></dt>
<dd><pre class="code c++">class Complex <span class="br0">&#123;</span>
public<span class="sy0">:</span>
    <span class="kw4">double</span> re<span class="sy0">;</span>
    <span class="kw4">double</span> im<span class="sy0">;</span>
&nbsp;
    Complex conjugate<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
<span class="br0">&#125;</span><span class="sy0">;</span></pre>
</dd></dl>

</div>
<!-- EDIT13 SECTION "Specificatori de acces" [8152-8827] -->
<h3 class="sectionedit14" id="constructori_si_destructori">Constructori și destructori</h3>
<div class="level3">

<p>
Studiați codul de mai jos.
</p>
<table class="columns-plugin" style="width:100%">
<tr><td class="columns-plugin first" style="width:100%;">
<dl class="code">
<dt><a href="../../../../code/sd-ca/2013/laboratoare/laborator-01%3Fcodeblock=11" title="Download Snippet" class="mediafile mf_h">complex.h</a></dt>
<dd><pre class="code c++">class Complex <span class="br0">&#123;</span>
public<span class="sy0">:</span>
    <span class="co1">// Constructor</span>
    Complex<span class="br0">&#40;</span><span class="kw4">double</span> re<span class="sy0">,</span> <span class="kw4">double</span> im<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
    <span class="co1">// Destructor</span>
    ~Complex<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
    <span class="kw4">double</span> getRe<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
    <span class="kw4">double</span> getIm<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
    Complex conjugate<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span> 
&nbsp;
private<span class="sy0">:</span>
    <span class="kw4">double</span> re<span class="sy0">;</span>
    <span class="kw4">double</span> im<span class="sy0">;</span>
<span class="br0">&#125;</span><span class="sy0">;</span></pre>
</dd></dl>
</td><td class="columns-plugin last">
<dl class="code">
<dt><a href="../../../../code/sd-ca/2013/laboratoare/laborator-01%3Fcodeblock=12" title="Download Snippet" class="mediafile mf_cc">complex.cc</a></dt>
<dd><pre class="code c++"><span class="co2">#include &quot;complex.h&quot;</span>
Complex<span class="sy0">::</span><span class="me2">Complex</span><span class="br0">&#40;</span><span class="kw4">double</span> re<span class="sy0">,</span> <span class="kw4">double</span> im<span class="br0">&#41;</span> <span class="br0">&#123;</span>
    this<span class="sy0">-&gt;</span>re <span class="sy0">=</span> re<span class="sy0">;</span>
    this<span class="sy0">-&gt;</span>im <span class="sy0">=</span> im<span class="sy0">;</span>
<span class="br0">&#125;</span>
&nbsp;
Complex<span class="sy0">::</span>~Complex<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
<span class="br0">&#125;</span>
&nbsp;
Complex Complex<span class="sy0">::</span><span class="me2">conjugate</span><span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
    Complex conjugat<span class="br0">&#40;</span>re<span class="sy0">,</span> <span class="sy0">-</span>im<span class="br0">&#41;</span><span class="sy0">;</span>
    <span class="kw1">return</span> conjugat<span class="sy0">;</span>
<span class="br0">&#125;</span>
&nbsp;
<span class="kw4">double</span> Complex<span class="sy0">::</span><span class="me2">getRe</span><span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
    <span class="kw1">return</span> re<span class="sy0">;</span>
<span class="br0">&#125;</span>
&nbsp;
<span class="kw4">double</span> Complex<span class="sy0">::</span><span class="me2">getIm</span><span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
    <span class="kw1">return</span> im<span class="sy0">;</span>
<span class="br0">&#125;</span></pre>
</dd></dl>
</td></tr></table>
<dl class="code">
<dt><a href="../../../../code/sd-ca/2013/laboratoare/laborator-01%3Fcodeblock=13" title="Download Snippet" class="mediafile mf_cc">main.cc</a></dt>
<dd><pre class="code c++"><span class="co2">#include &lt;stdio.h&gt;</span>
<span class="co2">#include &quot;complex.h&quot;</span>
&nbsp;
<span class="kw4">int</span> main<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
    Complex number<span class="br0">&#40;</span><span class="nu0">2</span><span class="sy0">,</span> <span class="nu0">3</span><span class="br0">&#41;</span><span class="sy0">;</span>
    <a href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span class="kw3">printf</span></a><span class="br0">&#40;</span><span class="st0">&quot;%lf %lf<span class="es1">\n</span>&quot;</span><span class="sy0">,</span> number.<span class="me1">getRe</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">,</span> number.<span class="me1">getIm</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
    <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">&#125;</span></pre>
</dd></dl>

</div>
<!-- EDIT14 SECTION "Constructori și destructori" [8828-9738] -->
<h3 class="sectionedit15" id="constructor">Constructor</h3>
<div class="level3">

<p>
Observăm două bucăți din cod în mod special:
</p>
<pre class="code c++">Complex<span class="sy0">::</span><span class="me2">Complex</span><span class="br0">&#40;</span><span class="kw4">double</span> re<span class="sy0">,</span> <span class="kw4">double</span> im<span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>
Linia de mai sus <strong>nu are tip</strong> returnat, spre deosebire de celelalte linii.
Acesta este <strong>constructorul</strong> clasei, care este apelat în momentul alocării unui obiect.
</p>

<p>
Ce operații sunt uzuale în constructor?
</p>
<ul>
<li class="level1"><div class="li">inițializarea membrilor clasei cu valori predefinite sau date ca parametru</div>
</li>
<li class="level1"><div class="li">alocarea memoriei pentru anumiți membri</div>
</li>
</ul>

<p>
A doua bucată observată este:
</p>
<pre class="code c++">Complex numar<span class="br0">&#40;</span><span class="nu0">2</span><span class="sy0">,</span> <span class="nu0">3</span><span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>
Până acum nu ați mai alocat astfel structurile. Ce se întâmplă în spate este exact ceea ce intuiți: este apelat constructorul obiectului și se execută instrucțiunile acestuia pentru variabila numar (reprezentată ca pointer prin this, direct în interiorul constructorului).
</p>

<p>
În constructorul definit mai sus, tot ceea ce se întâmplă este să se inițializeze membri. Pentru asta, C++ vă pune la dispoziție o sintaxă simplă:
</p>
<pre class="code c++">Complex<span class="sy0">::</span><span class="me2">Complex</span><span class="br0">&#40;</span><span class="kw4">double</span> real<span class="sy0">,</span> <span class="kw4">double</span> imaginar<span class="br0">&#41;</span> <span class="sy0">:</span>
    re<span class="br0">&#40;</span>real<span class="br0">&#41;</span><span class="sy0">,</span>
    im<span class="br0">&#40;</span>imaginar<span class="br0">&#41;</span> <span class="br0">&#123;</span>
<span class="br0">&#125;</span></pre>

<p>
Cei doi constructori sunt identici ca funcționalitate.
</p>

</div>
<!-- EDIT15 SECTION "Constructor" [9739-10883] -->
<h3 class="sectionedit16" id="destructor">Destructor</h3>
<div class="level3">

<p>
Așa cum probabil ați observat, <strong>constructorul</strong> este apelat în mod <strong>explicit</strong> de către voi. <strong>Destructorul</strong> însă, în cazul de mai sus, este apelat <strong>implicit</strong> la terminarea blocului care realizează dealocărea automată a obiectului.
</p>

<p>
Un destructor nu are parametri și se declară în interiorul clasei astfel:
</p>
<pre class="code c++">~Complex<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>
Dacă în constructor sau în interiorul clasei ați fi alocat memorie, cel mai probabil în destructor ați fi făcut curat și ați fi apelat free pe membrul respectiv.
</p>

</div>
<!-- EDIT16 SECTION "Destructor" [10884-11433] -->
<h3 class="sectionedit17" id="alocareadealocarea_dinamica">Alocarea / Dealocarea dinamică</h3>
<div class="level3">

<p>
C++ introduce perechea de keyword-uri <em>new</em> și <em>delete</em>, care se folosesc pentru a aloca dinamic instanțe ale claselor.
</p>
<pre class="code c++">Complex <span class="sy0">*</span>numar <span class="sy0">=</span> new Complex<span class="br0">&#40;</span><span class="nu0">2</span><span class="sy0">,</span> <span class="nu0">3</span><span class="br0">&#41;</span><span class="sy0">;</span>
delete numar<span class="sy0">;</span></pre>

<p>
Keyword-ul <em>new</em> apelează constructorul clasei, iar keyword-ul <em>delete</em> apelează destructorul clasei.
</p>

<p>
<strong>Observație</strong>
</p>
<ul>
<li class="level1"><div class="li"> Un obiect se alocă/dezalocă cu combinația <em>new/delete</em></div>
</li>
<li class="level1"><div class="li"> Un vector de obiecte se alocă/dezalocă cu <em>combinația <code>new[]/delete[]</code></em></div>
</li>
</ul>
<pre class="code c++">Complex <span class="sy0">*</span>numere <span class="sy0">=</span> new Complex<span class="br0">&#91;</span><span class="nu0">10</span><span class="br0">&#93;</span><span class="sy0">;</span>
delete<span class="br0">&#91;</span><span class="br0">&#93;</span> numere<span class="sy0">;</span></pre>

</div>
<!-- EDIT17 SECTION "Alocarea / Dealocarea dinamică" [11434-12016] -->
<h3 class="sectionedit18" id="templates">Templates</h3>
<div class="level3">

<p>
Motivul principal pentru care folosim C++ în cadrul SD este datorită funcționalității oferite de template-uri.
</p>

<p>
Acestea permit generalizarea tipurilor de date folosite în interiorul funcțiilor și claselor.
</p>

<p>
Sintaxa pentru acestea este:
</p>
<pre class="code c++">template <span class="sy0">&lt;</span>class identifier<span class="sy0">&gt;</span> declaratie<span class="sy0">;</span>
template <span class="sy0">&lt;</span>typename identifier<span class="sy0">&gt;</span> declaratie<span class="sy0">;</span></pre>

<p>
<em>declaratie</em> poate fi fie o funcție, fie o clasă.
Nu există nicio diferență între keyword-ul <em>class</em> și <em>typename</em> - important este că ceea ce urmează după ele este un placeholder pentru un tip de date.
</p>

</div>
<!-- EDIT18 SECTION "Templates" [12017-12603] -->
<h3 class="sectionedit19" id="function_template">Function Template</h3>
<div class="level3">

<p>
În primul rând template-urile pot fi aplicate funcțiilor.
</p>

<p>
Un exemplu comun și simplu este următorul:
</p>
<pre class="code c++">template<span class="sy0">&lt;</span>typename T<span class="sy0">&gt;</span>
T getMax<span class="br0">&#40;</span>T a<span class="sy0">,</span> T b<span class="br0">&#41;</span> <span class="br0">&#123;</span>
    <span class="kw1">return</span> a <span class="sy0">&gt;</span> b <span class="sy0">?</span> a <span class="sy0">:</span> b<span class="sy0">;</span>
<span class="br0">&#125;</span></pre>

<p>
Funcția poate fi apelată astfel:
</p>
<pre class="code c++">getMax<span class="sy0">&lt;</span>int<span class="sy0">&gt;</span><span class="br0">&#40;</span><span class="nu0">2</span><span class="sy0">,</span> <span class="nu0">3</span><span class="br0">&#41;</span><span class="sy0">;</span>
getMax<span class="sy0">&lt;</span>double<span class="sy0">&gt;</span><span class="br0">&#40;</span><span class="nu16">3.2</span><span class="sy0">,</span> <span class="nu16">4.6</span><span class="br0">&#41;</span><span class="sy0">;</span></pre>

</div>
<!-- EDIT19 SECTION "Function Template" [12604-12928] -->
<h3 class="sectionedit20" id="class_template">Class Template</h3>
<div class="level3">

<p>
Concret, să presupunem că avem o clasă numită KeyStorage care are:
</p>
<ul>
<li class="level1"><div class="li">o cheie (de tip int)</div>
</li>
<li class="level1"><div class="li">un membru de date generic (al cărui tip de date nu îl știm la momentul scrierii clasei).</div>
</li>
</ul>

<p>
Vrem să putem folosi codul clasei indiferent de tipul de date al membrului.
</p>

<p>
Iată cum putem face acest lucru:
</p>
<dl class="code">
<dt><a href="../../../../code/sd-ca/2013/laboratoare/laborator-01%3Fcodeblock=23" title="Download Snippet" class="mediafile mf_h">KeyStorage.h</a></dt>
<dd><pre class="code c++">template<span class="sy0">&lt;</span>typename T<span class="sy0">&gt;</span>
class KeyStorage <span class="br0">&#123;</span>
public<span class="sy0">:</span>
    <span class="kw4">int</span> key<span class="sy0">;</span>
    T member<span class="sy0">;</span>
<span class="br0">&#125;</span><span class="sy0">;</span></pre>
</dd></dl>

<p>
În funcția main, să presupunem că vrem să folosim clasa cu membrul de tip long.
</p>
<dl class="code">
<dt><a href="../../../../code/sd-ca/2013/laboratoare/laborator-01%3Fcodeblock=24" title="Download Snippet" class="mediafile mf_cc">main.cc</a></dt>
<dd><pre class="code c++"><span class="co2">#include &quot;KeyStorage.h&quot;</span>
&nbsp;
<span class="kw4">int</span> main<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
    KeyStorage<span class="sy0">&lt;</span>long<span class="sy0">&gt;</span> keyElement<span class="sy0">;</span>
    <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">&#125;</span></pre>
</dd></dl>

<p>
Practic, oriunde folosim tipul de date T în clasă, este înlocuit cu tipul pe care îl specificăm.
</p>

</div>
<!-- EDIT20 SECTION "Class Template" [12929-13670] -->
<h3 class="sectionedit21" id="where_s_the_magic_happening">Where&#039;s the magic happening?</h3>
<div class="level3">

<p>
Sunt destul de multe lucruri de spus despre template-uri, dar ne vom concentra pe lucrurile care schimbă modul în care ați implementat până acum.
</p>

<p>
Template-urile sunt de fapt indicii pentru compilator pentru a genera cod la rândul lui!
Practic, voi îi spuneți compilatorului un șablon generic pe care ați vrea să-l folosiți și el trebuie să fie pregătit să îl pună la dispoziția voastră când aveți nevoie.
</p>

<p>
Ce trebuie să rețineți din asta? Totul se întâmplă la <strong>compile time</strong>, nu la run time.
</p>

<p>
Compilatorul practic analizează modul în care voi folosiți clasa respectivă și generează pentru fiecare mod în care o folosiți șablonul corespunzător.
Folosirea KeyStorage&lt;int&gt; și KeyStorage&lt;float&gt; determină compilatorul să genereze cod pentru ambele clase (înlocuind o dată T cu int și altă cu float).
</p>

</div>
<!-- EDIT21 SECTION "Where's the magic happening?" [13671-14555] -->
<h3 class="sectionedit22" id="guideline-uri_implementare">Guideline-uri implementare</h3>
<div class="level3">

<p>
Pentru că totul se întâmplă la compile time, înseamnă că în momentul în care compilatorul întâlnește secvența de cod ce folosește template-uri trebuie să știe <em>toate</em> modurile în care aceasta este folosita.
</p>

<p>
Asta înseamnă că:
</p>
<ul>
<li class="level1"><div class="li">Trebuie să scrieți întreaga implementare în header! <em>sau</em></div>
</li>
<li class="level1"><div class="li">Scrieți descrierea clasei generic în header, în fișierul de implementare fiecare metodă declarată este de fapt o funcție cu template și la sfârșitul implementării adăugat <em>template class numeclasa&lt;numetip&gt;</em>;</div>
</li>
</ul>

<p>
Ultimul rând de fapt forțează folosirea template-ului cu un anumit tip de date și deci compilatorul generează cod corespunzător (trebuie să scrieți asta pentru toate tipurile).
</p>

</div>
<!-- EDIT22 SECTION "Guideline-uri implementare" [14556-15318] -->
<h3 class="sectionedit23" id="clasa_keystorage">Clasa KeyStorage</h3>
<div class="level3">

<p>
Iată mai jos o structură mai dezvoltată pentru clasa KeyStorage, în care cheia este setată în constructor.
.
</p>
<dl class="code">
<dt><a href="../../../../code/sd-ca/2013/laboratoare/laborator-01%3Fcodeblock=25" title="Download Snippet" class="mediafile mf_h">KeyStorage.h</a></dt>
<dd><pre class="code c++">template<span class="sy0">&lt;</span>typename T<span class="sy0">&gt;</span>
class KeyStorage <span class="br0">&#123;</span>
public<span class="sy0">:</span>
    KeyStorage<span class="br0">&#40;</span><span class="kw4">int</span> k<span class="br0">&#41;</span><span class="sy0">;</span>
    ~KeyStorage<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
    T getMember<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
    T setMember<span class="br0">&#40;</span>T element<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
private<span class="sy0">:</span>
    T member<span class="sy0">;</span>
    <span class="kw4">int</span> key<span class="sy0">;</span>
<span class="br0">&#125;</span><span class="sy0">;</span></pre>
</dd></dl>

<p>
Implementarea completa a ei poate fi realizată:
</p>
<ul>
<li class="level1"><div class="li">în header (în cazul template-urilor, acest mod este cel mai indicat).</div>
</li>
<li class="level1"><div class="li">în fișierul de implementare .cc / .cpp (al cărui schelet parțial îl găsiți mai jos).</div>
</li>
</ul>
<dl class="code">
<dt><a href="../../../../code/sd-ca/2013/laboratoare/laborator-01%3Fcodeblock=26" title="Download Snippet" class="mediafile mf_cpp">KeyStorage.cpp</a></dt>
<dd><pre class="code c++"><span class="co2">#include &quot;KeyStorage.h&quot;</span>
&nbsp;
template<span class="sy0">&lt;</span>typename T<span class="sy0">&gt;</span>
KeyStorage<span class="sy0">&lt;</span>T<span class="sy0">&gt;::</span><span class="me2">KeyStorage</span><span class="br0">&#40;</span><span class="kw4">int</span> k<span class="br0">&#41;</span> <span class="br0">&#123;</span>
<span class="co1">//TODO</span>
<span class="br0">&#125;</span>
&nbsp;
template<span class="sy0">&lt;</span>typename T<span class="sy0">&gt;</span>
KeyStorage<span class="sy0">&lt;</span>T<span class="sy0">&gt;::</span>~KeyStorage<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
<span class="br0">&#125;</span>
&nbsp;
<span class="co1">//TODO: restul metodelor.</span>
&nbsp;
<span class="co1">// La sfarsit, cu tipurile de date pe care le veti folosi.</span>
template class KeyStorage<span class="sy0">&lt;</span>int<span class="sy0">&gt;;</span>
template class KeyStorage<span class="sy0">&lt;</span>long<span class="sy0">&gt;;</span></pre>
</dd></dl>

</div>
<!-- EDIT23 SECTION "Clasa KeyStorage" [15319-16233] -->
<h2 class="sectionedit24" id="exercitii">Exercitii</h2>
<div class="level2">
<ul>
<li class="level1"><div class="li">[<strong>2p</strong>] Parcurgeți laboratorul în întregime și discutați cu asistentul vostru eventualele neclarități.</div>
</li>
</ul>
<ul>
<li class="level1"><div class="li">[<strong>3p</strong>] Clasa Complex</div>
<ul>
<li class="level2"><div class="li">[<strong>2p</strong>] Adăugați clasei Complex metode pentru adunare, scădere și înmulțire cu un alt număr complex.</div>
</li>
<li class="level2"><div class="li">[<strong>1p</strong>] Arătați funcționalitatea prin adăugarea unui cod simplist în fișierul main.cc</div>
</li>
</ul>
</li>
</ul>
<ul>
<li class="level1"><div class="li">[<strong>5p</strong>] Clasa KeyStorage</div>
<ul>
<li class="level2"><div class="li">[<strong>2p</strong>] Implementați și folosiți utilizând template-uri clasa KeyStorage de mai sus adăugând constructor, destructor.</div>
</li>
<li class="level2"><div class="li">[<strong>2p</strong>] Alocați o instanță de tip KeyStorage local și dinamic (utilizând new / delete).</div>
</li>
<li class="level2"><div class="li">[<strong>1p</strong>] Verificați cu valgrind că nu aveți memory leaks.</div>
</li>
</ul>
</li>
</ul>

</div>
<!-- EDIT24 SECTION "Exercitii" [16234-16934] -->
<h2 class="sectionedit25" id="interviu">Interviu</h2>
<div class="level2">

<p>
Această secțiune nu este punctată și încearcă să vă facă o oarecare idee a tipurilor de întrebări pe care le puteți întâlni la un job interview (internship, part-time, full-time, etc.) din materia prezentată în cadrul laboratorului.
</p>
<ul>
<li class="level1"><div class="li"> Care este diferența între struct și class în C++?</div>
</li>
<li class="level1"><div class="li"> Ce înseamnă specializarea unui template? Cum se realizează aceasta?</div>
</li>
<li class="level1"><div class="li"> Ce este o clasă abstractă?</div>
</li>
<li class="level1"><div class="li"> Când este indicat să folosim template-uri versus clase abstracte?</div>
</li>
<li class="level1"><div class="li"> Ce face keyword-ul static în fața metodei unei clase în C++?</div>
</li>
<li class="level1"><div class="li"> Ce este diferit între o metodă statică și o metodă normală a unei clase? (Hint: explicați cum e cu pointer-ul <em>this</em>)</div>
</li>
</ul>

<p>
Și multe altele…
</p>

</div>
<!-- EDIT25 SECTION "Interviu" [16935-17664] -->
<h2 class="sectionedit26" id="bibliografie_obligatorie">Bibliografie obligatorie</h2>
<div class="level2">
<ol>
<li class="level1"><div class="li"> <a href="https://google-styleguide.googlecode.com/svn/trunk/cppguide.xml" class="urlextern" title="https://google-styleguide.googlecode.com/svn/trunk/cppguide.xml"  rel="nofollow"> Cum scriem cod C++ corect?</a></div>
</li>
<li class="level1"><div class="li"> <a href="http://swarm.cs.pub.ro/~adrian.sc/PA/TutorialC++.pdf" class="urlextern" title="http://swarm.cs.pub.ro/~adrian.sc/PA/TutorialC++.pdf"  rel="nofollow">Tutorial basic C++</a></div>
</li>
</ol>

</div>
<!-- EDIT26 SECTION "Bibliografie obligatorie" [17665-17881] -->
<h2 class="sectionedit27" id="bibliografie_recomandata">Bibliografie recomandată</h2>
<div class="level2">
<ol>
<li class="level1"><div class="li"> <a href="http://www.cplusplus.com" class="urlextern" title="http://www.cplusplus.com"  rel="nofollow"> C++ Reference</a></div>
</li>
<li class="level1"><div class="li"> <a href="http://www.cplusplus.com/doc/tutorial/templates" class="urlextern" title="http://www.cplusplus.com/doc/tutorial/templates"  rel="nofollow"> Templates</a></div>
</li>
<li class="level1"><div class="li"> <a href="http://sites.cs.queensu.ca/gradresources/stuff/cpp98.pdf" class="urlextern" title="http://sites.cs.queensu.ca/gradresources/stuff/cpp98.pdf"  rel="nofollow"> Standard C++98</a></div>
</li>
<li class="level1"><div class="li"> <a href="https://github.com/cplusplus/draft/blob/master/papers/N3485.pdf" class="urlextern" title="https://github.com/cplusplus/draft/blob/master/papers/N3485.pdf"  rel="nofollow">Standard C++11</a></div>
</li>
</ol>

</div>
<!-- EDIT27 SECTION "Bibliografie recomandată" [17882-] --></div>
</body>
</html>
