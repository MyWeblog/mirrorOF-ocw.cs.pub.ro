    
    

<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
  <meta charset="utf-8" />
  <title>sd-ca:laboratoare:laborator-11</title>
<meta name="generator" content="DokuWiki"/>
<meta name="robots" content="index,follow"/>
<meta name="date" content="2015-05-21T05:57:54+0300"/>
<meta name="keywords" content="sd-ca,laboratoare,laborator-11"/>
<link rel="search" type="application/opensearchdescription+xml" href="../../../../lib/exe/opensearch.php" title="CS Open CourseWare"/>
<link rel="start" href="../../../../../courses.1.html"/>
<link rel="alternate" type="application/rss+xml" title="Recent Changes" href="../../../../feed.php"/>
<link rel="alternate" type="application/rss+xml" title="Current Namespace" href="../../../../feed.php%3Fmode=list&amp;ns=sd-ca:laboratoare"/>
<link rel="alternate" type="text/html" title="Plain HTML" href="laborator-11.html"/>
<link rel="canonical" href="../../../../sd-ca/laboratoare/laborator-11.html"/>
<link rel="stylesheet" type="text/css" href="../../../../lib/exe/css.php%3Ft=arctic&amp;tseed=1476798676.css"/>
<script type="text/javascript">/*<![CDATA[*/var NS='sd-ca:laboratoare';var JSINFO = {"id":"sd-ca:laboratoare:laborator-11","namespace":"sd-ca:laboratoare","isadmin":0,"isauth":0};
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="../../../../lib/exe/js.php%3Ftseed=1476798676"></script>
<script type="text/x-mathjax-config">/*<![CDATA[*/MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ["$","$"], ["\\(","\\)"] ],
        displayMath: [ ["$$","$$"], ["\\[","\\]"] ],
        processEscapes: true
    }
});
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
<script type="text/javascript">/*<![CDATA[*/
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
		  
/*!]]>*/</script>
<script type="text/javascript">/*<![CDATA[*/
var pageTracker = _gat._getTracker("UA-38383934-1");
pageTracker._initData();
pageTracker._trackPageview();
		  
/*!]]>*/</script>
</head>
<body>
<div class="dokuwiki export">
<!-- TOC START -->
<div id="dw__toc">
<h3 class="toggle">Table of Contents</h3>
<div>

<ul class="toc">
<li class="level1"><div class="li"><a href="laborator-11.html#laborator_11_-_heap-uri">Laborator 11 - Heap-uri</a></div>
<ul class="toc">
<li class="level2"><div class="li"><a href="laborator-11.html#obiective">Obiective</a></div></li>
<li class="level2"><div class="li"><a href="laborator-11.html#moduri_de_reprezentare_a_arborilor">Moduri de reprezentare a arborilor</a></div></li>
<li class="level2"><div class="li"><a href="laborator-11.html#proprietati_ale_structurii_de_heap_binar_operatii_elementare">Proprietăţi ale structurii de heap binar. Operaţii elementare.</a></div></li>
<li class="level2"><div class="li"><a href="laborator-11.html#operatii_uzuale_asupra_heap-ului">Operaţii uzuale asupra heap-ului</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="laborator-11.html#peek">Peek</a></div></li>
<li class="level3"><div class="li"><a href="laborator-11.html#push_insert">Push (insert)</a></div></li>
<li class="level3"><div class="li"><a href="laborator-11.html#pop_extractmin">Pop (extractMin)</a></div></li>
</ul>
</li>
<li class="level2"><div class="li"><a href="laborator-11.html#algoritmul_heap_sort">Algoritmul Heap Sort</a></div></li>
<li class="level2"><div class="li"><a href="laborator-11.html#aplicatii">Aplicaţii</a></div></li>
<li class="level2"><div class="li"><a href="laborator-11.html#resurse">Resurse</a></div></li>
</ul></li>
</ul>
</div>
</div>
<!-- TOC END -->

<h1 class="sectionedit1" id="laborator_11_-_heap-uri">Laborator 11 - Heap-uri</h1>
<div class="level1">

<p>
Responsabili:
</p>
<ul>
<li class="level1"><div class="li"> <a href="mailto:&#x6d;&#x69;&#x68;&#x61;&#x69;&#x2e;&#x6d;&#x6e;&#x65;&#x61;&#x63;&#x73;&#x75;&#x40;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;" class="mail" title="&#x6d;&#x69;&#x68;&#x61;&#x69;&#x2e;&#x6d;&#x6e;&#x65;&#x61;&#x63;&#x73;&#x75;&#x40;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;">Mihai Neacşu</a></div>
</li>
<li class="level1"><div class="li"> <a href="mailto:&#x70;&#x65;&#x74;&#x72;&#x69;&#x73;&#x6f;&#x72;&#x5f;&#x63;&#x6f;&#x73;&#x6d;&#x69;&#x6e;&#x5f;&#x69;&#x6f;&#x61;&#x6e;&#x40;&#x79;&#x61;&#x68;&#x6f;&#x6f;&#x2e;&#x63;&#x6f;&#x6d;" class="mail" title="&#x70;&#x65;&#x74;&#x72;&#x69;&#x73;&#x6f;&#x72;&#x5f;&#x63;&#x6f;&#x73;&#x6d;&#x69;&#x6e;&#x5f;&#x69;&#x6f;&#x61;&#x6e;&#x40;&#x79;&#x61;&#x68;&#x6f;&#x6f;&#x2e;&#x63;&#x6f;&#x6d;">Cosmin Petrişor</a></div>
</li>
</ul>

</div>
<!-- EDIT1 SECTION "Laborator 11 - Heap-uri" [1-155] -->
<h2 class="sectionedit2" id="obiective">Obiective</h2>
<div class="level2">

<p>
În urma parcurgerii acestui laborator, studentul va fi capabil să:
</p>
<ul>
<li class="level1"><div class="li"> înţeleagă diferitele moduri de reprezentare a arborilor;</div>
</li>
<li class="level1"><div class="li"> definească proprietăţile structurii de heap;</div>
</li>
<li class="level1"><div class="li"> implementeze operaţii de inserare, ştergere şi căutare care să păstreze proprietatea de heap;</div>
</li>
<li class="level1"><div class="li"> folosească heap-ul pentru a implementa o metodă de sortare eficientă.</div>
</li>
</ul>

</div>
<!-- EDIT2 SECTION "Obiective" [156-544] -->
<h2 class="sectionedit3" id="moduri_de_reprezentare_a_arborilor">Moduri de reprezentare a arborilor</h2>
<div class="level2">

<p>
În laboratorul precedent am considerat arborii binari ca fiind o înlănţuire de structuri, legate între ele prin pointeri la descendenţii stâng, respectiv drept. Această reprezentare are avantajul flexibilităţii şi a posibilităţii de a creşte sau micşora dimensiunea arborelui oricât de mult, cu un efort minim. Cu toate acestea, metoda precedentă nu poate fi folosită atunci când este nevoie de o reprezentare compactă a arborelui în memorie (de exemplu pentru stocarea într-un fişier), pentru că acei pointeri nu sunt valizi decât în cadrul programului curent. 
</p>

<p>
Din acest motiv, există câteva moduri de a stoca arborii într-o structura liniară de date (vectori), dintre care:
</p>
<ul>
<li class="level1"><div class="li">Înlocuirea pointer-ilor din structurile asociate nodurilor cu întregi ce reprezintă indici într-un vector de astfel de structuri. Primul element din vector va fi rădăcina arborelui, şi va exista un contor curent (la nivelul întregului vector) care indică următoarea poziţie liberă. Atunci când un nod trebuie adăugat în arbore, i se va asocia valoarea curentă a contorului, iar acesta va fi incrementat. În nodul părinte se va reţine indicele <strong>în vector</strong> al noului nod, în locul adresei lui în memorie (practic acesta este un mic mecanism de alocare de memorie, pe care îl gestionăm noi).</div>
</li>
<li class="level1"><div class="li">Eliminarea totală a informaţiei legate de predecesori, şi folosirea unei formule de calcul a părintelui si a descendenţilor unui nod pe baza indicelui acestuia în vector.</div>
</li>
</ul>

<p>
Pentru un arbore binar, cea de-a doua modalitate se implementează conform figurii de mai jos:
</p>

<p>
<a href="../../../../_detail/sd-ca/laboratoare/heap.jpg%3Fid=sd-ca%253Alaboratoare%253Alaborator-11.html" class="media" title="sd-ca:laboratoare:heap.jpg"><img src="../../../../_media/sd-ca/laboratoare/heap.jpg" class="media" title="heap.jpg" alt="heap.jpg" /></a>
</p>

<p>
Se consideră că arborele este aşezat în vector în ordine (începând de la 0) de la primul nivel până la ultimul, iar nodurile fiecărui nivel se aşează de la stânga la dreapta. Poziţiile fiecărui nod în nivel se consideră ca şi când arborele ar fi complet (iar nodurile lipsă sunt ignorate).
</p>

<p>
Reprezentarea liniara (sub formă de vector) pentru un arbore binar complet devine:
</p>

<p>
<a href="../../../../_detail/sd-ca/laboratoare/2000px-binary_tree_in_array.svg.png%3Fid=sd-ca%253Alaboratoare%253Alaborator-11.html" class="media" title="sd-ca:laboratoare:2000px-binary_tree_in_array.svg.png"><img src="../../../../_media/sd-ca/laboratoare/2000px-binary_tree_in_array.svg.png%3Fw=400&amp;tok=36e296" class="media" alt="" width="400" /></a>
</p>

<p>
Se constată că poziţia nodului rădăcină în vector este 0, iar pentru fiecare nod în parte, părintele şi descendenţii se pot calcula după formulele:
</p>
<ul>
<li class="level1"><div class="li"> Parinte(i) = (i - 1) / 2, unde i este indicele nodului curent</div>
</li>
<li class="level1"><div class="li"> IndexStanga(i) = 2 * i + 1, unde i este indicele nodului curent</div>
</li>
<li class="level1"><div class="li"> IndexDreapta(i) = 2 * i + 2, unde i este indicele nodului curent</div>
</li>
</ul>

</div>
<!-- EDIT3 SECTION "Moduri de reprezentare a arborilor" [545-3051] -->
<h2 class="sectionedit4" id="proprietati_ale_structurii_de_heap_binar_operatii_elementare">Proprietăţi ale structurii de heap binar. Operaţii elementare.</h2>
<div class="level2">

<p>
În cele ce urmează vom considera un heap ca fiind de fapt un min-heap. Noţiunile sunt perfect similare şi pentru max-heap-uri.
</p>

<p>
Un min-heap binar este un arbore binar în care fiecare nod are proprietatea că valoarea sa este mai mare sau egală decât cea a părintelui său.
</p>

<p>
Într-o enunțare echivalentă:
</p>

<p>
Un min-heap binar este un arbore binar în care fiecare nod are proprietatea că valoarea sa este mai mică sau egală decât cea a tuturor descendenților săi.
</p>
<pre class="code c">H<span class="br0">&#91;</span>Parinte<span class="br0">&#40;</span>x<span class="br0">&#41;</span><span class="br0">&#93;</span> <span class="sy0">&lt;=</span> H<span class="br0">&#91;</span>x<span class="br0">&#93;</span></pre>

<p>
<strong>H[x]</strong> reprezintă valoarea nodului <strong>x</strong>, din vectorul H asociat arborelui.
</p>

<p>
În mod similar, un max-heap are semnul inegalităţii inversat. Astfel, putem defini şi recursiv proprietatea de heap pentru orice (sub)arbore:
</p>
<ul>
<li class="level1"><div class="li"> nodul rădăcină trebuie să respecte proprietatea de heap (inegalitatea);</div>
</li>
<li class="level1"><div class="li"> cei doi subarbori descendenţi sa fie heap-uri.</div>
</li>
</ul>

<p>
Pentru a implementa operaţiile de inserare, ştergere, etc. pentru un heap, vom avea nevoie mai întâi de două operaţii elementare:
</p>
<ul>
<li class="level1"><div class="li"><code>pushDown</code>, care presupune că heap-ul a fost modificat într-un singur nod şi noua valoare este mai mare decât cel puţin unul dintre descendenţi, şi astfel ea trebuie “cernută” către nivelurile de jos, până când heap-ul devine din nou valid.</div>
</li>
</ul>
<ul>
<li class="level1"><div class="li"><code>pushUp</code>, care presupune că valoarea modificată (sau adăugată la sfârşitul vectorului, în acest caz) este mai mică decât părintele, şi astfel se propagă acea valoare spre rădăcina arborelui, până cand heap-ul devine valid. </div>
</li>
</ul>

</div>
<!-- EDIT4 SECTION "Proprietăţi ale structurii de heap binar. Operaţii elementare." [3052-4642] -->
<h2 class="sectionedit5" id="operatii_uzuale_asupra_heap-ului">Operaţii uzuale asupra heap-ului</h2>
<div class="level2">

<p>
Având implementate cele două operaţii de bază, putem defini operaţiile uzuale de manipulare a heap-urilor:
</p>

</div>
<!-- EDIT5 SECTION "Operaţii uzuale asupra heap-ului" [4643-4801] -->
<h3 class="sectionedit6" id="peek">Peek</h3>
<div class="level3">

<p>
Operația întoarce valoarea minimă din min-heap. Valoarea se va afla la indexul 0 al vectorului de implementare a heap-ului.
</p>

</div>
<!-- EDIT6 SECTION "Peek" [4802-4944] -->
<h3 class="sectionedit7" id="push_insert">Push (insert)</h3>
<div class="level3">

<p>
Adaugă o nouă valoare la heap, crescându-i astfel dimensiunea cu 1.
</p>

<p>
Algoritmul pentru această funcție este următorul:
</p>
<ol>
<li class="level1"><div class="li"> introducem elementul de inserat pe prima poziție liberă din vectorul de implementare a heap-ului (în principiu <code>dimVect</code>);</div>
</li>
<li class="level1"><div class="li"> “împingem” elementul adăugat în vector până la poziția în care se respectă proprietatea de heap; veți folosi funcția <code>pushUp</code>.</div>
</li>
</ol>

<p>
Pseudocod:
</p>
<pre class="code c">push<span class="br0">&#40;</span>X<span class="br0">&#41;</span>
<span class="br0">&#123;</span>
    heap<span class="br0">&#91;</span>dimVec<span class="br0">&#93;</span> <span class="sy0">=</span> X<span class="sy0">;</span>
    dimVec<span class="sy0">++;</span>
    pushUp<span class="br0">&#40;</span>dimVec <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">&#41;</span><span class="sy0">;</span>
<span class="br0">&#125;</span></pre>

</div>
<!-- EDIT7 SECTION "Push (insert)" [4945-5474] -->
<h3 class="sectionedit8" id="pop_extractmin">Pop (extractMin)</h3>
<div class="level3">

<p>
Funcția aceasta scoate valoarea minimă din heap (și reactualizează heap-ul). Poate întoarce valoarea scoasă din heap.
</p>

<p>
Pentru a face operația de <code>pop</code> veți urma pașii:
</p>
<ol>
<li class="level1"><div class="li"> elementul minim din heap (de pe prima poziție) va fi interschimbat cu elementul de pe ultima poziție a vectorului;</div>
</li>
<li class="level1"><div class="li"> dimensiunea vectorului va fi redusă cu 1 (pentru a ignora ultimul element, acum cel pe care doream să-l înlăturăm)</div>
</li>
<li class="level1"><div class="li"> vom “împinge” nodul care se afla acum în rădăcina heap-ului către poziția în care trebuie sa fie pentru a fi respectată proprietatea de heap; acest lucru se va face cu funcția <code>pushDown</code>.</div>
</li>
</ol>

<p>
Pseudocod:
</p>
<pre class="code c">extractMin<span class="br0">&#40;</span><span class="br0">&#41;</span>
<span class="br0">&#123;</span>
    interschimba<span class="br0">&#40;</span>heap<span class="br0">&#91;</span><span class="nu0">0</span><span class="br0">&#93;</span><span class="sy0">,</span> heap<span class="br0">&#91;</span>dimVec <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">&#93;</span><span class="br0">&#41;</span><span class="sy0">;</span>
    dimVect<span class="sy0">--;</span>
    pushDown<span class="br0">&#40;</span><span class="nu0">0</span><span class="br0">&#41;</span><span class="sy0">;</span>
<span class="br0">&#125;</span></pre>

</div>
<!-- EDIT8 SECTION "Pop (extractMin)" [5475-6255] -->
<h2 class="sectionedit9" id="algoritmul_heap_sort">Algoritmul Heap Sort</h2>
<div class="level2">

<p>
Întrucât operaţiile de extragere a minimului şi de adăugare/reconstituire sunt efectuate foarte eficient (complexităţi de O(1), respectiv O(log n) ), heap-ul poate fi folosit într-o multitudine de aplicaţii care necesită rapiditatea unor astfel de operaţii. O aplicaţie importantă o reprezintă sortarea, care poate fi implementată foarte eficient folosind heap-uri. Complexitatea acesteia este O(n*log n), aceeaşi cu cea de la quick sort şi merge sort. Există mai multe metode de a implementa această sortare, dintre care prezentăm doua dintre ele:
</p>
<ol>
<li class="level1"><div class="li"> Se inserează, pe rând, în heap, toate elementele din vectorul nesortat. Apoi într-un alt şir se extrag minimele. Noul şir va conţine vechiul vector sortat.</div>
</li>
<li class="level1"><div class="li"> Se implementează funcţiile din secţiunile precedente pentru un max-heap, şi apoi se foloseşte următorul algoritm (în pseudocod):</div>
</li>
</ol>
<pre class="code c">HeapSort<span class="br0">&#40;</span><span class="br0">&#41;</span> 
<span class="br0">&#123;</span>
    ConstruiesteMaxHeap<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
    <span class="kw1">for</span> <span class="br0">&#40;</span>i<span class="sy0">=</span>dimHeap<span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span> i<span class="sy0">&gt;=</span><span class="nu0">1</span><span class="sy0">;</span> i<span class="sy0">--</span><span class="br0">&#41;</span> 
    <span class="br0">&#123;</span>
        <span class="co1">// Punem maximul la sfarsitul vectorului</span>
        interschimba<span class="br0">&#40;</span>heap<span class="br0">&#91;</span><span class="nu0">0</span><span class="br0">&#93;</span><span class="sy0">,</span> heap<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="br0">&#41;</span><span class="sy0">;</span>
        <span class="co1">// 'Desprindem' maximul de heap (valoarea ramanand astfel in pozitia finala)</span>
        dimHeap<span class="sy0">--;</span>
        <span class="co1">// Reconstituim heap-ul ramas</span>
        pushDown<span class="br0">&#40;</span><span class="nu0">0</span><span class="br0">&#41;</span><span class="sy0">;</span>
    <span class="br0">&#125;</span>
<span class="br0">&#125;</span></pre>

</div>
<!-- EDIT9 SECTION "Algoritmul Heap Sort" [6256-7523] -->
<h2 class="sectionedit10" id="aplicatii">Aplicaţii</h2>
<div class="level2">

<p>
Porniți exercițiile de la <a href="../../../../_media/sd-ca/laboratoare/labheap-tasks.zip" class="media mediafile mf_zip" title="sd-ca:laboratoare:labheap-tasks.zip (11.9 KB)"> scheletul de cod</a> oferit.
Modificați <strong>main.cpp</strong>, adăugând și testând toate operațiile din clasa Heap.
</p>

<p>
1. [1p] <strong>heap.h</strong> Definiţi o structură de vector pe care să poată fi folosite operaţiile de heap-uri, şi funcţii de construcţie şi eliberare a structurii:
</p>
<ul>
<li class="level1"><div class="li">[0.5p] Constructor pentru inițializarea unui heap. <code>capVect</code> reprezintă numărul maxim de elemente din vector. Codul va trebui să aloce memorie separată şi apoi să lucreze cu acea memorie.</div>
</li>
</ul>
<pre class="code c++">template <span class="sy0">&lt;</span>typename T<span class="sy0">&gt;</span>
Heap<span class="sy0">&lt;</span>T<span class="sy0">&gt;::</span><span class="me2">Heap</span><span class="br0">&#40;</span><span class="kw4">int</span> capVect<span class="br0">&#41;</span>
<span class="br0">&#123;</span>
    <span class="co1">// TODO 1.1</span>
<span class="br0">&#125;</span></pre>
<ul>
<li class="level1"><div class="li">[0.5p] Funcție pentru eliberarea memoriei alocate pentru values.</div>
</li>
</ul>
<pre class="code c++">template <span class="sy0">&lt;</span>typename T<span class="sy0">&gt;</span>
Heap<span class="sy0">&lt;</span>T<span class="sy0">&gt;::</span>~Heap<span class="br0">&#40;</span><span class="br0">&#41;</span>
<span class="br0">&#123;</span>
    <span class="co1">// TODO 1.2</span>
<span class="br0">&#125;</span></pre>

<p>
2. [3p] Implementaţi operaţiile elementare de lucru cu heap-uri, prezentate în secţiunile anterioare:
</p>
<ul>
<li class="level1"><div class="li">[1p] Implementati functiile de calcul ai parintelui si ai descendentilor.</div>
</li>
</ul>
<pre class="code c++">template <span class="sy0">&lt;</span>typename T<span class="sy0">&gt;</span>
<span class="kw4">int</span> Heap<span class="sy0">&lt;</span>T<span class="sy0">&gt;::</span><span class="me2">parent</span><span class="br0">&#40;</span><span class="kw4">int</span> poz<span class="br0">&#41;</span>
<span class="br0">&#123;</span>
    <span class="co1">// TODO 2.1</span>
<span class="br0">&#125;</span>
&nbsp;
template <span class="sy0">&lt;</span>typename T<span class="sy0">&gt;</span>
<span class="kw4">int</span> Heap<span class="sy0">&lt;</span>T<span class="sy0">&gt;::</span><span class="me2">leftSubtree</span><span class="br0">&#40;</span><span class="kw4">int</span> poz<span class="br0">&#41;</span>
<span class="br0">&#123;</span>
    <span class="co1">// TODO 2.1</span>
<span class="br0">&#125;</span>
&nbsp;
template <span class="sy0">&lt;</span>typename T<span class="sy0">&gt;</span>
<span class="kw4">int</span> Heap<span class="sy0">&lt;</span>T<span class="sy0">&gt;::</span><span class="me2">rightSubtree</span><span class="br0">&#40;</span><span class="kw4">int</span> poz<span class="br0">&#41;</span>
<span class="br0">&#123;</span>
    <span class="co1">// TODO 2.1</span>
<span class="br0">&#125;</span></pre>

<p>
Cele trei funcţii de mai sus vor întoarce -1 în cazul în care părintele, respectiv descendenţii nu există.
</p>
<ul>
<li class="level1"><div class="li"> [2p] Implementati pushUp si pushDown.</div>
</li>
</ul>
<pre class="code c++">template <span class="sy0">&lt;</span>typename T<span class="sy0">&gt;</span>
<span class="kw4">void</span> Heap<span class="sy0">&lt;</span>T<span class="sy0">&gt;::</span><span class="me2">pushUp</span><span class="br0">&#40;</span><span class="kw4">int</span> poz<span class="br0">&#41;</span>
<span class="br0">&#123;</span>
    <span class="co1">// TODO 2.2</span>
&nbsp;
<span class="br0">&#125;</span>
&nbsp;
template <span class="sy0">&lt;</span>typename T<span class="sy0">&gt;</span>
<span class="kw4">void</span> Heap<span class="sy0">&lt;</span>T<span class="sy0">&gt;::</span><span class="me2">pushDown</span><span class="br0">&#40;</span><span class="kw4">int</span> poz<span class="br0">&#41;</span>
<span class="br0">&#123;</span>
    <span class="co1">// TODO 2.2</span>
&nbsp;
<span class="br0">&#125;</span></pre>

<p>
3. [1p] Implementaţi operaţiile uzuale de lucru cu heap-uri:
</p>
<pre class="code c++">template <span class="sy0">&lt;</span>typename T<span class="sy0">&gt;</span>
<span class="kw4">void</span> Heap<span class="sy0">&lt;</span>T<span class="sy0">&gt;::</span><span class="me2">insert</span><span class="br0">&#40;</span>T x<span class="br0">&#41;</span>
<span class="br0">&#123;</span>
    <span class="co1">// TODO 3</span>
<span class="br0">&#125;</span>
&nbsp;
template <span class="sy0">&lt;</span>typename T<span class="sy0">&gt;</span>
T Heap<span class="sy0">&lt;</span>T<span class="sy0">&gt;::</span><span class="me2">peek</span><span class="br0">&#40;</span><span class="br0">&#41;</span>
<span class="br0">&#123;</span>
    <span class="co1">// TODO 3</span>
<span class="br0">&#125;</span>
&nbsp;
template <span class="sy0">&lt;</span>typename T<span class="sy0">&gt;</span>
T Heap<span class="sy0">&lt;</span>T<span class="sy0">&gt;::</span><span class="me2">extractMin</span><span class="br0">&#40;</span><span class="br0">&#41;</span>
<span class="br0">&#123;</span>
    <span class="co1">// TODO 3</span>
<span class="br0">&#125;</span></pre>

<p>
4. [2p] <strong>p4.cpp</strong> Implementaţi algoritmul de sortare folosind heap-uri, alegând una dintre cele două metode prezentate mai sus. Testați implementarea voastră a sortării rulând scriptul de testare <code>test.sh</code>.
</p>

<p>
<strong>Obs.:</strong>
</p>
<ul>
<li class="level1"><div class="li"> Se va citi întâi numărul <strong>n</strong> de elemente, iar apoi <strong>n</strong> numere care trebuie sortate.</div>
</li>
<li class="level1"><div class="li"> Citirea se face de la <strong>stdin</strong>. Nu modificați afișarea! Afișarea are formatul folosit pentru script-ul de testing.</div>
</li>
</ul>

<p>
<strong>BONUS!</strong> [1p] Implementaţi şi celelalta metoda de sortare prin heap-uri, în afară de cea aleasă iniţial. Pentru testare se va modifica doar funcția <code>heapSort</code> și se va executa tot scriptul <code>test.sh</code>.
</p>

</div>
<!-- EDIT10 SECTION "Aplicaţii" [7524-11754] -->
<h2 class="sectionedit11" id="resurse">Resurse</h2>
<div class="level2">

<p>
[1] <a href="http://www.cplusplus.com" class="urlextern" title="http://www.cplusplus.com"  rel="nofollow"> C++ Reference</a>
</p>

<p>
[2] Thomas H. Cormen, Charles E. Leiserson, Ronald R. Rivest -“Introducere în Algoritmi” (Capitolul 7 - Heapsort)
</p>

<p>
[3] <a href="http://en.wikipedia.org/wiki/Heap_(data_structure)" class="urlextern" title="http://en.wikipedia.org/wiki/Heap_(data_structure)"  rel="nofollow">Heap Data Structure</a>
</p>

<p>
[4] <a href="http://en.wikipedia.org/wiki/Binary_heap" class="urlextern" title="http://en.wikipedia.org/wiki/Binary_heap"  rel="nofollow">Binary Heap</a>
</p>

<p>
[5] <a href="http://en.wikipedia.org/wiki/Heap_sort" class="urlextern" title="http://en.wikipedia.org/wiki/Heap_sort"  rel="nofollow">Heap Sort</a>
</p>

</div>
<!-- EDIT11 SECTION "Resurse" [11755-] --></div>
</body>
</html>
