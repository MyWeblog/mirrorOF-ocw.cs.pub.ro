    
    

<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
  <meta charset="utf-8" />
  <title>sd-ca:2015:laboratoare:laborator-08</title>
<meta name="generator" content="DokuWiki"/>
<meta name="robots" content="index,follow"/>
<meta name="date" content="2016-02-21T19:12:22+0200"/>
<meta name="keywords" content="sd-ca,2015,laboratoare,laborator-08"/>
<link rel="search" type="application/opensearchdescription+xml" href="../../../../../lib/exe/opensearch.php" title="CS Open CourseWare"/>
<link rel="start" href="../../../../../../courses.1.html"/>
<link rel="alternate" type="application/rss+xml" title="Recent Changes" href="../../../../../feed.php"/>
<link rel="alternate" type="application/rss+xml" title="Current Namespace" href="../../../../../feed.php%3Fmode=list&amp;ns=sd-ca:2015:laboratoare"/>
<link rel="alternate" type="text/html" title="Plain HTML" href="laborator-08.html"/>
<link rel="canonical" href="../../../../../sd-ca/2015/laboratoare/laborator-08.html"/>
<link rel="stylesheet" type="text/css" href="../../../../../lib/exe/css.php%3Ft=arctic&amp;tseed=1476798676.css"/>
<script type="text/javascript">/*<![CDATA[*/var NS='sd-ca:2015:laboratoare';var JSINFO = {"id":"sd-ca:2015:laboratoare:laborator-08","namespace":"sd-ca:2015:laboratoare","isadmin":0,"isauth":0};
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="../../../../../lib/exe/js.php%3Ftseed=1476798676"></script>
<script type="text/x-mathjax-config">/*<![CDATA[*/MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ["$","$"], ["\\(","\\)"] ],
        displayMath: [ ["$$","$$"], ["\\[","\\]"] ],
        processEscapes: true
    }
});
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
<script type="text/javascript">/*<![CDATA[*/
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
		  
/*!]]>*/</script>
<script type="text/javascript">/*<![CDATA[*/
var pageTracker = _gat._getTracker("UA-38383934-1");
pageTracker._initData();
pageTracker._trackPageview();
		  
/*!]]>*/</script>
</head>
<body>
<div class="dokuwiki export">
<!-- TOC START -->
<div id="dw__toc">
<h3 class="toggle">Table of Contents</h3>
<div>

<ul class="toc">
<li class="level1"><div class="li"><a href="laborator-08.html#laborator_08_-_grafuri">Laborator 08 - Grafuri</a></div>
<ul class="toc">
<li class="level2"><div class="li"><a href="laborator-08.html#obiective">Obiective</a></div></li>
<li class="level2"><div class="li"><a href="laborator-08.html#ce_este_un_graf">Ce este un graf</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="laborator-08.html#diferenta_intre_graf_orientat_si_graf_neorientat">Diferenţa între graf orientat şi graf neorientat</a></div></li>
</ul>
</li>
<li class="level2"><div class="li"><a href="laborator-08.html#reprezentarile_grafurilor_in_memorie">Reprezentările grafurilor în memorie</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="laborator-08.html#liste_de_adiacenta">Liste de adiacenţă</a></div></li>
<li class="level3"><div class="li"><a href="laborator-08.html#matrice_de_adiacenta">Matrice de adiacenţă</a></div></li>
</ul>
</li>
<li class="level2"><div class="li"><a href="laborator-08.html#parcurgerea_grafurilor">Parcurgerea grafurilor</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="laborator-08.html#parcurgerea_in_latime">Parcurgerea în lăţime</a></div>
<ul class="toc">
<li class="level4"><div class="li"><a href="laborator-08.html#pasi_de_executie">Pași de execuție</a></div></li>
<li class="level4"><div class="li"><a href="laborator-08.html#pseudocod_bfs">Pseudocod BFS</a></div></li>
<li class="level4"><div class="li"><a href="laborator-08.html#complexitate_bfs">Complexitate BFS</a></div></li>
</ul>
</li>
<li class="level3"><div class="li"><a href="laborator-08.html#parcurgerea_in_adancime">Parcurgerea în adâncime</a></div>
<ul class="toc">
<li class="level4"><div class="li"><a href="laborator-08.html#pasi_de_executie1">Pași de execuție</a></div></li>
<li class="level4"><div class="li"><a href="laborator-08.html#pseudocod_dfs">Pseudocod DFS</a></div></li>
<li class="level4"><div class="li"><a href="laborator-08.html#complexitate_dfs">Complexitate DFS</a></div></li>
</ul>
</li>
</ul>
</li>
<li class="level2"><div class="li"><a href="laborator-08.html#aplicatii_parcurgeri">Aplicaţii parcurgeri</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="laborator-08.html#aflarea_distantei_minime_intre_doua_noduri">Aflarea distanței minime între două noduri</a></div></li>
<li class="level3"><div class="li"><a href="laborator-08.html#sortarea_topologica">Sortarea topologică</a></div></li>
</ul>
</li>
<li class="level2"><div class="li"><a href="laborator-08.html#importanta">Importanţă</a></div></li>
<li class="level2"><div class="li"><a href="laborator-08.html#aplicatii">Aplicaţii</a></div></li>
<li class="level2"><div class="li"><a href="laborator-08.html#interviu">Interviu</a></div></li>
<li class="level2"><div class="li"><a href="laborator-08.html#resurse">Resurse</a></div></li>
</ul></li>
</ul>
</div>
</div>
<!-- TOC END -->

<h1 class="sectionedit1" id="laborator_08_-_grafuri">Laborator 08 - Grafuri</h1>
<div class="level1">

<p>
Responsabili:
</p>
<ul>
<li class="level1"><div class="li"> <a href="mailto:&#x6d;&#x69;&#x68;&#x61;&#x69;&#x2e;&#x6d;&#x6e;&#x65;&#x61;&#x63;&#x73;&#x75;&#x40;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;" class="mail" title="&#x6d;&#x69;&#x68;&#x61;&#x69;&#x2e;&#x6d;&#x6e;&#x65;&#x61;&#x63;&#x73;&#x75;&#x40;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;">Mihai Neacşu</a></div>
</li>
<li class="level1"><div class="li"> <a href="mailto:&#x70;&#x65;&#x74;&#x72;&#x69;&#x73;&#x6f;&#x72;&#x5f;&#x63;&#x6f;&#x73;&#x6d;&#x69;&#x6e;&#x5f;&#x69;&#x6f;&#x61;&#x6e;&#x40;&#x79;&#x61;&#x68;&#x6f;&#x6f;&#x2e;&#x63;&#x6f;&#x6d;" class="mail" title="&#x70;&#x65;&#x74;&#x72;&#x69;&#x73;&#x6f;&#x72;&#x5f;&#x63;&#x6f;&#x73;&#x6d;&#x69;&#x6e;&#x5f;&#x69;&#x6f;&#x61;&#x6e;&#x40;&#x79;&#x61;&#x68;&#x6f;&#x6f;&#x2e;&#x63;&#x6f;&#x6d;">Cosmin Petrişor</a></div>
</li>
</ul>

</div>
<!-- EDIT1 SECTION "Laborator 08 - Grafuri" [1-155] -->
<h2 class="sectionedit2" id="obiective">Obiective</h2>
<div class="level2">

<p>
În urma parcurgerii acestui laborator, studentul va fi capabil să:
</p>
<ul>
<li class="level1"><div class="li"> înțeleagă operațiile de parcurgere a grafurilor și diferențele dintre ele.</div>
</li>
<li class="level1"><div class="li"> implementeze parcurgerile pe grafuri având la dispoziție structurile de date studiate.</div>
</li>
<li class="level1"><div class="li"> evalueze complexitatea parcurgerii grafurilor.</div>
</li>
<li class="level1"><div class="li"> găsească soluțiile unor probleme folosind algoritmii de parcurgere</div>
</li>
</ul>

</div>
<!-- EDIT2 SECTION "Obiective" [156-551] -->
<h2 class="sectionedit3" id="ce_este_un_graf">Ce este un graf</h2>
<div class="level2">

<p>
Un graf este o pereche de mulţimi <code>G = (V, E)</code>. Mulțimea <code>V</code> conține nodurile grafului (<strong>vertices</strong>), iar mulțimea <code>E</code> conține muchiile sale (<strong>edges</strong>), fiecare muchie stabilind o relație de vecinătate între două noduri. Mulţimea <code>E</code> este inclusă în mulţimea <code>VxV</code>.
</p>

</div>
<!-- EDIT3 SECTION "Ce este un graf" [552-871] -->
<h3 class="sectionedit4" id="diferenta_intre_graf_orientat_si_graf_neorientat">Diferenţa între graf orientat şi graf neorientat</h3>
<div class="level3">

<p>
Dacă pentru orice element al mulţimii <code>E</code>, <code>e = (u, v)</code>, elementul <code>e&#039; = (v, u)</code> aparţine de asemenea mulţimii <code>E</code>, atunci spunem că graful este <strong>neorientat</strong>. În caz contrar, graful este <strong>orientat</strong>. În cazul grafului orientat, muchiile se mai numesc şi arce.
</p>

<p>
<a href="../../../../../_detail/sd-ca/laboratoare/neorientat.png%3Fid=sd-ca%253A2015%253Alaboratoare%253Alaborator-08.html" class="media" title="sd-ca:laboratoare:neorientat.png"><img src="../../../../../_media/sd-ca/laboratoare/neorientat.png" class="media" alt="" /></a> <a href="../../../../../_detail/sd-ca/laboratoare/orientat.png%3Fid=sd-ca%253A2015%253Alaboratoare%253Alaborator-08.html" class="media" title="sd-ca:laboratoare:orientat.png"><img src="../../../../../_media/sd-ca/laboratoare/orientat.png" class="media" alt="" /></a>
</p>

</div>
<!-- EDIT4 SECTION "Diferenţa între graf orientat şi graf neorientat" [872-1286] -->
<h2 class="sectionedit5" id="reprezentarile_grafurilor_in_memorie">Reprezentările grafurilor în memorie</h2>
<div class="level2">

<p>
În funcţie de problemă şi de tipul grafurilor, avem 2 reprezentări: liste de adiacenţă sau matrice de adiacenţă.
</p>

</div>
<!-- EDIT5 SECTION "Reprezentările grafurilor în memorie" [1287-1460] -->
<h3 class="sectionedit6" id="liste_de_adiacenta">Liste de adiacenţă</h3>
<div class="level3">

<p>
Reprezentarea prin liste de adiacenţă constă într-un tablou <code>Adj</code> cu <code>|V|</code> liste, una pentru fiecare vârf din <code>V</code>. Pentru fiecare <code>u</code> din <code>V</code>, lista de adiacenţă <code>Adj[u]</code> conţine referinţe către toate vârfurile <code>v</code> pentru care există muchia <code>(u, v)</code> în <code>E</code>. Cu alte cuvinte, <code>Adj[u]</code> este formată din totalitatea vârfurilor adiacente lui <code>u</code> în <code>G</code>.
</p>

<p>
Această reprezentare este preferată pentru grafurile rare ( <code>|E|</code> este mult mai mic decât <code>|V|x|V|</code>).
</p>

<p>
<a href="../../../../../_detail/sd-ca/laboratoare/undirected_graph.gif%3Fid=sd-ca%253A2015%253Alaboratoare%253Alaborator-08.html" class="media" title="sd-ca:laboratoare:undirected_graph.gif"><img src="../../../../../_media/sd-ca/laboratoare/undirected_graph.gif" class="media" alt="" /></a>
</p>

<p>
Pentru graful de mai sus, lista de adiacenţă este următoarea:
</p>
<ul>
<li class="level1"><div class="li"><strong>0</strong>: 1→2</div>
</li>
<li class="level1"><div class="li"><strong>1</strong>: 0→2→3→4</div>
</li>
<li class="level1"><div class="li"><strong>2</strong>: 0→1→3</div>
</li>
<li class="level1"><div class="li"><strong>3</strong>: 1→2→4</div>
</li>
<li class="level1"><div class="li"><strong>4</strong>: 1→3</div>
</li>
</ul>

</div>
<!-- EDIT6 SECTION "Liste de adiacenţă" [1461-2191] -->
<h3 class="sectionedit7" id="matrice_de_adiacenta">Matrice de adiacenţă</h3>
<div class="level3">

<p>
Reprezentarea prin matrice de adiacenţă a unui graf constă într-o matrice <code>A[i][j]</code> de dimensiune <code>|V|x|V|</code> astfel încât:
</p>
<ul>
<li class="level1"><div class="li"><code>A[i][j] = 1</code>, dacă muchia <code>(i,j)</code> aparţine lui <code>E</code></div>
</li>
<li class="level1"><div class="li"><code>A[i][j] = 0</code>, în caz contrar.</div>
</li>
</ul>

<p>
Această reprezentare este preferată pentru grafurile dense ( <code>|E|</code> este aproximativ egal cu <code>|V|x|V|</code>).
</p>

<p>
Pentru graful de mai sus, matricea de adiacenţă este următoarea:
</p>
<div class="table sectionedit8"><table class="inline">
	<tr class="row0">
		<th class="col0"> </th><th class="col1">0</th><th class="col2">1</th><th class="col3">2</th><th class="col4">3</th><th class="col5">4</th>
	</tr>
	<tr class="row1">
		<th class="col0">0</th><td class="col1">0</td><td class="col2">1</td><td class="col3">1</td><td class="col4">0</td><td class="col5">0</td>
	</tr>
	<tr class="row2">
		<th class="col0">1</th><td class="col1">1</td><td class="col2">0</td><td class="col3">1</td><td class="col4">1</td><td class="col5">1</td>
	</tr>
	<tr class="row3">
		<th class="col0">2</th><td class="col1">1</td><td class="col2">1</td><td class="col3">0</td><td class="col4">1</td><td class="col5">0</td>
	</tr>
	<tr class="row4">
		<th class="col0">3</th><td class="col1">0</td><td class="col2">1</td><td class="col3">1</td><td class="col4">1</td><td class="col5">0</td>
	</tr>
	<tr class="row5">
		<th class="col0">4</th><td class="col1">0</td><td class="col2">1</td><td class="col3">0</td><td class="col4">1</td><td class="col5">0</td>
	</tr>
</table></div>
<!-- EDIT8 TABLE [2638-2724] -->
</div>
<!-- EDIT7 SECTION "Matrice de adiacenţă" [2192-2725] -->
<h2 class="sectionedit9" id="parcurgerea_grafurilor">Parcurgerea grafurilor</h2>
<div class="level2">

</div>
<!-- EDIT9 SECTION "Parcurgerea grafurilor" [2726-2760] -->
<h3 class="sectionedit10" id="parcurgerea_in_latime">Parcurgerea în lăţime</h3>
<div class="level3">

<p>
Parcurgerea în lățime (<strong>Breadth-first Search - BFS</strong>) presupune vizitarea nodurilor în următoarea ordine:
</p>
<ul>
<li class="level1"><div class="li"> nodul sursă (considerat a fi pe nivelul 0)</div>
</li>
<li class="level1"><div class="li"> vecinii nodului sursă (aceștia constituind nivelul 1)</div>
</li>
<li class="level1"><div class="li"> vecinii încă nevizitați ai nodurilor de pe nivelul 1 (aceștia constituind nivelul 2)</div>
</li>
<li class="level1"><div class="li"> vecinii încă nevizitați ai nodurilor de pe nivelul 2</div>
</li>
<li class="level1"><div class="li"> s.a.m.d. </div>
</li>
</ul>

<p>
Caracteristica esențială a acestui tip de parcurgere este, deci, că se preferă explorarea <strong>în lățime</strong>, a nodurilor de pe același nivel (aceeași depărtare față de sursă) în detrimentul celei <strong>în adâncime</strong>, a nodurilor de pe nivelul următor.
</p>

</div>

<h4 id="pasi_de_executie">Pași de execuție</h4>
<div class="level4">
<ul>
<li class="level1"><div class="li"> colorarea nodurilor. Pe parcurs ce algoritmul avansează, se colorează nodurile în felul următor:</div>
<ul>
<li class="level2"><div class="li"><strong>alb</strong> - nodul este nedescoperit încă</div>
</li>
<li class="level2"><div class="li"><strong>gri</strong> - nodul a fost descoperit și este în curs de procesare</div>
</li>
<li class="level2"><div class="li"><strong>negru</strong> - procesarea nodului s-a încheiat </div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> păstrarea informațiilor despre distanța până la nodul sursă.</div>
<ul>
<li class="level2"><div class="li"> pentru fiecare nod în <code>d[u]</code> se reține distanța până la nodul sursă (poate fi util în unele probleme) </div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> obținerea arborelui BFS.</div>
<ul>
<li class="level2"><div class="li"> în urma aplicării algoritmului BFS se obține un arbore de acoperire (prin eliminarea muchiilor pe care nu le folosim la parcurgere). Pentru a putea reconstitui acest arbore, se păstrează pentru fiecare nod dat informația despre părintele său în <code>p[u]</code>. </div>
</li>
</ul>
</li>
</ul>

<p>
Pentru implementarea BFS se utilizează o coadă (<code>Q</code>) în care inițial se află doar nodul sursă. Se vizitează pe rând vecinii acestui nod şi se pun și ei în coada. În momentul în care nu mai există vecini nevizitați, nodul sursă este scos din coadă.
</p>

<p>
<a href="../../../../../_detail/sd-ca/laboratoare/bf1.jpg%3Fid=sd-ca%253A2015%253Alaboratoare%253Alaborator-08.html" class="media" title="sd-ca:laboratoare:bf1.jpg"><img src="../../../../../_media/sd-ca/laboratoare/bf1.jpg" class="media" title="bf1.jpg" alt="bf1.jpg" /></a>
</p>

<p>
<a href="../../../../../_detail/sd-ca/laboratoare/bf2.jpg%3Fid=sd-ca%253A2015%253Alaboratoare%253Alaborator-08.html" class="media" title="sd-ca:laboratoare:bf2.jpg"><img src="../../../../../_media/sd-ca/laboratoare/bf2.jpg" class="media" title="bf2.jpg" alt="bf2.jpg" /></a>
</p>

<p>
Arborele obținut în urma execuției este următorul:
</p>

<p>
<a href="../../../../../_detail/sd-ca/laboratoare/bf3.jpg%3Fid=sd-ca%253A2015%253Alaboratoare%253Alaborator-08.html" class="media" title="sd-ca:laboratoare:bf3.jpg"><img src="../../../../../_media/sd-ca/laboratoare/bf3.jpg" class="media" title="bf3.jpg" alt="bf3.jpg" /></a>
</p>

</div>

<h4 id="pseudocod_bfs">Pseudocod BFS</h4>
<div class="level4">
<pre class="code">// inițializări
pentru fiecare nod u din V
{
    culoare[u] = alb
    d[u] = infinit
    p[u] = null
}
culoare[sursa] = gri
d[sursa] = 0
enqueue(Q,sursa) // punem nodul sursă în coada Q
 
// algoritmul propriu-zis
cât timp coada Q nu este vidă
{
    v = dequeue(Q) // extragem nodul v din coadă
    pentru fiecare u dintre vecinii lui v
        dacă culoare[u] == alb
        {
            culoare[u] = gri
            p[u] = v
            d[u] = d[v] + 1
            enqueue(Q,u) // adăugăm nodul u în coadă
        }
    culoare[v] = negru // am terminat de explorat toți vecinii lui v
}</pre>

<p>
Dacă graful are mai multe componente conexe, algoritmul, în forma dată, va parcurge doar componenta din care face parte nodul sursă. Pe grafuri cu mai multe componente conexe se va aplica în continuare algoritmul pentru fiecare nod rămas nevizitat și astfel se vor obține mai mulți arbori, câte unul pentru fiecare componentă. 
</p>

</div>

<h4 id="complexitate_bfs">Complexitate BFS</h4>
<div class="level4">

<p>
<code>O(|E|+|V|)</code> - unde <code>|E|</code> este numărul de muchii, iar <code>|V|</code> este numărul de noduri.
</p>
<ul>
<li class="level1"><div class="li"> <strong>explicație</strong>: în cazul cel mai defavorabil, vor fi explorate toate muchiile și toate nodurile (când nodurile sunt liniarizate).</div>
</li>
</ul>

</div>
<!-- EDIT10 SECTION "Parcurgerea în lăţime" [2761-5889] -->
<h3 class="sectionedit11" id="parcurgerea_in_adancime">Parcurgerea în adâncime</h3>
<div class="level3">

<p>
Parcurgerea în adâncime (<strong>Depth-First Search - DFS</strong>) presupune explorarea nodurilor în următoarea ordine:
</p>
<ul>
<li class="level1"><div class="li"> nodul sursă</div>
</li>
<li class="level1"><div class="li"> primul vecin nevizitat al nodului sursă (îl vom numi <code>V1</code>)</div>
</li>
<li class="level1"><div class="li"> primul vecin nevizitat al lui <code>V1</code> (îl vom numi <code>V2</code>)</div>
</li>
<li class="level1"><div class="li"> primul vecin nevizitat al lui <code>V2</code></div>
</li>
<li class="level1"><div class="li"> s.a.m.d.</div>
</li>
<li class="level1"><div class="li"> în momentul în care am epuizat vecinii unui nod <code>Vn</code>, continuăm cu următorul vecin nevizitat al nodului anterior, <code>Vn-1</code> </div>
</li>
</ul>

<p>
Așadar, spre deosebire de BFS, acest tip de parcurgere pune prioritate pe explorarea <strong>în adâncime</strong> (la distanțe tot mai mari față de nodul sursă), în detrimentul celei <strong>în lățime</strong> (pe același nivel). 
</p>

</div>

<h4 id="pasi_de_executie1">Pași de execuție</h4>
<div class="level4">
<ul>
<li class="level1"><div class="li"> colorarea nodurilor. Pe parcurs ce algoritmul avansează, se colorează nodurile in felul următor:</div>
<ul>
<li class="level2"><div class="li"><strong>alb</strong> - nodul este nedescoperit încă</div>
</li>
<li class="level2"><div class="li"><strong>gri</strong> - nodul a fost descoperit și este în curs de procesare</div>
</li>
<li class="level2"><div class="li"><strong>negru</strong> - procesarea nodului s-a încheiat </div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> păstrarea informațiilor despre timp. Fiecare nod are două momente de timp asociate:</div>
<ul>
<li class="level2"><div class="li"><code>tDesc[u]</code> - momentul descoperirii nodului (și a schimbării culorii din alb în gri)</div>
</li>
<li class="level2"><div class="li"><code>tFin[u]</code> - momentul în care procesarea nodului s-a încheiat (și culoarea acestuia s-a schimbat din gri în negru) </div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> obținerea arborelui DFS.</div>
<ul>
<li class="level2"><div class="li"> în urma aplicării algoritmului DFS asupra fiecărei componente conexe a grafului, se obține pentru fiecare dintre acestea câte un arbore de acoperire (prin eliminarea muchiilor pe care nu le folosim la parcurgere). Pentru a putea reconstitui acest arbore, păstram pentru fiecare nod dat informația despre părintele său în <code>p[u]</code>.</div>
</li>
</ul>
</li>
</ul>

<p>
Un exemplu de aplicare al DFS este următorul:
</p>

<p>
<a href="../../../../../_detail/sd-ca/laboratoare/df1.jpg%3Fid=sd-ca%253A2015%253Alaboratoare%253Alaborator-08.html" class="media" title="sd-ca:laboratoare:df1.jpg"><img src="../../../../../_media/sd-ca/laboratoare/df1.jpg" class="media" title="df1.jpg" alt="df1.jpg" /></a>
</p>

<p>
Nodul de pornire este I, iar pentru simplificare vecinii sunt aleși în ordine alfabetică. În stânga nodului este notat <code>tDesc</code>, iar în dreapta <code>tFin</code>. Dacă se afișează nodurile, în urma parcurgerii se obține următorul output: <strong>I, E, B, A, C, D, G, F, H</strong>
</p>

<p>
Arborele obținut în urma parcurgerii este următorul:
</p>

<p>
<a href="../../../../../_detail/sd-ca/laboratoare/df2.jpg%3Fid=sd-ca%253A2015%253Alaboratoare%253Alaborator-08.html" class="media" title="sd-ca:laboratoare:df2.jpg"><img src="../../../../../_media/sd-ca/laboratoare/df2.jpg" class="media" title="df2.jpg" alt="df2.jpg" /></a>
</p>

</div>

<h4 id="pseudocod_dfs">Pseudocod DFS</h4>
<div class="level4">
<pre class="code">// inițializări
pentru fiecare nod u din V
{
    culoare[u] = alb
    p[u] = NULL
    tDesc[u] = 0
    tFin[u] = 0
}
contor_timp = 0

// funcţie de vizitare a nodului
vizitare(nod)
{
    contor_timp = contor_timp + 1
    tDesc[nod] = contor_timp
    culoare[nod] = gri
    printeaza nod;
}

// algoritmul propriu-zis
DFS(nod)
{
    stiva s;
     
    viziteaza nod; 
    s.introdu(nod);
    
    cât timp stiva s nu este goală
    {
        nodTop = nodul din vârful stivei 
               
        vecin = află primul vecin nevizitat al lui nodTop.
        dacă vecin există
        {
            p[v] = nodTop
            viziteaza v;
            s.introdu(v);
        }  
        altfel
        {
            contor_timp = contor_timp + 1
            tFin[nodTop] = contor_timp
            culoare[nodTop] = negru  
            s.scoate(nodTop);   
        }     
    }
}</pre>

</div>

<h4 id="complexitate_dfs">Complexitate DFS</h4>
<div class="level4">

<p>
La fel ca în cazul BFS, complexitatea este <code>O(|E|+|V|)</code> - unde <code>|E|</code> este numărul de muchii, iar <code>|V|</code> este numărul de noduri.
</p>
<ul>
<li class="level1"><div class="li"> <strong>explicație</strong>: în cazul cel mai defavorabil, vor fi explorate toate muchiile şi toate nodurile (când graful este liniarizat).</div>
</li>
</ul>

</div>
<!-- EDIT11 SECTION "Parcurgerea în adâncime" [5890-9234] -->
<h2 class="sectionedit12" id="aplicatii_parcurgeri">Aplicaţii parcurgeri</h2>
<div class="level2">

</div>
<!-- EDIT12 SECTION "Aplicaţii parcurgeri" [9235-9268] -->
<h3 class="sectionedit13" id="aflarea_distantei_minime_intre_doua_noduri">Aflarea distanței minime între două noduri</h3>
<div class="level3">

<p>
Dacă toate muchiile au același cost, putem afla distanța minimă între două noduri <code>A</code> și <code>B</code> efectuând o parcurgere <code>BFS</code> din nodul <code>A</code> și oprindu-ne atunci când nodul <code>B</code> a fost descoperit. Reamintindu-ne că nivelul unui nod este analog distanței, în muchii, față de sursă, și că <code>BFS</code> descoperă un nod de pe nivelul <code>N</code> numai după ce toate nodurile de pe nivele inferioare au fost descoperite, este ușor de văzut că nivelul nodului <code>B</code> în parcurgere corespunde distanței minime între <code>A</code> și <code>B</code>.
</p>

<p>
Pentru a reține distanța și drumul exact de la <code>A</code> la <code>B</code>, se vor reține pentru fiecare nod <code>d[x]</code> (distanța de la <code>sursă</code> la <code>x</code>) și <code>p[x]</code> (părintele lui <code>x</code> în drumul de la sursă spre <code>x</code>). În momentul descoperirii unui nod <code>y</code> al cărui părinte este <code>x</code>, se vor face următoarele atribuiri:
</p>
<pre class="code">d[y] = d[x] + 1
p[y] = x</pre>

<p>
sursa având <code>d[A] = 0</code> și <code>p[A] = NULL</code>.
</p>

<p>
Observații:
</p>
<ul>
<li class="level1"><div class="li">dacă parcurgerea BFS se încheie fără ca nodul B să fi fost descoperit, nu există drum între A și B și deci distanța între acestea este infinită.</div>
</li>
<li class="level1"><div class="li">Algoritmul funcționează corect numai în situații de cost uniform (toate muchiile au același cost). Pentru grafuri cu muchii de costuri diferite, sunt necesari algoritmi mai avansați, cum ar fi: Dijkstra, Bellman-Ford sau Floyd-Warshall. </div>
</li>
</ul>

</div>
<!-- EDIT13 SECTION "Aflarea distanței minime între două noduri" [9269-10708] -->
<h3 class="sectionedit14" id="sortarea_topologica">Sortarea topologică</h3>
<div class="level3">

<p>
Se dă un graf orientat aciclic. Orientarea muchiilor corespunde unei relații de ordine de la nodul sursă către cel destinație. O sortare topologică a unui astfel de graf este o ordonare liniară a vârfurilor sale astfel încât, dacă <code>(u,v)</code> este una dintre muchiile grafului, <code>u</code> trebuie să apară înaintea lui <code>v</code> în înșiruire. Dacă graful ar fi ciclic, nu ar putea exista o astfel de înșiruire (nu se poate stabili o ordine între nodurile care alcătuiesc un ciclu).
</p>

<p>
Sortarea topologică poate fi văzută și ca plasarea nodurilor de-a lungul unei linii orizontale astfel încât toate muchiile să fie direcționate de la stânga la dreapta (să nu existe nici o muchie înapoi, spre părinte).
</p>

<p>
Un exemplu: Profesorul Bumstead își sortează topologic hainele înainte de a se îmbrăca.
</p>
<ul>
<li class="level1"><div class="li"> fiecare muchie <code>(u, v</code>) înseamna că obiectul de îmbrăcăminte <code>u</code> trebuie îmbrăcat înaintea obiectului de îmbrăcaminte <code>v</code>. Timpii de descoperire <code>(tDesc)</code> și de finalizare <code>(tFin)</code> obținuți în urma parcurgerii DFS sunt notați lângă noduri.</div>
</li>
<li class="level1"><div class="li"> același graf, sortat topologic. Nodurile lui sunt aranjate de la stânga la dreapta în ordinea descrescătoare a <code>tFin</code>. Observați că toate muchiile sunt orientate de la stânga la dreapta. Acum profesorul Bumstead se poate îmbrăca liniștit. </div>
</li>
</ul>

<p>
<a href="../../../../../_detail/sd-ca/laboratoare/topologie.jpg%3Fid=sd-ca%253A2015%253Alaboratoare%253Alaborator-08.html" class="media" title="sd-ca:laboratoare:topologie.jpg"><img src="../../../../../_media/sd-ca/laboratoare/topologie.jpg" class="media" title="topologie.jpg" alt="topologie.jpg" /></a>
</p>

<p>
Așa cum se observă din poză, sortarea topologică constă în sortarea nodurilor descrescător după timpii de finalizare. Demonstrația acestei afirmații se face simplu, arătând că nodul care se termină mai târziu trebuie să fie efectuat înaintea celorlalte noduri finalizate. 
</p>

</div>
<!-- EDIT14 SECTION "Sortarea topologică" [10709-12415] -->
<h2 class="sectionedit15" id="importanta">Importanţă</h2>
<div class="level2">

<p>
Grafurile sunt utile pentru a modela diverse probleme şi se regăsesc implementaţi în multiple aplicaţii practice:
</p>
<ul>
<li class="level1"><div class="li"> reţele de calculatoare (ex: stabilirea unei topologii fără bucle)</div>
</li>
<li class="level1"><div class="li"> pagini Web (ex: Google PageRank)</div>
</li>
<li class="level1"><div class="li"> rețele sociale (ex: calcul centralitate)</div>
</li>
<li class="level1"><div class="li"> hărţi cu drumuri (ex: drum minim)</div>
</li>
<li class="level1"><div class="li"> modelare grafică (ex: prefuse, graph-cut)</div>
</li>
</ul>

</div>
<!-- EDIT15 SECTION "Importanţă" [12416-12804] -->
<h2 class="sectionedit16" id="aplicatii">Aplicaţii</h2>
<div class="level2">

<p>
Porniți exercițiile de la <strong><a href="../../../../../_media/sd-ca/laboratoare/lab07-tasks.zip" class="media mediafile mf_zip" title="sd-ca:laboratoare:lab07-tasks.zip (4.1 KB)"> scheletul de cod</a></strong> oferit.
</p>

<p>
1.<strong>[7p]</strong> Se citesc din fişierul <code>graf.in</code> M muchii ale unui graf <em>neorientat</em> cu N vârfuri. Folosind scheletul de cod dat implementaţi următoarele cerinţe:
</p>
<ul>
<li class="level1"><div class="li"> <strong>TODO1.1</strong>: Studiati reprezentarea grafului în scheletul de cod ataşat.</div>
</li>
<li class="level1"><div class="li"> <strong>TODO1.2</strong>: (1p) Adăugaţi muchiile în structura grafului. În scheletul de cod graful este reprezentat ca un vector de liste de adiacenţă.</div>
</li>
<li class="level1"><div class="li"> <strong>TODO1.3</strong>: (3p) Implementaţi parcurgerea BFS a grafului pornind dintr-un nod ales.</div>
</li>
<li class="level1"><div class="li"> <strong>TODO1.4</strong>: (3p) Implementaţi parcurgerea DFS a grafului pornind dintr-un nod ales.</div>
</li>
</ul>
<ul>
<li class="level1"><div class="li"> Datele se vor citi dintr-un fișier cu următorul format:</div>
<ul>
<li class="level3"><div class="li"> pe prima linie: numărul de varfuri <code>N</code> și de muchii <code>M</code> ale grafului</div>
</li>
<li class="level3"><div class="li"> pe următoarea linie: nodul de start BFS si nodul de start DFS</div>
</li>
<li class="level3"><div class="li"> pe următoarele <code>M</code> linii: perechi de noduri (u,v) pentru care există muchii în graf</div>
</li>
</ul>
</li>
</ul>
<ul>
<li class="level1"><div class="li"> <strong>hints:</strong> În cadrul scheletului, s-au folosit următoarele clase din STL: </div>
</li>
<li class="level1"><div class="li"> <a href="http://www.cplusplus.com/reference/stl/vector/" class="urlextern" title="http://www.cplusplus.com/reference/stl/vector/"  rel="nofollow"> Vector</a> pentru care aveţi nevoie de următoarele funcţii:</div>
<ul>
<li class="level2"><div class="li"> v.size() - întoarce numărul de elemente din vector</div>
</li>
<li class="level2"><div class="li"> v[i] (operatorul <code>[]</code>) - întoarce elementul de pe poziția i</div>
</li>
<li class="level2"><div class="li"> Un vector se poate sorta cu ajutorul funcției <a href="http://www.cplusplus.com/reference/algorithm/sort/" class="urlextern" title="http://www.cplusplus.com/reference/algorithm/sort/"  rel="nofollow">sort</a> din STL.</div>
</li>
<li class="level2"><div class="li"> Exemplu de sortare: <code>std::sort(v.begin(),v.end());</code></div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Exemplu de parcurgere și afișare a elementelor dintr-un vector STL folosind indecsi:</div>
</li>
</ul>
<pre class="code c++">    <span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">unsigned</span> <span class="kw4">int</span> i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> v.<span class="me1">size</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span> <span class="sy0">++</span>i<span class="br0">&#41;</span> 
    <span class="br0">&#123;</span>
        std<span class="sy0">::</span><span class="me2">cout</span> <span class="sy0">&lt;&lt;</span> v<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy0">&lt;&lt;</span> std<span class="sy0">::</span><span class="me2">endl</span><span class="sy0">;</span>
    <span class="br0">&#125;</span></pre>
<ul>
<li class="level1"><div class="li"> Exemplu de parcurgere și afișare a elementelor dintr-un vector STL folosind iteratori:</div>
</li>
</ul>
<pre class="code c++">    <span class="kw1">for</span> <span class="br0">&#40;</span>std<span class="sy0">::</span><span class="me2">vector</span><span class="sy0">&lt;</span>int<span class="sy0">&gt;::</span><span class="me2">iterator</span> it <span class="sy0">=</span> v.<span class="me1">begin</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span> it <span class="sy0">!=</span> v.<span class="me1">end</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span> <span class="sy0">++</span>it<span class="br0">&#41;</span> 
    <span class="br0">&#123;</span>
        std<span class="sy0">::</span><span class="me2">cout</span> <span class="sy0">&lt;&lt;</span> <span class="sy0">*</span>it <span class="sy0">&lt;&lt;</span> std<span class="sy0">::</span><span class="me2">endl</span><span class="sy0">;</span>
    <span class="br0">&#125;</span></pre>
<ul>
<li class="level1"><div class="li"> Exemplu de parcurgere și afișare a elementelor dintr-un vector STL folosind funcția<a href="http://www.cplusplus.com/reference/algorithm/copy/" class="urlextern" title="http://www.cplusplus.com/reference/algorithm/copy/"  rel="nofollow">copy</a> din STL.</div>
</li>
</ul>
<pre class="code c++">   std<span class="sy0">::</span><span class="me2">ostream_iterator</span><span class="sy0">&lt;</span>int<span class="sy0">&gt;</span> out_it<span class="br0">&#40;</span>std<span class="sy0">::</span><span class="me2">cout</span><span class="sy0">,</span> std<span class="sy0">::</span><span class="me2">endl</span><span class="br0">&#41;</span><span class="sy0">;</span>
   std<span class="sy0">::</span><span class="me2">copy</span><span class="br0">&#40;</span>v.<span class="me1">begin</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">,</span> v.<span class="me1">end</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">,</span> out_it<span class="br0">&#41;</span><span class="sy0">;</span></pre>

</div>
<!-- EDIT16 SECTION "Aplicaţii" [12805-19122] -->
<h2 class="sectionedit17" id="interviu">Interviu</h2>
<div class="level2">

<p>
Această secțiune nu este punctată și încearcă să vă facă o oarecare idee a tipurilor de întrebări pe care le puteți întâlni la un job interview (internship, part-time, full-time, etc.) din materia prezentată în cadrul laboratorului.
</p>

<p>
Cum multe din companiile mari folosesc date stocate sub formă de grafuri (Facebook Open Graph, Google Social Graph şi Page Rank, etc.) la angajare vor dori să vadă ca ştiţi grafuri: 
</p>
<ul>
<li class="level1"><div class="li"> cum se reprezintă grafurile</div>
</li>
<li class="level1"><div class="li"> cum funcţionează şi cum se implementează parcurgerile (BFS, DFS)</div>
</li>
<li class="level1"><div class="li"> algoritmi mai avansaţi pentru grafuri precum Dijkstra şi A* (cu care vă veţi familiariza la materiile de algoritmică din anul 2: Analiza Algoritmilor si Proiectarea Algoritmilor)</div>
</li>
</ul>

<p>
Puteţi căuta mai multe întrebări pe <a href="http://www.careercup.com/" class="urlextern" title="http://www.careercup.com/"  rel="nofollow">http://www.careercup.com/</a> şi pe <a href="http://www.glassdoor.com/" class="urlextern" title="http://www.glassdoor.com/"  rel="nofollow">http://www.glassdoor.com/</a>
</p>

</div>
<!-- EDIT17 SECTION "Interviu" [19123-19977] -->
<h2 class="sectionedit18" id="resurse">Resurse</h2>
<div class="level2">

<p>
[1] - <a href="http://en.wikipedia.org/wiki/Breadth-first_search" class="urlextern" title="http://en.wikipedia.org/wiki/Breadth-first_search"  rel="nofollow"> BFS</a>
</p>

<p>
[2] - <a href="http://en.wikipedia.org/wiki/Shortest_path" class="urlextern" title="http://en.wikipedia.org/wiki/Shortest_path"  rel="nofollow"> Distanţa minimă </a>
</p>

<p>
[3] - <a href="http://en.wikipedia.org/wiki/Depth-first_search" class="urlextern" title="http://en.wikipedia.org/wiki/Depth-first_search"  rel="nofollow"> DFS </a>
</p>

<p>
[4] - <a href="http://en.wikipedia.org/wiki/Topological_sorting" class="urlextern" title="http://en.wikipedia.org/wiki/Topological_sorting"  rel="nofollow"> Sortare topologică </a>
</p>

<p>
[5] - <a href="http://en.wikipedia.org/wiki/Dijkstra%27s_algorithm" class="urlextern" title="http://en.wikipedia.org/wiki/Dijkstra%27s_algorithm"  rel="nofollow"> Dijkstra </a>
</p>

<p>
[6] - <a href="http://en.wikipedia.org/wiki/Bellman-ford" class="urlextern" title="http://en.wikipedia.org/wiki/Bellman-ford"  rel="nofollow"> Bellman-Ford </a>
</p>

<p>
[7] - <a href="http://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm" class="urlextern" title="http://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm"  rel="nofollow"> Floyd-Warshall </a>
</p>

<p>
[8] - <a href="http://en.wikipedia.org/wiki/A*_search_algorithm" class="urlextern" title="http://en.wikipedia.org/wiki/A*_search_algorithm"  rel="nofollow"> A* </a>
</p>

</div>
<!-- EDIT18 SECTION "Resurse" [19978-] --></div>
</body>
</html>
