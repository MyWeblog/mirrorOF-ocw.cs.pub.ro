    
    

<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
  <meta charset="utf-8" />
  <title>sd-ca:2014:laboratoare:laborator-11</title>
<meta name="generator" content="DokuWiki"/>
<meta name="robots" content="index,follow"/>
<meta name="date" content="2015-02-17T13:40:13+0200"/>
<meta name="keywords" content="sd-ca,2014,laboratoare,laborator-11"/>
<link rel="search" type="application/opensearchdescription+xml" href="../../../../../lib/exe/opensearch.php" title="CS Open CourseWare"/>
<link rel="start" href="../../../../../../courses.1.html"/>
<link rel="alternate" type="application/rss+xml" title="Recent Changes" href="../../../../../feed.php"/>
<link rel="alternate" type="application/rss+xml" title="Current Namespace" href="../../../../../feed.php%3Fmode=list&amp;ns=sd-ca:2014:laboratoare"/>
<link rel="alternate" type="text/html" title="Plain HTML" href="laborator-11.html"/>
<link rel="canonical" href="../../../../../sd-ca/2014/laboratoare/laborator-11.html"/>
<link rel="stylesheet" type="text/css" href="../../../../../lib/exe/css.php%3Ft=arctic&amp;tseed=1476798676.css"/>
<script type="text/javascript">/*<![CDATA[*/var NS='sd-ca:2014:laboratoare';var JSINFO = {"id":"sd-ca:2014:laboratoare:laborator-11","namespace":"sd-ca:2014:laboratoare","isadmin":0,"isauth":0};
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="../../../../../lib/exe/js.php%3Ftseed=1476798676"></script>
<script type="text/x-mathjax-config">/*<![CDATA[*/MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ["$","$"], ["\\(","\\)"] ],
        displayMath: [ ["$$","$$"], ["\\[","\\]"] ],
        processEscapes: true
    }
});
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
<script type="text/javascript">/*<![CDATA[*/
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
		  
/*!]]>*/</script>
<script type="text/javascript">/*<![CDATA[*/
var pageTracker = _gat._getTracker("UA-38383934-1");
pageTracker._initData();
pageTracker._trackPageview();
		  
/*!]]>*/</script>
</head>
<body>
<div class="dokuwiki export">
<!-- TOC START -->
<div id="dw__toc">
<h3 class="toggle">Table of Contents</h3>
<div>

<ul class="toc">
<li class="level1"><div class="li"><a href="laborator-11.html#laborator_11_-_arbori_binari_de_cautare_echilibrati_treapuri">Laborator 11 - Arbori binari de căutare echilibrați. Treapuri.</a></div>
<ul class="toc">
<li class="level2"><div class="li"><a href="laborator-11.html#obiective">Obiective</a></div></li>
<li class="level2"><div class="li"><a href="laborator-11.html#necesitatea_structurii_de_arbore_binar_de_cautare_echilibrat">Necesitatea structurii de arbore binar de căutare echilibrat</a></div></li>
<li class="level2"><div class="li"><a href="laborator-11.html#notiuni_de_baza_despre_treapuri">Noțiuni de bază despre treapuri</a></div></li>
<li class="level2"><div class="li"><a href="laborator-11.html#structura_unui_nod">Structura unui nod</a></div></li>
<li class="level2"><div class="li"><a href="laborator-11.html#operatii_de_baza">Operații de bază</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="laborator-11.html#cautarea">Căutarea</a></div></li>
<li class="level3"><div class="li"><a href="laborator-11.html#inserarea">Inserarea</a></div></li>
<li class="level3"><div class="li"><a href="laborator-11.html#stergerea">Ștergerea</a></div></li>
</ul>
</li>
<li class="level2"><div class="li"><a href="laborator-11.html#exercitii">Exerciții</a></div></li>
<li class="level2"><div class="li"><a href="laborator-11.html#referinte">Referințe</a></div></li>
</ul></li>
</ul>
</div>
</div>
<!-- TOC END -->

<h1 class="sectionedit1" id="laborator_11_-_arbori_binari_de_cautare_echilibrati_treapuri">Laborator 11 - Arbori binari de căutare echilibrați. Treapuri.</h1>
<div class="level1">

<p>
Responsabil:
</p>
<ul>
<li class="level1"><div class="li"> <a href="mailto:&#x61;&#x6e;&#x64;&#x72;&#x65;&#x69;&#x2e;&#x70;&#x61;&#x72;&#x76;&#x75;&#x40;&#x63;&#x74;&#x69;&#x2e;&#x70;&#x75;&#x62;&#x2e;&#x72;&#x6f;" class="mail" title="&#x61;&#x6e;&#x64;&#x72;&#x65;&#x69;&#x2e;&#x70;&#x61;&#x72;&#x76;&#x75;&#x40;&#x63;&#x74;&#x69;&#x2e;&#x70;&#x75;&#x62;&#x2e;&#x72;&#x6f;"> Andrei Pârvu</a> (2013, 2014)</div>
</li>
</ul>

</div>
<!-- EDIT1 SECTION "Laborator 11 - Arbori binari de căutare echilibrați. Treapuri." [1-156] -->
<h2 class="sectionedit2" id="obiective">Obiective</h2>
<div class="level2">

<p>
În urma parcurgerii acestui laborator studentul va: 
</p>
<ul>
<li class="level1"><div class="li"> înțelege conceptul unui arbore echilibrat de căutare</div>
</li>
<li class="level1"><div class="li"> exemplifica acest concept pe structura de treap</div>
</li>
<li class="level1"><div class="li"> implementa operațiile de adăugare nod, ștergere nod și rotiri </div>
</li>
<li class="level1"><div class="li"> face operații mai complexe si parcurgri de treapuri</div>
</li>
</ul>

</div>
<!-- EDIT2 SECTION "Obiective" [157-476] -->
<h2 class="sectionedit3" id="necesitatea_structurii_de_arbore_binar_de_cautare_echilibrat">Necesitatea structurii de arbore binar de căutare echilibrat</h2>
<div class="level2">

<p>
O structură de date este o metodă de a reține anumite date astfel încât operațiile cu acestea (căutare, inserare, ștergere) să fie făcute cât mai eficient și să respecte cerințele programatorului. De multe ori, o anumită structură de date se află la baza unui algoritm sau sistem, iar o performanță bună a acesteia (complexitate spațială și temporală cât mai mică) influențează performanța întregului sistem.
</p>

<p>
În laboratoarele precedente am observat că un arbore binar de căutare de înalțime <code>h</code> implementează operațiile descrise mai sus într-o complexitate de <code>O(h)</code>. Dacă acest arbore binar nu este capabil de a gestiona elementele ce sunt inserate pentru a își menține o structura echilibrată atunci complexitatea pe operațiile de baza va crește. Exemplu: să presupunem ca avem de introdus <code>n</code> numere intr-un arbore binar de căutare; întamplarea face ca numerele să fie sortate, de unde rezultă că arborele format va fi liniar (fiecare nod va avea maxim doi vecini); astfel, complexitatea pe operatiile de baza va fi <code>O(n)</code> la fel ca în cazul folosirii unui simplu vector.
</p>

</div>
<!-- EDIT3 SECTION "Necesitatea structurii de arbore binar de căutare echilibrat" [477-1688] -->
<h2 class="sectionedit4" id="notiuni_de_baza_despre_treapuri">Noțiuni de bază despre treapuri</h2>
<div class="level2">

<p>
Treapurile sunt unii din arborii de căutare echilibrați cel mai des folosiți datorită implementării relativ ușoare (comparativ cu alte structuri similare cum ar fi Red-Black Trees, AVL-uri sau B-Trees), dar și a modului de operare destul de intuitiv.
Fiecare nod din treap va retine două câmpuri:
</p>
<ul>
<li class="level1"><div class="li"> cheia - informația care se reține în arbore și pe care se fac operațiile de inseare, căutare și ștergere</div>
</li>
<li class="level1"><div class="li"> prioritatea - un număr pe baza căruia se face echilibrarea arborelui</div>
</li>
</ul>

<p>
Această structură trebuie să respecte doi invarianți:
</p>
<ul>
<li class="level1"><div class="li"> Invariantul de arbore de cautare (search <strong>tr</strong>ee) - <strong>cheia</strong> unui nod va fi mai mare sau egală decât <strong>cheia</strong> fiului stânga (dacă există) si mai mică sau egală decât <strong>cheia</strong> fiului dreapta (dacă există); cu alte cuvinte o parcurgere in inordine a arborelui va genera șirul sortat de chei.</div>
</li>
<li class="level1"><div class="li"> Invariantul de h<strong>eap</strong> - <strong>prioritatea</strong> unui nod este mai mare sau egală decât <strong>prioritățile</strong> fiilor.</div>
</li>
</ul>

<p>
Astfel, se poate observa că numele structurii de date a venit din acești doi invarianți: tr-eap.
</p>

<p>
Cum se menține echilibrul structurii? De fiecare dată când un nod este inserat în arbore prioritatea lui este generată random (o metodă similară cu cea de la randomized quick sort, în care la fiecare pas pivotul este generat aleator) - astfel arborele va fi aranjat într-un mod aleator (bineînțeles, respectând cei doi invarianți)cum numărul arborilor echilibrați este mai mare decât cel al arborilor rău echilibrați, șansa este destul de mică ca prioritățile generate aleator să nu mențină arborele echilibrat.
Demonstratia complet teoretică asupra faptului că operațiile de baza au complexitatea O(logN) se poate găsi in 2.
</p>

</div>
<!-- EDIT4 SECTION "Noțiuni de bază despre treapuri" [1689-3474] -->
<h2 class="sectionedit5" id="structura_unui_nod">Structura unui nod</h2>
<div class="level2">

<p>
Mai jos avem codul pentru structura nodului unui treap; se pot observa asemănările cu structura de arbore binar și cu cea de heap.
</p>
<pre class="code c++">template <span class="sy0">&lt;</span>typename T<span class="sy0">&gt;</span> <span class="kw4">struct</span> Treap <span class="br0">&#123;</span>
  T key<span class="sy0">;</span>
  <span class="kw4">int</span> priority<span class="sy0">;</span>
  Treap<span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> <span class="sy0">*</span>left<span class="sy0">,</span> <span class="sy0">*</span>right<span class="sy0">;</span>
<span class="br0">&#125;</span><span class="sy0">;</span></pre>

<p>
Bineînțeles, tipul de date trebuie să permită o relație de ordine totală astfel încât oricare două elemente să poată fi comparate.
</p>

</div>
<!-- EDIT5 SECTION "Structura unui nod" [3475-3895] -->
<h2 class="sectionedit6" id="operatii_de_baza">Operații de bază</h2>
<div class="level2">

<p>
Mai jos este descris pseudocodul pentru operațiile de bază făcute cu treapuri.<br/>

Pentru exemplificarea operațiilor am folosit un nod special, numit <code>nil</code>, care reprezintă un nod fictiv, ce nu reține date, folosit pentru a arăta că nu există un nod efectiv în treap. De exemplu, dacă un nod <code>x</code> are ambii fii egali cu <code>nil</code> înseamnă ca <code>x</code> este frunză în arbore.
</p>

</div>
<!-- EDIT6 SECTION "Operații de bază" [3896-4313] -->
<h3 class="sectionedit7" id="cautarea">Căutarea</h3>
<div class="level3">

<p>
Căutarea se face exact ca la un arbore binar de căutare.
</p>
<pre class="code">bool cautare(nod, cheie) {
  if nod == nil
    return false;
  if nod.cheie == cheie
    return true;
  
  if cheie &lt; nod.cheie
    return cautare(nod.stanga, cheie);
  else
    return cautare(nod.dreapta, cheie);
}</pre>

</div>
<!-- EDIT7 SECTION "Căutarea" [4314-4627] -->
<h3 class="sectionedit8" id="inserarea">Inserarea</h3>
<div class="level3">

<p>
Inserarea unui nod se face generand o prioritate aleatoare pentru acesta și procedând asemănător ca pentru un arbore de căutare, adăugând nodul la baza arborelui printr-o procedură recursivă, pornind de la rădăcina acestuia.
</p>

<p>
Deși inserarea menține invariantul arborelui de căutare, invariantul de heap poate să nu se mai respecte. De aceea, trebuie definite operații de rotire (stânga sau dreapta), care să fie aplicate unui nod în cazul în care prioritatea sa este mai mare decât ce a părintelui său.
</p>

<p>
Mai jos avem pseudocodul pentru operația de inserare.
</p>
<pre class="code">void insert(nod, cheie, prioritate) {
  if nod == nil
    nod = creza nou nod pe baza de cheie si prioritate
  else if cheie &lt; nod.cheie
    insert(nod.stanga, cheie, prioritate)
  else
    insert(nod.dreapta, cheie, prioritate)
    
  if nod.stanga.prioritate &gt; nod.prioritate
    rotireDreapta(nod)
  else if nod.dreapta.prioritate &gt; nod.prioritate
    rotireStanga(nod)
}</pre>

<p>
 Spre exemplu, dacă am dori să inserăm nodul cu cheia 9 si prioritatea 51, pașii vor arată în felul urmator:
</p>

<p>
<a href="../../../../../_detail/sd-ca/laboratoare/inserare.png%3Fid=sd-ca%253A2014%253Alaboratoare%253Alaborator-11.html" class="media" title="sd-ca:laboratoare:inserare.png"><img src="../../../../../_media/sd-ca/laboratoare/inserare.png" class="mediacenter" alt="" /></a>
</p>

<p>
Se observă necesitatea rotirilor pentru a aduce nodul nou inserat în vârful arborelui (are prioritatea cea mai mare).
</p>

<p>
Cele două tipuri de rotiri sunt prezentate vizual în imaginea de mai jos:
</p>

<p>
<a href="../../../../../_detail/sd-ca/laboratoare/rotire.png%3Fid=sd-ca%253A2014%253Alaboratoare%253Alaborator-11.html" class="media" title="sd-ca:laboratoare:rotire.png"><img src="../../../../../_media/sd-ca/laboratoare/rotire.png" class="mediacenter" alt="" /></a>
</p>

</div>
<!-- EDIT8 SECTION "Inserarea" [4628-6014] -->
<h3 class="sectionedit9" id="stergerea">Ștergerea</h3>
<div class="level3">

<p>
Operația de ștergere este inversul operației de inserare și se aseamăna foarte mult cu ștergerea unui nod în cadrul unui heap. Nodul pe care îl dorim a fi șters este rotit până când ajunge la baza arborelui, iar atunci este șters. Pentru a menține invariantul de heap, vom face o rotire stânga dacă fiul drept are o prioritate mai mare decât fiul stâng și o rotire drepta în caz contrar.
</p>
<pre class="code">void sterge(nod, cheie) {
  if nod == nil
    return
 
  if cheie &lt; nod.cheie
    sterge(nod.stanga, cheie)
  else if cheie &gt; nod.cheie
    sterge(nod.dreapta, cheie)
  else if nod.stanga == nil si nod.dreapta == nil
    sterge nod
  else if nod.stanga.prioritate &gt; nod.dreapta.prioritate
    rotireDreapta(nod)
    sterge(nod, cheie);
  else
    rotireStanga(nod)
    sterge(nod, cheie)
}</pre>

</div>
<!-- EDIT9 SECTION "Ștergerea" [6015-6851] -->
<h2 class="sectionedit10" id="exercitii">Exerciții</h2>
<div class="level2">

<p>
Pentru exerciții porniți de la <a href="../../../../../_media/sd-ca/laboratoare/lab11-schelet.zip" class="media mediafile mf_zip" title="sd-ca:laboratoare:lab11-schelet.zip (2.3 KB)">acest</a> schelet de laborator.
</p>
<ol>
<li class="level1"><div class="li"> Implementați funcțiile de bază pentru un treap:</div>
<ul>
<li class="level2"><div class="li"> [0.5p] Căutare</div>
</li>
<li class="level2"><div class="li"> [0.5p] Rotiri stânga și dreapta</div>
</li>
<li class="level2"><div class="li"> [0.5p] Inserare</div>
</li>
<li class="level2"><div class="li"> [0.5p] Ștergere</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> [1p] Realizați o parcurgere a treapului astfel încât să obțineți cheile sortate crescător/descrescător.</div>
</li>
<li class="level1"><div class="li"> [2p] Realizați o parcurgere a treapului astfel încât să obțineți o structură arborescentă a priorităților, pentru a observa invariantul de heap.</div>
</li>
<li class="level1"><div class="li"> [4p] Scrieți o funcție care să răspundă într-o complexitate de <code>O(logN)</code> la următoarea cerință: Care este cea de-a K-a cheie, în ordinea sortării crescătoare, care se află în treap?.</div>
</li>
</ol>

</div>
<!-- EDIT10 SECTION "Exerciții" [6852-7620] -->
<h2 class="sectionedit11" id="referinte">Referințe</h2>
<div class="level2">
<ul>
<li class="level1"><div class="li"> <a href="http://www.cs.cmu.edu/afs/cs.cmu.edu/project/scandal/public/papers/treaps-spaa98.pdf" class="urlextern" title="http://www.cs.cmu.edu/afs/cs.cmu.edu/project/scandal/public/papers/treaps-spaa98.pdf"  rel="nofollow"> Fast Set Operations Using Treaps</a></div>
</li>
<li class="level1"><div class="li"> <a href="http://compgeom.cs.uiuc.edu/~jeffe/teaching/algorithms/notes/10-treaps.pdf" class="urlextern" title="http://compgeom.cs.uiuc.edu/~jeffe/teaching/algorithms/notes/10-treaps.pdf"  rel="nofollow"> Randomized Binary Search Trees</a></div>
</li>
<li class="level1"><div class="li"> <a href="http://www.cs.cmu.edu/afs/cs.cmu.edu/academic/class/15451-s07/www/lecture_notes/lect0208.pdf" class="urlextern" title="http://www.cs.cmu.edu/afs/cs.cmu.edu/academic/class/15451-s07/www/lecture_notes/lect0208.pdf"  rel="nofollow"> Balanced Search Trees</a></div>
</li>
</ul>

</div>
<!-- EDIT11 SECTION "Referințe" [7621-] --></div>
</body>
</html>
