    
    

<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
  <meta charset="utf-8" />
  <title>sd-ca:2014:teme:teme-03</title>
<meta name="generator" content="DokuWiki"/>
<meta name="robots" content="index,follow"/>
<meta name="date" content="2015-02-17T13:46:42+0200"/>
<meta name="keywords" content="sd-ca,2014,teme,teme-03"/>
<link rel="search" type="application/opensearchdescription+xml" href="../../../../../lib/exe/opensearch.php" title="CS Open CourseWare"/>
<link rel="start" href="../../../../../../courses.1.html"/>
<link rel="alternate" type="application/rss+xml" title="Recent Changes" href="../../../../../feed.php"/>
<link rel="alternate" type="application/rss+xml" title="Current Namespace" href="../../../../../feed.php%3Fmode=list&amp;ns=sd-ca:2014:teme"/>
<link rel="alternate" type="text/html" title="Plain HTML" href="teme-03.html"/>
<link rel="canonical" href="../../../../../sd-ca/2014/teme/teme-03.html"/>
<link rel="stylesheet" type="text/css" href="../../../../../lib/exe/css.php%3Ft=arctic&amp;tseed=1476798676.css"/>
<script type="text/javascript">/*<![CDATA[*/var NS='sd-ca:2014:teme';var JSINFO = {"id":"sd-ca:2014:teme:teme-03","namespace":"sd-ca:2014:teme","isadmin":0,"isauth":0};
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="../../../../../lib/exe/js.php%3Ftseed=1476798676"></script>
<script type="text/x-mathjax-config">/*<![CDATA[*/MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ["$","$"], ["\\(","\\)"] ],
        displayMath: [ ["$$","$$"], ["\\[","\\]"] ],
        processEscapes: true
    }
});
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
<script type="text/javascript">/*<![CDATA[*/
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
		  
/*!]]>*/</script>
<script type="text/javascript">/*<![CDATA[*/
var pageTracker = _gat._getTracker("UA-38383934-1");
pageTracker._initData();
pageTracker._trackPageview();
		  
/*!]]>*/</script>
</head>
<body>
<div class="dokuwiki export">
<!-- TOC START -->
<div id="dw__toc">
<h3 class="toggle">Table of Contents</h3>
<div>

<ul class="toc">
<li class="level1"><div class="li"><a href="teme-03.html#tema_3_-_biblioteca">Tema 3 - Biblioteca</a></div></li>
<li class="level1"><div class="li"><a href="teme-03.html#introducere">Introducere</a></div></li>
<li class="level1"><div class="li"><a href="teme-03.html#detalii_implementare">Detalii implementare</a></div>
<ul class="toc">
<li class="level2"><div class="li"><a href="teme-03.html#input">Input</a></div></li>
<li class="level2"><div class="li"><a href="teme-03.html#comanda_put">Comanda PUT</a></div></li>
<li class="level2"><div class="li"><a href="teme-03.html#comanda_get">Comanda GET</a></div></li>
<li class="level2"><div class="li"><a href="teme-03.html#comanda_play">Comanda PLAY</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="teme-03.html#observatii_generale_input">Observații generale INPUT</a></div></li>
<li class="level3"><div class="li"><a href="teme-03.html#observatii_generale_timpi">Observații generale timpi</a></div></li>
</ul>
</li>
<li class="level2"><div class="li"><a href="teme-03.html#hashtable">Hashtable</a></div></li>
<li class="level2"><div class="li"><a href="teme-03.html#schelet_de_cod">Schelet de Cod</a></div></li>
</ul>
</li>
<li class="level1"><div class="li"><a href="teme-03.html#exemple">Exemple</a></div></li>
<li class="level1"><div class="li"><a href="teme-03.html#bonus">Bonus</a></div>
<ul class="toc">
<li class="clear">
<ul class="toc">
<li class="level3"><div class="li"><a href="teme-03.html#cerinta_bonus">Cerinta bonus</a></div></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><div class="li"><a href="teme-03.html#trimitere_si_punctare">Trimitere și punctare</a></div></li>
<li class="level1"><div class="li"><a href="teme-03.html#checker">Checker</a></div></li>
<li class="level1"><div class="li"><a href="teme-03.html#link-uri_extra">Link-uri extra</a></div></li>
<li class="level1"><div class="li"><a href="teme-03.html#faq">FAQ</a></div></li>
</ul>
</div>
</div>
<!-- TOC END -->

<h1 class="sectionedit1" id="tema_3_-_biblioteca">Tema 3 - Biblioteca</h1>
<div class="level1">

<p>
Responsabili:
</p>
<ul>
<li class="level1"><div class="li"> <a href="mailto:&#x65;&#x6d;&#x69;&#x6c;&#x2e;&#x72;&#x61;&#x63;&#x65;&#x63;&#x40;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;" class="mail" title="&#x65;&#x6d;&#x69;&#x6c;&#x2e;&#x72;&#x61;&#x63;&#x65;&#x63;&#x40;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;">Emil Racec</a></div>
</li>
<li class="level1"><div class="li"> <a href="mailto:&#x70;&#x33;&#x31;&#x61;&#x6e;&#x64;&#x72;&#x65;&#x69;&#x40;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;" class="mail" title="&#x70;&#x33;&#x31;&#x61;&#x6e;&#x64;&#x72;&#x65;&#x69;&#x40;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;">Andrei Petre</a></div>
</li>
</ul>

<p>
<strong> Deadline soft: 28 aprilie, ora 23:55 </strong>
</p>

<p>
Depunctare întârziere după depășirea deadline-ului soft: <strong> -10p/zi </strong>
</p>

<p>
<strong> Deadline hard: 1 mai, ora 23:55 </strong>
</p>

<p>
<strong>Changelist:</strong>
</p>
<ul>
<li class="level1"><div class="li"> 09 aprilie, ora: 09:24 actualizare checker (in conformitate cu constrangerile cerintei)</div>
</li>
<li class="level1"><div class="li"> 14 aprilie, ora: 19:45 actualizare checker (adaugare bonus)</div>
</li>
</ul>

</div>
<!-- EDIT1 SECTION "Tema 3 - Biblioteca" [1-469] -->
<h1 class="sectionedit2" id="introducere">Introducere</h1>
<div class="level1">

<p>
Fiind aproape de terminarea anului I de facultate, dornici sa ne afirmam si sa ne testam cunostintele acumulate pana acum, acceptam sa participam intr-un proiect de modernizare a unei biblioteci.
</p>

<p>
In prima faza a proiectului, cea de documentare si intelegere a cerintelor clientului, aflam de la directorul institutiei urmatoarele:
</p>
<ol>
<li class="level1"><div class="li"> se doreste o metoda de indexare a fiecarei carti intr-un format electronic, astfel incat operatiile de gestiune a volumelor sa fie simple, rapide, moderne, sigure etc. (operatia <code>PUT</code>)</div>
</li>
<li class="level1"><div class="li"> majoritatea cautarilor in baza de date a bibliotecii nu se realizeaza dupa numele cartilor ci dupa continut astfel incat este nevoie de o metoda <strong>rapida</strong> de cautare, tinand cont de volumul mare de carti. Practic, date niste cuvinte cheie (ce se afla in continutul cartilor) trebuie sa se gaseasca numele cartilor ce le contin. (operatia <code>GET</code>)</div>
</li>
<li class="level1"><div class="li"> multi clienti organizeaza competitii unu-la-unu pe baza cartilor citite astfel: primul alege numele cartii, iar oponentul sau scrie o lista de cuvinte continute in acea carte. In cazul in care nu a gresit niciun cuvant (toate cuvintele mentionate se gasesc in carte), acesta acumuleaza un punctaj egal cu numarul de cuvinte scrise, si 0p altfel. Dupa un numar prestabilit de runde, se desemneaza castigatorul: persoana cu cele mai multe puncte acumulate! Deoarece partea de verificare a cuvintelor este foarte costisitoare manual, se doreste implementarea in aplicatia electronica si a acestei functionalitati. Formal, dat un nume de carte si o lista de cuvinte, sa se determine daca <strong>toate</strong> cuvintele se afla in acea carte. (operatia <code>PLAY</code>)</div>
</li>
</ol>

</div>
<!-- EDIT2 SECTION "Introducere" [470-2124] -->
<h1 class="sectionedit3" id="detalii_implementare">Detalii implementare</h1>
<div class="level1">

<p>
Dându-se ca input o serie de comenzi, fiecare comanda specifica aplicatiei: <code>PUT</code>, <code>GET</code> sau <code>PLAY</code>, se doreste generarea unui output cu raspunsurile corespunzatoare. Atat fomatele comenzilor cat si a raspunsurilor sunt detaliate in continuare.
</p>

</div>
<!-- EDIT3 SECTION "Detalii implementare" [2125-2412] -->
<h2 class="sectionedit4" id="input">Input</h2>
<div class="level2">

<p>
Input-ul constă dintr-o insiruire de comenzi, fiecare pe cate o linie. Citirea se realizeaza pana la intalnirea caracterului de sfarsit de fisier <code><abbr title="End of file">EOF</abbr></code>.
</p>
<pre class="code">comanda1
comanda2
...</pre>

<p>
Tipurile de comenzi (detaliate ulterior):
</p>
<ul>
<li class="level1"><div class="li"> PUT</div>
</li>
<li class="level1"><div class="li"> GET</div>
</li>
<li class="level1"><div class="li"> PLAY</div>
</li>
</ul>

</div>
<!-- EDIT4 SECTION "Input" [2413-2693] -->
<h2 class="sectionedit5" id="comanda_put">Comanda PUT</h2>
<div class="level2">

<p>
Sintaxa comenzii PUT este:
</p>
<pre class="code">      PUT titlu_carte  cuv1 cuv2 .. cuvN</pre>

<p>
Rolul acestei comenzi este de a indexa conținutul cărții <code>titlu_carte</code> si anume: <code>cuv1 cuv2 .. cuvN</code>, astfel încât la orice căutare ulterioara de cuvinte apartinand cartii, aceasta să fie printre rezultatele găsite.
</p>

<p>
Această comandă se poate reprezenta în două moduri:
</p>
<ul>
<li class="level1"><div class="li"> Într-un hashtable, se rețin asocieri de tipul <strong>titlu_carte - lista de cuvinte.</strong> Astfel cheia intrării în hashtable este <code>titlu_carte</code> și valoarea: lista de cuvinte: <code>cuv1 cuv2 .. cuvN</code>. Există o serie de avantaje și dezavantaje pentru această abordare:</div>
<ul>
<li class="level2"><div class="li"> operația de PUT este mult ușurată, întrucât nu se fac deloc prelucrări asupra conținutului.</div>
</li>
<li class="level2"><div class="li"> operația de GET în cadrul acestei structuri este mult îngreunată, întrucât se caută cuvinte și nu cărți (ar trebui ca pentru fiecare carte în parte, să căutăm dacă are în lista de cuvinte (valoarea cheii) cuvântul căutat).</div>
</li>
<li class="level2"><div class="li"> (Remember: proprietatea de bază a unui hashtable este că operația de căutare se efectuează în O(1) complexitate)</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> <a href="http://en.wikipedia.org/wiki/Inverted_index#Example" class="urlextern" title="http://en.wikipedia.org/wiki/Inverted_index#Example"  rel="nofollow">Inverted index</a>.  Tot într-un hashtable, se rețin asocieri de tipul <strong>cuvânt - lista de cărți</strong>. Astfel cheia intrării în hashtable este <em>cuvântul</em> și valoarea <em>lista de titluri de cărți ce conțin acel cuvânt</em>. În acest fel, căutarea unui cuvânt este efectuată mult mai ușor, întrucât hashtable-ul este indexat după cuvinte.</div>
</li>
</ul>

<p>
În tema voastră, va trebui să implementați cea de-a doua tehnică de reținere a informațiilor, cea în care într-un hashtable se rețin asocieri de tipul <strong>cuvânt - listă de carti</strong>.
</p>

<p>
Astfel dacă se dau la input următoarele 3 comenzi:
</p>
<pre class="code">PUT titlu_carte1 cand rasare soarele
PUT titlu_carte2 afara este soarele
PUT titlu_carte3 cand mergem afara</pre>

<p>
Hashtable-ul după aceste 3 comenzi va arăta în felul următor:
</p>
<ul>
<li class="level1"><div class="li"> afara → {titlu_carte2, titlu_carte3}</div>
</li>
<li class="level1"><div class="li"> cand → {titlu_carte1, titlu_carte3}</div>
</li>
<li class="level1"><div class="li"> este → {titlu_carte2}</div>
</li>
<li class="level1"><div class="li"> mergem → {titlu_carte3}</div>
</li>
<li class="level1"><div class="li"> rasare → {titlu_carte1}</div>
</li>
<li class="level1"><div class="li"> soarele → {titlu_carte1, titlu_carte2}</div>
</li>
</ul>

<p>
Observații comandă PUT:
</p>
<ul>
<li class="level1"><div class="li"> Două comenzi PUT pentru același titlu de carte se consideră adăugări de conținut și nu ștergere sau înlocuire de conținut. </div>
</li>
<li class="level1"><div class="li"> Un cuvânt poate apărea de mai multe ori în cadrul unei cărți, insa nu e nevoie sa retineti de cate ori apare.</div>
</li>
</ul>

</div>
<!-- EDIT5 SECTION "Comanda PUT" [2694-5168] -->
<h2 class="sectionedit6" id="comanda_get">Comanda GET</h2>
<div class="level2">

<p>
Sintaxa comenzii GET este:
</p>
<pre class="code">    GET cuv1_interogare cuv2_interogare .. cuvN_interogare</pre>

<p>
Această comandă va întoarce toate cărțile în care apar <em>toți</em> termenii interogării. De exemplu, pentru următoarele interogări:
</p>
<ul>
<li class="level1"><div class="li"> <code>GET cand</code></div>
<ul>
<li class="level3"><div class="li"> Rezultatul va fi {titlu_carte1, titlu_carte3}</div>
</li>
<li class="level3"><div class="li"> Cuvântul „cand” apare în cartea 1 si in cartea 3.</div>
</li>
<li class="level3"><div class="li"> Cele două cărți sunt afișate în ordine alfabetică.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> <code>GET cand rasare</code></div>
<ul>
<li class="level3"><div class="li"> Rezultatul va fi  {titlu_carte1, titlu_carte3} SI {titlu_carte1} = {titlu_carte1}</div>
</li>
<li class="level3"><div class="li"> SI - intersectie de mulțimi</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> <code>GET cenusareasa</code></div>
<ul>
<li class="level3"><div class="li"> Rezultatul va fi BOOK_NOT_FOUND (Nu există nicio carte indexată care să conțină cuvântul cenusareasa)</div>
</li>
</ul>
</li>
</ul>

<p>
Observații comandă GET:
</p>
<ul>
<li class="level1"><div class="li"> Numele cărților întoarse vor fi afișate în <strong>ordine alfabetică</strong></div>
</li>
<li class="level1"><div class="li"> Dacă nu există nicio carte care să conțină toți termenii interogării, atunci se va afișa <strong>BOOK_NOT_FOUND</strong></div>
</li>
</ul>

<p>
<p><div class="noteimportant">Intrucât va trebui să afisați toate cărțile care conțin toți termenii interogării, va trebui să găsiți o metodă de intersecție rapidă (eficienta).
</div></p>
</p>

</div>
<!-- EDIT6 SECTION "Comanda GET" [5169-6327] -->
<h2 class="sectionedit7" id="comanda_play">Comanda PLAY</h2>
<div class="level2">

<p>
Sintaxa comenzii PLAY este: 
</p>
<pre class="code">   PLAY titlu_carte cuv1_concurent cuv2_concurent .. cuvN_concurent
   </pre>

<p>
Această comandă verifică dacă <strong>toți termenii</strong> din interogarea: <code>cuv1_concurent cuv2_concurent .. cuvN_concurent</code> există în cartea <code>titlu_carte</code>.  Dacă toți termenii există în carte, atunci se va afișa YOU_WIN, iar dacă nu, se va afișa YOU_LOSE.
</p>

<p>
Exemplu:
INPUT:
</p>
<pre class="code">PLAY titlu_carte1 soarele cand
PLAY titlu_carte3 mergem bal</pre>

<p>
OUTPUT:
</p>
<pre class="code">YOU_WIN
YOU_LOSE</pre>

</div>
<!-- EDIT7 SECTION "Comanda PLAY" [6328-6856] -->
<h3 class="sectionedit8" id="observatii_generale_input">Observații generale INPUT</h3>
<div class="level3">
<ul>
<li class="level1"><div class="li"> Delimitatorul între cuvintele din conținutul cărților sau din interogare este doar caracterul spațiu.</div>
</li>
<li class="level1"><div class="li"> Aveti la dispozitie un schelet de cod care să realizeze parsarea unei comenzi intr-un vector de string-uri.</div>
</li>
<li class="level1"><div class="li"> Fiecare comandă se află pe o linie. </div>
</li>
<li class="level1"><div class="li"> Nu există un număr maxim de comenzi și nici nu există un număr maxim de caractere pe o linie.</div>
</li>
<li class="level1"><div class="li"> Se garantează ca numele cartilor sau al comenzilor de interogare nu va contine spatii.</div>
</li>
<li class="level1"><div class="li"> Comenzile se termina cu caracterul terminator de linie(<code>\n</code>), care se garantează ca nu apare în conținutul cărților sau în interogări.</div>
</li>
<li class="level1"><div class="li"> Output-ul comenzilor GET și PLAY este influențat doar de comenzile PUT de până atunci. Așadar nu va trebui să rețineți comenzile date, ci doar să le procesați imediat.</div>
</li>
<li class="level1"><div class="li"> Output-ul comenzilor GET și PLAY trebuie scris la stdout, în ordinea citirii comenzilor GET și PLAY din input.</div>
</li>
<li class="level1"><div class="li"> Comanda PUT nu are output. Ca urmare, in urma unei comenzi PUT voi trebuie doar sa actualizati corespunzator structura de date, fara sa afisati nimic.</div>
</li>
</ul>

</div>
<!-- EDIT8 SECTION "Observații generale INPUT" [6857-7960] -->
<h3 class="sectionedit9" id="observatii_generale_timpi">Observații generale timpi</h3>
<div class="level3">
<ul>
<li class="level1"><div class="li"> Fiecare test are asociat un timeout, calculat in functie de dimensiunea lui. Este interzisa folosirea oricaror optimizari de compilator (exemplu: <code>-O2</code>, <code>-O3</code>, etc.) pentru incadrarea in timpul limita.</div>
</li>
<li class="level1"><div class="li"> Acesti timpi sunt specifici rularii temei pe vmchecker si nu rularii temei local, unde este posibil sa obtineti timpi diferiti (mai buni). Timpul de rulare/test considerat va fi numai cel de pe vmchecker.</div>
</li>
</ul>

</div>
<!-- EDIT9 SECTION "Observații generale timpi" [7961-8417] -->
<h2 class="sectionedit10" id="hashtable">Hashtable</h2>
<div class="level2">

<p>
Pentru implementarea eventualelor structuri de date de tip hashtable din temă, puteți pleca de la implementarea din <a href="../../../../../sd-ca/laboratoare/laborator-06.html" class="urlextern" title="http://ocw.cs.pub.ro/courses/sd-ca/laboratoare/laborator-06"  rel="nofollow">Laboratorul 6</a>, bazată pe vector de liste înlănțuite. 
Evident, elementele din dictionar sunt de tipul (cheie, valoare). In cazul temei, valoare va fi reprezentat sub forma unui vector <code>std::vector&lt;std::string&gt;</code> in care veti mentine lista cartilor in care se gaseste cuvantul din cheie. Pentru a optimiza cautarea in acest vector va trebui sa <strong>mentineti acest vector sortat lexicografic</strong> si sa <strong>optimizati cautarea in vector folosind un algoritm specific acestei proprietati (de sortare)</strong>.
</p>

<p>
Pentru a putea efectua tema, trebuie să  țineți cont de următoarele observații:
</p>
<ul>
<li class="level1"><div class="li"> Operația de GET dintr-un hashtable trebuie să poată fi efectuată în timp constant și să nu fie influențată de numărul de intrări în hashtable. Din acest motiv, dacă implementați hashtable-ul ca un vector, așa cum este în laboratorul de hash-uri, trebuie să tineți cont de raportul între câte intrări sunt în hashtable și capacitatea lui.</div>
<ul>
<li class="level3"><div class="li"> Dacă acest raport, numit <strong>factor de încărcare</strong>, depășeste o valoare predefinită (se recomandă ca această valoare să fie 0.7), atunci va trebui să redimensionați vectorul și bineînțeles va trebui să introduceți vechile intrări în noul vector.</div>
</li>
<li class="level3"><div class="li"> Pentru vectorul inițial din hashtable, puteți considera o capacitate predefinită de intrări, de exemplu 16, urmând ca la fiecare redimensionare să dublați capacitatea vectorului.</div>
</li>
<li class="level3"><div class="li"> Va trebui să gasiți o metodă prin care două liste de cărți se intersectează foarte rapid.</div>
</li>
<li class="level3"><div class="li"> Întrucât se lucrează doar cu string-uri puteți folosi funcția de hash din laboratorul 6.</div>
</li>
</ul>
</li>
</ul>

<p>
 <p><div class="noteimportant"> In cadrul temei este <strong>obligatorie</strong> setarea dimensiunii initiale a dictionarului la valoarea <code>16</code> si setarea factorului de incarcare la valoarea <code>0.7</code>, pentru ca toate implementarile voastre sa faca acelasi numar de redimensionari.
</div></p>
</p>

<p>
Următorul exemplu vă va ajuta să înțelegeți cum se redimensionează un hashtable:
</p>

<p>
Înainte: 
</p>

<p>
<a href="../../../../../_detail/sd-ca/teme/hash1.jpg%3Fid=sd-ca%253A2014%253Ateme%253Ateme-03.html" class="media" title="sd-ca:teme:hash1.jpg"><img src="../../../../../_media/sd-ca/teme/hash1.jpg%3Fw=300&amp;tok=9db3aa" class="media" alt="" width="300" /></a>
</p>

<p>
După redimensionare: 
</p>

<p>
<a href="../../../../../_detail/sd-ca/teme/hash2.jpg%3Fid=sd-ca%253A2014%253Ateme%253Ateme-03.html" class="media" title="sd-ca:teme:hash2.jpg"><img src="../../../../../_media/sd-ca/teme/hash2.jpg%3Fw=300&amp;tok=d4950e" class="media" alt="" width="300" /></a>
</p>

<p>
Explicații:
</p>
<ul>
<li class="level1"><div class="li"> Cele două poze indică același hashtable, odată înainte de redimensionare, având capacitatea de 10 și apoi după redimensionare, având capacitatea de 20.</div>
</li>
<li class="level1"><div class="li"> În cele două poze sunt arătate doar pozițiile din vector care conțin o listă nevidă de elemente. </div>
</li>
<li class="level1"><div class="li"> În poze, numele țărilor indică cheia din hashtable, iar valorile (listele de carti care conțin aceste cuvinte) nu au fost afișate</div>
</li>
<li class="level1"><div class="li"> Între paranteze, pentru fiecare țară este arătat valoarea hash-ului calculat cu funcția din laborator (<em>hash(“romania”)==1443285676</em>)</div>
</li>
<li class="level1"><div class="li"> Poziția din vector în care s-a inserat o cheie este indicele <strong>hash(cuvânt)%capacitate</strong></div>
</li>
<li class="level1"><div class="li"> În prima situație, în hashtable sunt deja 7 elemente (70% din capacitatea hashtable-ului este ocupată) și se inserează o nouă cheie (“romania”).</div>
</li>
<li class="level1"><div class="li"> În acest caz, întrucât factorul de încărcare depășeste 70%, trebuie ca hashtable-ul să fie redimensionat, iar cheile remapate la noii indecși. </div>
</li>
<li class="level1"><div class="li"> Astfel cheia “america” a fost mutată în elementul 15 din vector, întrucât <em>hash(“america”)%20==15</em> samd. </div>
</li>
<li class="level1"><div class="li"> Cheia “romania” a fost inserată pe poziția 16. </div>
</li>
</ul>

</div>
<!-- EDIT10 SECTION "Hashtable" [8418-11858] -->
<h2 class="sectionedit11" id="schelet_de_cod">Schelet de Cod</h2>
<div class="level2">

<p>
Aveti la dispoziție un schelet de cod, care realizează citirea și parsarea comenzilor. Acesta va scuteste de efortul de a implementa partea nefunctionla a temei.
Scheletul de cod se gaseste aici: <a href="../../../../../_media/sd-ca/teme/schelet_cod_tema3_2014.zip" class="media mediafile mf_zip" title="sd-ca:teme:schelet_cod_tema3_2014.zip (2.6 KB)">3-biblioteca_schelet</a>
</p>

<p>
<p><div class="noteclassic">Nu este obligatorie folosirea acestui schelet de cod.
</div></p>
</p>

</div>
<!-- EDIT11 SECTION "Schelet de Cod" [11859-12219] -->
<h1 class="sectionedit12" id="exemple">Exemple</h1>
<div class="level1">
<div class="table sectionedit13"><table class="inline">
	<tr class="row0">
		<th class="col0 leftalign"> Input                          </th><th class="col1 leftalign"> Output                  </th>
	</tr>
	<tr class="row1">
		<td class="col0 leftalign"> PUT titlu_carte1 cand rasare soarele    </td><td class="col1 leftalign">                            </td>
	</tr>
	<tr class="row2">
		<td class="col0 leftalign"> PUT titlu_carte3 cand mergem            </td><td class="col1 leftalign">                            </td>
	</tr>
	<tr class="row3">
		<td class="col0 leftalign"> GET mergem                              </td><td class="col1 centeralign">  titlu_carte3              </td>
	</tr>
	<tr class="row4">
		<td class="col0 leftalign"> PLAY titlu_carte1 cand rasare           </td><td class="col1 centeralign">  YOU_WIN                   </td>
	</tr>
	<tr class="row5">
		<td class="col0 leftalign"> PLAY titlu_carte1 ana are               </td><td class="col1 centeralign">  YOU_LOSE                  </td>
	</tr>
	<tr class="row6">
		<td class="col0 leftalign"> PLAY titlu_carte3 mergem                </td><td class="col1 centeralign">  YOU_WIN                   </td>
	</tr>
	<tr class="row7">
		<td class="col0 leftalign"> PUT titlu_carte3 afara soarele          </td><td class="col1 leftalign">                            </td>
	</tr>
	<tr class="row8">
		<td class="col0 leftalign"> GET cand soarele                        </td><td class="col1 rightalign">  titlu_carte1 titlu_carte3 </td>
	</tr>
	<tr class="row9">
		<td class="col0 leftalign"> PUT titlu_carte2 afara este soarele     </td><td class="col1 leftalign">                            </td>
	</tr>
	<tr class="row10">
		<td class="col0 leftalign"> GET afara                               </td><td class="col1 rightalign">  titlu_carte2 titlu_carte3 </td>
	</tr>
	<tr class="row11">
		<td class="col0 leftalign"> GET afara                               </td><td class="col1 rightalign">  titlu_carte2 titlu_carte3 </td>
	</tr>
	<tr class="row12">
		<td class="col0 leftalign"> GET cand mergem                         </td><td class="col1 centeralign">  titlu_carte3              </td>
	</tr>
	<tr class="row13">
		<td class="col0 leftalign"> GET temaSD                              </td><td class="col1 centeralign">  BOOK_NOT_FOUND            </td>
	</tr>
</table></div>
<!-- EDIT13 TABLE [12243-13252] -->
<p>
<p><div class="noteimportant">Așa cum observați, pentru claritate răspunsul comenzilor GET/PLAY a fost pus pe rândul corespunzător din tabel, lăsând câte o linie goală pentru fiecare comandă PUT, dar voi <strong>NU</strong> trebuie să lăsați nicio linie goală. Pentru mai multe detalii, consultați checkerul disponibil.
</div></p>
</p>

<p>
<p><div class="noteimportant">Așa cum am amintit și în secțiunea corespunzătoare comenzii GET, cărțile sunt afișate în ordine alfabetică.
</div></p>
</p>

</div>
<!-- EDIT12 SECTION "Exemple" [12220-13712] -->
<h1 class="sectionedit14" id="bonus">Bonus</h1>
<div class="level1">

<p>
Bucurosi ca am finalizat cu succes cea de-a doua faza a proiectului, anume implementarea corecta a bibliotecii virtuale, dorim sa aflam cum functioneaza aplicatia, “in mediul real”. Contactandu-l pe director, acesta ne spune ca lucrurile stau mult mai bine acum: gestiunea cartilor este mult usurata, clientii s-au obisnuit cu folosirea aplicatiei si a crescut numarul de competitii datorita simplificarii verificarilor. Insa, exista si o mica problema recenta, neprevazuta la inceputul proiectului: din cauza numarului mare de carti, si a numarului mare de interogari: GET/PLAY, aplicatia este destul de lenta. Deoarece momentan nu exista fonduri suficiente pentru achizitionarea unor echipamente hardware dedicate si nici de upgrade-uri la cele existente, acesta ne propune o prima pentru optimizarea (software) a aplicatiei. 
</p>

</div>
<!-- EDIT14 SECTION "Bonus" [13713-14563] -->
<h3 class="sectionedit15" id="cerinta_bonus">Cerinta bonus</h3>
<div class="level3">

<p>
Optimizati aplicatia din punct de vedere a timpului de rulare, <strong>pastrand implemetarea si algoritmul folosit in tema</strong>, astfel incat sa respecte timeout-urile noi (setate in checker, la sectiunea bonus).
Pentru indeplinirea cerintei, este obligatoriu sa pastrati algoritmul si structura descrisa in cerinta temei. Scopul bonusului este scrierea corecta si eficienta a codului. Cateva sfaturi in acest sens ar fi:
</p>
<ul>
<li class="level1"><div class="li"> atentie la copieri inutile:</div>
<ul>
<li class="level2"><div class="li"> atunci cand trasmiteti parametrii: transmiteti parametrii prin referinta acolo unde este posibil</div>
</li>
<li class="level2"><div class="li"> copieri de structuri de date. Atentie cand lucrati cu structuri de date in C++. Spre deosebire de C, unde o copiere de structura rezulta, in general, in copieri de adrese (de poiteri), in C++ marea majoritate a structurilor implementeaza operatorul de copiere pentru o copiere totala a structurii. Exemplu:</div>
</li>
</ul>
</li>
</ul>
<pre class="code">std::vector&lt;T&gt; a, b;
//fill a with many elements
b = a; //realizeaza o copiere (duplicare a tuturor elementelor din a)</pre>
<ul>
<li class="level1"><div class="li"> eliminati flag-ul &#039;-g&#039; din Makefile. Acest flag realizeaza imbogatirea executabilului cu informatii de debugging, foarte utile in acest sens, dar care aduc un impact negativ asupra performantei.</div>
</li>
<li class="level1"><div class="li"> in general, lucrati ingrijit: modularizati codul, <strong>considerati mebrii claselor private si folositi metode pentru interactiunea cu clasele</strong>, organizati clasele pe diverse nivele logice/de abstractizare. Intr-adevar, asta nu va creste performata, dar va va face sa vedeti mai usor eventuale bug-uri in implementare si actiuni care se puteau realiza mai eficient.</div>
</li>
<li class="level1"><div class="li"> pentru clasa vector: in momentul in care folosim structura vector implementata in C++, este bine sa folositi functia <code>reserve(size_type n)</code>, ce aloca in prealabil <code>n</code> elemente, atunci cand capacitatea finala (sau minima) a vectorului este cunoscuta. De obicei se foloseste impreuna cu functia push_back(T&amp; el). Un exemplu de folosire este:</div>
</li>
</ul>
<pre class="code">std::vector&lt;int&gt; intVect;
for (int i = 0; i &lt; 10000; ++i)
    intVect.push_back(i);
// In acest caz, in vector se aloca un element nou, pentru fiecare apel push_back. 
// Apelul de alocare este unul costisitor.
// Chiar mai ineficient este cazul cand, din lipsa posibilitatii alocarii
// unui element nou in continuarea elementelor vectorului, se copiaza toate elementele
// intr-un spatiu continuu suficient de mare. Acest proces poate sa apara, in cel mai
// defavorabil caz, la fiecare alocare.

    
// Solutie:
std::vector&lt;int&gt; intVect;
intVect.reserve(10000);
for (int i = 0; i &lt; 10000; ++i)
    intVect.push_back(i);
// In acest caz se va face o alocare de 10000 elemente o singura data (la inceput)
// dupa care nu va mai fi nevoie de nicio realocare.</pre>

</div>
<!-- EDIT15 SECTION "Cerinta bonus" [14564-17275] -->
<h1 class="sectionedit16" id="trimitere_si_punctare">Trimitere și punctare</h1>
<div class="level1">

<p>
Temele vor trebui trimise pe <a href="https://elf.cs.pub.ro/vmchecker/ui/#SD" class="urlextern" title="https://elf.cs.pub.ro/vmchecker/ui/#SD"  rel="nofollow">vmchecker</a>. 
<strong>Atenție!</strong> Temele trebuie trimise în secțiunea <strong>Structuri de Date (CA)</strong>.
</p>

<p>
Arhiva trebuie să conțină:
</p>
<ul>
<li class="level1"><div class="li"> surse</div>
</li>
<li class="level1"><div class="li"> fișier Makefile cu două reguli:</div>
<ul>
<li class="level2"><div class="li"> regula <strong>build</strong>: în urma căreia se generează un executabil numit <strong>tema3</strong></div>
</li>
<li class="level2"><div class="li"> regula <strong>clean</strong> care şterge executabilul</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> fisier <strong>README</strong> care să conțină detalii despre implementarea temei</div>
</li>
</ul>

<p>
Punctare:
</p>
<ul>
<li class="level1"><div class="li"> 90 puncte obținute pe testele principale de pe vmchecker</div>
<ul>
<li class="level3"><div class="li"> Test1: Test SIMPLE GET</div>
</li>
<li class="level3"><div class="li"> Test2: Test SIMPLE GET/PLAY</div>
</li>
<li class="level3"><div class="li"> Test3: Test MEDIUM GET/PLAY</div>
</li>
<li class="level3"><div class="li"> Test4: Test MEDIUM GET/PLAY</div>
</li>
<li class="level3"><div class="li"> Test5: Test HARD GET/PLAY</div>
</li>
<li class="level3"><div class="li"> Test6: Test HARD GET/PLAY</div>
</li>
<li class="level3"><div class="li"> Test7: Test HARD GET/PLAY</div>
</li>
<li class="level3"><div class="li"> Test8: Test VERY HARD GET/PLAY</div>
</li>
<li class="level3"><div class="li"> Test9: Test Valgrind, verifică dacă eliberați toată memoria</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> 10 puncte: coding style și README</div>
</li>
<li class="level1"><div class="li"> 10 puncte obținute pe testele bonus de pe vmchecker</div>
<ul>
<li class="level3"><div class="li"> 2p: Test5, cu un alt TIMEOUT</div>
</li>
<li class="level3"><div class="li"> 2p: Test6, cu un alt TIMEOUT</div>
</li>
<li class="level3"><div class="li"> 2p: Test7, cu un alt TIMEOUT</div>
</li>
<li class="level3"><div class="li"> 2p: Test8, cu un alt TIMEOUT</div>
</li>
<li class="level3"><div class="li"> 2p: Test9, cu un alt TIMEOUT</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> TOTAL: 110 puncte</div>
</li>
</ul>

<p>
<p><div class="noteimportant">
Timpul de rulare/test: Există un timp de rulare specific pentru fiecare test, astfel încât să fie verificat că implementați bine operațiile hashtable si ca respectati optimizarile precizate in cerinta. Acesti timpi sunt specifici <strong>rularii temei pe vmchecker</strong> si <strong>nu rularii temei local</strong>, unde este posibil sa obtineti timpi diferiti (mai buni). Timpul de rulare/test considerat va fi numai cel de pe vmchecker.

</div></p>
</p>

<p>
Pentru alte detalii legate de punctare citiți <a href="../../../../../sd-ca/regulament.html#reguli_de_trimitere_a_temelor" class="urlextern" title="http://ocw.cs.pub.ro/courses/sd-ca/regulament#reguli_de_trimitere_a_temelor"  rel="nofollow">Regulamentul General de Trimitere a Temelor</a>.
</p>

</div>
<!-- EDIT16 SECTION "Trimitere și punctare" [17276-19114] -->
<h1 class="sectionedit17" id="checker">Checker</h1>
<div class="level1">

<p>
Puteți descărca checker-ul, cu testele publice aferente, de aici: <a href="../../../../../_media/sd-ca/teme/3-biblioteca_checker_v2.zip" class="media mediafile mf_zip" title="sd-ca:teme:3-biblioteca_checker_v2.zip (4.4 MB)">3-biblioteca_checker_v2</a>
</p>

</div>
<!-- EDIT17 SECTION "Checker" [19115-19274] -->
<h1 class="sectionedit18" id="link-uri_extra">Link-uri extra</h1>
<div class="level1">

<p>
* <a href="http://www.quora.com/Algorithms/What-is-the-search-algorithm-used-by-the-Google-search-engine-What-is-its-complexity" class="urlextern" title="http://www.quora.com/Algorithms/What-is-the-search-algorithm-used-by-the-Google-search-engine-What-is-its-complexity"  rel="nofollow">Un post scurt despre interted index @google + video</a>
</p>
<ul>
<li class="level1"><div class="li"> este mai complex decat inverted index, dar poate il veti gasi interesant</div>
</li>
</ul>

</div>
<!-- EDIT18 SECTION "Link-uri extra" [19275-19558] -->
<h1 class="sectionedit19" id="faq">FAQ</h1>
<div class="level1">

<p>
<strong>Q:</strong> Se poate folosi STL?
</p>

<p>
<strong>R:</strong> Puteți folosi clasele <strong>std::vector</strong>, <strong>std::list</strong> și <strong>std::string</strong> pentru a reține cuvintele, titlurile cartilor etc. De asemenea, in general este recomandat sa folositi iteratorii nativi structurii, precum <code>std::vector&lt;T&gt;::iterator</code> in C++, acestia fiind mai eficienti in parcurgerea structurilor (iterabile). Vedeti exemple de utilizare in scheletul de cod.
</p>

</div>
<!-- EDIT19 SECTION "FAQ" [19559-] --></div>
</body>
</html>
