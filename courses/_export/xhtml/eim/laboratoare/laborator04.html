    
    

<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
  <meta charset="utf-8" />
  <title>eim:laboratoare:laborator04</title>
<meta name="generator" content="DokuWiki"/>
<meta name="robots" content="index,follow"/>
<meta name="date" content="2016-10-13T15:10:40+0300"/>
<meta name="keywords" content="eim,laboratoare,laborator04"/>
<link rel="search" type="application/opensearchdescription+xml" href="../../../../lib/exe/opensearch.php" title="CS Open CourseWare"/>
<link rel="start" href="../../../../../courses.1.html"/>
<link rel="alternate" type="application/rss+xml" title="Recent Changes" href="../../../../feed.php"/>
<link rel="alternate" type="application/rss+xml" title="Current Namespace" href="../../../../feed.php%3Fmode=list&amp;ns=eim:laboratoare"/>
<link rel="alternate" type="text/html" title="Plain HTML" href="laborator04.html"/>
<link rel="canonical" href="../../../../eim/laboratoare/laborator04.html"/>
<link rel="stylesheet" type="text/css" href="../../../../lib/exe/css.php%3Ft=arctic&amp;tseed=1479898000.css"/>
<script type="text/javascript">/*<![CDATA[*/var NS='eim:laboratoare';var JSINFO = {"id":"eim:laboratoare:laborator04","namespace":"eim:laboratoare","isadmin":0,"isauth":0};
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="../../../../lib/exe/js.php%3Ftseed=1479898000"></script>
<script type="text/x-mathjax-config">/*<![CDATA[*/MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ["$","$"], ["\\(","\\)"] ],
        displayMath: [ ["$$","$$"], ["\\[","\\]"] ],
        processEscapes: true
    }
});
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
<script type="text/javascript">/*<![CDATA[*/
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
		  
/*!]]>*/</script>
<script type="text/javascript">/*<![CDATA[*/
var pageTracker = _gat._getTracker("UA-38383934-1");
pageTracker._initData();
pageTracker._trackPageview();
		  
/*!]]>*/</script>
</head>
<body>
<div class="dokuwiki export">
<!-- TOC START -->
<div id="dw__toc">
<h3 class="toggle">Table of Contents</h3>
<div>

<ul class="toc">
<li class="level1"><div class="li"><a href="laborator04.html#laborator_04_structura_unei_aplicatii_ii">Laborator 04. Structura unei Aplicații (II)</a></div>
<ul class="toc">
<li class="level2"><div class="li"><a href="laborator04.html#intentii_obligatoriu">Intenții (obligatoriu)</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="laborator04.html#structura_unei_intentii">Structura unei Intenții</a></div></li>
<li class="level3"><div class="li"><a href="laborator04.html#controlul_fluxului_de_activitati_prin_intentii">Controlul fluxului de activități prin intenții</a></div>
<ul class="toc">
<li class="level4"><div class="li"><a href="laborator04.html#intentii_construite_prin_precizarea_clasei_incarcate">Intenții construite prin precizarea clasei încărcate</a></div></li>
<li class="level4"><div class="li"><a href="laborator04.html#intentii_construite_prin_precizarea_actiunii">Intenții construite prin precizarea acțiunii</a></div></li>
<li class="level4"><div class="li"><a href="laborator04.html#intentii_construite_prin_intermediul_unui_uri">Intenții construite prin intermediul unui URI</a></div></li>
</ul>
</li>
<li class="level3"><div class="li"><a href="laborator04.html#transmiterea_de_informatii_intre_componente_prin_intermediul_intentiilor">Transmiterea de informații între componente prin intermediul intențiilor</a></div></li>
<li class="level3"><div class="li"><a href="laborator04.html#gestiunea_evenimentelor_cu_difuzare_prin_intermediul_intentiilor">Gestiunea evenimentelor cu difuzare prin intermediul intențiilor</a></div>
<ul class="toc">
<li class="level4"><div class="li"><a href="laborator04.html#trimiterea_unei_intentii_cu_difuzare">Trimiterea unei intenții cu difuzare</a></div></li>
<li class="level4"><div class="li"><a href="laborator04.html#primirea_unui_intentii_cu_difuzare">Primirea unui intenții cu difuzare</a></div></li>
<li class="level4"><div class="li"><a href="laborator04.html#tipuri_particulare_de_intentii_cu_difuzare">Tipuri particulare de intenții cu difuzare</a></div></li>
<li class="level4"><div class="li"><a href="laborator04.html#gestiunea_intentiilor_cu_difuzare_native">Gestiunea intențiilor cu difuzare native</a></div></li>
</ul>
</li>
</ul>
</li>
<li class="level2"><div class="li"><a href="laborator04.html#fragmente_optional">Fragmente (opțional)</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="laborator04.html#componentele_unui_fragment">Componentele unui Fragment</a></div></li>
<li class="level3"><div class="li"><a href="laborator04.html#ciclul_de_viata_al_unui_fragment">Ciclul de Viață al unui Fragment</a></div></li>
<li class="level3"><div class="li"><a href="laborator04.html#gestiunea_fragmentelor_din_cadrul_unei_activitati">Gestiunea Fragmentelor din cadrul unei Activități</a></div>
<ul class="toc">
<li class="level4"><div class="li"><a href="laborator04.html#adaugarea_unui_fragment">Adăugarea unui Fragment</a></div></li>
<li class="level4"><div class="li"><a href="laborator04.html#scoaterea_unui_fragment">Scoaterea unui Fragment</a></div></li>
<li class="level4"><div class="li"><a href="laborator04.html#inlocuirea_unui_fragment">Înlocuirea unui Fragment</a></div></li>
<li class="level4"><div class="li"><a href="laborator04.html#utilizarea_stivei_de_fragmente">Utilizarea Stivei de Fragmente</a></div></li>
<li class="level4"><div class="li"><a href="laborator04.html#folosirea_de_animatii_la_tranzitia_dintre_fragmente">Folosirea de Animații la Tranziția dintre Fragmente</a></div></li>
</ul>
</li>
<li class="level3"><div class="li"><a href="laborator04.html#interactiunea_dintre_fragmente">Interacțiunea dintre fragmente</a></div></li>
</ul>
</li>
<li class="level2"><div class="li"><a href="laborator04.html#activitate_de_laborator">Activitate de Laborator</a></div></li>
<li class="level2"><div class="li"><a href="laborator04.html#resurse_utile">Resurse Utile</a></div></li>
</ul></li>
</ul>
</div>
</div>
<!-- TOC END -->

<h1 class="sectionedit1" id="laborator_04_structura_unei_aplicatii_ii">Laborator 04. Structura unei Aplicații (II)</h1>
<div class="level1">

</div>
<!-- EDIT1 SECTION "Laborator 04. Structura unei Aplicații (II)" [1-60] -->
<h2 class="sectionedit2" id="intentii_obligatoriu">Intenții (obligatoriu)</h2>
<div class="level2">

<p>
Conceptul de intenție în Android este destul de complex (și unic), putând fi definit ca o acțiune având asociată o serie de informații, transmisă sistemului de operare Android pentru a fi executată sub forma unui mesaj asincron. În acest fel, intenția asigură interacțiunea între toate aplicațiile instalate pe dispozitivul mobil, chiar dacă fiecare în parte are o existență autonomă. Din această perspectivă, sistemul de operare Android poate fi privit ca o colecție de componente funcționale, independente și interconectate.
</p>

<p>
De regulă, o intenție poate fi utilizată pentru:
</p>
<ul>
<li class="level1"><div class="li"> a invoca activități din cadrul aceleiași aplicații Android;</div>
</li>
<li class="level1"><div class="li"> a invoca alte activități, existente în contextul altor aplicații Android;</div>
</li>
<li class="level1"><div class="li"> a transmite mesaje cu difuzare (<em>eng.</em> broadcast messages), care sunt propagate la nivelul întregului sistem de operare Android și pe care unele aplicații Android le pot prelucra, prin definirea unor clase ascultător specifice; un astfel de comportament este util pentru a implementa aplicații bazate pe evenimente.</div>
</li>
</ul>

<p>
<p><div class="notetip">În sistemul de operare Android, evenimente de tipul primirea unui apel telefonic / mesaj, modificarea nivelului de încărcare al bateriei, schimbarea stării legate de conectivitatea la Internet sunt transmise prin intermediul unor intenții prelucrate de aplicațiile specifice. Un utilizator poate înlocui astfel aplicațiile native cu propriile sale aplicații pentru a realiza operațiile specifice acestor tipuri de evenimente.
</div></p>
</p>

<p>
O intenție reprezintă o instanță a clasei <code>android.content.Intent</code>. Aceasta este transmisă ca parametru unor metode (de tipul <code>startActivity()</code> sau <code>startService()</code>, definite în clasa abstractă <code>android.content.Context</code>), pentru a invoca anumite componente (activități sau servicii). Un astfel de obiect poate încapsula anumite date (împachetate sub forma unui <code>android.os.Bundle</code>), care pot fi utilizate de componenta ce se dorește a fi executată prin intermediul intenției.
</p>

<p>
În programarea Android, un principiu de bază este de folosi intenții pentru a propaga acțiuni, chiar și în cadrul aceleiași aplicații, în detrimentul încărcării clasei corespunzătoare. În acest fel, se asigură cuplarea slabă a componentelor, oferind flexibilitate în cazul înlocuirii acestora, permițând totodată extinderea funcționalității cu ușurință.
</p>

</div>
<!-- EDIT2 SECTION "Intenții (obligatoriu)" [61-2518] -->
<h3 class="sectionedit3" id="structura_unei_intentii">Structura unei Intenții</h3>
<div class="level3">

<p>
În structura unei intenții pot fi identificate mai multe elemente, precizate în cadrul secțiunii <code>&lt;intent-filter&gt;</code>, prin intermediul cărora se declară faptul că o componentă a unei aplicații poate realiza o anumită acțiune pentru un anumit set de date (sau pe care un ascultător al unei intenții cu difuzare îl poate procesa):
</p>
<ul>
<li class="level1"><div class="li"> <strong>acțiunea</strong> (<code>action</code>) care trebuie executată este indicată prin proprietatea <code>android:name</code>, cele mai frecvent utilizate valori fiind: <code>MAIN</code>, <code>VIEW</code>,  <code>DIAL</code>, <code>CALL</code>, <code>ANSWER</code>, <code>SEND</code>, <code>SENDTO</code>, <code>INSERT</code>, <code>EDIT</code>, <code>DELETE</code>, <code>SEARCH</code>, <code>WEB_SEARCH</code>; fiecare filtru de intenție trebuie să indice cel puțin o acțiune; este recomandat să se utilizeze convențiile folosite în Java pentru identificarea pachetelor pentru denumirile acțiunilor;</div>
</li>
</ul>

<p>
<p><div class="noteimportant">Între o acțiune și componenta pe care aceasta o invocă nu există o relație de tip 1:1, întrucât o acțiune poate determina execuția unor componente diferite, în funcție de tipul de date care sunt atașate acesteia. Astfel, fiecare activitate va defini ca atribute ale alementului <code>data</code> din <code>&lt;intent-filter&gt;</code> informații legate de categoria MIME ale datelor procesate (<code>mimeType</code>), de locația la care se găsesc (<code>path</code>, <code>host</code>, <code>port</code>), de schema utilizată (<code>scheme</code>).
</div></p>
</p>
<ul>
<li class="level1"><div class="li"> <strong>categoria</strong> (<code>category</code>), indicată tot prin proprietatea <code>android:name</code> oferă informații suplimentare cu privire la acțiunea care trebuie realizată; fiecare filtru de intenție poate specifica mai multe categorii, putând fi utilizate valori definite de utilizator sau valori preexistente în sistemul de operare Android:</div>
<ul>
<li class="level2"><div class="li"> <code>ALTERNATIVE</code> - acțiunea ar trebui să fie disponibilă ca o alternativă la activitatea implicită pentru tipul de date respectiv;</div>
</li>
<li class="level2"><div class="li"> <code>SELECTED_ALTERNATIVE</code> - acțiunea poate fi selectată, dintr-o listă, ca o alternativă la activitatea implicită pentru tipul de date respectiv;</div>
</li>
<li class="level2"><div class="li"> <code>BROWSABLE</code> - indică o acțiune disponibilă din cadrul navigatorului; pentru ca o activitate sau un serviciu să poată fi invocate din cadrul navigatorului trebuie să specifice în mod obligatoriu această categorie;</div>
</li>
<li class="level2"><div class="li"> <code>DEFAULT</code> - utilizat pentru ca activitatea sau serviciul să fie utilizate în mod implicit pentru tipul de date specificat în filtrul de intenții; de asemenea, este necesar pentru activitățile sau serviciile care se doresc a fi lansate în execuție prin intermediul unor intenții explicite;</div>
</li>
<li class="level2"><div class="li"> <code>HOME</code> - este folosit pentru a indica o alternativă la ecranul principal, dacă nu este indicată nici o acțiune;</div>
</li>
<li class="level2"><div class="li"> <code>LAUNCHER</code> - atunci când este specificat, face ca activitatea să fie inclusă în meniul de aplicații care pot fi lansate în execuție direct de către utilizator, prin accesarea lor;</div>
</li>
<li class="level2"><div class="li"> alte valori: <code>INFO</code>, <code>PREFERENCE</code>, <code>CAR_DOCK</code>, <code>DESK_DOCK</code>, <code>CAR_MODE</code>, <code>APP_MAKET</code>.</div>
</li>
</ul>
</li>
</ul>
<ul>
<li class="level1"><div class="li"> <strong>datele</strong> (<code>data</code>) reprezință informațiile care vor fi procesate, fiind exprimate de obicei sub forma unui <abbr title="Uniform Resource Identifier">URI</abbr>, fie că este vorba despre un număr de telefon (prefixat de <code>tel:</code>), despre datele unei persoane din lista de contacte (prefixate de <code>content://contacts/people</code>), despre coordonate geografice (prefixate de <code>geo:</code>) sau o adresă Internet (prefixată de <code>http://www.</code>); pot fi specificate o serie de proprietăți (în orice combinație) pentru a indica datele suportate de componenta respectivă:</div>
<ul>
<li class="level2"><div class="li"> <code>android:host</code> - o adresă (accesibilă prin rețea - poate fi indicată denumirea sau adresa IP a gazdei) la care se găsesc datele ce pot fi procesate de componentă;</div>
</li>
<li class="level2"><div class="li"> <code>android:mimeType</code> - tipul de date;</div>
</li>
<li class="level2"><div class="li"> <code>android:path</code> - locația la care se găsesc datele;</div>
</li>
<li class="level2"><div class="li"> <code>android:port</code> - portul pe care se permite conexiunea pentru accesarea datelor;</div>
</li>
<li class="level2"><div class="li"> <code>android:scheme</code> - un protocol prin intermediul căruia pot fi accesate datele (spre exemplu, <code>file</code>, <code>http</code>, <code>mailto</code>, <code>content</code>, <code>tel</code>).</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> <strong>tipul</strong> (<code>type</code>) referă în mod explicit clasificarea MIME al datelor (deși aceasta poate fi dedus în mod automat din conținutul propriu-zis al datelor respective);</div>
</li>
<li class="level1"><div class="li"> <strong>componenta</strong> (<code>component</code>) specifică în mod explicit denumirea unei clase care va fi invocată de intenție (deși aceasta putea fi dedusă în mod automat din denumirea acțiunii și categoria ei, datele și tipul lor);</div>
</li>
</ul>

<p>
<p><div class="noteclassic">În situația în care se specifică un nume de componentă, intenția se numește explicită, iar în situația în care aceasta este determinată în funcție de acțiune și de date, intenția se numește implicită.
</div></p>
</p>
<ul>
<li class="level1"><div class="li"> <strong>extra</strong> (<code>extra</code>) este un obiect de tip <code>Bundle</code> care conține informații suplimentare cu privire la componenta respectivă; informațiile conținute într-o intenție pot fi obținute folosind <code>intent.getExtras()</code>, în timp ce specificarea unor informații care vor fi atașate la o intenție va fi realizată printr-un apel al metodei <code>intent.putExtras(Bundle)</code>.</div>
</li>
</ul>

<p>
Dintre aceste componente, esențiale sunt acțiunea și datele:
</p>
<ul>
<li class="level1"><div class="li"> acțiunea este transmisă ca parametru al constructorului clasei <code>Intent</code>;</div>
</li>
<li class="level1"><div class="li"> datele sunt transmise prin intermediul metodei <code>setData()</code> (pentru acțiunile care necesită date); fiind vorba despre un <abbr title="Uniform Resource Identifier">URI</abbr>, acesta va fi construit ca rezultat al <code>Uri.parse(…)</code>.</div>
</li>
</ul>

<p>
După ce a fost construit obiectul de tip <code>Intent</code> prin specificarea acestor parametri, acțiunea poate fi executată prin transmiterea acestuia ca parametru al metodei <code>startActivity()</code> sau <code>startService()</code>, disponibile în clasa <code>android.content.Context</code>.
</p>
<table class="columns-plugin" style="width:100%">
<tr><td class="columns-plugin first" style="width:50%;">
<pre class="code java">startActivity<span class="br0">&#40;</span>intent<span class="br0">&#41;</span><span class="sy0">;</span></pre>
</td><td class="columns-plugin last">
<pre class="code java">startService<span class="br0">&#40;</span>intent<span class="br0">&#41;</span><span class="sy0">;</span></pre>
</td></tr></table>

<p>
Terminarea unei activități (moment în care se realizează revenirea la activitatea părinte) este realizată prin apelul metodei <code>finish()</code>.
</p>

</div>
<!-- EDIT3 SECTION "Structura unei Intenții" [2519-8462] -->
<h3 class="sectionedit4" id="controlul_fluxului_de_activitati_prin_intentii">Controlul fluxului de activități prin intenții</h3>
<div class="level3">

</div>

<h4 id="intentii_construite_prin_precizarea_clasei_incarcate">Intenții construite prin precizarea clasei încărcate</h4>
<div class="level4">

<p>
În fișierul <code>AndroidManifest.xml</code>, orice activitate definește în cadrul elementului <code>&lt;intent-filter&gt;</code>, denumirea unei acțiuni care va putea fi folosită de o intenție pentru a o invoca.
</p>
<pre class="code xml"><span class="sc3"><span class="re1">&lt;activity</span></span>
<span class="sc3">  <span class="re0">android:name</span>=<span class="st0">&quot;ro.pub.cs.systems.eim.lab04.MainActivity&quot;</span></span>
<span class="sc3">  <span class="re0">android:label</span>=<span class="st0">&quot;@string/app_name&quot;</span> <span class="re2">&gt;</span></span>
  <span class="sc3"><span class="re1">&lt;intent-filter<span class="re2">&gt;</span></span></span>
    <span class="sc3"><span class="re1">&lt;action</span> <span class="re0">android:name</span>=<span class="st0">&quot;ro.pub.cs.systems.eim.lab04.intent.action.MainActivity&quot;</span> <span class="re2">/&gt;</span></span>
    <span class="sc3"><span class="re1">&lt;category</span> <span class="re0">android:name</span>=<span class="st0">&quot;android.intent.category.LAUNCHER&quot;</span> <span class="re2">/&gt;</span></span>
  <span class="sc3"><span class="re1">&lt;/intent-filter<span class="re2">&gt;</span></span></span>
<span class="sc3"><span class="re1">&lt;/activity<span class="re2">&gt;</span></span></span></pre>

<p>
<p><div class="notetip">Se obișnuiește ca denumirea unei acțiuni să respecte convenția<br/>
<code>&lt;pachet-aplicație&gt;.intent.action.ACȚIUNE</code>.
</div></p>
</p>

<p>
<p><div class="noteimportant">Pentru fiecare activitate trebuie să existe un element de tip <code>&lt;activity&gt;</code> în fișierul <code>AndroidManifest.xml</code>.
</div></p>
</p>

<p>
<p><div class="noteimportant">Pentru ca o activitate să poată fi invocată, aceasta trebuie să specifice la elementul <code>category</code> din <code>&lt;intent-filter&gt;</code> valoarea <code>android.intent.category.DEFAULT</code>.
</div></p>
</p>

<p>
Pentru ca o funcționalitatea expusă de o activitate să poată fi invocată (în mod anonim) și din contextul altor componente ale sistemului de operare Android, pentru tipul de acțiune și pentru tipurile de date precizate, în cadrul secțiunii <code>&lt;intent-filter&gt;</code> trebuie precizat atributul <code>android:label</code> (șir de caractere care conține o descriere a funcționalității implementate), indicându-se ca tip de categorie valorile <code>ALTERNATIVE</code>, <code>SELECTED_ALTERNATIVE</code> sau ambele.
</p>

<p>
O activitate este în principiu invocată de o intenție care poate fi identificată prin apelul metodei <code>getIntent()</code>. Rezultatul acestei metode poate fi inclusiv <code>null</code>, în cazul în care activitatea nu a fost pornită prin intermediul unei intenții.
</p>

<p>
Prin intermediul unei intenții, o aplicație poate invoca atât o activitate din cadrul său, cât și o activitate aparținând altei aplicații.
</p>
<ul>
<li class="level1"><div class="li"> în situația în care se apelează o activitate din cadrul aceleiași aplicații, se poate folosi folosi metoda <pre class="code java">startActivity<span class="br0">&#40;</span><span class="kw1">new</span> Intent<span class="br0">&#40;</span><span class="kw1">this</span>, AnotherActivity.<span class="kw1">class</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy0">;</span></pre>
</div>
</li>
<li class="level1"><div class="li"> dacă se dorește rularea unei activități existente în cadrul altei aplicații, aceasta va trebui referită prin numele său complet, inclusiv denumirea pachetului care o identifică  <pre class="code java">startActivity<span class="br0">&#40;</span><span class="kw1">new</span> Intent<span class="br0">&#40;</span><span class="st0">&quot;ro.pub.cs.systems.eim.lab04.AnotherActivity&quot;</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy0">;</span></pre>
</div>
</li>
</ul>

<p>
De remarcat faptul că în situația în care este pornită o activitate din cadrul aceleiași aplicații Android, obiectul de tip <code>Intent</code> primește ca parametru și contextul curent (<code>this</code>), în timp ce în cazul în care este lansată în execuție o activitate din cadrul altei aplicații Android acest parametru este omis.
</p>

<p>
În momentul în care este invocată metoda <code>startActivity()</code>, activitatea respectivă este lansată în execuție (prin apelul metodelor <code>onCreate()</code>, <code>onStart()</code>, <code>onResume()</code>) și plasată în vârful stivei care conține toate componentele care au rulate anterior, fără a fi fost terminate. În momentul în care se apelează metoda <code>finish()</code> (sau se apasă butonul <em>Back</em>), activitatea este încheiată (prin apelul metodelor <code>onPause()</code>, <code>onStop()</code>, <code>onDestroy()</code>), fiind scoasă din stivă, restaurându-se activitatea anterioară.
</p>

</div>

<h4 id="intentii_construite_prin_precizarea_actiunii">Intenții construite prin precizarea acțiunii</h4>
<div class="level4">

<p>
O intenție poate fi definită și prin intermediul unei acțiuni care se dorește a fi realizată, pentru care pot fi atașate opțional și anumite date. Utilizatorul care folosește un astfel de mecanism nu cunoaște activitatea (sau aplicația Android) care va fi lansată în execuție pentru realizarea acțiunii respective. Pentru a putea îndeplini o astfel de solicitare, sistemul de operare Android trebuie să identifice, la momentul rulării, activitatea care este cea mai adecvată pentru a rezolva acțiunea dorită. În acest fel, pot fi utilizate funcționalități deja implementate în cadrul sistemului de operare Android, fără a cunoaște în prealabil aplicația responsabilă de aceasta.
</p>

<p>
<p><div class="noteclassic">În cazul în care există mai multe activități care au specificat la elementul <code>action</code> din <code>intent-filter</code> aceeași valoare care este transmisă ca parametru constructorului clasei <code>Intent</code>, la execuția intenției în cauză utilizatorului i se va prezenta o listă de opțiuni dintre care poate alege. Dacă la realizarea selecției va fi precizată și opțiunea <em>Use by default for this action</em>, preferințele vor fi salvate astfel încât în continuare vor fi utilizate fără a se mai solicita intervenția utilizatorului în acest sens.
</div></p>
</p>

<p>
Procesul de rezolvare a unei intenții (<em>eng.</em> intent resolution) se face prin intermediul analizei tuturor ascultătorilor înregistrați.
</p>

<p>
Cele mai frecvent utilizate acțiuni implicite ale unui obiect de tip <code>Intent</code> sunt:
</p>
<ul>
<li class="level1"><div class="li"> vizualizarea conținutului specificat în secțiunea <code>data</code> asociată intenției, sub forma unui <abbr title="Uniform Resource Identifier">URI</abbr>, de către aplicații Android diferite, în funcție de schema (protocolul) utilizat (<code>http</code> - navigator, <code>tel</code> - aplicația pentru formarea unui număr de telefon, <code>geo</code> - Google Maps, <code>content</code> - aplicația pentru gestiunea contactelor din agenda telefonică): <pre class="code java">Intent intent <span class="sy0">=</span> <span class="kw1">new</span> Intent<span class="br0">&#40;</span>Intent.<span class="me1">ACTION_VIEW</span><span class="br0">&#41;</span><span class="sy0">;</span>
intent.<span class="me1">setData</span><span class="br0">&#40;</span>Uri.<span class="me1">parse</span><span class="br0">&#40;</span><span class="st0">&quot;http://ocw.cs.pub.ro/eim&quot;</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy0">;</span></pre>
</div>
</li>
<li class="level1"><div class="li"> căutarea unor informații pe Internet folosind un motor de căutare, termenul căutat fiind indicat în secțiunea <code>extra</code> asociată intenției, fiind identificată prin cheia <code>SearchManager.QUERY</code>: <pre class="code java">Intent intent <span class="sy0">=</span> <span class="kw1">new</span> Intent<span class="br0">&#40;</span>Intent.<span class="me1">ACTION_WEB_SEARCH</span><span class="br0">&#41;</span><span class="sy0">;</span>
intent.<span class="me1">setData</span><span class="br0">&#40;</span>Uri.<span class="me1">parse</span><span class="br0">&#40;</span><span class="st0">&quot;http://www.google.ro&quot;</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy0">;</span></pre>
</div>
</li>
<li class="level1"><div class="li"> invocarea aplicației Android pentru formarea unui număr de telefon (interfața grafică a aplicației Android poate fi populată deja cu numărul de telefon furnizat în secțiunea de date a intenției asociate, în cadrul unui <abbr title="Uniform Resource Identifier">URI</abbr>); aplicația Android nativă poate normaliza majoritatea schemelor de numere de telefon (cod de țară, prefix, număr de telefon propriu-zis): <pre class="code java">Intent intent <span class="sy0">=</span> <span class="kw1">new</span> Intent<span class="br0">&#40;</span>Intent.<span class="me1">ACTION_DIAL</span><span class="br0">&#41;</span><span class="sy0">;</span></pre>
</div>
</li>
<li class="level1"><div class="li"> invocarea aplicației pentru formarea unui număr de telefon și realizarea propriu-zisă a apelului telefonic, folosind valoarea furnizată în secțiunea de date a intenției asociate (în cadrul unui <abbr title="Uniform Resource Identifier">URI</abbr>); se recomandă să fie folosită pentru activitățile care înlocuiesc aplicația Android nativă pentru formarea unui număr de telefon: <pre class="code java">Intent intent <span class="sy0">=</span> <span class="kw1">new</span> Intent<span class="br0">&#40;</span>Intent.<span class="me1">ACTION_CALL</span><span class="br0">&#41;</span><span class="sy0">;</span>
intent.<span class="me1">setData</span><span class="br0">&#40;</span>Uri.<span class="me1">parse</span><span class="br0">&#40;</span><span class="st0">&quot;tel:0214029466&quot;</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy0">;</span></pre>
</div>
</li>
</ul>

<p>
<p><div class="noteimportant">Pentru a fi posibil ca aplicația să realizeze un apel telefonic, în fișierul <code>AndroidManifest.xml</code> trebuie specificată explicit permisiunea pentru o astfel de acțiune<br/>
<code>&lt;uses-permission android:name=“android.permission.CALL_PHONE”&gt;</code>. 
</div></p>
</p>
<ul>
<li class="level1"><div class="li"> vizualizarea unei locații pe hartă pentru care s-au specificat coordonatele GPS <pre class="code java">Intent intent <span class="sy0">=</span> <span class="kw1">new</span> Intent<span class="br0">&#40;</span>Intent.<span class="me1">ACTION_VIEW</span><span class="br0">&#41;</span><span class="sy0">;</span>
intent.<span class="me1">setData</span><span class="br0">&#40;</span>Uri.<span class="me1">parse</span><span class="br0">&#40;</span><span class="st0">&quot;geo:44.436877,26.048029?z=100&amp;q=Education&quot;</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy0">;</span></pre>
</div>
</li>
<li class="level1"><div class="li"> selectarea unei valori din cadrul furnizorului de conținut indicat în cadrul secțiunii de date asociate intenției, sub forma unui <abbr title="Uniform Resource Identifier">URI</abbr>; de regulă, este lansată în execuție ca subacvititate, fiind necesar să furnizeze un <abbr title="Uniform Resource Identifier">URI</abbr> către valoarea care a fost accesată, atunci când este terminată <pre class="code java">Intent intent <span class="sy0">=</span> <span class="kw1">new</span> Intent<span class="br0">&#40;</span>Intent.<span class="me1">ACTION_PICK</span><span class="br0">&#41;</span><span class="sy0">;</span>
intent.<span class="me1">setData</span><span class="br0">&#40;</span>Uri.<span class="me1">parse</span><span class="br0">&#40;</span><span class="st0">&quot;content://contacts/people&quot;</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy0">;</span></pre>
</div>
</li>
</ul>

<p>
Alte acțiuni implicite utilizate sunt:
</p>
<ul>
<li class="level1"><div class="li"> <code>ACTION_ALL_APPS</code> - lansează în execuție o activitate care afișează toate aplicațiile Android instalate pe dispozitivul mobil; implicit, această acțiune este tratată de aplicația nativă care listează aplicațiile Android în meniul de aplicații din care pot fi rulate de utilizator prin accesarea pictogramei asociate;</div>
</li>
<li class="level1"><div class="li"> <code>ACTION_ANSWER</code> - lansează în execuție o activitate care gestionează apelurile primite;</div>
</li>
<li class="level1"><div class="li"> <code>ACTION_BUG_REPORT</code> - lansează în execuție o activitate prin intermediul căruia poate fi raportată funcționarea anormală a unei aplicații Android;</div>
</li>
<li class="level1"><div class="li"> <code>ACTION_CALL_BUTTON</code> - lansează în execuție o activitate responsabilă cu formarea numărului de telefon; de regulă, o astfel de acțiune este generată în momentul în care utilizatorul accesează un buton dedicat;</div>
</li>
<li class="level1"><div class="li"> <code>ACTION_DELETE</code> - lansează în execuție o activitate care permite ștergerea informațiilor specificate în secțiunea <code>data</code> asociată intenției, sub forma unui <abbr title="Uniform Resource Identifier">URI</abbr>;</div>
</li>
<li class="level1"><div class="li"> <code>ACTION_EDIT</code> - lansează în execuție o activitate care permite modificarea informațiilor specificate în secțiunea <code>data</code> asociată intenției, sub forma unui <abbr title="Uniform Resource Identifier">URI</abbr>;</div>
</li>
<li class="level1"><div class="li"> <code>ACTION_INSERT</code> - lansează în execuție o activitate care permite adăugarea unor informații în cursorul specificat în secțiunea de secțiunea <code>data</code> asociată intenției, sub forma unui <abbr title="Uniform Resource Identifier">URI</abbr> (în cazul în care este rulată ca subactivitate, trebuie să furnizeze <abbr title="Uniform Resource Identifier">URI</abbr>-ul informațiilor adăugate);</div>
</li>
<li class="level1"><div class="li"> <code>ACTION_SEARCH</code> - lansează în execuție o activitate care implementează o activitate de căutare; termenul care este căutat trebuie să fie specificat în secțiunea <code>extra</code> a activității, fiind identificat prin cheia <code>SearchManager.QUERY</code>;</div>
</li>
<li class="level1"><div class="li"> <code>ACTION_SEARCH_LONG_PRESS</code>  - lansează în execuție o activitate care implementează o activitate de căutare, fiind generată în momentul în care este detectat un eveniment de tip apăsare prelungită a unui buton dedicat (implicit, lansează în execuție o activitate pentru a realiza o căutare vocală);</div>
</li>
<li class="level1"><div class="li"> <code>ACTION_SENDTO</code> - lansează în execuție o activitate pentru a transmite anumite informații către un contact indicat în secțiunea <code>data</code> asociată intenției;</div>
</li>
<li class="level1"><div class="li"> <code>ACTION_SEND</code> - lansează în execuție o activitate care transmite informațiile conținute în cadrul intenției către un contact care va fi selectat ulterior (aflat pe un alt dispozitiv mobil):</div>
<ul>
<li class="level2"><div class="li"> tipul MIME trebuie indicat prin intermediul metodei <code>setType()</code>;</div>
</li>
<li class="level2"><div class="li"> informațiile propriu-zise trebnuie conținute în secțiunea <code>extra</code> asociată intenției, fiind identificate prin cheile <code>EXTRA_TEXT</code> sau <code>EXTRA_STREAM</code>, în funcție de tipul respectiv (pentru aplicațiile de poștă electronică sunt suportate și cheile <code>EXTRA_EMAIL</code>, <code>EXTRA_CC</code>, <code>EXTRA_BCC</code>, <code>EXTRA_SUBJECT</code>).</div>
</li>
</ul>
</li>
</ul>

<p>
Totuși, un utilizator nu poate avea garanția că acțiunea pe care o transmite ca parametru al unei intenții va putea fi rezolvată, întrucât există posibilitatea să nu existe nici o activitate asociată acesteia sau ca aplicația ce ar fi putut să o execute să nu fie instalată în contextul sistemului de operare Android. Din acest motiv, o practică curentă este de a verifica dacă o acțiune poate fi rezolvată <strong>înainte</strong> de a apela metoda <code>startActivity()</code>. Astfel, procesul de gestiune a pachetelor poate fi interogat (prin intermediul metodei <code>resolveActivity()</code>) dacă există o activitate ce poate executa o acțiune și în caz afirmativ, care este aceasta.
</p>
<pre class="code java">Intent applicationIntent <span class="sy0">=</span> <span class="kw1">new</span> Intent<span class="br0">&#40;</span>...<span class="br0">&#41;</span><span class="sy0">;</span>
PackageManager packageManager <span class="sy0">=</span> <span class="kw1">new</span> PackageManager<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
ComponentName componentName <span class="sy0">=</span> applicationIntent.<span class="me1">resolveActivity</span><span class="br0">&#40;</span>packageManager<span class="br0">&#41;</span><span class="sy0">;</span>
<span class="kw1">if</span> <span class="br0">&#40;</span>componentName <span class="sy0">==</span> <span class="kw2">null</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
  Intent marketIntent <span class="sy0">=</span> <span class="kw1">new</span> Intent<span class="br0">&#40;</span>Intent.<span class="me1">ACTION_VIEW</span>, Uri.<span class="me1">parse</span><span class="br0">&#40;</span><span class="st0">&quot;market://search?q=pname:...&quot;</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy0">;</span>
  <span class="kw1">if</span> <span class="br0">&#40;</span>marketIntent.<span class="me1">resolveActivity</span><span class="br0">&#40;</span>packageManager<span class="br0">&#41;</span> <span class="sy0">!=</span> <span class="kw2">null</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
    startActivity<span class="br0">&#40;</span>marketIntent<span class="br0">&#41;</span><span class="sy0">;</span>
  <span class="br0">&#125;</span> <span class="kw1">else</span> <span class="br0">&#123;</span>
    Toast.<span class="me1">makeText</span><span class="br0">&#40;</span>getApplicationContext<span class="br0">&#40;</span><span class="br0">&#41;</span>, <span class="st0">&quot;Google Play Store is not available&quot;</span>, Toast.<span class="me1">LENGTH_LONG</span><span class="br0">&#41;</span>.<span class="me1">show</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
  <span class="br0">&#125;</span>
<span class="br0">&#125;</span> <span class="kw1">else</span> <span class="br0">&#123;</span>
  startActivity<span class="br0">&#40;</span>intent<span class="br0">&#41;</span><span class="sy0">;</span>
<span class="br0">&#125;</span></pre>

<p>
În situația în care nu este identificată nici o activitate asociată acțiunii respective, utilizatorul poate dezactiva componenta grafică asociată până în momentul în care aceasta devine disponibilă, prin descărcarea aplicației Android corespunzătoare din Google Play Store.
</p>

<p>
Prin intermediul clasei <code>PackageManager</code> poate fi obținută lista tuturor acțiunilor care pot fi realizate pentru un set de date, atașat unei intenții, invocându-se metoda <code>queryIntentActivities()</code>:
</p>
<pre class="code java">Intent applicationIntent <span class="sy0">=</span> <span class="kw1">new</span> Intent<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
intent.<span class="me1">setData</span><span class="br0">&#40;</span>...<span class="br0">&#41;</span><span class="sy0">;</span>
intent.<span class="me1">addCategory</span><span class="br0">&#40;</span>Intent.<span class="me1">CATEGORY_SELECTED_ALTERNATIVE</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
PackageManager packageManager <span class="sy0">=</span> <span class="kw1">new</span> PackageManager<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
<span class="kw4">int</span> flags <span class="sy0">=</span> PackageManager.<span class="me1">MATCH_DEFAULT_ONLY</span><span class="sy0">;</span>
&nbsp;
List<span class="sy0">&lt;</span>ResolveInfo<span class="sy0">&gt;</span> availableActions <span class="sy0">=</span> packageManager.<span class="me1">queryIntentActivities</span><span class="br0">&#40;</span>applicationIntent, flags<span class="br0">&#41;</span><span class="sy0">;</span>
<span class="kw1">for</span> <span class="br0">&#40;</span>ResolveInfo availableAction<span class="sy0">:</span> availableActions<span class="br0">&#41;</span> <span class="br0">&#123;</span>
  Log.<span class="me1">d</span><span class="br0">&#40;</span>Constants.<span class="me1">TAG</span>, <span class="st0">&quot;An available action for the data is &quot;</span><span class="sy0">+</span>getResources<span class="br0">&#40;</span><span class="br0">&#41;</span>.<span class="me1">getString</span><span class="br0">&#40;</span>availableAction.<span class="me1">labelRes</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy0">;</span>
<span class="br0">&#125;</span></pre>

<p>
Procesul de rezolvare a unei intenții pe baza unei acțiuni implică următoarele etape:
</p>
<ol>
<li class="level1"><div class="li"> se construiește o listă cu toate filtrele de intenții asociate componentelor din aplicațiile Android existente;</div>
</li>
<li class="level1"><div class="li"> sunt eliminate toate filtrele de intenții care nu corespund acțiunii sau categoriei intenției care se dorește a fi rezolvată:</div>
<ol>
<li class="level2"><div class="li"> verificările în privința acțiunii sunt realizate numai în situația în care filtrul de intenție specifică o acțiune; sunt eliminate acele filtre de intenții pentru care <strong>nici una</strong> dintre acțiunile pe care le include nu corespund acțiunii intenției care se dorește a fi rezolvată;</div>
</li>
<li class="level2"><div class="li"> verificările în privința categorie sunt realizate numai în situația în care filtrul de intenție specifică o categorie sau în cazul în care nu specifică nici o categorie, dacă nici intenția care se dorește a fi rezolvată nu include nici o categorie; sunt eliminate acele filtre de intenții care nu includ <strong>toate</strong> categoriile pe care le conține și intenția care se dorește a fi rezolvată (putând conține totuși și categorii suplimentare);</div>
</li>
</ol>
</li>
<li class="level1"><div class="li"> fiecare parte a <abbr title="Uniform Resource Identifier">URI</abbr>-ului datelor corespunzătoare intenției care se dorește a fi rezolvată este comparată cu secțiunea <code>data</code> din filtrul de intenție; gazda, autoritatea, tipul MIME, calea, portul, schema), orice neconcordanță conducând la eliminarea acestuia din listă (în situația în care filtrul de intenții nu specifică proprietăți în secțiunea <code>data</code>, acesta va fi considerat compatibil cu intenția care se dorește a fi rezolvată;</div>
</li>
<li class="level1"><div class="li"> în situația în care, ca urmare a acestui proces, există mai multe componente rămase în listă, utilizatorul va trebui să aleagă dintre toate aceste posibilități.</div>
</li>
</ol>

<p>
<p><div class="noteclassic">Aplicațiile Android native sunt supuse aceluiași proces în momentul în care se realizează rezolvarea unei intenții ca și aplicațiile Android instalate din alte surse, având aceeiași prioritate și putând fi chiar înlocuite de acestea, dacă definesc filtre de intenții cu aceleași acțiuni / categorii.
</div></p>
</p>

<p>
În cazul în care o componentă a unei activități este lansată în execuție prin intermediul unei intenții, aceasta trebuie să identifice acțiunea pe care trebuie să o realizeze și datele pe care trebuie sp le proceseze. În acest sens, clasa <code>Intent</code> pune la dispoziție metodele <code>getAction()</code>, <code>getData()</code> și <code>getExtras()</code>.
</p>
<pre class="code java">@Override
<span class="kw1">protected</span> <span class="kw4">void</span> onCreate<span class="br0">&#40;</span>Bundle state<span class="br0">&#41;</span> <span class="br0">&#123;</span>
  <span class="kw1">super</span>.<span class="me1">onCreate</span><span class="br0">&#40;</span>state<span class="br0">&#41;</span><span class="sy0">;</span>
  setContentView<span class="br0">&#40;</span>R.<span class="me1">layout</span>.<span class="me1">activity_main</span><span class="br0">&#41;</span><span class="sy0">;</span>
  Intent intent <span class="sy0">=</span> getIntent<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
  <span class="kw1">if</span> <span class="br0">&#40;</span>intent <span class="sy0">!=</span> <span class="kw2">null</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
    <a href="http://www.google.com/search?hl=en&amp;q=allinurl%3Adocs.oracle.com+javase+docs+api+string"><span class="kw3">String</span></a> action <span class="sy0">=</span> intent.<span class="me1">getAction</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
    Uri data <span class="sy0">=</span> intent.<span class="me1">getData</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
    Bundle extras <span class="sy0">=</span> intent.<span class="me1">getExtras</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
  <span class="br0">&#125;</span>
<span class="br0">&#125;</span></pre>

<p>
<p><div class="notetip">În anumite situații, o componentă poate primi și alte intenții după ce a fost creată. De fiecare dată, va fi apelată în mod automat metoda <code>onNewIntent()</code>: 
</p>
<pre class="code java">@Override
<span class="kw1">public</span> <span class="kw4">void</span> onNewIntent<span class="br0">&#40;</span>Intent newIntent<span class="br0">&#41;</span> <span class="br0">&#123;</span>
  <span class="kw1">super</span>.<span class="me1">onNewIntent</span><span class="br0">&#40;</span>newIntent<span class="br0">&#41;</span><span class="sy0">;</span>
  <span class="co1">// ...</span>
<span class="br0">&#125;</span></pre>

<p>

</div></p>
</p>

<p>
<p><div class="notetip">O componentă are de asemenea posibilitatea de a transfera responsabilitatea cu privire la gestiunea unei intenții către altă componentă care corespunde criteriilor legate de acțiune și categorie, prin intermediul metodei <code>startNextMatchingActivity()</code>: 
</p>
<pre class="code java">Intent intent <span class="sy0">=</span> getIntent<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
<span class="kw1">if</span> <span class="br0">&#40;</span>intent <span class="sy0">!=</span> <span class="kw2">null</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
  startNextMatchingActivity<span class="br0">&#40;</span>intent<span class="br0">&#41;</span><span class="sy0">;</span>
<span class="br0">&#125;</span></pre>

<p>
În acest mod, o componentă poate indica condiții suplimentare cu privire la tratarea unei anumite acțiuni, în situația în care acestea nu pot fi exprimate în cadrul filtrului de intenții, pentru a putea fi luate în considerare în cadrul procesului automat de identificare a componentei care deservește o intenție.

</div></p>
</p>

</div>

<h4 id="intentii_construite_prin_intermediul_unui_uri">Intenții construite prin intermediul unui URI</h4>
<div class="level4">

<p>
De asemenea, un obiect de tip <code>Intent</code> poate fi creat și prin intermediul unui <abbr title="Uniform Resource Identifier">URI</abbr> care identifică în mod unic o anumită activitate:
</p>
<pre class="code java">Uri uri <span class="sy0">=</span> Uri.<span class="me1">parse</span><span class="br0">&#40;</span><span class="st0">&quot;myprotocol://mynamespace/myactivity&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
Intent intent <span class="sy0">=</span> <span class="kw1">new</span> Intent<span class="br0">&#40;</span>Intent.<span class="me1">ACTION_VIEW</span>, uri<span class="br0">&#41;</span><span class="sy0">;</span>
intent.<span class="me1">putExtra</span><span class="br0">&#40;</span><span class="st0">&quot;someKey&quot;</span>, someValue<span class="br0">&#41;</span><span class="sy0">;</span>
startActivity<span class="br0">&#40;</span>intent<span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>
Pentru a putea fi apelată folosind acest mecanism, activitatea va trebui să definească elementul <code>data</code> în cadrul <code>&lt;intent-filter&gt;</code>:
</p>
<pre class="code xml"><span class="sc3"><span class="re1">&lt;activity</span></span>
<span class="sc3">  <span class="re0">android:name</span>=<span class="st0">&quot;ro.pub.cs.systems.eim.lab04.AnotherActivity&quot;</span></span>
<span class="sc3">  <span class="re0">android:label</span>=<span class="st0">&quot;@string/app_name&quot;</span> <span class="re2">&gt;</span></span>
  <span class="sc3"><span class="re1">&lt;intent-filter<span class="re2">&gt;</span></span></span>
    <span class="sc3"><span class="re1">&lt;action</span> <span class="re0">android:name</span>=<span class="st0">&quot;ro.pub.cs.systems.eim.lab04.intent.action.AnotherActivity&quot;</span> <span class="re2">/&gt;</span></span>
    <span class="sc3"><span class="re1">&lt;category</span> <span class="re0">android:name</span>=<span class="st0">&quot;android.intent.category.DEFAULT&quot;</span> <span class="re2">/&gt;</span></span>
    <span class="sc3"><span class="re1">&lt;data</span></span>
<span class="sc3">      <span class="re0">android:scheme</span>=<span class="st0">&quot;myprotocol&quot;</span></span>
<span class="sc3">      <span class="re0">android:host</span>=<span class="st0">&quot;mynamespace&quot;</span> <span class="re2">/&gt;</span></span>
  <span class="sc3"><span class="re1">&lt;/intent-filter<span class="re2">&gt;</span></span></span>
<span class="sc3"><span class="re1">&lt;/activity<span class="re2">&gt;</span></span></span></pre>

<p>
De remarcat este faptul că în structura <abbr title="Uniform Resource Identifier">URI</abbr>-ului, partea de după <code>schemă://protocol/</code> poate conține orice șir de caractere, rolul său fiind strict acela de a respecta forma unui astfel de obiect (estetic), fără a influența în vreo formă funcționalitatea acestuia. 
</p>

</div>
<!-- EDIT4 SECTION "Controlul fluxului de activități prin intenții" [8463-26285] -->
<h3 class="sectionedit5" id="transmiterea_de_informatii_intre_componente_prin_intermediul_intentiilor">Transmiterea de informații între componente prin intermediul intențiilor</h3>
<div class="level3">

<p>
Intențiile pot încapsula anumite informații care pot fi partajate de componentele între care fac legătura (însă unidirecțional, de la componenta care invocă spre componenta invocată!) prin intermediul secțiunii <code>extra</code> care conține un obiect de tip <code>Bundle</code>. Obținerea valorii secțiunii <code>extra</code> corespunzătoare unei intenții poate fi obținute folosind metoda <code>getExtras()</code>, în timp ce specificarea unor informații care vor fi asociate unei intenții poate fi realizată printr-un apel al metodei <code>putExtras()</code>.
</p>

<p>
<p><div class="noteclassic">În cazul în care o intenție are deja atașat un obiect de tip <code>Bundle</code> în momentul în care se apelează metoda <code>putExtras()</code>, perechile (cheie, valoare) vor fi transferate din cadrul parametrului metodei în obiectul deja existent.
</div></p>
</p>

<p>
Construirea unui obiect de tip <code>Bundle</code> care să fie transmis ca parametru al metodei <code>putExtras()</code> poate fi evitată prin utilizarea metodei <code>putExtra()</code> apelată pe obiectul <code>Intent</code>, primind ca parametrii denumirea cheii prin care datele vor fi identificate și o valoare având un tip compatibil cu <code>android.os.Parcelable</code>. Obținerea datelor se realizează apelând metoda pereche <code>getExtra()</code> căreia i se transmite denumirea cheii ce identifică în mod unic informațiile respective. De asemenea, sunt implementate și metode specifice pentru fiecare tip de dată (<code>put&lt;type&gt;Extra()</code>, respectiv <code>get&lt;type&gt;Extra()</code>).
</p>

<p>
<p><div class="notetip">Se recomandă ca pentru cheie să se utilizeze o denumire prefixată de pachetul aplicației.
</div></p>
</p>

<p>
O activitate copil, lansată în execuție prin intermediul metodei <code>startActivity()</code>, este independentă de activitatea părinte, astfel încât aceasta nu va fi notificată cu privire la terminarea sa. În situațiile în care un astfel de comportament este necesar, activitatea copil va fi pornită de activitatea părinte ca subactivitate care transmite înapoi un rezultat. Acest lucru se realizează prin lansarea în execuție a activității copil prin intermediul metodei <code>startActivityForResult()</code>. În momentul în care este finalizată, va fi invocată automat metoda <code>onActivityResult()</code> de la nivelul activității părinte.
</p>

<p>
La nivelul <strong>activității părinte</strong>, vor trebui implementate:
</p>
<ul>
<li class="level1"><div class="li"> metoda <code>startActivityForResult()</code> va primi ca parametrii obiectul de tip <code>Intent</code> precum și un cod de cerere (de tip întreg), utilizat pentru a identifica în mod unic activitatea copil care a transmis un rezultat;</div>
</li>
<li class="level1"><div class="li"> metoda <code>onActivityResult()</code> care va fi apelată în mod automat în momentul în care activitatea copil a fost terminată; parametrii pe care îi furnizează aceasta sunt:</div>
<ul>
<li class="level2"><div class="li"> codul de cerere (prin care se distinge între instanțe diferite ale activității copil);</div>
</li>
<li class="level2"><div class="li"> codul de rezultat transmis activității părinte (poate avea valorile <code>RESULT_OK</code> sau <code>RESULT_CANCELED</code>);</div>
</li>
<li class="level2"><div class="li"> un obiect <code>Intent</code> prin intermediul căruia pot fi furnizate date suplimentare.</div>
</li>
</ul>
</li>
</ul>
<pre class="code java"><span class="kw1">final</span> <span class="kw1">private</span> <span class="kw1">static</span> <span class="kw4">int</span> ANOTHER_ACTIVITY_REQUEST_CODE <span class="sy0">=</span> <span class="nu0">2015</span><span class="sy0">;</span>
&nbsp;
@Override
<span class="kw1">protected</span> <span class="kw4">void</span> onCreate<span class="br0">&#40;</span>Bundle state<span class="br0">&#41;</span> <span class="br0">&#123;</span>
  <span class="kw1">super</span>.<span class="me1">onCreate</span><span class="br0">&#40;</span>state<span class="br0">&#41;</span><span class="sy0">;</span>
  setContentView<span class="br0">&#40;</span>R.<span class="me1">layout</span>.<span class="me1">activity_main</span><span class="br0">&#41;</span><span class="sy0">;</span>
  Intent intent <span class="sy0">=</span> <span class="kw1">new</span> Intent<span class="br0">&#40;</span><span class="st0">&quot;ro.pub.cs.systems.eim.lab04.AnotherActivity&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
  intent.<span class="me1">putExtra</span><span class="br0">&#40;</span><span class="st0">&quot;ro.pub.cs.systems.eim.eim.someKey&quot;</span>, someValue<span class="br0">&#41;</span><span class="sy0">;</span>
  startActivityForResult<span class="br0">&#40;</span>intent, ANOTHER_ACTIVITY_REQUEST_CODE<span class="br0">&#41;</span><span class="sy0">;</span>
  <span class="co1">// start another activities with their own request codes</span>
<span class="br0">&#125;</span>
&nbsp;
<span class="kw1">public</span> <span class="kw4">void</span> onActivityResult<span class="br0">&#40;</span><span class="kw4">int</span> requestCode, <span class="kw4">int</span> resultCode, Intent intent<span class="br0">&#41;</span> <span class="br0">&#123;</span>
  <span class="kw1">switch</span><span class="br0">&#40;</span>requestCode<span class="br0">&#41;</span> <span class="br0">&#123;</span>
    <span class="kw1">case</span> ANOTHER_ACTIVITY_REQUEST_CODE<span class="sy0">:</span>
      <span class="kw1">if</span> <span class="br0">&#40;</span>resultCode <span class="sy0">==</span> Activity.<span class="me1">RESULT_OK</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        Bundle data <span class="sy0">=</span> intent.<span class="me1">getExtras</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
        <span class="co1">// process information from data ...</span>
      <span class="br0">&#125;</span>
      <span class="kw1">break</span><span class="sy0">;</span>
&nbsp;
      <span class="co1">// process other request codes</span>
  <span class="br0">&#125;</span>
<span class="br0">&#125;</span></pre>

<p>
În <strong>activitatea copil</strong>, înainte de apelul metodei <code>finish()</code>, va trebui transmis activității părinte codul de rezultat (<code>Activity.RESULT_OK</code>, <code>Activity.RESULT_CANCELED</code> sau orice fel de rezultat de tip întreg) și obiectul de tip intenție care conține datele (opțional, în situația în care trebuie întoarse rezultate explicit), ca parametrii ai metodei <code>setResult()</code>.
</p>
<pre class="code java">@Override
<span class="kw1">protected</span> <span class="kw4">void</span> onCreate<span class="br0">&#40;</span>Bundle state<span class="br0">&#41;</span> <span class="br0">&#123;</span>
  <span class="kw1">super</span>.<span class="me1">onCreate</span><span class="br0">&#40;</span>state<span class="br0">&#41;</span><span class="sy0">;</span>
  setContentView<span class="br0">&#40;</span>R.<span class="me1">layout</span>.<span class="me1">activity_another</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
  <span class="co1">// intent from parent</span>
  Intent intentFromParent <span class="sy0">=</span> getIntent<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
  Bundle data <span class="sy0">=</span> intentFromParent.<span class="me1">getExtras</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
  <span class="co1">// process information from data ...</span>
&nbsp;
  <span class="co1">// intent to parent</span>
  Intent intentToParent <span class="sy0">=</span> <span class="kw1">new</span> Intent<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
  intent.<span class="me1">putExtra</span><span class="br0">&#40;</span><span class="st0">&quot;ro.pub.cs.systems.eim.lab04.anotherKey&quot;</span>, anotherValue<span class="br0">&#41;</span><span class="sy0">;</span>
  setResult<span class="br0">&#40;</span>RESULT_OK, intentToParent<span class="br0">&#41;</span><span class="sy0">;</span>
  finish<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
<span class="br0">&#125;</span></pre>

<p>
În cazul folosirii unor intenții în care activitățile sunt invocate prin intermediul unor <abbr title="Uniform Resource Identifier">URI</abbr>-uri, datele vor putea fi concatenate direct în cadrul acestuia (fără a utiliza un obiect de tip <code>Bundle</code>), restricția constând în faptul că pot fi utilizate numai șiruri de caractere:
</p>
<ul>
<li class="level1"><div class="li"> în activitatea părinte <pre class="code java">Uri uri <span class="sy0">=</span> Uri.<span class="me1">parse</span><span class="br0">&#40;</span><span class="st0">&quot;myprotocol://mynamespace/myactivity?someKey=someValue&amp;...&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
Intent intent <span class="sy0">=</span> <span class="kw1">new</span> Intent<span class="br0">&#40;</span>Intent.<span class="me1">ACTION_VIEW</span>, uri<span class="br0">&#41;</span><span class="sy0">;</span>
startActivity<span class="br0">&#40;</span>intent<span class="br0">&#41;</span><span class="sy0">;</span></pre>
</div>
</li>
<li class="level1"><div class="li"> în activitatea copil  <pre class="code java">Uri uri <span class="sy0">=</span> getIntent<span class="br0">&#40;</span><span class="br0">&#41;</span>.<span class="me1">getData</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
<a href="http://www.google.com/search?hl=en&amp;q=allinurl%3Adocs.oracle.com+javase+docs+api+string"><span class="kw3">String</span></a> someValue <span class="sy0">=</span> uri.<span class="me1">getQueryParameter</span><span class="br0">&#40;</span><span class="st0">&quot;someKey&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span></pre>
</div>
</li>
</ul>

</div>
<!-- EDIT5 SECTION "Transmiterea de informații între componente prin intermediul intențiilor" [26286-31675] -->
<h3 class="sectionedit6" id="gestiunea_evenimentelor_cu_difuzare_prin_intermediul_intentiilor">Gestiunea evenimentelor cu difuzare prin intermediul intențiilor</h3>
<div class="level3">

<p>
Intențiile reprezintă și un mecanism de comunicație inter-proces, asigurând transferul unor mesaje structurate. Astfel, intențiile pot fi distribuite către toate componentele de la nivelul sistemului de operare Android, pentru a notifica producerea unui eveniment (legat de starea dispozitivului mobil sau a unor aplicații), fiind procesate în cadrul unor obiecte ascultător dedicate tipului de mesaj respectiv.
</p>

<p>
<p><div class="notetip">Și sistemul de operare Android folosește acest mecanism pentru a notifica producerea unor modificări la nivelul stării curente (primirea unui apel telefonic / mesaj, schimbarea nivelului de încărcare al bateriei sau a conectivității).
</div></p>
</p>

<p>
<p><div class="noteclassic">Trebuie realizată distincția între intențiile cu difuzare transmise la nivelul întregului sistem de operare Android și a celor transmise doar la nivelul aplicației, prin intermediul unui obiect de tipul <code>LocalBroadcastManager</code> (a cărui instanță se obține prin intermediul metodei statice <code>getInstance()</code> ce primește ca parametru contextul aplicației curente). Acesta operează într-un mod similar, implementând metodele <code>sendBroadcast()</code> și <code>registerReceiver()</code>. În plus, dispune de o metodă ce permite trimiterea sincronă a notificărilor, apelul acesteia fiind blocant până la momentul în care toți ascultătorii le-au primit.
</div></p>
</p>

<p>
Pentru o aplicație Android, în momentul rulării, pot fi activate / dezactivate oricare dintre componente (deci inclusiv ascultătorii pentru intențiile cu difuzare) prin intermediul metodei <code>setComponentEnabledSetting()</code> din cadrul clasei <code>PackageManager</code>. Un astfel de comportament este util pentru a optimiza performanțele aplicației atunci când o anumită funcționalitate nu este necesară.
</p>
<pre class="code java">PackageManager packageManager <span class="sy0">=</span> getPackageManager<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
ComponentName someEventBroadcastReceiver <span class="sy0">=</span> <span class="kw1">new</span> ComponentName<span class="br0">&#40;</span><span class="kw1">this</span>, SomeEventBroadcastReceiver.<span class="kw1">class</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
packageManager.<span class="me1">setComponentEnabledSetting</span><span class="br0">&#40;</span>someEventBroadcastReceiver ,
  PackageManager.<span class="me1">COMPONENT_ENABLED_STATE_ENABLED</span>,
  PackageManager.<span class="me1">DONT_KILL_APP</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
packageManager.<span class="me1">setComponentEnabledSetting</span><span class="br0">&#40;</span>someEventBroadcastReceiver ,
  PackageManager.<span class="me1">COMPONENT_ENABLED_STATE_DISABLED</span>,
  PackageManager.<span class="me1">DONT_KILL_APP</span><span class="br0">&#41;</span><span class="sy0">;</span></pre>

</div>

<h4 id="trimiterea_unei_intentii_cu_difuzare">Trimiterea unei intenții cu difuzare</h4>
<div class="level4">

<p>
Construirea unei intenții care urmează să fie difuzată la nivelul sistemului de operare Android poate fi realizată prin definirea unui obiect de tipul <code>Intent</code>, pentru care se vor specifica acțiunea, datele și categoria, astfel încât obiectele de tip ascultător să îl poată identifica cât mai exact. Ulterior, acesta va fi trimis tuturor proceselor aferente aplicațiilor instalate pe dispozitivul mobil prin intermediul metodei <code>sendBroadcast()</code>, căreia îi este atașat ca parametru.
</p>

<p>
<p><div class="notetip">Pot fi utilizate atât acțiuni predefinite (care vor fi procesate atât de aplicațiile Android native cât și de eventuale aplicații instalate din alte surse) cât și acțiuni definite de utilizator, pentru care trebuie implementate aplicații dedicate, responsabile cu procesarea acestora.
</div></p>
</p>
<pre class="code java"><span class="kw1">final</span> <span class="kw1">public</span> <span class="kw1">static</span> <a href="http://www.google.com/search?hl=en&amp;q=allinurl%3Adocs.oracle.com+javase+docs+api+string"><span class="kw3">String</span></a> SOME_ACTION <span class="sy0">=</span> <span class="st0">&quot;ro.pub.cs.systems.eim.lab04.SomeAction.SOME_ACTION&quot;</span><span class="sy0">;</span>
&nbsp;
Intent intent <span class="sy0">=</span> <span class="kw1">new</span> Intent<span class="br0">&#40;</span>SOME_ACTION<span class="br0">&#41;</span><span class="sy0">;</span>
intent.<span class="me1">putExtra</span><span class="br0">&#40;</span><span class="st0">&quot;ro.pub.cs.systems.eim.lab04.someKey&quot;</span>, someValue<span class="br0">&#41;</span><span class="sy0">;</span>
sendBroadcast<span class="br0">&#40;</span>intent<span class="br0">&#41;</span><span class="sy0">;</span></pre>

</div>

<h4 id="primirea_unui_intentii_cu_difuzare">Primirea unui intenții cu difuzare</h4>
<div class="level4">

<p>
Pentru a putea primi o intenție cu difuzare, o componentă trebuie să fie înregistrată în acest sens, definind un filtru de intenții pentru a specifica ce tipuri de acțiuni și ce tipuri de date asociate intenției poate procesa. 
</p>

<p>
Acesta poate fi precizat:
</p>
<ul>
<li class="level1"><div class="li"> în fișierul <code>AndroidManifest.xml</code> (caz în care nu este necesar ca aplicația să ruleze la momentul în care se produce evenimentul cu difuzare pentru a-l putea procesa); elementul <code>&lt;receiver&gt;</code> trebuie să conțină în mod obligatoriu filtrul de intenții prin care se indică acțiunea care poate fi procesată: <dl class="file">
<dt><a href="../../../code/eim/laboratoare/laborator04%3Fcodeblock=24" title="Download Snippet" class="mediafile mf_xml">AndroidManifest.xml</a></dt>
<dd><pre class="code file xml"><span class="sc3"><span class="re1">&lt;manifest</span> ... <span class="re2">&gt;</span></span>
  <span class="sc3"><span class="re1">&lt;application</span> ... <span class="re2">&gt;</span></span>
    <span class="sc3"><span class="re1">&lt;receiver</span></span>
<span class="sc3">      <span class="re0">android:name</span>=<span class="st0">&quot;.SomeEventBroadcastReceiver&quot;</span><span class="re2">&gt;</span></span>
      <span class="sc3"><span class="re1">&lt;intent-filter<span class="re2">&gt;</span></span></span>
        <span class="sc3"><span class="re1">&lt;action</span> <span class="re0">android:name</span>=<span class="st0">&quot;ro.pub.cs.systems.eim.lab04.SomeAction.SOME_ACTION&quot;</span> <span class="re2">/&gt;</span></span>
      <span class="sc3"><span class="re1">&lt;/intent-filter<span class="re2">&gt;</span></span></span> 
    <span class="sc3"><span class="re1">&lt;/receiver<span class="re2">&gt;</span></span></span>
  <span class="sc3"><span class="re1">&lt;/application<span class="re2">&gt;</span></span></span>
<span class="sc3"><span class="re1">&lt;/manifest<span class="re2">&gt;</span></span></span></pre>
</dd></dl>
</div>
</li>
<li class="level1"><div class="li"> programatic, în codul sursă (caz în care aplicația trebuie să fie în execuție la momentul în care se produce evenimentul cu difuzare pentru a-l putea procesa); o astfel de abordare este utilă când procesarea intenției cu difuzare implică actualizarea unor componente din cadrul interfeței grafice asociate activității: <pre class="code java"><span class="kw1">private</span> SomeEventBroadcastReceiver someEventBroadcastReceiver <span class="sy0">=</span> <span class="kw1">new</span> SomeEventBroadcastReceiver<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
<span class="kw1">private</span> IntentFilter intentFilter <span class="sy0">=</span> <span class="kw1">new</span> IntentFilter<span class="br0">&#40;</span>SOME_ACTION<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
@Override
<span class="kw1">protected</span> <span class="kw4">void</span> onResume<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
  <span class="kw1">super</span>.<span class="me1">onResume</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
  registerReceiver<span class="br0">&#40;</span>someEventBroadcastReceiver, intentFilter<span class="br0">&#41;</span><span class="sy0">;</span>
<span class="br0">&#125;</span>
&nbsp;
@Override
<span class="kw1">protected</span> <span class="kw4">void</span> onPause<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
  <span class="kw1">super</span>.<span class="me1">onPause</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
  unregisterReceiver<span class="br0">&#40;</span>someEventBroadcastReceiver<span class="br0">&#41;</span><span class="sy0">;</span>
<span class="br0">&#125;</span></pre>
</div>
</li>
</ul>

<p>
<p><div class="notetip">O regulă este de a înregistra obiectul ascultător pe metoda <code>onResume()</code> și de a-l deînregistra pe metoda <code>onPause()</code>, astfel încât acesta să nu reacționeze decât atunci când activitatea este vizibilă.
</div></p>
</p>

<p>
O clasă capabilă să proceseze intenții cu difuzare este derivată din <code>android.content.BroadcastReceiver</code>, implementând metoda <code>onReceive()</code> pe care realizează rutina de tratare propriu-zisă:
</p>
<dl class="file">
<dt><a href="../../../code/eim/laboratoare/laborator04%3Fcodeblock=26" title="Download Snippet" class="mediafile mf_java">SomeEventBroadcastReceiver.java</a></dt>
<dd><pre class="code file java"><span class="kw1">import</span> <span class="co2">android.content.BroadcastReceiver</span><span class="sy0">;</span>
<span class="kw1">import</span> <span class="co2">android.content.Context</span><span class="sy0">;</span>
<span class="kw1">import</span> <span class="co2">android.content.Intent</span><span class="sy0">;</span>
&nbsp;
<span class="kw1">public</span> <span class="kw1">class</span> SomeEventBroadcastReceiver <span class="kw1">extends</span> BroadcastReceiver <span class="br0">&#123;</span>
  @Override
  <span class="kw1">public</span> <span class="kw4">void</span> onReceive<span class="br0">&#40;</span><a href="http://www.google.com/search?hl=en&amp;q=allinurl%3Adocs.oracle.com+javase+docs+api+context"><span class="kw3">Context</span></a> context, Intent intent<span class="br0">&#41;</span> <span class="br0">&#123;</span>
    <span class="co1">// ...</span>
  <span class="br0">&#125;</span>
<span class="br0">&#125;</span></pre>
</dd></dl>

<p>
Metoda <code>onReceive()</code> va fi invocată în mod automat în momentul în care este primită o intenție cu difuzare, fiind executată pe firul de execuție principal al aplicației. De regulă, în cadrul acestei metode utilizatorul este anunțat asupra producerii evenimentului prin intermediul serviciului de notificare (<em>Notification Manager</em>), este lansat în execuție un serviciu sau sunt actualizate componente din cadrul interfeței grafice.
</p>

<p>
<p><div class="noteimportant">Este necesar ca metoda <code>onReceive()</code> să se termine în maximum 5 secunde, în caz contrar fiind afișată o fereastră de dialog pentru a determina oprirea sa forțată.
</div></p>
</p>

</div>

<h4 id="tipuri_particulare_de_intentii_cu_difuzare">Tipuri particulare de intenții cu difuzare</h4>
<div class="level4">

<p>
Există și tipuri particulare de intenții cu difuzare:
</p>
<ol>
<li class="level1"><div class="li"> intenții cu difuzare <strong>ordonate</strong>, utile în situația în care o intenție cu difuzare trebuie să fie procesată secvențial de mai mulți ascultători, fiecare dintre aceștia având posibilitatea de a modifica intenția respectivă;</div>
</li>
<li class="level1"><div class="li"> intenții cu difuzare <strong>persistente</strong>, care mențin valoarea care a fost transmisă cel mai recent.</div>
</li>
</ol>

</div>

<h5 id="intentii_cu_difuzare_ordonate">Intenții cu difuzare ordonate</h5>
<div class="level5">

<p>
Pentru ca o intenție cu difuzare să poate fi procesată de mai mulți ascultători într-o anumită ordine, ar trebui să fie transmisă prin intermediul metodei <code>sendOrderedBroadcast()</code> căreia i se poate atașa (opțional) și o anumită permisiune, pe care clasa ascultător trebuie să o dețină:
</p>
<pre class="code java"><span class="kw1">final</span> <span class="kw1">public</span> <span class="kw1">static</span> <a href="http://www.google.com/search?hl=en&amp;q=allinurl%3Adocs.oracle.com+javase+docs+api+string"><span class="kw3">String</span></a> SOME_ORDERED_ACTION <span class="sy0">=</span> <span class="st0">&quot;ro.pub.cs.systems.eim.lab04.SomeOrderedAction.SOME_ORDERED_ACTION&quot;</span><span class="sy0">;</span>
&nbsp;
Intent intent <span class="sy0">=</span> <span class="kw1">new</span> Intent<span class="br0">&#40;</span>SOME_ORDERED_ACTION<span class="br0">&#41;</span><span class="sy0">;</span>
intent.<span class="me1">putExtra</span><span class="br0">&#40;</span><span class="st0">&quot;ro.pub.cs.systems.eim.lab04.someKey&quot;</span>, someValue<span class="br0">&#41;</span><span class="sy0">;</span>
sendOrderedBroadcast<span class="br0">&#40;</span>intent, <span class="st0">&quot;ro.pub.cs.systems.eim.lab04.SOME_PERMISSION&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>
Ordinea în care va fi procesată intenția de clasele ascultător înregistrate în acest sens este dată de prioritatea pe care acestea o precizează în filtrul de intenții, convenția fiind aceea că aceasta este direct proporțională cu valoarea (ascultătorii cu prioritate mai mare vor procesa intenția cu difuzare înaintea ascultătorilor cu prioritate mai mică): 
</p>
<dl class="file">
<dt><a href="../../../code/eim/laboratoare/laborator04%3Fcodeblock=28" title="Download Snippet" class="mediafile mf_xml">AndroidManifest.xml</a></dt>
<dd><pre class="code file xml"><span class="sc3"><span class="re1">&lt;manifest</span> ... <span class="re2">&gt;</span></span>
  <span class="sc3"><span class="re1">&lt;application</span> ... <span class="re2">&gt;</span></span>
    <span class="sc3"><span class="re1">&lt;receiver</span></span>
<span class="sc3">      <span class="re0">android:name</span>=<span class="st0">&quot;.SomeEventOrderedBroadcastReceiver&quot;</span></span>
<span class="sc3">      <span class="re0">android:permission</span>=<span class="st0">&quot;ro.pub.cs.systems.eim.lab04.SOME_PERMISSION&quot;</span><span class="re2">&gt;</span></span>
      <span class="sc3"><span class="re1">&lt;intent-filter</span></span>
<span class="sc3">        <span class="re0">android:permission</span>=<span class="st0">&quot;100&quot;</span><span class="re2">&gt;</span></span>
        <span class="sc3"><span class="re1">&lt;action</span> <span class="re0">android:name</span>=<span class="st0">&quot;ro.pub.cs.systems.eim.lab04.SomeOrderedAction.SOME_ORDERED_ACTION&quot;</span> <span class="re2">/&gt;</span></span>
      <span class="sc3"><span class="re1">&lt;/intent-filter<span class="re2">&gt;</span></span></span> 
    <span class="sc3"><span class="re1">&lt;/receiver<span class="re2">&gt;</span></span></span>
  <span class="sc3"><span class="re1">&lt;/application<span class="re2">&gt;</span></span></span>
<span class="sc3"><span class="re1">&lt;/manifest<span class="re2">&gt;</span></span></span></pre>
</dd></dl>

<p>
Frecvent, intențiile cu difuzare ordonate sunt folosite atunci când se dorește transmiterea unor rezultate înapoi, către aplicația Android care le-a transmis, după ce toți ascultătorii au realizat procesarea acestora. În acest sens, metoda <code>sendOrderedBroadcast()</code> va primi suplimentar ca parametrii și obiectul de tip <code>BroadcastReceiver</code> care va procesa ultimul intenția cu difuzare, un obiect de tip <code>Handler</code> care va primi rezultatul final (se transmite valoarea <code>null</code> dacă se dorește ca acesta să fie aplicația care a transmis intenția), rezultatul, secțiunile <code>data</code> / <code>extra</code> ale intenției pe care se poate opera.
</p>

</div>

<h5 id="intentii_cu_difuzare_persistente">Intenții cu difuzare persistente</h5>
<div class="level5">

<p>
Pentru ca o intenție cu difuzare să își mențină cea mai recentă valoare, ar trebui să fie transmisă prin intermediul metodei <code>sendStickyBroadcast()</code>.
</p>
<pre class="code java"><span class="kw1">final</span> <span class="kw1">public</span> <span class="kw1">static</span> <a href="http://www.google.com/search?hl=en&amp;q=allinurl%3Adocs.oracle.com+javase+docs+api+string"><span class="kw3">String</span></a> SOME_STICKY_ACTION <span class="sy0">=</span> <span class="st0">&quot;ro.pub.cs.systems.eim.lab04.SomeStickyAction.SOME_STICKY_ACTION&quot;</span><span class="sy0">;</span>
&nbsp;
Intent intent <span class="sy0">=</span> <span class="kw1">new</span> Intent<span class="br0">&#40;</span>SOME_STICKY_ACTION<span class="br0">&#41;</span><span class="sy0">;</span>
intent.<span class="me1">putExtra</span><span class="br0">&#40;</span><span class="st0">&quot;ro.pub.cs.systems.eim.lab04.someKey&quot;</span>, someValue<span class="br0">&#41;</span><span class="sy0">;</span>
sendStickyBroadcast<span class="br0">&#40;</span>intent<span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>
<p><div class="noteimportant">Pentru a fi posibil ca aplicația să transmită o intenție cu difuzare persistentă, în fișierul <code>AndroidManifest.xml</code> trebuie specificată explicit permisiunea pentru o astfel de acțiune<br/>
<code>&lt;uses-permission android:name=“android.permission.BROADCAST_STICKY”&gt;</code>. 
</div></p>
</p>

<p>
În momentul în care menținerea stării nu mai este necesară, se poate apela metoda <code>removeStickyBroadcast()</code>.
</p>

<p>
Obținerea celei mai recente valori a intenției cu difuzare poate fi obținută chiar fără a preciza un obiect ascultător, doar prin indicarea filtrului de intenții:
</p>
<pre class="code java">IntentFilter intentFilter <span class="sy0">=</span> <span class="kw1">new</span> IntentFilter<span class="br0">&#40;</span>SOME_STICKY_ACTION<span class="br0">&#41;</span><span class="sy0">;</span>
Intent intent <span class="sy0">=</span> registerReceiver<span class="br0">&#40;</span><span class="kw2">null</span>, intentFilter<span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>
<p><div class="noteclassic">În Android, astfel de intenții sunt utilizate de sistemul de operare pentru a indica starea dispozitivului mobil (nivelul de încărcare al bateriei, conectivitatea la Internet) pentru a îmbunătăți eficiența.
</div></p>
</p>

</div>

<h4 id="gestiunea_intentiilor_cu_difuzare_native">Gestiunea intențiilor cu difuzare native</h4>
<div class="level4">

<p>
Cele mai multe servicii de sistem transmit intenții cu difuzare pentru a semnala faptul că s-au produs anumite modificări la nivelul stării dispozitivului mobil sau al aplicațiilor (primirea unui apel telefonic / mesaj, schimbarea nivelului de încărcare al bateriei, conectivitatea la Internet).
</p>
<div class="table sectionedit7"><table class="inline">
	<tr class="row0">
		<th class="col0 centeralign">  <strong>ACȚIUNE</strong>  </th><th class="col1 centeralign">  <strong>DESCRIERE</strong>  </th>
	</tr>
	<tr class="row1">
		<td class="col0"> <code>ACTION_BATTERY_CHANGED</code> </td><td class="col1"> acțiune transmisă în momentul în care se modifică nivelul de încărcare al bateriei; starea bateriei este disponibilă în secțiunea <code>extra</code>, prin intermediul cheii <code>EXTRA_STATUS</code>, putând avea valorile:<br/>
♦ <code>BatteryManager.BATTERY_STATUS_CHARGING</code><br/>
♦ <code>BatteryManager.BATTERY_STATUS_FULL</code> </td>
	</tr>
	<tr class="row2">
		<td class="col0"> <code>ACTION_BATTERY_LOW</code> </td><td class="col1"> acțiune transmisă în momentul în care nivelul de încărcare al bateriei este scăzut, impunându-se încărcarea acesteia </td>
	</tr>
	<tr class="row3">
		<td class="col0"> <code>ACTION_BATTERY_OKAY</code> </td><td class="col1"> acțiune transmisă în momentul în care nivelul de încărcare al bateriei este acceptabil </td>
	</tr>
	<tr class="row4">
		<td class="col0"> <code>ACTION_BATTERY_CONNECTED</code> </td><td class="col1"> acțiune transmisă în momentul în care bateria este conectată la o sursă de energie externă </td>
	</tr>
	<tr class="row5">
		<td class="col0"> <code>ACTION_BATTERY_DISCONNECTED</code> </td><td class="col1"> acțiune transmisă în momentul în care bateria este deconectată de la o sursă de energie externă </td>
	</tr>
	<tr class="row6">
		<td class="col0"> <code>ACTION_BOOT_COMPLETED</code> </td><td class="col1"> acțiune transmisă în momentul în care a fost realizată complet secvența de pornire a dispozitivului mobil (aplicația poate primi o astfel de intenție cu difuzare dacă deține permisiunea <code>RECEIVE_BOOT_COMPLETED</code>) </td>
	</tr>
	<tr class="row7">
		<td class="col0"> <code>ACTION_CAMERA_BUTTON</code> </td><td class="col1"> acțiune transmisă în momentul în momentul în care este accesat butonul pentru pornirea camerei foto </td>
	</tr>
	<tr class="row8">
		<td class="col0"> <code>ACTION_DATE_CHANGED</code> / <code>ACTION_TIME_CHANGED</code> </td><td class="col1"> acțiuni transmise în momentul în care data calendaristică sau timpul sunt modificate manual (nu datorită progresului său natural) </td>
	</tr>
	<tr class="row9">
		<td class="col0"> <code>ACTION_DOCK_EVENT</code> </td><td class="col1"> acțiune transmisă în momentul în care dispozitivul mobil este ancorat, printr-un dispozitiv de birou sau de mașină, stare plasată în secțiunea <code>extra</code> prin intermediul cheii <code>ETRA_DOCK_STATE</code> </td>
	</tr>
	<tr class="row10">
		<td class="col0"> <code>ACTION_MEDIA_EJECT</code> </td><td class="col1"> acțiune transmisă în momentul în care este îndepărtat un mediu de stocare extern (util în situația în care aplicația scrie / citește de pe acesta, pentru a salva conținutul și pentru a le închide) </td>
	</tr>
	<tr class="row11">
		<td class="col0"> <code>ACTION_MEDIA_MOUNTED</code> / <code>ACTION_MEDIA_UNMOUNTED</code> </td><td class="col1"> acțiuni transmise de fiecare dată când dispozitive de stocare externe sunt adăugate sau îndepărtate cu succes </td>
	</tr>
	<tr class="row12">
		<td class="col0"> <code>ACTION_NEW_OUTGOING_CALL</code> </td><td class="col1"> acțiune transmisă în momentul în care urmează să fie format un număr de telefon, a cărui valoare este plasată în secțiunea <code>extra</code>, prin intermediul cheii <code>EXTRA_PHONE_NUMBER</code> (aplicația poate primi o astfel de intenție cu difuzare dacă deține permisiunea <code>PROCESS_OUTGOING_CALLS</code> </td>
	</tr>
	<tr class="row13">
		<td class="col0"> <code>ACTION_SCREEN_OFF</code> / <code>ACTION_SCREEN_ON</code> </td><td class="col1"> acțiuni transmise în momentul în care ecranul este închis, respectiv este deschis </td>
	</tr>
	<tr class="row14">
		<td class="col0"> <code>ACTION_TIMEZONE_CHANGED</code> </td><td class="col1"> acțiune transmisă în momentul în care zona de timp a telefonului este modificată, a cărui valoare (identificator) este plasată în secțiunea <code>extra</code> prin intermediul cheii <code>time-zone</code> </td>
	</tr>
</table></div>
<!-- EDIT7 TABLE [42640-45508] -->
<p>
<p><div class="notetip">Pentru aceste tipuri de intenții cu difuzare, înregistrarea și deînregistrarea unor obiecte de tip ascultător poate fi realizată numai programatic, în codul sursă.
</div></p>
</p>

<p>
În cazul unei aplicații Android, foarte importante sunt și modificările în privința conectivității la Internet (inclusiv parametrii precum lățimea de bandă, latența) întrucât acestea pot fi semnificative în privința luării unor decizii legate de realizarea anumitor actualizări sau de descărcarea unor fișiere având dimensiuni mari. O astfel de funcționalitate poate fi definită prin implementarea unui obiect ascultător, care procesează acțiunea <code>android.net.conn.CONNECTIVITY_CHANGE</code> (<code>ConnectivityManager.CONNECTIVITY_ACTION</code>). Se transmise o intenție cu difuzie nepersistentă care nu conține informații suplimentare cu privire la schimbarea stării.
</p>
<pre class="code java">ConnectivityManager connectivityManager <span class="sy0">=</span> <span class="br0">&#40;</span>ConnectivityManager<span class="br0">&#41;</span>context.<span class="me1">getSystemService</span><span class="br0">&#40;</span><a href="http://www.google.com/search?hl=en&amp;q=allinurl%3Adocs.oracle.com+javase+docs+api+context"><span class="kw3">Context</span></a>.<span class="me1">CONNECTIVITY_SERVICE</span><span class="br0">&#41;</span><span class="sy0">;</span>
NetworkInfo networkInfo <span class="sy0">=</span> connectivityManager.<span class="me1">getActiveNetworkInfo</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
<span class="kw4">boolean</span> isConnected <span class="sy0">=</span> networkInfo.<span class="me1">isConnectedOrConnecting</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
<span class="kw4">boolean</span> isMobile <span class="sy0">=</span> <span class="br0">&#40;</span>networkInfo.<span class="me1">getType</span><span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="sy0">==</span> ConnectivityManager.<span class="me1">TYPE_MOBILE</span><span class="br0">&#41;</span><span class="sy0">;</span></pre>

</div>
<!-- EDIT6 SECTION "Gestiunea evenimentelor cu difuzare prin intermediul intențiilor" [31676-46738] -->
<h2 class="sectionedit8" id="fragmente_optional">Fragmente (opțional)</h2>
<div class="level2">

<p>
Un fragment este o componentă Android atomică, încapsulând o interfață grafică ce poate fi reutilizată, definind un ciclu de viață propriu. O activitate poate fi formată din unul sau mai multe fragmente, în funcție de cerințele aplicației la un moment dat de timp.
</p>

<p>
<p><div class="noteclassic">Fragmentele sunt mai ales utilizate pentru a gestiona în mod eficient suprafața de afișare și pentru a se evita dezvoltarea mai multor interfețe grafice pentru diferite tipuri de rezoluții. Acestea vor cuprinde un număr de fragmente corespunzător posibilităților dispozitivului respectiv, distribuite pe una sau mai multe ferestre (activități). Se permite astfel dezvoltarea unor interfețe grafice flexibile în mod dinamic, asigurându-se adaptabilitatea la suprafațe de afișare diverse (ceasuri și telefoane inteligente, tablete, televizoare).
</div></p>
</p>

<p>
Deși reprezintă un modul independent, un fragment este strâns legat de activitatea din care face parte. Un fragment poate fi (re)utilizat în cadrul mai multor activități, putând fi plasat în numeroase moduri în funcție de capabilitățile ecranului dispozitivului mobil (tip, dimensiune, densitate, rezoluție). Operațiile de atașare și detașare a unui fragment la o activitate se realizează de regulă programatic, în cadrul codului sursă.
</p>

<p>
<p><div class="notetip">Utilizarea de fragmente nu este obligatorie, însă reprezintă o recomandare pentru dezvoltarea aplicațiilor Android, întrucât ușurează foarte mult posibilitatea de a adapta experiența utilizatorului la noi configurații ale suprafeței de afișare.
</div></p>
</p>

<p>
Fragmentele au fost introduse în Android începând cu nivelul de <abbr title="Application Programming Interface">API</abbr> 11 (Honeycomb), odată cu apariția tabletelor dotate cu un astfel de sistem de operare. Ulterior, au fost incluse și în bibliotecile de suport, astfel încât această funcționalitate să fie disponibilă pentru toate dispozitivele mobile echipate cu un sistem de operare având minim versiunea 1.6.
</p>

</div>
<!-- EDIT8 SECTION "Fragmente (opțional)" [46739-48912] -->
<h3 class="sectionedit9" id="componentele_unui_fragment">Componentele unui Fragment</h3>
<div class="level3">

<p>
Un fragment este o clasă derivată din <code>android.app.Fragment</code>, care:
</p>
<ul>
<li class="level1"><div class="li"> definește o interfața grafică (opțional);</div>
</li>
</ul>

<p>
<p><div class="noteclassic">Există și fragmente care nu conțin o interfață grafică, ci furnizează un anumit comportament pentru o activitate
</div></p>
</p>
<ul>
<li class="level1"><div class="li"> implementează o anumită funcționalitate.</div>
</li>
</ul>

<p>
Pentru a construi interfața grafică corespunzătoare unui fragment, în codul sursă se va suprascrie metoda <code>onCreateView()</code> ce utilizează:
</p>
<ul>
<li class="level1"><div class="li"> un obiect de tip <code>LayoutInflator</code> pentru a încărca fișierul XML;</div>
</li>
<li class="level1"><div class="li"> un obiect de tip <code>ViewGroup</code> ce referă containerul din care face parte fragmentul (de obicei, acesta aparține activității părinte);</div>
</li>
<li class="level1"><div class="li"> un obiect de tip <code>Bundle</code> utilizat pentru restaurarea stării în situația fragmentul este reluat (după ce anterior a fost întrerupt temporar).</div>
</li>
</ul>
<dl class="file">
<dt><a href="../../../code/eim/laboratoare/laborator04%3Fcodeblock=32" title="Download Snippet" class="mediafile mf_java">SomeFragment.java</a></dt>
<dd><pre class="code file java"><span class="kw1">package</span> <span class="co2">ro.pub.cs.systems.eim.lab04</span><span class="sy0">;</span>
&nbsp;
<span class="kw1">import</span> <span class="co2">android.app.Fragment</span><span class="sy0">;</span>
<span class="kw1">import</span> <span class="co2">android.os.Bundle</span><span class="sy0">;</span>
<span class="kw1">import</span> <span class="co2">android.view.LayoutInflater</span><span class="sy0">;</span>
<span class="kw1">import</span> <span class="co2">android.view.View</span><span class="sy0">;</span>
<span class="kw1">import</span> <span class="co2">android.view.ViewGroup</span><span class="sy0">;</span>
&nbsp;
<span class="kw1">public</span> <span class="kw1">class</span> SomeFragment <span class="kw1">extends</span> Fragment <span class="br0">&#123;</span>
&nbsp;
  @Override
  <span class="kw1">public</span> <a href="http://www.google.com/search?hl=en&amp;q=allinurl%3Adocs.oracle.com+javase+docs+api+view"><span class="kw3">View</span></a> onCreateView<span class="br0">&#40;</span>LayoutInflater layoutInflater, ViewGroup container, Bundle state<span class="br0">&#41;</span> <span class="br0">&#123;</span>
    <span class="kw1">return</span> layoutInflater.<span class="me1">inflate</span><span class="br0">&#40;</span>R.<span class="me1">layout</span>.<span class="me1">some_fragment</span>, container, <span class="kw2">false</span><span class="br0">&#41;</span><span class="sy0">;</span>
  <span class="br0">&#125;</span>
&nbsp;
<span class="br0">&#125;</span></pre>
</dd></dl>

<p>
Se observă că metoda <code>inflate()</code> din clasa <code>LayoutInflater</code> primește următorii parametrii:
</p>
<ul>
<li class="level1"><div class="li"> un întreg, reprezentând identificatorul către o resursă de tip mecanism de control al conținutului;</div>
</li>
<li class="level1"><div class="li"> un obiect de tip <code>android.view.ViewGroup</code>;</div>
</li>
<li class="level1"><div class="li"> o valoare de tip adevărat/fals, care indică dacă parametrul anterior este folosit ca părinte pentru interfața grafică încărcată sau dacă acesta este utilizat numai pentru a-i prelua parametrii de tip <code>LayoutParams</code>, spre a afișa în mod corect componentele conținute.</div>
</li>
</ul>

<p>
Pentru fiecare fragment trebuie să existe în directorul <code>/res/layout</code> un fișier XML corespunzător, descriind interfața grafică similar cu modul în care se realiza acest lucru în cadrul unei activități (exceptând atributul <code>tools:context</code> din cadrul elementului rădăcină de tip layout):
</p>
<dl class="file">
<dt><a href="../../../code/eim/laboratoare/laborator04%3Fcodeblock=33" title="Download Snippet" class="mediafile mf_xml">some_fragment.xml</a></dt>
<dd><pre class="code file xml"><span class="sc3"><span class="re1">&lt;?xml</span> <span class="re0">version</span>=<span class="st0">&quot;1.0&quot;</span> <span class="re0">encoding</span>=<span class="st0">&quot;UTF-8&quot;</span><span class="re2">?&gt;</span></span>
<span class="sc3"><span class="re1">&lt;LinearLayout</span> <span class="re0">xmlns:android</span>=<span class="st0">&quot;http://schemas.android.com/apk/res/android&quot;</span></span>
<span class="sc3">  <span class="re0">xmlns:tools</span>=<span class="st0">&quot;http://schemas.android.com/tools&quot;</span></span>
<span class="sc3">  <span class="re0">android:layout_width</span>=<span class="st0">&quot;match_parent&quot;</span></span>
<span class="sc3">  <span class="re0">android:layout_height</span>=<span class="st0">&quot;match_parent&quot;</span></span>
<span class="sc3">  <span class="re0">android:orientation</span>=<span class="st0">&quot;vertical&quot;</span> <span class="re2">&gt;</span></span>
  <span class="sc3"><span class="re1">&lt;ImageView</span></span>
<span class="sc3">    <span class="re0">android:id</span>=<span class="st0">&quot;@+id/some_image_view&quot;</span></span>
<span class="sc3">    <span class="re0">android:layout_width</span>=<span class="st0">&quot;wrap_content&quot;</span></span>
<span class="sc3">    <span class="re0">android:layout_height</span>=<span class="st0">&quot;wrap_content&quot;</span></span>
<span class="sc3">    <span class="re0">android:src</span>=<span class="st0">&quot;@drawable/some_image&quot;</span> <span class="re2">/&gt;</span></span>
  <span class="sc3"><span class="re1">&lt;TextView</span></span>
<span class="sc3">    <span class="re0">android:id</span>=<span class="st0">&quot;@+id/some_text_view&quot;</span></span>
<span class="sc3">    <span class="re0">android:layout_width</span>=<span class="st0">&quot;wrap_content&quot;</span></span>
<span class="sc3">    <span class="re0">android:layout_height</span>=<span class="st0">&quot;wrap_content&quot;</span></span>
<span class="sc3">    <span class="re0">android:text</span>=<span class="st0">&quot;@string/some_image_description&quot;</span> <span class="re2">/&gt;</span></span>
<span class="sc3"><span class="re1">&lt;/LinearLayout<span class="re2">&gt;</span></span></span></pre>
</dd></dl>

<p>
De asemenea, există posibilitatea de a defini o interfață grafică programatic, în codul sursă, folosind un obiect de tipul <code>android.view.ViewGroup</code>, însă o astfel de abordare nu este recomandată, nefiind scalabilă.
</p>

<p>
În fișierul <code>AndroidManifest.xml</code> NU este necesar să existe nici o referință la fragmente, întrucât existența acestora este limitată la activitatea în care sunt conținute.
</p>

</div>
<!-- EDIT9 SECTION "Componentele unui Fragment" [48913-52183] -->
<h3 class="sectionedit10" id="ciclul_de_viata_al_unui_fragment">Ciclul de Viață al unui Fragment</h3>
<div class="level3">

<p>
Ca și în cazul unei activități, ciclul de viață al unui fragment poate fi controlat prin intermediul unor metode care sunt apelate în mod automat. În cazul în care sunt suprascrise, acestea trebuie să apeleze în mod necesar metodele din clasa părinte. Pe lângă metodele apelate în momentul în care fragmentul este creat, pornit, reluat, întrerupt, oprit și distrus, există și metode specifice care semnalizează atașarea și detașarea sa în cadrul unei activități, crearea și distrugerea ierarhiei de controale grafice precum și crearea activității părinte.
</p>

<p>
<img src="../../../../_media/eim/laboratoare/laborator04/ciclul_de_viata_al_unui_fragment.png%3Fw=900&amp;tok=72c7fc" class="mediacenter" alt="" width="900" />
</p>
<ul>
<li class="level1"><div class="li"> la creare sunt apelate metodele: <code>onAttach()</code>, <code>onCreate()</code>, <code>onCreateView()</code> și <code>onActivityCreated()</code></div>
</li>
<li class="level1"><div class="li"> în momentul în care devine vizibil, interacționând cu utilizatorul, sunt apelate <code>onStart()</code> și <code>onResume()</code></div>
</li>
<li class="level1"><div class="li"> în momentul în care nu mai este vizibil, nemaiinteracționând cu utilizatorul, sunt apelate <code>onPause()</code> și <code>onStop()</code></div>
</li>
<li class="level1"><div class="li"> la distrugere sunt apelate metodele <code>onDestroyView()</code>, <code>onDestroy()</code> și <code>onDetach()</code></div>
</li>
</ul>

<p>
Unele dintre aceste metode sunt aceleași ca în cazul activităților, având aceeași funcționalitate, în timp ce altele sunt specifice:
</p>
<ul>
<li class="level1"><div class="li"> <code>onAttach(Activity)</code> - apelată în momentul în care fragmentul este atașat la activitate; de regulă, în această metodă se reține referința către activitate;</div>
</li>
<li class="level1"><div class="li"> <code>onCreateView(LayoutInflator, ViewGroup, Bundle)</code> - apelată pentru a crea interfața grafică a fragmentului, fie prin încărcarea din fișierul XML corespunzător (folosind metoda <code>inflate()</code> din clasa <code>LayoutInflater</code>), fie prin construirea programatică; interfața grafică (obiect de tip <code>android.view.View</code>) trebuie întoarsă ca rezultat al acestei metode; pentru fragmentele care nu dețin o interfață grafică se întoarce <code>null</code>;</div>
</li>
<li class="level1"><div class="li"> <code>onActivityCreated(Bundle)</code> - apelată în momentul în care s-a terminat metoda <code>onCreate()</code> a activității care conține fragmentul; în cadrul acestei metode este finalizat procesul de inițializare al fragmentului, fiind executate operații pentru care este necesar ca activitatea să fie creată;</div>
</li>
<li class="level1"><div class="li"> <code>onDestroyView()</code> - apelată pentru a elibera resursele aferente controalelor din cadrul fragmentului, atunci când interfața grafică este descărcată;</div>
</li>
<li class="level1"><div class="li"> <code>onDetach()</code> - apelată în momentul în care fragmentul este detașat de la activitate</div>
</li>
</ul>

<p>
<p><div class="noteclassic">Se observă faptul că restaurarea stării se poate face în oricare din metodele <code>onCreate()</code>, <code>onCreateView()</code>, respectiv <code>onActivityCreated()</code>.
</div></p>
</p>

<p>
Se observă că ciclul de viață al unui fragment se desfășoară între momentele în care acesta este atașat la activitatea din care face parte, respectiv este detașat din cadrul acesteia, metodele corespunzătoare fiind <code>onAttach()</code> și <code>onDetach()</code>.
</p>

<p>
Metoda <code>onAttach()</code> este apelată înainte de a se crea interfața grafică a fragmentului, fragmentul însuși și chiar activitatea din care acesta face parte. În cadrul său, de regulă se obține o referință către activitate pentru a se realiza alte operații de inițializare.
</p>

<p>
Se consideră că un fragment există între metodele <code>onCreate()</code> și <code>onDestroy()</code>.
</p>

<p>
În cadrul metodei <code>onCreate()</code> se recomandă să fie instanțiate orice obiecte care vor fi utilizate în cadrul fragmentului. Tot aici sunt realizate și alte operații de inițializare.
</p>

<p>
<p><div class="noteimportant">Spre diferență de activități, interfața grafică a unui fragment NU este încărcată în cadrul metodei <code>onCreate()</code>.
</div></p>
</p>

<p>
În cazul unui fragment, interfața grafică este construită, respectiv distrusă în cadrul metodelor <code>onCreateView()</code> și <code>onDestroyView()</code>.
</p>

<p>
În cadrul metodei <code>onCreateView()</code> se recomandă să se încarce interfața grafică din fișierul XML asociat (respectiv să se creeze programatic), obținându-se referințe către controalele grafice respective și asociindu-li-se obiecte de tip ascultător pentru diferite tipuri de evenimente din cadrul interacțiunii cu utilizatorul. Tot acum pot fi pornite diferite servicii sau cronometre.
</p>

<p>
<p><div class="noteimportant">Este obligatoriu ca metoda <code>onCreateView()</code> să întoarcă un obiect de tip <code>android.view.View</code> reprezentând interfața grafică a fragmentului respectiv.
</div></p>
</p>

<p>
În cazul în care este necesar ca fragmentul să acceseze obiecte din interfața grafică a activității din care face parte, astfel de operații nu pot fi realizate decât după ce a fost apelată metoda <code>onActivityCreated()</code>, semnificând faptul că procesul de inițializare al acestuia a fost terminat. În caz contrar, este destul de probabil să se genereze o excepție de tipul <code>NullPointerException</code>.
</p>

<p>
Stările unui fragment sunt strâns legate de cele ale activității din care face parte. În plus, un fragment poate fi atașat sau detașat în mod dinamic unei activități, astfel încât acesta poate parcurge stările de creat, vizibil și activ de mai multe ori în timpul ciclului de viață al containerului din care face parte.
</p>

<p>
Gestiunea tranzițiilor între diferitele stări din cadrul ciclului de viață al unui fragment este foarte importantă pentru a se asigura o experiență adecvată a utilizatorilor. Diferitele treceri între stările de inactivitate și activitate ale fragmentului trebuie să se realizeze în mod transparent pentru utilizatorii aplicației Android. De aceea, este foarte important ca să se asigure persistența controalelor grafice și a celorlalte date, salvându-se starea atunci când fragmentul este întrerupt temporar și oprit, restaurarea fiind realizată atunci când acesta este (re)pornit și reluat.
</p>

<p>
<p><div class="notetip">Este posibil ca după întreruperea temporară a activității / fragmentului să nu mai fie apelată nici o metodă, dacă necesarul de memorie impune ca acestea să fie distruse.
</div></p>
</p>
<dl class="file">
<dt><a href="../../../code/eim/laboratoare/laborator04%3Fcodeblock=34" title="Download Snippet" class="mediafile mf_java">SomeFragment.java</a></dt>
<dd><pre class="code file java"><span class="kw1">package</span> <span class="co2">ro.pub.cs.systems.eim.lab04</span><span class="sy0">;</span>
&nbsp;
<span class="kw1">import</span> <span class="co2">android.app.Activity</span><span class="sy0">;</span>
<span class="kw1">import</span> <span class="co2">android.app.Fragment</span><span class="sy0">;</span>
<span class="kw1">import</span> <span class="co2">android.os.Bundle</span><span class="sy0">;</span>
<span class="kw1">import</span> <span class="co2">android.view.LayoutInflater</span><span class="sy0">;</span>
<span class="kw1">import</span> <span class="co2">android.view.View</span><span class="sy0">;</span>
<span class="kw1">import</span> <span class="co2">android.view.ViewGroup</span><span class="sy0">;</span>
&nbsp;
<span class="kw1">public</span> <span class="kw1">class</span> SomeFragment <span class="kw1">extends</span> Fragment <span class="br0">&#123;</span>
&nbsp;
  @Override
  <span class="kw1">public</span> <span class="kw4">void</span> onAttach<span class="br0">&#40;</span>Activity activity<span class="br0">&#41;</span> <span class="br0">&#123;</span>
    <span class="kw1">super</span>.<span class="me1">onAttach</span><span class="br0">&#40;</span>activity<span class="br0">&#41;</span><span class="sy0">;</span>
    <span class="co1">// ...</span>
  <span class="br0">&#125;</span>
&nbsp;
  @Override
  <span class="kw1">public</span> <span class="kw4">void</span> onCreate<span class="br0">&#40;</span>Bundle savedInstanceState<span class="br0">&#41;</span> <span class="br0">&#123;</span>
    <span class="kw1">super</span>.<span class="me1">onCreate</span><span class="br0">&#40;</span>savedInstanceState<span class="br0">&#41;</span><span class="sy0">;</span>
    <span class="co1">// ...</span>
  <span class="br0">&#125;</span>
&nbsp;
  @Override
  <span class="kw1">public</span> <a href="http://www.google.com/search?hl=en&amp;q=allinurl%3Adocs.oracle.com+javase+docs+api+view"><span class="kw3">View</span></a> onCreateView<span class="br0">&#40;</span>LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState<span class="br0">&#41;</span> <span class="br0">&#123;</span>
    <span class="kw1">return</span> inflater.<span class="me1">inflate</span><span class="br0">&#40;</span>R.<span class="me1">layout</span>.<span class="me1">some_fragment</span>, container, <span class="kw2">false</span><span class="br0">&#41;</span><span class="sy0">;</span>
  <span class="br0">&#125;</span>
&nbsp;
  @Override
  <span class="kw1">public</span> <span class="kw4">void</span> onActivityCreated<span class="br0">&#40;</span>Bundle savedInstanceState<span class="br0">&#41;</span> <span class="br0">&#123;</span>
    <span class="kw1">super</span>.<span class="me1">onActivityCreated</span><span class="br0">&#40;</span>savedInstanceState<span class="br0">&#41;</span><span class="sy0">;</span>
    <span class="co1">// ...</span>
  <span class="br0">&#125;</span>
&nbsp;
  @Override
  <span class="kw1">public</span> <span class="kw4">void</span> onStart<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
    <span class="kw1">super</span>.<span class="me1">onStart</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
    <span class="co1">// ...</span>
  <span class="br0">&#125;</span>
&nbsp;
  @Override
  <span class="kw1">public</span> <span class="kw4">void</span> onResume<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
    <span class="kw1">super</span>.<span class="me1">onResume</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
    <span class="co1">// ...</span>
  <span class="br0">&#125;</span>
&nbsp;
  @Override
  <span class="kw1">public</span> <span class="kw4">void</span> onPause<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#123;</span>
    <span class="kw1">super</span>.<span class="me1">onPause</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
    <span class="co1">// ...</span>
  <span class="br0">&#125;</span>
&nbsp;
  @Override
  <span class="kw1">public</span> <span class="kw4">void</span> onSaveInstanceState<span class="br0">&#40;</span>Bundle savedInstanceState<span class="br0">&#41;</span> <span class="br0">&#123;</span>
    <span class="kw1">super</span>.<span class="me1">onSaveInstanceState</span><span class="br0">&#40;</span>savedInstanceState<span class="br0">&#41;</span><span class="sy0">;</span>
    <span class="co1">// ...</span>
  <span class="br0">&#125;</span>
&nbsp;
  @Override
  <span class="kw1">public</span> <span class="kw4">void</span> onStop<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
    <span class="kw1">super</span>.<span class="me1">onStop</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
    <span class="co1">// ...</span>
  <span class="br0">&#125;</span>
&nbsp;
  @Override
  <span class="kw1">public</span> <span class="kw4">void</span> onDestroyView<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
    <span class="kw1">super</span>.<span class="me1">onDestroyView</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
    <span class="co1">// ...</span>
  <span class="br0">&#125;</span>
&nbsp;
  @Override
  <span class="kw1">public</span> <span class="kw4">void</span> onDestroy<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
    <span class="kw1">super</span>.<span class="me1">onDestroy</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
    <span class="co1">// ...</span>
  <span class="br0">&#125;</span>
&nbsp;
  @Override
  <span class="kw1">public</span> <span class="kw4">void</span> onDetach<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
    <span class="kw1">super</span>.<span class="me1">onDetach</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
    <span class="co1">// ...</span>
  <span class="br0">&#125;</span>
<span class="br0">&#125;</span></pre>
</dd></dl>

</div>
<!-- EDIT10 SECTION "Ciclul de Viață al unui Fragment" [52184-59703] -->
<h3 class="sectionedit11" id="gestiunea_fragmentelor_din_cadrul_unei_activitati">Gestiunea Fragmentelor din cadrul unei Activități</h3>
<div class="level3">

<p>
Fiecare activitate dispune de un proces de gestiune a fragmentelor conține, acesta fiind o instanță a clasei <code>FragmentManager</code>, putând fi obținut din cadrul contextului asociat și punând la dispoziția utilizatorilor metode pentru adăugarea și scoaterea, respectiv înlocuirea unui fragment din cadrul său.
</p>
<pre class="code java">FragmentManager fragmentManager <span class="sy0">=</span> getFragmentManager<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span></pre>

</div>

<h4 id="adaugarea_unui_fragment">Adăugarea unui Fragment</h4>
<div class="level4">

<p>
Operația de adăugare a unui fragment poate fi realizată:
</p>
<ol>
<li class="level1"><div class="li"> static, în cadrul fișierului XML, prin intermediul elementului <code>&lt;fragment&gt;</code>, în situația în care sunt definite interfețe grafice pentru fiecare dintre tipurile de suprafețe de afișare suportate; <pre class="code xml"><span class="sc3"><span class="re1">&lt;LinearLayout</span> <span class="re0">xmlns:android</span>=<span class="st0">&quot;http://schemas.android.com/apk/res/android&quot;</span></span>
<span class="sc3">  <span class="re0">xmlns:tools</span>=<span class="st0">&quot;http://schemas.android.com/tools&quot;</span></span>
<span class="sc3">  <span class="re0">android:layout_width</span>=<span class="st0">&quot;match_parent&quot;</span></span>
<span class="sc3">  <span class="re0">android:layout_height</span>=<span class="st0">&quot;match_parent&quot;</span></span>
<span class="sc3">  <span class="re0">android:paddingBottom</span>=<span class="st0">&quot;@dimen/activity_vertical_margin&quot;</span></span>
<span class="sc3">  <span class="re0">android:paddingLeft</span>=<span class="st0">&quot;@dimen/activity_horizontal_margin&quot;</span></span>
<span class="sc3">  <span class="re0">android:paddingRight</span>=<span class="st0">&quot;@dimen/activity_horizontal_margin&quot;</span></span>
<span class="sc3">  <span class="re0">android:paddingTop</span>=<span class="st0">&quot;@dimen/activity_vertical_margin&quot;</span></span>
<span class="sc3">  <span class="re0">android:orientation</span>=<span class="st0">&quot;vertical&quot;</span></span>
<span class="sc3">  <span class="re0">tools:context</span>=<span class="st0">&quot;.MainActivity&quot;</span> <span class="re2">&gt;</span></span>
  <span class="sc3"><span class="re1">&lt;fragment</span></span>
<span class="sc3">    <span class="re0">android:name</span>=<span class="st0">&quot;ro.pub.cs.systems.eim.labo04.Fragment1&quot;</span></span>
<span class="sc3">    <span class="re0">android:id</span>=<span class="st0">&quot;@+id/fragment1&quot;</span></span>
<span class="sc3">    <span class="re0">android:layout_weight</span>=<span class="st0">&quot;1&quot;</span></span>
<span class="sc3">    <span class="re0">android:layout_width</span>=<span class="st0">&quot;match_parent&quot;</span></span>
<span class="sc3">    <span class="re0">android:layout_height</span>=<span class="st0">&quot;wrap_content&quot;</span> <span class="re2">/&gt;</span></span>
  <span class="sc3"><span class="re1">&lt;fragment</span></span>
<span class="sc3">    <span class="re0">android:name</span>=<span class="st0">&quot;ro.pub.cs.systems.eim.labo04.Fragment2&quot;</span></span>
<span class="sc3">    <span class="re0">android:id</span>=<span class="st0">&quot;@+id/fragment2&quot;</span></span>
<span class="sc3">    <span class="re0">android:layout_weight</span>=<span class="st0">&quot;1&quot;</span></span>
<span class="sc3">    <span class="re0">android:layout_width</span>=<span class="st0">&quot;match_parent&quot;</span></span>
<span class="sc3">    <span class="re0">android:layout_height</span>=<span class="st0">&quot;wrap_content&quot;</span> <span class="re2">/&gt;</span></span>
<span class="sc3"><span class="re1">&lt;/LinearLayout<span class="re2">&gt;</span></span></span></pre>
</div>
</li>
<li class="level1"><div class="li"> dinamic (programatic), în cadrul codului sursă, prin definirea unor containere (obiecte de tip <code>FrameLayout</code>, care pot conține un sigur element vizibil) în cadrul interfețele grafice în care pot fi plasate fragmentele la diferite momente de timp. <pre class="code xml"><span class="sc3"><span class="re1">&lt;LinearLayout</span> <span class="re0">xmlns:android</span>=<span class="st0">&quot;http://schemas.android.com/apk/res/android&quot;</span></span>
<span class="sc3">  <span class="re0">xmlns:tools</span>=<span class="st0">&quot;http://schemas.android.com/tools&quot;</span></span>
<span class="sc3">  <span class="re0">android:layout_width</span>=<span class="st0">&quot;match_parent&quot;</span></span>
<span class="sc3">  <span class="re0">android:layout_height</span>=<span class="st0">&quot;match_parent&quot;</span></span>
<span class="sc3">  <span class="re0">android:paddingBottom</span>=<span class="st0">&quot;@dimen/activity_vertical_margin&quot;</span></span>
<span class="sc3">  <span class="re0">android:paddingLeft</span>=<span class="st0">&quot;@dimen/activity_horizontal_margin&quot;</span></span>
<span class="sc3">  <span class="re0">android:paddingRight</span>=<span class="st0">&quot;@dimen/activity_horizontal_margin&quot;</span></span>
<span class="sc3">  <span class="re0">android:paddingTop</span>=<span class="st0">&quot;@dimen/activity_vertical_margin&quot;</span></span>
<span class="sc3">  <span class="re0">android:orientation</span>=<span class="st0">&quot;vertical&quot;</span></span>
<span class="sc3">  <span class="re0">tools:context</span>=<span class="st0">&quot;.MainActivity&quot;</span> <span class="re2">&gt;</span></span>
  <span class="sc3"><span class="re1">&lt;FrameLayout</span></span>
<span class="sc3">    <span class="re0">android:id</span>=<span class="st0">&quot;@+id/frame1&quot;</span></span>
<span class="sc3">    <span class="re0">android:layout_weight</span>=<span class="st0">&quot;1&quot;</span></span>
<span class="sc3">    <span class="re0">android:layout_width</span>=<span class="st0">&quot;match_parent&quot;</span></span>
<span class="sc3">    <span class="re0">android:layout_height</span>=<span class="st0">&quot;wrap_content&quot;</span> <span class="re2">/&gt;</span></span>
  <span class="sc3"><span class="re1">&lt;FrameLayout</span></span>
<span class="sc3">    <span class="re0">android:id</span>=<span class="st0">&quot;@+id/frame2&quot;</span></span>
<span class="sc3">    <span class="re0">android:layout_weight</span>=<span class="st0">&quot;1&quot;</span></span>
<span class="sc3">    <span class="re0">android:layout_width</span>=<span class="st0">&quot;match_parent&quot;</span></span>
<span class="sc3">    <span class="re0">android:layout_height</span>=<span class="st0">&quot;wrap_content&quot;</span> <span class="re2">/&gt;</span></span>
<span class="sc3"><span class="re1">&lt;/LinearLayout<span class="re2">&gt;</span></span></span></pre>

<p>
 În metoda <code>onCreate()</code> corespunzătoare activității, se creează un obiect de tip <code>FragmentManager</code> pentru care se definesc operațiile care trebuie realizate (atomic) în cadrul unei tranzacții (obiectul de tip <code>FragmentTransaction</code> fiind obținut prin invocarea metodei <code>beginTransaction()</code>). O tranzacție poate specifica suplimentar animațiile asociate unei tranziții prcum și dacă se dorește ca tranzacție să fie stocată și pe stivă. Realizarea propriu-zisă a operațiilor indicate se realizează doar atunci când se apelează metoda <code>commit()</code>.<br/>
Pentru adăugarea unui fragment în cadrul unei activități, trebuie să se precizeze, ca parametrii ai metodei <code>add()</code> din clasa <code>FragmentTransaction</code> identificatorul containerului în care va fi plasat fragmentul, obiectul de tip fragment și (opțional) o etichetă (de tip șir de caractere) prin intermediul căreia acesta poate fi ulterior referit.
</p>
<pre class="code java">@Override
<span class="kw1">protected</span> <span class="kw4">void</span> onCreate<span class="br0">&#40;</span>Bundle savedInstanceState<span class="br0">&#41;</span> <span class="br0">&#123;</span>
  FragmentManager fragmentManager <span class="sy0">=</span> getFragmentManager<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
  FragmentTransaction fragmentTransaction <span class="sy0">=</span> fragmentManager.<span class="me1">beginTransaction</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
  fragmentTransaction.<span class="me1">add</span><span class="br0">&#40;</span>R.<span class="me1">id</span>.<span class="me1">frame1</span>, <span class="kw1">new</span> Fragment1<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy0">;</span>
  fragmentTransaction.<span class="me1">add</span><span class="br0">&#40;</span>R.<span class="me1">id</span>.<span class="me1">frame2</span>, <span class="kw1">new</span> Fragment2<span class="br0">&#40;</span><span class="br0">&#41;</span>, Constants.<span class="me1">FRAGMENT2_TAG</span><span class="br0">&#41;</span><span class="sy0">;</span>
  fragmentTransaction.<span class="me1">commit</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
<span class="br0">&#125;</span></pre>

<p>
 De remarcat faptul că referințele <code>R.id.frame1</code> și <code>R.id.frame2</code> se referă la conținutul activității.
</p>
</div>
</li>
</ol>

<p>
Pentru a asigura o experiență a utilizatorului consistentă, sistemul de operare Android asigură în mod automat persistența mecanismului de dispunere a fragmentelor și stiva asociată atunci când activitatea părinte este distrusă și (re)creată din cauza unei modificări a configurației. Din acest motiv, se recomandă ca toate interfețele grafice corespunzătoare diferitelor configurații să conțină toate containerele implicate în tranzacții de fragmente. Altfel, atunci când se va încerca restaurarea unor fragmente (în containere care nu exista în configurația respectivă), se pot produce anumite excepții. Dacă nu se dorește ca un container să fie afișat în cadrul unei interfețe grafice aferente unei configurații, se poate folosi atributul <code>visibility</code>.
</p>
<table class="columns-plugin" style="width:100%">
<tr><td class="columns-plugin first" style="width:50%;">
<pre class="code xml"><span class="sc3"><span class="re1">&lt;LinearLayout</span> ... <span class="re2">&gt;</span></span>
  <span class="sc3"><span class="re1">&lt;FrameLayout</span></span>
<span class="sc3">    <span class="re0">android:id</span>=@+id/frame1</span>
<span class="sc3">    ... <span class="re2">/&gt;</span></span>
  <span class="sc3"><span class="re1">&lt;FrameLayout</span></span>
<span class="sc3">    <span class="re0">android:id</span>=@+id/frame2</span>
<span class="sc3">    <span class="re0">android:visibility</span>=<span class="st0">&quot;gone&quot;</span></span>
<span class="sc3">    ... <span class="re2">/&gt;</span></span>
<span class="sc3"><span class="re1">&lt;/LinearLayout<span class="re2">&gt;</span></span></span></pre>
</td><td class="columns-plugin last">
<pre class="code java">FrameLayout frame1 <span class="sy0">=</span> <span class="br0">&#40;</span>FrameLayout<span class="br0">&#41;</span>findViewById<span class="br0">&#40;</span>R.<span class="me1">id</span>.<span class="me1">frame1</span><span class="br0">&#41;</span><span class="sy0">;</span>
FrameLayout frame2 <span class="sy0">=</span> <span class="br0">&#40;</span>FrameLayout<span class="br0">&#41;</span>findViewById<span class="br0">&#40;</span>R.<span class="me1">id</span>.<span class="me1">frame2</span><span class="br0">&#41;</span><span class="sy0">;</span>
frame2.<span class="me1">setVisibility</span><span class="br0">&#40;</span><a href="http://www.google.com/search?hl=en&amp;q=allinurl%3Adocs.oracle.com+javase+docs+api+visibility"><span class="kw3">Visibility</span></a>.<span class="me1">GONE</span><span class="br0">&#41;</span><span class="sy0">;</span></pre>
<!-- EDIT11 SECTION "Gestiunea Fragmentelor din cadrul unei Activități" [59704-65197] --></td></tr></table>

</div>

<h4 id="scoaterea_unui_fragment">Scoaterea unui Fragment</h4>
<div class="level4">

<p>
Pentru scoaterea unui fragment din cadrul unei activități, trebuie ca anterior să se obțină o referință către acesta, pe baza identificatorului (metoda <code>findFragmentById()</code>), respectiv pe baza etichetei (metoda <code>findFragmentByTag()</code>). Ulterior, se apelează metoda <code>remove()</code> din clasa <code>FragmentTransaction</code> care primește ca parametru această referință.
</p>
<pre class="code java">FragmentManager fragmentManager <span class="sy0">=</span> getFragmentManager<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
FragmentTransaction fragmentTransaction <span class="sy0">=</span> fragmentManager.<span class="me1">beginTransaction</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
Fragment fragment1 <span class="sy0">=</span> fragmentManager.<span class="me1">findFragmentById</span><span class="br0">&#40;</span>R.<span class="me1">id</span>.<span class="me1">fragment1</span><span class="br0">&#41;</span><span class="sy0">;</span>
Fragment fragment2 <span class="sy0">=</span> fragmentManager.<span class="me1">findFragmentByTag</span><span class="br0">&#40;</span>Constants.<span class="me1">FRAGMENT2_TAG</span><span class="br0">&#41;</span><span class="sy0">;</span>
fragmentTransaction.<span class="me1">remove</span><span class="br0">&#40;</span>fragment1<span class="br0">&#41;</span><span class="sy0">;</span>
fragmentTransaction.<span class="me1">remove</span><span class="br0">&#40;</span>fragment2<span class="br0">&#41;</span><span class="sy0">;</span>
fragmentTransaction.<span class="me1">commit</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>
Metoda <code>findViewById()</code> poate primi ca parametru și identificatorul containerului care conține fragmentul. În cazul în care aceasta nu are nici un conținut, rezultatul metodei este <code>null</code>.
</p>

</div>

<h4 id="inlocuirea_unui_fragment">Înlocuirea unui Fragment</h4>
<div class="level4">

<p>
Pentru înlocuirea unui fragment din cadrul unei activități, trebuie să se precizeze, ca parametrii ai metodei <code>replace()</code> din clasa <code>FragmentTransaction</code> identificatorul containerului în care va fi plasat fragmentul, obiectul de tip fragment și (opțional) o etichetă (de tip șir de caractere) prin intermediul căreia acesta poate fi ulterior referit.
</p>
<pre class="code java">FragmentManager fragmentManager <span class="sy0">=</span> getFragmentManager<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
FragmentTransaction fragmentTransaction <span class="sy0">=</span> fragmentManager.<span class="me1">beginTransaction</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
Fragment fragment2 <span class="sy0">=</span> <span class="kw1">new</span> Fragment2<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
fragmentTransaction.<span class="me1">replace</span><span class="br0">&#40;</span>R.<span class="me1">id</span>.<span class="me1">frame1</span>, fragment2, Constants.<span class="me1">FRAGMENT2_TAG</span><span class="br0">&#41;</span><span class="sy0">;</span>
fragmentTransaction.<span class="me1">commit</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span></pre>

</div>

<h4 id="utilizarea_stivei_de_fragmente">Utilizarea Stivei de Fragmente</h4>
<div class="level4">

<p>
Prin intermediul fragmentelor, se oferă posibilitatea de a se crea interfețe grafice asociate activităților în mod dinamic. Unele modificări între diferite stări pot fi considerate de utilizatori ca fiind ecrane noi, comportamentul așteptat fiind acela de restaurare a acestora atunci când se accesează butonul <em>Back</em>. Un astfel de comportament presupune realizarea unei tranzacții de fragmente în sens invers. Această funcționalitate poate fi obținută prin utilizarea unei stive de fragmente, în care o tranzacție poate fi identificată prin intermediul unei etichete.
</p>

<p>
În acest sens, va trebui apelată explicit metoda <code>addToBackStack()</code> pentru obiectul de tip <code>FragmentTransaction</code> care se ocupă de atașarea și detașarea fragmentelor de la activitate, înainte de a se apela metoda <code>commit()</code>.
</p>
<pre class="code java">FragmentManager fragmentManager <span class="sy0">=</span> getFragmentManager<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
FragmentTransaction fragmentTransaction <span class="sy0">=</span> fragmentManager.<span class="me1">beginTransaction</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
fragmentTransaction.<span class="me1">add</span><span class="br0">&#40;</span>R.<span class="me1">id</span>.<span class="me1">frame1</span>, <span class="kw1">new</span> Fragment1<span class="br0">&#40;</span><span class="br0">&#41;</span>, Constants.<span class="me1">FRAGMENT1_TAG</span><span class="br0">&#41;</span><span class="sy0">;</span>
Fragment fragment2 <span class="sy0">=</span> fragmentManager.<span class="me1">findFragmentByTag</span><span class="br0">&#40;</span>Constants.<span class="me1">FRAGMENT2_TAG</span><span class="br0">&#41;</span><span class="sy0">;</span>
fragmentTransaction.<span class="me1">remove</span><span class="br0">&#40;</span>fragment2<span class="br0">&#41;</span><span class="sy0">;</span>
fragmentTransaction.<span class="me1">addToBackStack</span><span class="br0">&#40;</span><span class="kw2">null</span><span class="br0">&#41;</span><span class="sy0">;</span>
fragmentTransaction.<span class="me1">commit</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>
Astfel, atunci când se apelează metoda <code>commit()</code>, fragmentul 2 este oprit și salvat pe stiva de fragmente (în loc să fie distrus). Când utilizatorul accesează butonul <em>Back</em> fragmentul 1 este distrus și fragmentul 2 este restaurat de pe stivă și (re)pornit.
</p>

</div>

<h4 id="folosirea_de_animatii_la_tranzitia_dintre_fragmente">Folosirea de Animații la Tranziția dintre Fragmente</h4>
<div class="level4">

<p>
Tranzițiile între diferitele stări ale activității care implică operații cu fragmente pot fi realizate:
</p>
<ol>
<li class="level1"><div class="li"> folosind metoda <code>setTransition()</code> a unui obiect de tip <code>FragmentTransaction</code>, utilizând oricare dintre variantele predefinite, de tipul <code>FragmentTransaction.TRANSIT_FRAGMENT_…</code> <pre class="code java">fragmentTransaction.<span class="me1">setTransition</span><span class="br0">&#40;</span>FragmentTransaction.<span class="me1">TRANSIT_FRAGMENT_</span>...<span class="br0">&#41;</span><span class="sy0">;</span></pre>
</div>
</li>
<li class="level1"><div class="li"> folosind metoda <code>setCustomAnimation()</code> a unui obiect de tip <code>FragmentTransaction</code>, pentru utilizarea de animații definite de utilizator; metoda primește două argumente, indicând referințele către fișiere XML care descriu animațiile folosite pentru fragmentele care sunt adăugate, respectiv pentru fragmentele care sunt scoase <pre class="code java">fragmentTransaction.<span class="me1">setCustomAnimations</span><span class="br0">&#40;</span>R.<span class="me1">animator</span>.<span class="me1">fade_in</span>, R.<span class="me1">animator</span>.<span class="me1">fade_out</span><span class="br0">&#41;</span><span class="sy0">;</span></pre>
</div>
</li>
</ol>

</div>

<h3 class="sectionedit12" id="interactiunea_dintre_fragmente">Interacțiunea dintre fragmente</h3>
<div class="level3">

<p>
Elementele grafice dintr-un fragment al unei activități pot fi accesate și din alt fragment al activității, prin obținerea unei referințe către activitatea părinte (folosind metoda <code>getActivity()</code>) și accesarea controlului respectiv prin intermediul identificatorului său din cadrul fragmentului (folosind metoda <code>findViewById()</code>).
</p>

<p>
O astfel de abordare (folosind obiectul de tip <code>Activity</code> ca intermediar al comunicației) este recomandată pentru a asigura cuplarea slabă și autonomia fragmentelor. Altfel, este permisă comunicația directă prin intermediul obiectului de tip <code>FragmentManager</code> asociat activității.
</p>

<p>
În cazul evenimentelor produse la nivelul unui fragment, decizia cu privire la impactul pe care acesta îl are asupra interfeței grafice trebuie să aparțină activității. Astfel, fragmentul va invoca o metodă de callback la nivelul activității care va determina modul în care va fi tratat evenimentul.
</p>
<pre class="code java"><span class="kw1">public</span> <span class="kw1">interface</span> OnEventProducedListener <span class="br0">&#123;</span>
  <span class="kw1">public</span> <span class="kw4">void</span> onEventProduced<span class="br0">&#40;</span><a href="http://www.google.com/search?hl=en&amp;q=allinurl%3Adocs.oracle.com+javase+docs+api+event"><span class="kw3">Event</span></a> event<span class="br0">&#41;</span><span class="sy0">;</span>
<span class="br0">&#125;</span><span class="sy0">;</span></pre>
<pre class="code java"><span class="kw1">public</span> <span class="kw1">class</span> SomeFragment <span class="kw1">extends</span> Fragment <span class="br0">&#123;</span>
&nbsp;
  OnEventProducedListener onEventProducedListener<span class="sy0">;</span>
&nbsp;
  @Override
  <span class="kw1">public</span> <span class="kw4">void</span> onAttach<span class="br0">&#40;</span>Activity activity<span class="br0">&#41;</span> <span class="br0">&#123;</span>
    <span class="kw1">super</span>.<span class="me1">onAttach</span><span class="br0">&#40;</span>activity<span class="br0">&#41;</span><span class="sy0">;</span>
    <span class="kw1">try</span> <span class="br0">&#123;</span>
      onEventProducedListener <span class="sy0">=</span> <span class="br0">&#40;</span>OnEventProducedListener<span class="br0">&#41;</span>activity<span class="sy0">;</span>
    <span class="br0">&#125;</span> <span class="kw1">catch</span> <span class="br0">&#40;</span><a href="http://www.google.com/search?hl=en&amp;q=allinurl%3Adocs.oracle.com+javase+docs+api+classcastexception"><span class="kw3">ClassCastException</span></a> classCastException<span class="br0">&#41;</span> <span class="br0">&#123;</span>
      Log.<span class="me1">e</span><span class="br0">&#40;</span>Constants.<span class="me1">TAG</span>, <span class="st0">&quot;Parent activity does not implement OnEventProducedListener!&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
    <span class="br0">&#125;</span>
  <span class="br0">&#125;</span>
&nbsp;
  <span class="kw1">private</span> <span class="kw4">void</span> onEventProduced<span class="br0">&#40;</span><a href="http://www.google.com/search?hl=en&amp;q=allinurl%3Adocs.oracle.com+javase+docs+api+event"><span class="kw3">Event</span></a> event<span class="br0">&#41;</span> <span class="br0">&#123;</span>
    onEventProducedListener.<span class="me1">onEventProduced</span><span class="br0">&#40;</span>event<span class="br0">&#41;</span><span class="sy0">;</span>
  <span class="br0">&#125;</span>
<span class="br0">&#125;</span></pre>
<pre class="code java"><span class="kw1">public</span> <span class="kw1">class</span> SomeActivity <span class="kw1">extends</span> Activity <span class="kw1">implements</span> OnEventProducedListener <span class="br0">&#123;</span>
  @Override
  <span class="kw1">protected</span> <span class="kw4">void</span> onCreate<span class="br0">&#40;</span>Bundle savedStateInstance<span class="br0">&#41;</span> <span class="br0">&#123;</span>
    <span class="kw1">super</span>.<span class="me1">onCreate</span><span class="br0">&#40;</span>savedInstanceState<span class="br0">&#41;</span><span class="sy0">;</span>
    FragmentManager framentManager <span class="sy0">=</span> <span class="kw1">new</span> FragmentManager<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
    FragmentTransaction fragmentTransaction <span class="sy0">=</span> fragmentManager.<span class="me1">beginTransaction</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
    fragmentTransaction.<span class="me1">add</span><span class="br0">&#40;</span>R.<span class="me1">id</span>.<span class="me1">frame</span>, <span class="kw1">new</span> SomeFragment<span class="br0">&#40;</span><span class="br0">&#41;</span>, Constants.<span class="me1">SOME_FRAGMENT_TAG</span><span class="br0">&#41;</span><span class="sy0">;</span>
    fragmentTransaction.<span class="me1">commit</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
    <span class="co1">// ...</span>
  <span class="br0">&#125;</span>
&nbsp;
  @Override
  <span class="kw1">public</span> <span class="kw4">void</span> onEventProduced<span class="br0">&#40;</span><a href="http://www.google.com/search?hl=en&amp;q=allinurl%3Adocs.oracle.com+javase+docs+api+event"><span class="kw3">Event</span></a> event<span class="br0">&#41;</span> <span class="br0">&#123;</span>
    <span class="co1">// ...</span>
  <span class="br0">&#125;</span>
<span class="br0">&#125;</span></pre>

</div>
<!-- EDIT12 SECTION "Interacțiunea dintre fragmente" [69400-71619] -->
<h2 class="sectionedit13" id="activitate_de_laborator">Activitate de Laborator</h2>
<div class="level2">

<p>
Se dorește implementarea unei aplicații Android, conținând o activitate care să ofere utilizatorilor funcționalitatea necesară pentru a stoca un număr de telefon în agenda de contacte, specificând pentru acesta mai multe informații.
</p>

<p>
<img src="../../../../_media/eim/laboratoare/laborator04/activitate_de_laborator01.png%3Fw=300&amp;tok=27a468" class="mediacenter" alt="" width="300" />
</p>

<p>
<img src="../../../../_media/eim/laboratoare/laborator04/activitate_de_laborator02.png%3Fw=300&amp;tok=92e94f" class="mediacenter" alt="" width="300" />
</p>

<p>
<strong>1.</strong> În contul Github personal, să se creeze un depozit denumit &#039;Laborator04&#039;. Acesta trebuie să conțină unui fișier <code>README.md</code>, un fișier <code>.gitignore</code> specific unei aplicații Android și un fișier <code>LICENSE</code> care să descrie condițiile pentru utilizarea aplicației.
</p>

<p>
<strong>2.</strong> Să se cloneze într-un director de pe discul local conținutul depozitului la distanță astfel creat. În urma acestei operații, directorul Laborator04 va trebui să se conțină fișierele <code>README.md</code>, <code>.gitignore</code> care indică tipurile de fișiere (extensiile) ignorate și <code>LICENSE</code>. 
</p>
<pre class="code">student@eim2016:~$ git clone https://www.github.com/perfectstudent/Laborator04</pre>

<p>
<strong>3.</strong> În directorul Laborator04 de pe discul local, să se creeze un proiect denumit <em>ContactsManager</em>.
</p>

<p>
<strong>Android Studio</strong>
</p>

<p>
Se utilizează următoarele detalii ale proiectului:
</p>
<ul>
<li class="level1"><div class="li"> <strong>Application Name</strong> - <em>Contacts Manager</em></div>
</li>
<li class="level1"><div class="li"> <strong>Company Domain</strong> - <code>lab04.eim.systems.cs.pub.ro</code></div>
</li>
<li class="level1"><div class="li"> <strong>ProjectLocation</strong></div>
</li>
<li class="level1"><div class="li"> <strong>Target Android Devices</strong> - <em>Phone and Tablet</em>, <strong>Minimum SDK</strong> - <abbr title="Application Programming Interface">API</abbr> 16: Android 4.1 (Jelly Bean)</div>
</li>
</ul>

<p>
Ceilalți parametrii de configurare sunt:
</p>
<ul>
<li class="level1"><div class="li"> <strong>Add an activity to Mobile</strong> - <em>Blank Activity</em></div>
</li>
<li class="level1"><div class="li"> <strong>Customize the Activity</strong></div>
<ul>
<li class="level2"><div class="li"> <strong>Activity Name</strong> - <em>ContactsManagerActivity</em></div>
</li>
<li class="level2"><div class="li"> <strong>Layout Name</strong> - <code>activity_contacts_manager</code></div>
</li>
<li class="level2"><div class="li"> <strong>Title</strong> - <em>ContactsManagerActivity</em></div>
</li>
<li class="level2"><div class="li"> <strong>Menu Resource Name</strong> - <code>menu_contacts_manager</code></div>
</li>
<li class="level2"><div class="li"> <strong>Use a Fragment</strong> (leave unchecked)</div>
</li>
</ul>
</li>
</ul>

<p>
<strong>Eclipse Mars</strong>
</p>

<p>
Se utilizează următoarele detalii ale proiectului:
</p>
<ul>
<li class="level1"><div class="li"> <strong>Application Name</strong> - <em>Contacts Manager</em></div>
</li>
<li class="level1"><div class="li"> <strong>Project Name</strong> - <em>ContactsManager</em></div>
</li>
<li class="level1"><div class="li"> <strong>Package Name</strong> - <code>ro.pub.cs.systems.eim.lab04.contactsmanager</code></div>
</li>
<li class="level1"><div class="li"> <strong>Minimum Required SDK</strong> - <abbr title="Application Programming Interface">API</abbr> 16: Android 4.1 (Jelly Bean)</div>
</li>
<li class="level1"><div class="li"> <strong>Target SDK</strong> - <abbr title="Application Programming Interface">API</abbr> 16: Android 4.1 (Jelly Bean)</div>
</li>
<li class="level1"><div class="li"> <strong>Compile With</strong> - <abbr title="Application Programming Interface">API</abbr> 16: Android 4.1 (Jelly Bean)</div>
</li>
<li class="level1"><div class="li"> <strong>Theme</strong> - Holo Light with Dark Action Bar</div>
</li>
</ul>

<p>
Ceilalți parametrii de configurare sunt:
</p>
<ul>
<li class="level1"><div class="li"> denumirea activității - <code>ContactsManagerActivity</code>;</div>
</li>
<li class="level1"><div class="li"> denumirea fișierului XML din <code>res/layout</code> în care va fi construită interfața grafică - <code>activity_contacts_manager</code>.</div>
</li>
</ul>

<p>
<strong>4.</strong> În fișierul <code>activity_contacts_manager</code> din directorul <code>res/layout</code> să se construiască interfața grafică folosind:
</p>
<ul>
<li class="level1"><div class="li"> editorul vizual (<em>Graphical Layout</em>)</div>
</li>
<li class="level1"><div class="li"> editorul XML (<em>Text</em>)</div>
</li>
</ul>

<p>
Acesta va fi format din două containere după cum urmează:
</p>
<ul>
<li class="level1"><div class="li"> primul conține mai multe elemente dispuse vertical și ocupând pe lățime întregul spațiu avut la dispoziție:</div>
<ul>
<li class="level2"><div class="li"> un buton (<code>Button</code>) având mesajul <em>Show Additional Fields</em> în cazul în care celălalt container nu este afișat, respectiv mesajul <em>Hide Additional Fields</em> în cazul în care celălalt container este afișat, determinând atașarea / detașarea acestuia la activitate;</div>
</li>
<li class="level2"><div class="li"> patru controale de tip câmpuri text (<code>EditText</code>) prin care se introduc:</div>
<ul>
<li class="level3"><div class="li"> numele;</div>
</li>
<li class="level3"><div class="li"> numărul de telefon - acest câmp este dezactivat (are proprietatea <code>android:enabled=“false”</code>), urmând ca valoarea sa să fie preluată din câmpul <code>extra</code> al unei intenții;</div>
</li>
<li class="level3"><div class="li"> adresa electronică;</div>
</li>
<li class="level3"><div class="li"> adresa poștală.</div>
</li>
</ul>
</li>
</ul>
</li>
<li class="level1"><div class="li"> cel de-al doilea container (care nu este vizibil inițial) conține patru controale de tip câmpuri text dispuse vertical și ocupând pe lățime întregul spațiu avut la dispoziție, prin care se introduc:</div>
<ul>
<li class="level2"><div class="li"> poziția ocupată;</div>
</li>
<li class="level2"><div class="li"> denumirea companiei;</div>
</li>
<li class="level2"><div class="li"> site-ul web;</div>
</li>
<li class="level2"><div class="li"> identificatorul pentru mesagerie instantanee.</div>
</li>
</ul>
</li>
</ul>

<p>
Să se implementeaze interacțiunea cu utilizatorul a aplicației.
</p>
<ul>
<li class="level1"><div class="li"> în metoda <code>onCreate()</code> a activității se obțin referințe către butoanele <em>Show Additional Details</em> / <em>Hide Additional Details</em>, respectiv <em>Save</em> și <em>Cancel</em> prin intermediul metodei <code>findViewById(R.id….)</code>;</div>
</li>
<li class="level1"><div class="li"> se implementează o clasă ascultător pentru butoane, care implementează <code>View.OnClickListener</code> și implementează metoda <code>onClick(View v)</code>; în funcție de id-ul butonului care este transmis argument metodei, sunt realizate următoarele acțiuni:</div>
<ul>
<li class="level2"><div class="li"> butonul <em>Show Additional Details</em> / <em>Hide Additional Details</em> - afișează / ascunde al doilea container în funcție de starea curentă , modificând corespunzător textul afișat pe buton. (Hint: atributul <code>visibility</code> al containerului, resepctiv metoda <code>setVisibility()</code> a clasei Java împreună cu constantele <code>View.VISIBLE</code>, <code>View.GONE</code>).</div>
</li>
<li class="level2"><div class="li"> butonul <em>Save</em> - lansează în execuție aplicația Android nativă pentru stocarea unui contact în agenda telefonică, după ce în prealabil au fost preluate informațiile din controalele grafice: <pre class="code java">Intent intent <span class="sy0">=</span> <span class="kw1">new</span> Intent<span class="br0">&#40;</span>ContactsContract.<span class="me1">Intents</span>.<span class="me1">Insert</span>.<span class="me1">ACTION</span><span class="br0">&#41;</span><span class="sy0">;</span>
intent.<span class="me1">setType</span><span class="br0">&#40;</span>ContactsContract.<span class="me1">RawContacts</span>.<span class="me1">CONTENT_TYPE</span><span class="br0">&#41;</span><span class="sy0">;</span>
<span class="kw1">if</span> <span class="br0">&#40;</span>name <span class="sy0">!=</span> <span class="kw2">null</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
  intent.<span class="me1">putExtra</span><span class="br0">&#40;</span>ContactsContract.<span class="me1">Intents</span>.<span class="me1">Insert</span>.<span class="me1">NAME</span>, name<span class="br0">&#41;</span><span class="sy0">;</span>
<span class="br0">&#125;</span>
<span class="kw1">if</span> <span class="br0">&#40;</span>phone <span class="sy0">!=</span> <span class="kw2">null</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
  intent.<span class="me1">putExtra</span><span class="br0">&#40;</span>ContactsContract.<span class="me1">Intents</span>.<span class="me1">Insert</span>.<span class="me1">PHONE</span>, phone<span class="br0">&#41;</span><span class="sy0">;</span>
<span class="br0">&#125;</span>
<span class="kw1">if</span> <span class="br0">&#40;</span>email <span class="sy0">!=</span> <span class="kw2">null</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
  intent.<span class="me1">putExtra</span><span class="br0">&#40;</span>ContactsContract.<span class="me1">Intents</span>.<span class="me1">Insert</span>.<span class="me1">EMAIL</span>, email<span class="br0">&#41;</span><span class="sy0">;</span>
<span class="br0">&#125;</span>
<span class="kw1">if</span> <span class="br0">&#40;</span>address <span class="sy0">!=</span> <span class="kw2">null</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
  intent.<span class="me1">putExtra</span><span class="br0">&#40;</span>ContactsContract.<span class="me1">Intents</span>.<span class="me1">Insert</span>.<span class="me1">POSTAL</span>, address<span class="br0">&#41;</span><span class="sy0">;</span>
<span class="br0">&#125;</span>
<span class="kw1">if</span> <span class="br0">&#40;</span>jobTitle <span class="sy0">!=</span> <span class="kw2">null</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
  intent.<span class="me1">putExtra</span><span class="br0">&#40;</span>ContactsContract.<span class="me1">Intents</span>.<span class="me1">Insert</span>.<span class="me1">JOB_TITLE</span>, jobTitle<span class="br0">&#41;</span><span class="sy0">;</span>
<span class="br0">&#125;</span>
<span class="kw1">if</span> <span class="br0">&#40;</span>company <span class="sy0">!=</span> <span class="kw2">null</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
  intent.<span class="me1">putExtra</span><span class="br0">&#40;</span>ContactsContract.<span class="me1">Intents</span>.<span class="me1">Insert</span>.<span class="me1">COMPANY</span>, company<span class="br0">&#41;</span><span class="sy0">;</span>
<span class="br0">&#125;</span>
ArrayList<span class="sy0">&lt;</span>ContentValues<span class="sy0">&gt;</span> contactData <span class="sy0">=</span> <span class="kw1">new</span> ArrayList<span class="sy0">&lt;</span>ContentValues<span class="sy0">&gt;</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
<span class="kw1">if</span> <span class="br0">&#40;</span>website <span class="sy0">!=</span> <span class="kw2">null</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
  ContentValues websiteRow <span class="sy0">=</span> <span class="kw1">new</span> ContentValues<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
  websiteRow.<span class="me1">put</span><span class="br0">&#40;</span>ContactsContract.<span class="me1">Data</span>.<span class="me1">MIMETYPE</span>, ContactsContract.<span class="me1">CommonDataKinds</span>.<span class="me1">Website</span>.<span class="me1">CONTENT_ITEM_TYPE</span><span class="br0">&#41;</span><span class="sy0">;</span>
  websiteRow.<span class="me1">put</span><span class="br0">&#40;</span>ContactsContract.<span class="me1">CommonDataKinds</span>.<span class="me1">Website</span>.<a href="http://www.google.com/search?hl=en&amp;q=allinurl%3Adocs.oracle.com+javase+docs+api+url"><span class="kw3">URL</span></a>, website<span class="br0">&#41;</span><span class="sy0">;</span>
  contactData.<span class="me1">add</span><span class="br0">&#40;</span>websiteRow<span class="br0">&#41;</span><span class="sy0">;</span>
<span class="br0">&#125;</span>
<span class="kw1">if</span> <span class="br0">&#40;</span>im <span class="sy0">!=</span> <span class="kw2">null</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
  ContentValues imRow <span class="sy0">=</span> <span class="kw1">new</span> ContentValues<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
  imRow.<span class="me1">put</span><span class="br0">&#40;</span>ContactsContract.<span class="me1">Data</span>.<span class="me1">MIMETYPE</span>, ContactsContract.<span class="me1">CommonDataKinds</span>.<span class="me1">Im</span>.<span class="me1">CONTENT_ITEM_TYPE</span><span class="br0">&#41;</span><span class="sy0">;</span>
  imRow.<span class="me1">put</span><span class="br0">&#40;</span>ContactsContract.<span class="me1">CommonDataKinds</span>.<span class="me1">Im</span>.<span class="me1">DATA</span>, im<span class="br0">&#41;</span><span class="sy0">;</span>
  contactData.<span class="me1">add</span><span class="br0">&#40;</span>imRow<span class="br0">&#41;</span><span class="sy0">;</span>
<span class="br0">&#125;</span>
intent.<span class="me1">putParcelableArrayListExtra</span><span class="br0">&#40;</span>ContactsContract.<span class="me1">Intents</span>.<span class="me1">Insert</span>.<span class="me1">DATA</span>, contactData<span class="br0">&#41;</span><span class="sy0">;</span>
startActivity<span class="br0">&#40;</span>intent<span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>
 Intenția pentru realizarea acestei operații are asociată acțiunea <code>ContactsContract.Intents.Insert.ACTION</code> și tipul <code>ContactsContract.RawContacts.CONTENT_TYPE</code>. Informațiile care se doresc a fi completate sunt atașate în câmpul <code>extra</code> al acesteia, având cheile:<br/>
✔ <code>ContactsContract.Intents.Insert.NAME</code>;<br/>
✔ <code>ContactsContract.Intents.Insert.PHONE</code>;<br/>
✔ <code>ContactsContract.Intents.Insert.EMAIL</code>;<br/>
✔ <code>ContactsContract.Intents.Insert.POSTAL</code>;<br/>
✔ <code>ContactsContract.Intents.Insert.JOB_TITLE</code>;<br/>
✔ <code>ContactsContract.Intents.Insert.COMPANY</code>;<br/>
Pentru site-ul web și identificatorul de mesagerie instantanee, se folosește un tablou de elemente <code>ContentValues</code> în care se specifică înregistrări de tipul <code>CommonDataKinds.Website.<abbr title="Uniform Resource Locator">URL</abbr></code>, respectiv <code>CommonDataKinds.Im.DATA</code>;<br/>
Pentru a putea gestiona agenda telefonică, este necesar ca în fișierul <code>AndroidManifest.xml</code> să fie specificate următoarele permisiuni: 
</p>
<pre class="code xml"><span class="sc3"><span class="re1">&lt;uses-permission</span></span>
<span class="sc3">  <span class="re0">android:name</span>=<span class="st0">&quot;android.permission.READ_CONTACTS&quot;</span> <span class="re2">/&gt;</span></span>
<span class="sc3"><span class="re1">&lt;uses-permission</span></span>
<span class="sc3">  <span class="re0">android:name</span>=<span class="st0">&quot;android.permission.WRITE_CONTACTS&quot;</span> <span class="re2">/&gt;</span></span></pre>
</div>
</li>
<li class="level2"><div class="li"> butonul <em>Cancel</em> - termină aplicația Android: <pre class="code java">finish<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span></pre>
</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> se înregistrează o instanță a clasei ascultător ca mecanism de tratare a evenimentelor de tip accesare a butoanelor din cadrul interfeței grafice, prin apelul metodei <code>setOnClickListener()</code>.</div>
</li>
</ul>

<p>
<strong>5.</strong> Să se modifice aplicația Android <a href="https://github.com/eim2016/Laborator03.git" class="urlextern" title="https://github.com/eim2016/Laborator03.git"  rel="nofollow">Phone Dialer</a> astfel încât să conțină un buton suplimentar prin care este invocată aplicația <em>Contacts Manager</em> căreia îi transmite numărul de telefon format și așteptând un rezultat cu privire la stocarea contactului în agenda telefonică.
</p>

<p>
<img src="../../../../_media/eim/laboratoare/laborator04/activitate_de_laborator_03.png%3Fw=300&amp;tok=8b506b" class="mediacenter" alt="" width="300" />
</p>

<p>
<img src="../../../../_media/eim/laboratoare/laborator04/activitate_de_laborator_04.png%3Fw=500&amp;tok=2432ac" class="mediacenter" alt="" width="500" />
</p>

<p>
Ca imagine pentru butonul care invocă aplicația <em>Contacts Manager</em> se poate folosi <a href="../../../../_media/eim/laboratoare/laborator04/contacts.png" class="urlextern" title="http://ocw.cs.pub.ro/courses/_media/eim/laboratoare/laborator04/contacts.png"  rel="nofollow"> această resursă</a>.
</p>

<p>
Metoda de tratare a evenimentului de tip accesare a butonului de stocare a numărului de telefon în agenda telefonică invocă o intenție asociată aplicației <em>Contacts Manager</em>, transmițând și numărul de telefon în câmpul <code>extra</code> asociat acesteia, identificabil prin intermediul unei chei. 
</p>
<pre class="code java"><span class="kw1">if</span> <span class="br0">&#40;</span>phoneNumber.<span class="me1">length</span><span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="sy0">&gt;</span> <span class="nu0">0</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
  intent <span class="sy0">=</span> <span class="kw1">new</span> Intent<span class="br0">&#40;</span><span class="st0">&quot;ro.pub.cs.systems.eim.lab04.contactsmanager.intent.action.ContactsManagerActivity&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
  intent.<span class="me1">putExtra</span><span class="br0">&#40;</span><span class="st0">&quot;ro.pub.cs.systems.eim.lab04.contactsmanager.PHONE_NUMBER_KEY&quot;</span>, phoneNumber<span class="br0">&#41;</span><span class="sy0">;</span>
  startActivityForResult<span class="br0">&#40;</span>intent, Constants.<span class="me1">CONTACTS_MANAGER_REQUEST_CODE</span><span class="br0">&#41;</span><span class="sy0">;</span>
<span class="br0">&#125;</span> <span class="kw1">else</span> <span class="br0">&#123;</span>
  Toast.<span class="me1">makeText</span><span class="br0">&#40;</span>getApplication<span class="br0">&#40;</span><span class="br0">&#41;</span>, getResources<span class="br0">&#40;</span><span class="br0">&#41;</span>.<span class="me1">getString</span><span class="br0">&#40;</span>R.<span class="me1">string</span>.<span class="me1">phone_error</span><span class="br0">&#41;</span>, Toast.<span class="me1">LENGTH_LONG</span><span class="br0">&#41;</span>.<span class="me1">show</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
<span class="br0">&#125;</span></pre>

<p>
Definiți în prealabil constanta <code>CONTACTS_MANAGER_REQUEST_CODE</code> și valoarea string <code>phone_error</code> în fișierele corespunzătoare din folderul de resurse statice <em>res</em>.
</p>

<p>
<strong>6.</strong> Să se modifice aplicația Android <em>Contacts Manager</em> astfel încât să poată fi lansată în execuție doar din contextul altei activități, prin intermediul unei intenții care conține în câmpul <code>extra</code> un număr de telefon, identificabil prin cheia <code>ro.pub.cs.systems.eim.lab04.contactsmanager.PHONE_NUMBER_KEY</code>, acesta fiind plasat în câmpul text needitabil corespunzător. Totodată, va transmite înapoi rezultatul operației de stocare (<code>Activity.RESULT_OK</code> sau <code>Activity.RESULT_CANCELED</code>).
</p>
<ul>
<li class="level1"><div class="li"> în fișierul <code>AndroidManifest.xml</code> se modifică filtrul de intenții (acțiunea și categoria), astfel încât activitatea să poată fi rulată doar prin intermediul unei intenții <dl class="file">
<dt><a href="../../../code/eim/laboratoare/laborator04%3Fcodeblock=54" title="Download Snippet" class="mediafile mf_xml">AndroidManifest.xml</a></dt>
<dd><pre class="code file xml"><span class="sc3"><span class="re1">&lt;manifest</span> ...<span class="re2">&gt;</span></span>
  <span class="sc3"><span class="re1">&lt;application</span> ...<span class="re2">&gt;</span></span>
    <span class="sc3"><span class="re1">&lt;activity</span></span>
<span class="sc3">      <span class="re0">android:name</span>=<span class="st0">&quot;.graphicuserinterface.ContactsManagerActivity&quot;</span></span>
<span class="sc3">      <span class="re0">android:label</span>=<span class="st0">&quot;@string/app_name&quot;</span> <span class="re2">&gt;</span></span>
      <span class="sc3"><span class="re1">&lt;intent-filter<span class="re2">&gt;</span></span></span>
        <span class="sc3"><span class="re1">&lt;action</span> <span class="re0">android:name</span>=<span class="st0">&quot;ro.pub.cs.systems.eim.lab04.contactsmanager.intent.action.ContactsManagerActivity&quot;</span> <span class="re2">/&gt;</span></span>
        <span class="sc3"><span class="re1">&lt;category</span> <span class="re0">android:name</span>=<span class="st0">&quot;android.intent.category.DEFAULT&quot;</span> <span class="re2">/&gt;</span></span>
      <span class="sc3"><span class="re1">&lt;/intent-filter<span class="re2">&gt;</span></span></span>
    <span class="sc3"><span class="re1">&lt;/activity<span class="re2">&gt;</span></span></span>
  <span class="sc3"><span class="re1">&lt;/application<span class="re2">&gt;</span></span></span>
<span class="sc3"><span class="re1">&lt;/manifest<span class="re2">&gt;</span></span></span></pre>
</dd></dl>
</div>
</li>
<li class="level1"><div class="li"> în metoda <code>onCreate()</code> a activității aplicației <code>ContactsManager</code> este verificată intenția cu care este pornită, și în cazul în care aceasta nu este nulă, este preluată informația din secțiunea <code>extra</code>, identificată prin cheia <code>ro.pub.cs.systems.eim.lab04.contactsmanager.PHONE_NUMBER_KEY</code>, conținutul său fiind plasat în cadrul câmpului text corespunzător: <pre class="code java">Intent intent <span class="sy0">=</span> getIntent<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
<span class="kw1">if</span> <span class="br0">&#40;</span>intent <span class="sy0">!=</span> <span class="kw2">null</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
  <a href="http://www.google.com/search?hl=en&amp;q=allinurl%3Adocs.oracle.com+javase+docs+api+string"><span class="kw3">String</span></a> phone <span class="sy0">=</span> intent.<span class="me1">getStringExtra</span><span class="br0">&#40;</span><span class="st0">&quot;ro.pub.cs.systems.eim.lab04.contactsmanager.PHONE_NUMBER_KEY&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
  <span class="kw1">if</span> <span class="br0">&#40;</span>phone <span class="sy0">!=</span> <span class="kw2">null</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
    phoneEditText.<span class="me1">setText</span><span class="br0">&#40;</span>phone<span class="br0">&#41;</span><span class="sy0">;</span>
  <span class="br0">&#125;</span> <span class="kw1">else</span> <span class="br0">&#123;</span>
    Toast.<span class="me1">makeText</span><span class="br0">&#40;</span><span class="kw1">this</span>, activity.<span class="me1">getResources</span><span class="br0">&#40;</span><span class="br0">&#41;</span>.<span class="me1">getString</span><span class="br0">&#40;</span>R.<span class="me1">string</span>.<span class="me1">phone_error</span><span class="br0">&#41;</span>, Toast.<span class="me1">LENGTH_LONG</span><span class="br0">&#41;</span>.<span class="me1">show</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
  <span class="br0">&#125;</span>
<span class="br0">&#125;</span> </pre>
</div>
</li>
<li class="level1"><div class="li"> pe metodele de tratare a evenimentelor de accesare a butoanelor:</div>
<ul>
<li class="level2"><div class="li"> <em>Save</em> - este lansată în execuție aplicația nativă pentru gestiunea agendei telefonice, folosind un cod de cerere prin intermediul căruia se va verifica rezultatul furnizat: <pre class="code java">startActivityForResult<span class="br0">&#40;</span>intent, Constants.<span class="me1">CONTACTS_MANAGER_REQUEST_CODE</span><span class="br0">&#41;</span><span class="sy0">;</span></pre>
</div>
</li>
<li class="level2"><div class="li"> <em>Cancel</em> - se transmite înapoi rezultatul <pre class="code java">setResult<span class="br0">&#40;</span>Activity.<span class="me1">RESULT_CANCELED</span>, <span class="kw1">new</span> Intent<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy0">;</span></pre>
</div>
</li>
</ul>
</li>
</ul>
<ul>
<li class="level1"><div class="li"> în metoda <code>onActivityResult()</code> asociată activității aplicației <em>ContactsManager</em>, în momentul în care s-a părăsit aplicația nativă pentru gestiunea agendei telefonice, se verifică codul de cerere și se transmite înapoi un rezultat: <pre class="code java"><span class="kw1">public</span> <span class="kw4">void</span> onActivityResult<span class="br0">&#40;</span><span class="kw4">int</span> requestCode, <span class="kw4">int</span> resultCode, Intent intent<span class="br0">&#41;</span> <span class="br0">&#123;</span>
<span class="kw1">switch</span><span class="br0">&#40;</span>requestCode<span class="br0">&#41;</span> <span class="br0">&#123;</span>
  <span class="kw1">case</span> Constants.<span class="me1">CONTACTS_MANAGER_REQUEST_CODE</span><span class="sy0">:</span>
    setResult<span class="br0">&#40;</span>resultCode, <span class="kw1">new</span> Intent<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy0">;</span>
    finish<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
    <span class="kw1">break</span><span class="sy0">;</span>
  <span class="br0">&#125;</span>
<span class="br0">&#125;</span></pre>
</div>
</li>
</ul>

<p>
<strong>7.</strong>  Să se încarce modificările realizate în cadrul depozitului &#039;Laborator04&#039; de pe contul Github personal, folosind un mesaj sugestiv. 
</p>
<pre class="code">student@eim2016:~/Laborator04$ git add *
student@eim2016:~/Laborator04$ git commit -m &quot;implemented taks for laboratory 04&quot;
student@eim2016:~/Laborator04$ git push origin master</pre>

</div>
<!-- EDIT13 SECTION "Activitate de Laborator" [71620-84395] -->
<h2 class="sectionedit14" id="resurse_utile">Resurse Utile</h2>
<div class="level2">

<p>
<a href="http://ptgmedia.pearsoncmg.com/images/9780321940261/samplepages/0321940261.pdf" class="urlextern" title="http://ptgmedia.pearsoncmg.com/images/9780321940261/samplepages/0321940261.pdf"  rel="nofollow">Joseph ANNUZZI, Jr, Lauren DARCEY, Shane CONDER, Introduction to Android Application Development - Developer&#039;s Library, 4th Edition, Addison-Wesley, 2013</a> - capitolul 4, subcapitolele <em>Organizing Activity Components with Fragments</em>, <em>Managing Activity Transition with Intents</em>, <em>Working with Services</em>, <em>Receiving and Broadcasting Intents</em><br/>

<a href="http://www.bignerdranch.com/we-write/android-programming/" class="urlextern" title="http://www.bignerdranch.com/we-write/android-programming/"  rel="nofollow">Bill PHILLIPS, Brian HARDY, Android Programming. The Big Nerd Ranch Guide, Pearson Technology Group, 2013</a> - capitolele 5, 7, 10, 21, 23, 29, 30<br/>

<a href="http://www.amazon.com/Professional-Android-4-Application-Development/dp/1118102274" class="urlextern" title="http://www.amazon.com/Professional-Android-4-Application-Development/dp/1118102274"  rel="nofollow">Reto MEIER, Professional Android for Application Development, John Wiley &amp; Sons, 2012</a> - capitolul 4 (<em>Introducing Fragments</em>), 5 (<em>Introducing Intents</em>)<br/>

<a href="http://books.google.ro/books/about/The_Android_Developer_s_Cookbook.html?id=Y4JR2yI2Fo0C&amp;redir_esc=y" class="urlextern" title="http://books.google.ro/books/about/The_Android_Developer_s_Cookbook.html?id=Y4JR2yI2Fo0C&amp;redir_esc=y"  rel="nofollow">Ronan SCHWARZ, Phil DUTSON, James STEELE, Nelson TO, Android Developer&#039;s Cookbook, Building Applications with the Android SDK, 2nd Edition, Addison Wesley, 2013</a> - capitolele 2, 7<br/>

<a href="http://eu.wiley.com/WileyCDA/WileyTitle/productCd-1118199545.html" class="urlextern" title="http://eu.wiley.com/WileyCDA/WileyTitle/productCd-1118199545.html"  rel="nofollow">Wei Meng LEE, Beginning Android 4 Application Development, Wiley, 2012</a><br/>

<a href="http://www.apress.com/9781430239307" class="urlextern" title="http://www.apress.com/9781430239307"  rel="nofollow">Satya KOMATINENI, Dave MACLEAN, Pro Android 4, Apress, 2012</a><br/>

<a href="http://android.rosedu.org/wiki/" class="urlextern" title="http://android.rosedu.org/wiki/"  rel="nofollow">Dezvoltarea aplicațiilor pentru Android</a><br/>

<a href="http://www.coreservlets.com/android-tutorial" class="urlextern" title="http://www.coreservlets.com/android-tutorial"  rel="nofollow">Android Programming Tutorials - Core Servlets</a> - secțiunile Intents - part I, II &amp; III<br/>

<a href="http://www.vogella.com/tutorials/AndroidIntent/article.html" class="urlextern" title="http://www.vogella.com/tutorials/AndroidIntent/article.html"  rel="nofollow">Android Intents - Tutorial</a>
</p>

</div>
<!-- EDIT14 SECTION "Resurse Utile" [84396-] --></div>
</body>
</html>
