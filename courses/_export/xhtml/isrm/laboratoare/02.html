    
    

<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
  <meta charset="utf-8" />
  <title>isrm:laboratoare:02</title>
<meta name="generator" content="DokuWiki"/>
<meta name="robots" content="index,follow"/>
<meta name="date" content="2016-10-12T09:49:10+0300"/>
<meta name="keywords" content="isrm,laboratoare,02"/>
<link rel="search" type="application/opensearchdescription+xml" href="../../../../lib/exe/opensearch.php" title="CS Open CourseWare"/>
<link rel="start" href="../../../../../courses.1.html"/>
<link rel="alternate" type="application/rss+xml" title="Recent Changes" href="../../../../feed.php"/>
<link rel="alternate" type="application/rss+xml" title="Current Namespace" href="../../../../feed.php%3Fmode=list&amp;ns=isrm:laboratoare"/>
<link rel="alternate" type="text/html" title="Plain HTML" href="02.html"/>
<link rel="canonical" href="../../../../isrm/laboratoare/02.html"/>
<link rel="stylesheet" type="text/css" href="../../../../lib/exe/css.php%3Ft=arctic&amp;tseed=1476798676.css"/>
<script type="text/javascript">/*<![CDATA[*/var NS='isrm:laboratoare';var JSINFO = {"id":"isrm:laboratoare:02","namespace":"isrm:laboratoare","isadmin":0,"isauth":0};
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="../../../../lib/exe/js.php%3Ftseed=1476798676"></script>
<script type="text/x-mathjax-config">/*<![CDATA[*/MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ["$","$"], ["\\(","\\)"] ],
        displayMath: [ ["$$","$$"], ["\\[","\\]"] ],
        processEscapes: true
    }
});
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
<script type="text/javascript">/*<![CDATA[*/
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
		  
/*!]]>*/</script>
<script type="text/javascript">/*<![CDATA[*/
var pageTracker = _gat._getTracker("UA-38383934-1");
pageTracker._initData();
pageTracker._trackPageview();
		  
/*!]]>*/</script>
</head>
<body>
<div class="dokuwiki export">

<h3 class="sectionedit1" id="laboratorul_2">Laboratorul 2</h3>
<div class="level3">

</div>

<h5 id="introducere_in_gnuplot">Introducere în gnuplot</h5>
<div class="level5">
<ul>
<li class="level1"><div class="li"> <a href="http://www.gnuplotting.org/plotting-data/" class="urlextern" title="http://www.gnuplotting.org/plotting-data/"  rel="nofollow"> introducere în gnuplot </a></div>
</li>
<li class="level1"><div class="li"> <strong>Exercițiul 1</strong> realizați folosind <code>gnuplot</code> graficul din laboratorul 1. Indicați semnificațiile axelor și legenda. Salvați imaginea în format <code>png/svg</code>, și scriptul pentru restaurarea imaginilor.</div>
<ul>
<li class="level3"><div class="li"> Exemplu<pre class="code">plot &#039;out.tr&#039; using 1:2 t &quot;TCP&quot; with lp, \
     &#039;out.tr&#039; using 1:3 t &quot;UDP&quot; with lines lw 3
set xlabel &#039;Time[s]&#039;
set ylabel &#039;Bandwidth[Mbps]&#039;
set grid ytics
set term png
set out &#039;lab02bw.png&#039; 
replot
save &#039;lab02bw.plot&#039;  # se va putea reface graficul cu gnuplot ./lab02bw.plot</pre>

<p>
  <a href="../../../../_detail/isrm/laboratoare/02/lab02bw.png%3Fid=isrm%253Alaboratoare%253A02.html" class="media" title="isrm:laboratoare:02:lab02bw.png"><img src="../../../../_media/isrm/laboratoare/02/lab02bw.png%3Fw=300&amp;tok=de0911" class="media" alt="" width="300" /></a>
</p>
</div>
</li>
</ul>
</li>
</ul>

</div>

<h5 id="introducere_in_awk">Introducere în awk</h5>
<div class="level5">
<ul>
<li class="level1"><div class="li"> AWK (K vine de la Kernighan) este mic, simplu, și rapid, spre deosebire de perl sau python. Nu poți face tot ce faci în perl/python, dar poți face foarte ușor multe taskuri de procesare de text. Are o sintaxă apropiată de C, dar preferă datele organizate pe coloane, ca foarte multe date în rețelistică: trace-uri de simulare, tcpdump, loguri, etc. Un mare avantaj este ca poate fi rulat direct de pe linia de comandă, fără a mai folosi un script separat - de multe ori apare într-un pipeline cu cat, sed, tr.      </div>
</li>
<li class="level2"><div class="li"> În cazul cel mai des întâlnit, se specifică un program care este rulat succesiv pentru fiecare linie de intrare: <pre class="code">cat trace.out | awk &#039;{print $2}&#039;</pre>

<p>
 afișează coloana a doua a fiecărei linii. De exemplu, pentru acest fișier: 
</p>
<dl class="file">
<dt><a href="../../../code/isrm/laboratoare/02%3Fcodeblock=2" title="Download Snippet" class="mediafile mf_out">trace.out</a></dt>
<dd><pre class="code file txt">10 2    0.2
11 3 0.3
12 2 0.2
&nbsp;
13 3 0.1
14 4 0.05 </pre>
</dd></dl>
</div>
</li>
<li class="level2"><div class="li"> <pre class="code">cat trace.out | awk &#039;{print $1+$2, $2 $3, i++;}&#039;</pre>

<p>
 produce 
</p>
<pre class="code">12 20.2 0
14 30.3 1
14 20.2 2
0  3
16 30.1 4
18 40.05 5 </pre>
</div>
</li>
<li class="level2"><div class="li"> Din acest exemplu se observă că:</div>
<ul>
<li class="level3"><div class="li"> caracterul $ trebuie protejat de shell </div>
</li>
<li class="level3"><div class="li"> separatorul implicit este (tab|spațiu)+</div>
</li>
<li class="level3"><div class="li"> variabilele sunt inițializate la 0, și își păstrează valoarea de la o linie la alta</div>
</li>
<li class="level3"><div class="li"> câmpurile inexistente ale unei linii sunt șirul vid </div>
</li>
<li class="level3"><div class="li"> tipurile sunt slabe - int, float, string, din context  </div>
</li>
<li class="level3"><div class="li"> spațiu este operator de concatenare pe stringuri</div>
</li>
</ul>
</li>
<li class="level2"><div class="li"> <pre class="code">cat trace.out | awk &#039;NF==3 { s+=$3; n++} /1[2-3]/{print $0} END{print  n, s/n}&#039;</pre>

<p>
 produce 
</p>
<pre class="code">12 2 0.2
13 3 0.1
5 0.17 </pre>
</div>
</li>
<li class="level2"><div class="li"> Din acest exemplu se observă că:</div>
<ul>
<li class="level3"><div class="li"> există variabile predefinite NF= number of fields(each line); NR=number of records; $0 = toată linia  </div>
</li>
<li class="level3"><div class="li"> se pot rula mai multe programe per linie, dacă sunt activate de condiții logice/regex. Pentru o linie se execută TOATE programele care se pot activa. </div>
</li>
<li class="level3"><div class="li"> există secțiunea BEGIN{} care se rulează o singură dată înainte de input, și END{} la sfârșit </div>
</li>
<li class="level3"><div class="li"> sunt disponibile multe funcții de bibliotecă: printf, sqrt, substr, xor - vedeți <a href="https://linux.die.net/man/1/awk" class="urlextern" title="https://linux.die.net/man/1/awk"  rel="nofollow">man awk</a></div>
</li>
</ul>
</li>
</ul>


<ol>
<li class="level1"><div class="li"> <strong>Exercițiul 2</strong>: În laboratorul 1, folosiți <pre class="code tcl"><span class="re0">$tcp</span> attach <span class="br0">&#91;</span><span class="kw2">open</span> tcp.tr w<span class="br0">&#93;</span>
<span class="re0">$tcp</span> trace cwnd_
<span class="re0">$tcp</span> trace rtt_ </pre>
</div>
</li>
</ol>

<p>
pentru a explora relația dintre lungimea cozii la bottleneck (link n2 n3), RTT-ul perceput de TCP, și fracțiunea de debit obținută în concurență cu UDP.
</p>
<ul>
<li class="level1"><div class="li"> Rulați pentru valori ale cozii: 5, 15, 50</div>
</li>
<li class="level4"><div class="li"> De ce debitele obținute nu sunt stabile? </div>
</li>
<li class="level4"><div class="li"> De ce apar debite UDP mai mari ca 1Mbps?</div>
</li>
<li class="level4"><div class="li"> Care este relația dintre RTT și debite? </div>
</li>
</ul>

</div>

<h5 id="ns-2_wireless">ns-2 wireless</h5>
<div class="level5">

<p>
Citiți <a href="http://www.mathcs.emory.edu/~cheung/Courses/558-old/Syllabus/90-NS/4-Wireless/intro.html" class="urlextern" title="http://www.mathcs.emory.edu/~cheung/Courses/558-old/Syllabus/90-NS/4-Wireless/intro.html"  rel="nofollow"> ns2 wireless tutorial </a>
</p>
<ul>
<li class="level1"><div class="li"> Exemple de linii din trace cu newtrace:<pre class="code">r -t 0.016905500 -Hs 1 -Hd -2 -Ni 1 -Nx 0.00 -Ny 75.00 -Nz 0.00 -Ne -1.000000 -Nl MAC -Nw --- -Ma 0 -Md 1 -Ms 0 -Mt ACK 
d -t 1.804824308 -Hs 2 -Hd 2 -Ni 2 -Nx 75.00 -Ny 0.00 -Nz 0.00 -Ne -1.000000 -Nl MAC -Nw COL -Ma 13a -Md 2 -Ms 0 -Mt cbr -Is 0.0 -Id 2.1 -It cbr -Il 1590 -If 0 -Ii 144 -Iv 32 -Pn cbr -Pi 34 -Pf 0 -Po 0</pre>
</div>
</li>
<li class="level2"><div class="li">  Fiecare linie descrie un eveniment de trimitere, primire, dirijare, sau dropare a unui pachet. Câmpurile cele mai importante dintr-o linie a fișierului trace sunt: <pre class="code">s: Send
r: Receive
d: Drop
f: Forward 

-t 	double 	Time (* For Global Setting)
-Ni 	int 	Node ID
-Nx 	double 	Node X Coordinate
-Ny 	double 	Node Y Coordinate
-Nz 	double 	Node Z Coordinate
-Ne 	double 	Node Energy Level
-Nl 	string 	Network trace Level (AGT, RTR, MAC, etc.)
-Nw 	string 	Drop Reason
-Hs 	int 	Hop source node ID
-Hd 	int 	Hop destination Node ID, -1, -2
-Ma 	hexadecimal	Duration
-Ms 	hexadecimal	Source Ethernet Address
-Md 	hexadecimal	Destination Ethernet Address
-Mt 	hexadecimal	Ethernet Type
-P 	string 	Packet Type (arp, dsr, imep, tora, etc.)
-Pn 	string 	Packet Type (cbr, tcp) 
-Ps     sequence number (pentru tcp, coloana 47)</pre>
</div>
<ul>
<li class="level3"><div class="li"> detaliu <a href="http://www.isi.edu/nsnam/ns/doc/node186.html" class="urlextern" title="http://www.isi.edu/nsnam/ns/doc/node186.html"  rel="nofollow">http://www.isi.edu/nsnam/ns/doc/node186.html</a></div>
</li>
</ul>
</li>
</ul>
<ol>
<li class="level1"><div class="li"> Exercițiul 3: modificați <code>simple-wireless.tcl</code> din Marc Greis sec IX pentru </div>
<ul>
<li class="level2"><div class="li"> a utiliza noul format de trace ( cu <code>$ns_ use-newtrace</code>)</div>
</li>
<li class="level2"><div class="li"> a monitoriza evenimentele de la nivelele 2 și 4 (agent și MAC)</div>
</li>
<li class="level2"><div class="li"> a avea o coadă de doar 10 pachete în interfața wireless</div>
</li>
<li class="level2"><div class="li"> identificați în trace cadrele de tip CTS, ACK, ack, tcp. </div>
</li>
<li class="level2"><div class="li"> la ce moment începe transferul propriuzis (nodurile sunt suficient de aproape pentru a schimba cadre)? <sup><a href="02.html#fn__1" id="fnt__1" class="fn_top">1)</a></sup></div>
</li>
<li class="level2"><div class="li"> Desenați o diagramă cu transferul unui segment TCP între noduri, indicând tipurile cadrelor/pachetelor.    </div>
</li>
<li class="level2"><div class="li"> calculați numărul de cadre de date(tcp)pierdute de fiecare nod la nivelul 2 - MAC  <sup><a href="02.html#fn__2" id="fnt__2" class="fn_top">2)</a></sup></div>
</li>
<li class="level2"><div class="li"> calculați numărul de cadre de date(tcp)pierdute de fiecare nod la nivelul 3 - IFQ  <sup><a href="02.html#fn__3" id="fnt__3" class="fn_top">3)</a></sup></div>
</li>
<li class="level2"><div class="li"> justificați diferențele <sup><a href="02.html#fn__4" id="fnt__4" class="fn_top">4)</a></sup></div>
</li>
<li class="level2"><div class="li"> comparați pierderile între pachetele tcp și ack <sup><a href="02.html#fn__5" id="fnt__5" class="fn_top">5)</a></sup></div>
</li>
<li class="level2"><div class="li"> comparați pierderile între cadrele ACK și RTS <sup><a href="02.html#fn__6" id="fnt__6" class="fn_top">6)</a></sup></div>
</li>
<li class="level2"><div class="li"> justificați diferențele</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> dezactivați RTS/CTS folosind <pre class="code">Mac/802_11 set RTSThreshold_    3000</pre>

<p>
 și comparați performanța TCP cu cazul precendent. Sugestie: plotați evoluția în timp a numerelor de secvență   <sup><a href="02.html#fn__7" id="fnt__7" class="fn_top">7)</a></sup>
</p>
</div>
<ul>
<li class="level2"><div class="li"> <pre class="code"> cat simple.tr | grep &#039;^r&#039;  | grep AGT | grep tcp | grep -v ack | awk &#039;{print $3, $47}&#039; </pre>
</div>
</li>
<li class="level2"><div class="li"> <a href="../../../../_detail/isrm/laboratoare/02/lab02tcp_rts.png%3Fid=isrm%253Alaboratoare%253A02.html" class="media" title="isrm:laboratoare:02:lab02tcp_rts.png"><img src="../../../../_media/isrm/laboratoare/02/lab02tcp_rts.png%3Fw=300&amp;tok=9cea5f" class="media" alt="" width="300" /></a> </div>
</li>
</ul>
</li>
</ol>

</div>
<div class="footnotes">
<div class="fn"><sup><a href="02.html#fnt__1" id="fn__1" class="fn_bot">1)</a></sup> 
cat simple.tr | grep  &#039;^r.*AGT.*ack.*tcp&#039; | awk &#039;{print \$3, \$47}&#039;| head </div>
<div class="fn"><sup><a href="02.html#fnt__2" id="fn__2" class="fn_bot">2)</a></sup> 
 cat simple.tr | grep &#039;^d&#039; | grep MAC | grep &#039;tcp&#039;  | grep -v &#039;ack&#039; | wc -l</div>
<div class="fn"><sup><a href="02.html#fnt__3" id="fn__3" class="fn_bot">3)</a></sup> 
 cat simple.tr | grep &#039;^d&#039; | grep IFQ | grep &#039;tcp&#039;  | grep -v &#039;ack&#039; | wc -l</div>
<div class="fn"><sup><a href="02.html#fnt__4" id="fn__4" class="fn_bot">4)</a></sup> 
 
atenție, avem cadre ACK, tcp fără ack , tcp și ack. ACK sunt confirmări 802.11, ack sunt confirmări TCP. 
Se pierd 11 cadre TCP/date (linii cu tcp, dar fără ack) la nivelul 2, și 83 sunt aruncate din coadă. Dacă destinația nu mai 
răspunde în aer, 802.11 ajunge la maximum retries, apoi trece la următorul pachet. TCP însă nu trece mai departe după pierdere. 
Când destinația iese din zona de comunicare, TCP continuă să trimită deoarece are fereastră suficientă, și se pierde din coadă.  
</div>
<div class="fn"><sup><a href="02.html#fnt__5" id="fn__5" class="fn_bot">5)</a></sup> 
 un ack se generează ca răspuns la un tcp. Dacă tcp sunt pierdute la transmisie (coadă sau aer), se generează mai puține ack</div>
<div class="fn"><sup><a href="02.html#fnt__6" id="fn__6" class="fn_bot">6)</a></sup> 
 ACK=0 pierderi, RTS=14 pierderi. Dacă nodurile sunt în apropiere, conversația RTS-CTS-Date-ACK se desfășoară cu bine, nu se pierd ACK-uri. La distanță mare, destinația nu răspunde la RTS, deci sunt pierdute, și nu se mai ajunge la ACK.</div>
<div class="fn"><sup><a href="02.html#fnt__7" id="fn__7" class="fn_bot">7)</a></sup> 
Numărul de secvență în timp este de fapt throughput. RTS-CTS introduce un overhead, de fapt timp pierdut, care duce la un throughput redus. </div>
</div>
</div>
</body>
</html>
