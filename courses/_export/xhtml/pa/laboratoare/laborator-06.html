    
    

<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
  <meta charset="utf-8" />
  <title>pa:laboratoare:laborator-06</title>
<meta name="generator" content="DokuWiki"/>
<meta name="robots" content="index,follow"/>
<meta name="date" content="2016-04-07T00:39:51+0300"/>
<meta name="keywords" content="pa,laboratoare,laborator-06"/>
<link rel="search" type="application/opensearchdescription+xml" href="../../../../lib/exe/opensearch.php" title="CS Open CourseWare"/>
<link rel="start" href="../../../../../courses.1.html"/>
<link rel="alternate" type="application/rss+xml" title="Recent Changes" href="../../../../feed.php"/>
<link rel="alternate" type="application/rss+xml" title="Current Namespace" href="../../../../feed.php%3Fmode=list&amp;ns=pa:laboratoare"/>
<link rel="alternate" type="text/html" title="Plain HTML" href="laborator-06.html"/>
<link rel="canonical" href="../../../../pa/laboratoare/laborator-06.html"/>
<link rel="stylesheet" type="text/css" href="../../../../lib/exe/css.php%3Ft=arctic&amp;tseed=1476798676.css"/>
<script type="text/javascript">/*<![CDATA[*/var NS='pa:laboratoare';var JSINFO = {"id":"pa:laboratoare:laborator-06","namespace":"pa:laboratoare","isadmin":0,"isauth":0};
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="../../../../lib/exe/js.php%3Ftseed=1476798676"></script>
<script type="text/x-mathjax-config">/*<![CDATA[*/MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ["$","$"], ["\\(","\\)"] ],
        displayMath: [ ["$$","$$"], ["\\[","\\]"] ],
        processEscapes: true
    }
});
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
<script type="text/javascript">/*<![CDATA[*/
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
		  
/*!]]>*/</script>
<script type="text/javascript">/*<![CDATA[*/
var pageTracker = _gat._getTracker("UA-38383934-1");
pageTracker._initData();
pageTracker._trackPageview();
		  
/*!]]>*/</script>
</head>
<body>
<div class="dokuwiki export">
<!-- TOC START -->
<div id="dw__toc">
<h3 class="toggle">Table of Contents</h3>
<div>

<ul class="toc">
<li class="level1"><div class="li"><a href="laborator-06.html#laborator_6parcurgerea_grafurilor_sortare_topologica">Laborator 6: Parcurgerea Grafurilor. Sortare Topologica</a></div>
<ul class="toc">
<li class="level2"><div class="li"><a href="laborator-06.html#obiective_laborator">Obiective laborator</a></div></li>
<li class="level2"><div class="li"><a href="laborator-06.html#importanta_aplicatii_practice">Importanţă – aplicaţii practice</a></div></li>
<li class="level2"><div class="li"><a href="laborator-06.html#descrierea_problemei_si_a_rezolvarilor">Descrierea problemei și a rezolvărilor</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="laborator-06.html#parcurgerea_in_latime_-_bfs">Parcurgerea in lățime - BFS</a></div></li>
<li class="level3"><div class="li"><a href="laborator-06.html#parcurgerea_in_adancime_dfs">Parcurgerea in adancime – DFS</a></div></li>
<li class="level3"><div class="li"><a href="laborator-06.html#sortarea_topologica">Sortarea Topologica</a></div></li>
</ul>
</li>
<li class="level2"><div class="li"><a href="laborator-06.html#concluzii_si_observatii">Concluzii si observatii</a></div></li>
<li class="level2"><div class="li"><a href="laborator-06.html#referinte">Referinte</a></div></li>
<li class="level2"><div class="li"><a href="laborator-06.html#resurse">Resurse</a></div></li>
<li class="level2"><div class="li"><a href="laborator-06.html#probleme">Probleme</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="laborator-06.html#help_me_escape_5p">1. Help me escape! [5p]</a></div></li>
<li class="level3"><div class="li"><a href="laborator-06.html#ordinea_de_studiere_a_materiilor_5p">2. Ordinea de studiere a materiilor [5p]</a></div></li>
<li class="level3"><div class="li"><a href="laborator-06.html#bonus_1p">3.	Bonus [1p]</a></div></li>
</ul></li>
</ul></li>
</ul>
</div>
</div>
<!-- TOC END -->

<h1 class="sectionedit1" id="laborator_6parcurgerea_grafurilor_sortare_topologica">Laborator 6: Parcurgerea Grafurilor. Sortare Topologica</h1>
<div class="level1">

</div>
<!-- EDIT1 SECTION "Laborator 6: Parcurgerea Grafurilor. Sortare Topologica" [1-71] -->
<h2 class="sectionedit2" id="obiective_laborator">Obiective laborator</h2>
<div class="level2">
<ul>
<li class="level1"><div class="li">Intelegerea conceptului de graf si a modurilor de parcurgere aferente</div>
</li>
<li class="level1"><div class="li">Utilitatea si aplicabilitatea sortarii topologice</div>
</li>
</ul>

</div>
<!-- EDIT2 SECTION "Obiective laborator" [72-231] -->
<h2 class="sectionedit3" id="importanta_aplicatii_practice">Importanţă – aplicaţii practice</h2>
<div class="level2">

<p>
Grafurile sunt utile pentru a modela diverse probleme si se regasesc implementati in multiple aplicatii practice:
</p>
<ul>
<li class="level1"><div class="li">Retele de calculatoare (ex: stabilirea unei topologii fara bucle)</div>
</li>
<li class="level1"><div class="li">Pagini Web (ex: Google PageRank [1])</div>
</li>
<li class="level1"><div class="li">Retele sociale (ex: calcul centralitate [2])</div>
</li>
<li class="level1"><div class="li">Harti cu drumuri (ex: drum minim)</div>
</li>
<li class="level1"><div class="li">Modelare grafica (ex: prefuse [3], graph-cut [4] )</div>
</li>
</ul>

</div>
<!-- EDIT3 SECTION "Importanţă – aplicaţii practice" [232-645] -->
<h2 class="sectionedit4" id="descrierea_problemei_si_a_rezolvarilor">Descrierea problemei și a rezolvărilor</h2>
<div class="level2">

<p>
Graful poate fi modelat drept o pereche de multimi G = (V, E). Multimea V contine nodurile grafului (vertices), iar multimea E contine muchiile (edges), fiecare muchie stabilind o relatie de vecinatate intre doua noduri. O mare varietate de probleme se modeleaza folosind grafuri, iar rezolvarea acestora presupune explorarea spatiului. O parcurgere isi propune sa ia in discutie fiecare nod al grafului, exact o singura data, pornind de la un nod ales, numit in continuare nod sursa.
</p>

<p>
Reprezentarea in memorie a grafurilor se face, de obicei, cu liste de adiacenta sau cu matrice de adiacenta. Se pot folosi insa si alte structuri de date, de exemplu un map de perechi &lt; &lt;sursa,destinatie&gt;,cost&gt; .
</p>

<p>
Pe parcursul rularii algoritmilor de parcurgere, un nod poate avea 3 culori:
</p>
<ul>
<li class="level1"><div class="li">Alb = nedescoperit</div>
</li>
<li class="level1"><div class="li">Gri = a fost descoperit si este in curs de prcesare</div>
</li>
<li class="level1"><div class="li">Negru = a fost procesat</div>
</li>
</ul>

<p>
Se poate face o analogie cu o pata neagra care se extinde pe un spatiu alb. Nodurile gri se afla pe frontiera petei negre.
Algoritmii de parcurgere pot fi caracterizati prin completitudine si optimalitate. Un algoritm de explorare complet va descoperi intotdeauna o solutie, daca problema accepta solutie. Un algoritm de explorare optimal va descoperi solutia optima a problemei din perspectiva numarului de pasi care trebuie efectuati.
</p>

</div>
<!-- EDIT4 SECTION "Descrierea problemei și a rezolvărilor" [646-2020] -->
<h3 class="sectionedit5" id="parcurgerea_in_latime_-_bfs">Parcurgerea in lățime - BFS</h3>
<div class="level3">

<p>
Parcurgerea in latime <strong>(Breadth-first Search - BFS)</strong> este un algoritm de cautare in graf, in care, atunci cand se ajunge intr-un nod oarecare v, nevizitat, se viziteaza toate nodurile nevizitate adiacente lui v, apoi toate varfurile nevizitate adiacente varfurilor adiacente lui v, etc.
Atentie! BFS depinde de nodul de start. Plecand dintr-un nod se va parcurge doar componenta conexa din care acesta face parte. Pentru grafuri cu mai multe componente conexe se vor obtine mai multi arbori de acoperire.
</p>

<p>
In urma aplicarii algoritmului BFS asupra fiecarei componente conexe a grafului, se obtine un arbore de acoperire (prin eliminarea muchiilor pe care nu le folosim la parcurgere). Pentru a putea reconstitui acest arbore, se pastreaza pentru fiecare nod dat identitatea parintelui sau. In cazul in care nu exista o functie de cost asociata muchiilor, BFS va determina si drumurile minime de la radacina la oricare nod.
</p>

<p>
Pentru implementarea BFS se foloseste o coada. In momentul adaugarii in coada, un nod trebuie colorat gri (a fost descoperit si urmeaza sa fie prelucrat).
</p>

<p>
Algoritmul de explorare BFS este complet si optimal.
</p>

<p>
Algoritm:
</p>
<pre class="code cpp">BFS<span class="br0">&#40;</span>s, G<span class="br0">&#41;</span> <span class="br0">&#123;</span>
    foreach <span class="br0">&#40;</span>u ∈ V<span class="br0">&#41;</span> <span class="br0">&#123;</span>
        p<span class="br0">&#40;</span>u<span class="br0">&#41;</span> <span class="sy1">=</span> null<span class="sy4">;</span> <span class="co1">// initializari</span>
        dist<span class="br0">&#40;</span>s,u<span class="br0">&#41;</span> <span class="sy1">=</span> inf<span class="sy4">;</span>
        c<span class="br0">&#40;</span>u<span class="br0">&#41;</span> <span class="sy1">=</span> alb<span class="sy4">;</span> 
    <span class="br0">&#125;</span>
    dist<span class="br0">&#40;</span>s<span class="br0">&#41;</span> <span class="sy1">=</span> <span class="nu0">0</span><span class="sy4">;</span> <span class="co1">// distanta pana la sursa este 0</span>
    c<span class="br0">&#40;</span>s<span class="br0">&#41;</span> <span class="sy1">=</span> gri<span class="sy4">;</span> <span class="co1">//incepem prelucrarea nodului, deci culoarea devine gri</span>
    Q <span class="sy1">=</span> <span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy4">;</span> <span class="co1">//se foloseste o coada cu nodurile de prelucrat</span>
    Q <span class="sy1">=</span> Q <span class="sy2">+</span> s<span class="sy4">;</span> <span class="co1">// adaugam sursa in coada</span>
    <span class="kw1">while</span> <span class="br0">&#40;</span><span class="sy3">!</span>empty<span class="br0">&#40;</span>Q<span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span> <span class="co1">// cat timp mai am noduri de prelucrat</span>
        u <span class="sy1">=</span> top<span class="br0">&#40;</span>Q<span class="br0">&#41;</span><span class="sy4">;</span> <span class="co1">// se determina nodul din varful cozii</span>
        foreach v ∈ succs<span class="br0">&#40;</span>u<span class="br0">&#41;</span> <span class="br0">&#123;</span> <span class="co1">// pentru toti vecinii</span>
            <span class="kw1">if</span> <span class="br0">&#40;</span>c<span class="br0">&#40;</span>v<span class="br0">&#41;</span> <span class="sy1">=</span> alb<span class="br0">&#41;</span> <span class="br0">&#123;</span><span class="co1">// nodul nu a fost gasit, nu e in coada</span>
                <span class="co1">// actualizam structura date </span>
                dist<span class="br0">&#40;</span>v<span class="br0">&#41;</span> <span class="sy1">=</span> dist<span class="br0">&#40;</span>u<span class="br0">&#41;</span> <span class="sy2">+</span> <span class="nu0">1</span><span class="sy4">;</span>
                p<span class="br0">&#40;</span>v<span class="br0">&#41;</span> <span class="sy1">=</span> u<span class="sy4">;</span>
                c<span class="br0">&#40;</span>v<span class="br0">&#41;</span> <span class="sy1">=</span> gri<span class="sy4">;</span>
                Q <span class="sy1">=</span> Q <span class="sy2">+</span> v<span class="sy4">;</span>
            <span class="br0">&#125;</span> <span class="co1">// close if</span>
        <span class="br0">&#125;</span> <span class="co1">// close foreach</span>
        c<span class="br0">&#40;</span>u<span class="br0">&#41;</span> <span class="sy1">=</span> negru<span class="sy4">;</span> <span class="co1">//am terminat de prelucrat nodul curent</span>
        Q <span class="sy1">=</span> Q <span class="sy2">-</span> u<span class="sy4">;</span> <span class="co1">//nodul este eliminat din coada</span>
    <span class="br0">&#125;</span> <span class="co1">//close while</span>
<span class="br0">&#125;</span></pre>

<p>
Complexitate: 
</p>
<ul>
<li class="level1"><div class="li">cu lista: O(|E|+|V|)</div>
</li>
<li class="level1"><div class="li">cu matrice: O(|V|2)</div>
</li>
</ul>

</div>
<!-- EDIT5 SECTION "Parcurgerea in lățime - BFS" [2021-4240] -->
<h3 class="sectionedit6" id="parcurgerea_in_adancime_dfs">Parcurgerea in adancime – DFS</h3>
<div class="level3">

<p>
Parcurgerea in adancime <strong>(Depth-First Search - DFS)</strong> porneste de la un nod dat (nod de start), care este marcat ca fiind in curs de procesare. Se alege primul vecin nevizitat al acestui nod, se marcheaza si acesta ca fiind in curs de procesare, apoi si pentru acest vecin se cauta primul vecin nevizitat, si asa mai departe. In momentul in care nodul curent nu mai are vecini nevizitati, se marcheaza ca fiind deja procesat si se revine la nodul anterior. Pentru acest nod se cauta primul vecin nevizitat. Algoritmul se repeta pana cand toate nodurile grafului au fost procesate.
</p>

<p>
In urma aplicarii algoritmului DFS asupra fiecarei componente conexe a grafului, se obtine pentru fiecare dintre acestea cate un arbore de acoperire (prin eliminarea muchiilor pe care nu le folosim la parcurgere). Pentru a putea reconstitui acest arbore, pastram pentru fiecare nod dat identitatea parintelui sau.
</p>

<p>
Pentru fiecare nod se vor retine:
</p>
<ul>
<li class="level1"><div class="li">timpul descoperirii</div>
</li>
<li class="level1"><div class="li">timpul finalizarii</div>
</li>
<li class="level1"><div class="li">parintele</div>
</li>
<li class="level1"><div class="li">culoarea</div>
</li>
</ul>

<p>
Algoritmul de explorare DFS nu este nici complet (in cazul unei cautari pe un subarbore infinit), nici optimal (nu gaseste nodul cu adancimea minima).
</p>

<p>
Spre deosebire de BFS, pentru implementarea DFS se foloseste o stiva (abordare <strong>LIFO</strong> in loc de <strong>FIFO</strong>). Desi se poate face aceasta inlocuire in algoritmul de mai sus, de cele mai multe ori este mai intuitiva folosirea recusivitatii.
</p>

<p>
Algoritm:
</p>
<pre class="code cpp">DFS<span class="br0">&#40;</span>G<span class="br0">&#41;</span> <span class="br0">&#123;</span>
    V <span class="sy1">=</span> noduri<span class="br0">&#40;</span>G<span class="br0">&#41;</span>
    foreach <span class="br0">&#40;</span>u ∈ V<span class="br0">&#41;</span> <span class="br0">&#123;</span> 
        <span class="co1">// initializare structura date</span>
        c<span class="br0">&#40;</span>u<span class="br0">&#41;</span> <span class="sy1">=</span> alb<span class="sy4">;</span>
        p<span class="br0">&#40;</span>u<span class="br0">&#41;</span><span class="sy1">=</span>null<span class="sy4">;</span>      
    <span class="br0">&#125;</span>
    timp <span class="sy1">=</span> <span class="nu0">0</span><span class="sy4">;</span> <span class="co1">// retine distanta de la radacina pana la nodul curent</span>
    foreach <span class="br0">&#40;</span>u ∈ V<span class="br0">&#41;</span>
        <span class="kw1">if</span> <span class="br0">&#40;</span>c<span class="br0">&#40;</span>u<span class="br0">&#41;</span> <span class="sy1">=</span> alb<span class="br0">&#41;</span> explorare<span class="br0">&#40;</span>u<span class="br0">&#41;</span><span class="sy4">;</span> <span class="co1">// explorez nodul</span>
<span class="br0">&#125;</span>
&nbsp;
explorare<span class="br0">&#40;</span>u<span class="br0">&#41;</span> <span class="br0">&#123;</span>
    d<span class="br0">&#40;</span>u<span class="br0">&#41;</span> <span class="sy1">=</span> timp<span class="sy2">++</span><span class="sy4">;</span> <span class="co1">// timpul de descoperire al nodului u</span>
    c<span class="br0">&#40;</span>u<span class="br0">&#41;</span> <span class="sy1">=</span> gri<span class="sy4">;</span> <span class="co1">// nod in curs de explorare</span>
    foreach <span class="br0">&#40;</span>v ∈ succes<span class="br0">&#40;</span>u<span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="co1">// incerc sa prelucrez vecinii</span>
        <span class="kw1">if</span> <span class="br0">&#40;</span>c<span class="br0">&#40;</span>v<span class="br0">&#41;</span> <span class="sy1">=</span> alb<span class="br0">&#41;</span> <span class="br0">&#123;</span> <span class="co1">// daca nu au fost prelucrati deja</span>
            p<span class="br0">&#40;</span>v<span class="br0">&#41;</span> <span class="sy1">=</span> u<span class="sy4">;</span>
            explorare<span class="br0">&#40;</span>v<span class="br0">&#41;</span><span class="sy4">;</span>
        <span class="br0">&#125;</span>
    c<span class="br0">&#40;</span>u<span class="br0">&#41;</span> <span class="sy1">=</span> negru<span class="sy4">;</span> <span class="co1">// am terminat de prelucrat nodul curent</span>
    f<span class="br0">&#40;</span>u<span class="br0">&#41;</span> <span class="sy1">=</span> timp<span class="sy2">++</span><span class="sy4">;</span> <span class="co1">// timpul de finalizare al nodului u</span>
<span class="br0">&#125;</span></pre>

<p>
Complexitate:
</p>
<ul>
<li class="level1"><div class="li">cu lista: O(|E|+|V|)</div>
</li>
<li class="level1"><div class="li">cu matrice: O(|V|2)</div>
</li>
</ul>

</div>
<!-- EDIT6 SECTION "Parcurgerea in adancime – DFS" [4241-6477] -->
<h3 class="sectionedit7" id="sortarea_topologica">Sortarea Topologica</h3>
<div class="level3">

<p>
Dandu-se un graf orientat aciclic, sortarea topologica realizeaza o aranjare liniara a nodurilor in functie de muchiile dintre ele. Orientarea muchiilor corespunde unei relatii de ordine de la nodul sursa catre cel destinatie. Astfel, daca (u,v) este una dintre muchiile grafului, u trebuie sa apara inaintea lui v in insiruire. Daca graful ar fi ciclic, nu ar putea exista o astfel de insiruire (nu se poate stabili o ordine intre nodurile care alcatuiesc un ciclu). 
</p>

<p>
Sortarea topologica poate fi vazuta si ca plasarea nodurilor de-a lungul unei linii orizontale astfel incat toate muchiile sa fie directionate de la stanga la dreapta.
</p>

<p>
Exemplu:
</p>

<p>
Profesorul Bumstead isi sorteaza topologic hainele inainte de a se imbraca.
</p>

<p>
<a href="../../../../_detail/pa/laboratoare/6.1.png%3Fid=pa%253Alaboratoare%253Alaborator-06.html" class="media" title="pa:laboratoare:6.1.png"><img src="../../../../_media/pa/laboratoare/6.1.png%3Fw=500&amp;tok=d52283" class="mediacenter" alt="" width="500" /></a>
</p>

<p>
(a) Fiecare muchie (u,v) inseamna ca obiectul de imbracaminte u trebuie imbracat inaintea obiectului de imbracaminte v. Timpii de descoperire d(u) si de finalizare f(u) obtinuti in urma parcurgerii DFS sunt notati langa noduri.
</p>

<p>
<a href="../../../../_detail/pa/laboratoare/6.2.png%3Fid=pa%253Alaboratoare%253Alaborator-06.html" class="media" title="pa:laboratoare:6.2.png"><img src="../../../../_media/pa/laboratoare/6.2.png%3Fw=500&amp;tok=fbffe3" class="mediacenter" alt="" width="500" /></a>
</p>

<p>
(b) Acelasi graf, sortat topologic. Nodurile lui sunt aranjate de la stanga la dreapta in ordinea <strong>descrescatoare</strong> a <strong>timpului de finalizare</strong> f(u). Observati ca toate muchiile sunt orientate de la stanga la dreapta. Acum profesorul Bumstead se poate imbraca linistit.
</p>

<p>
Algoritm:
</p>

<p>
Sunt doi algoritmi cunoscuti pentru sortarea topologina.
</p>

<p>
Algoritmul bazat pe DFS:
</p>
<ul>
<li class="level1"><div class="li">parcurgere DFS pentru determinarea timpilor</div>
</li>
<li class="level1"><div class="li">sortare descrescatoare in functie de timpul de finalizare</div>
</li>
</ul>

<p>
Pentru a evita sortarea nodurilor in functie de timpul de finalizare, se poate folosi o stiva ce retine aceste noduri in ordinea terminarii parcurgerii.
</p>

<p>
Un alt algoritm este cel descris de Kahn:
</p>
<pre class="code cpp">TopSort<span class="br0">&#40;</span>G<span class="br0">&#41;</span> <span class="br0">&#123;</span>
    V <span class="sy1">=</span> noduri<span class="br0">&#40;</span>G<span class="br0">&#41;</span>
    L <span class="sy1">=</span> vida<span class="sy4">;</span><span class="co1">// lista care va contine elementele sortate</span>
    <span class="co1">// initializare S cu nodurile care nu au in-muchii</span>
    foreach <span class="br0">&#40;</span>u ∈ V<span class="br0">&#41;</span> <span class="br0">&#123;</span>
        <span class="kw1">if</span> <span class="br0">&#40;</span>u nu are in<span class="sy2">-</span>muchii<span class="br0">&#41;</span>
	    S <span class="sy1">=</span> S <span class="sy2">+</span> u<span class="sy4">;</span>
    <span class="br0">&#125;</span>
    <span class="kw1">while</span> <span class="br0">&#40;</span><span class="sy3">!</span>empty<span class="br0">&#40;</span>S<span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span> <span class="co1">// cat timp mai am noduri de prelucrat</span>
        u <span class="sy1">=</span> random<span class="br0">&#40;</span>S<span class="br0">&#41;</span><span class="sy4">;</span> <span class="co1">// se scoate un nod din multimea S</span>
        L <span class="sy1">=</span> L <span class="sy2">+</span> u<span class="sy4">;</span>  <span class="co1">// adaug U la lista finala</span>
        foreach v ∈ succs<span class="br0">&#40;</span>u<span class="br0">&#41;</span> <span class="br0">&#123;</span> <span class="co1">// pentru toti vecinii</span>
	    sterge u<span class="sy2">-</span>v<span class="sy4">;</span> <span class="co1">// sterge muchia u-v</span>
            <span class="kw1">if</span> <span class="br0">&#40;</span>v nu are in<span class="sy2">-</span>muchii<span class="br0">&#41;</span>
	        S <span class="sy1">=</span> S <span class="sy2">+</span> v<span class="sy4">;</span>  <span class="co1">// adauga v la multimea S</span>
        <span class="br0">&#125;</span> <span class="co1">// close foreach</span>
    <span class="br0">&#125;</span> <span class="co1">//close while</span>
    <span class="kw1">if</span> <span class="br0">&#40;</span>G are muchii<span class="br0">&#41;</span>
        print<span class="br0">&#40;</span>eroare<span class="br0">&#41;</span><span class="sy4">;</span>  <span class="co1">// graf ciclic</span>
    <span class="kw1">else</span>
        print<span class="br0">&#40;</span>L<span class="br0">&#41;</span><span class="sy4">;</span> <span class="co1">// ordinea topologica</span>
<span class="br0">&#125;</span></pre>

<p>
Complexitate optima: O(|E|+|V|)
</p>

</div>
<!-- EDIT7 SECTION "Sortarea Topologica" [6478-8987] -->
<h2 class="sectionedit8" id="concluzii_si_observatii">Concluzii si observatii</h2>
<div class="level2">

<p>
Grafurile sunt foarte importante pentru reprezentarea si rezolvarea unei multitudini de probleme.
Cele mai uzuale moduri de reprezentare a unui graf sunt:
</p>
<ul>
<li class="level1"><div class="li">liste de adiacenta</div>
</li>
<li class="level1"><div class="li">matrice de adiacenta</div>
</li>
</ul>

<p>
Cele doua moduri uzuale de parcurgere neinformata a unui graf sunt:
</p>
<ul>
<li class="level1"><div class="li">BFS – parcurgere in latime</div>
</li>
<li class="level1"><div class="li">DFS – parcurgere in adancime</div>
</li>
</ul>

<p>
Sortarea topologica este o modalitate de aranjare a nodurilor in functie de muchiile dintre ele. In functie de nodul de start al DFS, se pot obtine sortari diferite, pastrand insa proprietatile generale ale sortarii topologice.
</p>

</div>
<!-- EDIT8 SECTION "Concluzii si observatii" [8988-9590] -->
<h2 class="sectionedit9" id="referinte">Referinte</h2>
<div class="level2">

<p>
[1] <a href="http://en.wikipedia.org/wiki/PageRank" class="urlextern" title="http://en.wikipedia.org/wiki/PageRank"  rel="nofollow">http://en.wikipedia.org/wiki/PageRank</a>
</p>

<p>
[2] <a href="http://en.wikipedia.org/wiki/Social_network#Social_network_analysis" class="urlextern" title="http://en.wikipedia.org/wiki/Social_network#Social_network_analysis"  rel="nofollow">http://en.wikipedia.org/wiki/Social_network#Social_network_analysis</a>
</p>

<p>
[3] <a href="http://prefuse.org/" class="urlextern" title="http://prefuse.org/"  rel="nofollow">http://prefuse.org/</a>
</p>

<p>
[4] <a href="http://classes.engr.oregonstate.edu/eecs/spring2008/cs419/Lectures/jun_graphcut.pdf" class="urlextern" title="http://classes.engr.oregonstate.edu/eecs/spring2008/cs419/Lectures/jun_graphcut.pdf"  rel="nofollow">http://classes.engr.oregonstate.edu/eecs/spring2008/cs419/Lectures/jun_graphcut.pdf</a>
</p>

<p>
[5] <a href="http://en.wikipedia.org/wiki/Breadth-first_search" class="urlextern" title="http://en.wikipedia.org/wiki/Breadth-first_search"  rel="nofollow">http://en.wikipedia.org/wiki/Breadth-first_search</a>
</p>

<p>
[6] <a href="http://en.wikipedia.org/wiki/Depth-first_search" class="urlextern" title="http://en.wikipedia.org/wiki/Depth-first_search"  rel="nofollow">http://en.wikipedia.org/wiki/Depth-first_search</a>
</p>

<p>
[7] <a href="http://en.wikipedia.org/wiki/Topological_sorting" class="urlextern" title="http://en.wikipedia.org/wiki/Topological_sorting"  rel="nofollow">http://en.wikipedia.org/wiki/Topological_sorting</a>
</p>

<p>
[8] Introducere in Algoritmi, T. Cormen s.a., pag 403-419
</p>

<p>
[9] <a href="http://ww3.algorithmdesign.net/handouts/DFS.pdf" class="urlextern" title="http://ww3.algorithmdesign.net/handouts/DFS.pdf"  rel="nofollow">http://ww3.algorithmdesign.net/handouts/DFS.pdf</a>
</p>

<p>
[10] <a href="http://ww3.algorithmdesign.net/handouts/BFS.pdf" class="urlextern" title="http://ww3.algorithmdesign.net/handouts/BFS.pdf"  rel="nofollow">http://ww3.algorithmdesign.net/handouts/BFS.pdf</a>
</p>

</div>
<!-- EDIT9 SECTION "Referinte" [9591-10207] -->
<h2 class="sectionedit10" id="resurse">Resurse</h2>
<div class="level2">
<ul>
<li class="level1"><div class="li"> <a href="http://cs.curs.pub.ro/2015/pluginfile.php/31895/mod_resource/content/1/Lab%206%20BDFS.pdf" class="urlextern" title="http://cs.curs.pub.ro/2015/pluginfile.php/31895/mod_resource/content/1/Lab%206%20BDFS.pdf"  rel="nofollow">Varianta PDF a laboratorului</a></div>
</li>
</ul>

</div>
<!-- EDIT10 SECTION "Resurse" [10208-10355] -->
<h2 class="sectionedit11" id="probleme">Probleme</h2>
<div class="level2">

<p>
<p><div class="noteimportant">
La finalul laboratorului, încărcați soluțiile <a href="http://cs.curs.pub.ro/2015/mod/assign/view.php?id=5232" class="urlextern" title="http://cs.curs.pub.ro/2015/mod/assign/view.php?id=5232"  rel="nofollow">aici</a>.

</div></p>
</p>

</div>
<!-- EDIT11 SECTION "Probleme" [10356-10517] -->
<h3 class="sectionedit12" id="help_me_escape_5p">1. Help me escape! [5p]</h3>
<div class="level3">

<p>
Se dă un tablou bidimensional de dimensiune <strong>N</strong>, reprezentând suprafaţa unei camere. Camera poate să conţină obstacole, reprezentate în matrice printr-o valoare de 1. Celulele cu valoarea 0 reprezintă suprafeţele libere ale camerei. Dându-se un punct interior <strong>P(x, y)</strong>, să se decidă care este cel mai scurt drum până la o ieşire, folosind doar <strong>deplasări verticale şi/sau orizontale</strong>. Ieşirile pot să fie <strong>doar pe marginea tabloului</strong>, și sunt simbolizate prin <strong>cifra 2</strong>.
De asemenea, trebuie să afişaţi și drumul până la ieşire.
</p>

<p>
<p><div class="notetip">
</p>
<pre class="code">Exemplu:

  room.in               room.out
  
  5                     3
  1 0 2 1 0             3 4
  0 0 0 1 1             3 3
  2 1 0 0 1             2 3
  1 1 0 1 0             1 3
  0 1 2 1 0
  3 4
  </pre>

<p>
Explicaţii:<br/>

Există două posibilităţi de a porni din punctul de coordonate P(3, 4) şi a ajunge printr-un drum de lungime minimă la o ieşire, unul dintre acestea urmează traseul (3, 4)→(3, 3)→(2, 3)→(1, 3). Numărul minim de celule pe care le avem de străbătut până la o ieşire fiind astfel egal cu 3.
</p>

<p>

</div></p>
</p>

</div>
<!-- EDIT12 SECTION "1. Help me escape! [5p]" [10518-12852] -->
<h3 class="sectionedit13" id="ordinea_de_studiere_a_materiilor_5p">2. Ordinea de studiere a materiilor [5p]</h3>
<div class="level3">

<p>
În primii ani de studiu, toţi studenţii de la Facultatea de Automatică şi Calculatoare studiază un număr de <strong>N</strong> materii obligatorii.
Dându-se un set de relaţii între acestea, cu semnificaţia că materia din stânga trebuie studiată într-un semestru anterior (nu neapărat din acelaşi an), celei din partea dreaptă, găsiţi şi implementaţi un algoritm care propune o ordine corectă de studiere a materiilor universitare, care să respecte restricţiile impuse.
</p>

<p>
În fişierul de intrare se vor găsi pe prima linie, în ordine, <strong>N</strong> - numărul de materii distincte de studiat, <strong>M</strong> - numărul de dependenţe între acestea.
Pe liniile următoare, cuprinse între <strong>2 .. M + 1</strong> se vor găsi relaţiile efective între materii, cu semnificaţia prezentată.
</p>

<p>
În fişierul de ieşire se doreşte afişarea în ordine pe câte o linie a materiilor care se vor studia.
</p>

<p>
<p><div class="notetip">
</p>
<pre class="code">Exemplu:
  
  subjects.in
  
  6 5
  Analiza Algoritmilor → Proiectarea Algoritmilor
  Programarea Calculatoarelor → Proiectarea Algoritmilor
  Structuri de Date → Proiectarea Algoritmilor
  Proiectarea Algoritmilor → Algoritmi Paraleli si Distribuiti
  Protocoale de Comunicatie → Algoritmi Paraleli si Distribuiti
  
  
  subjects.out
  
  Programarea Calculatoarelor
  Structuri de Date
  Analiza Algoritmilor
  Proiectarea Algoritmilor
  Protocoale de Comunicatie
  Algoritmi Paraleli si Distribuiti</pre>

<p>
Explicaţii:<br/>

Există mai multe moduri de a genera o ordine validă de studiere a materiilor, iar dacă verificăm restricţiile impuse, din output reiese că Programarea Calculatoarelor se va studia înainte de Proiectarea Algoritmilor, deci implicit şi înainte de Protocoale de Comunicatie; Structurile de Date se vor studia înainte de Proiectarea Algoritmilor, deci implicit şi înainte de materia Algoritmi Paraleli si Distribuiti, etc.

</div></p>
</p>

</div>
<!-- EDIT13 SECTION "2. Ordinea de studiere a materiilor [5p]" [12853-15464] -->
<h3 class="sectionedit14" id="bonus_1p">3.	Bonus [1p]</h3>
<div class="level3">

<p>
Implementaţi algoritmul lui Kahn pentru problema anterioară.
</p>

</div>
<!-- EDIT14 SECTION "3.	Bonus [1p]" [15465-] --></div>
</body>
</html>
