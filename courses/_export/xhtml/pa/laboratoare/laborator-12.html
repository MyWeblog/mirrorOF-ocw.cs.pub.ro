    
    

<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
  <meta charset="utf-8" />
  <title>pa:laboratoare:laborator-12</title>
<meta name="generator" content="DokuWiki"/>
<meta name="robots" content="index,follow"/>
<meta name="date" content="2013-05-20T10:39:05+0300"/>
<meta name="keywords" content="pa,laboratoare,laborator-12"/>
<link rel="search" type="application/opensearchdescription+xml" href="../../../../lib/exe/opensearch.php" title="CS Open CourseWare"/>
<link rel="start" href="../../../../../courses.1.html"/>
<link rel="alternate" type="application/rss+xml" title="Recent Changes" href="../../../../feed.php"/>
<link rel="alternate" type="application/rss+xml" title="Current Namespace" href="../../../../feed.php%3Fmode=list&amp;ns=pa:laboratoare"/>
<link rel="alternate" type="text/html" title="Plain HTML" href="laborator-12.html"/>
<link rel="canonical" href="../../../../pa/laboratoare/laborator-12.html"/>
<link rel="stylesheet" type="text/css" href="../../../../lib/exe/css.php%3Ft=arctic&amp;tseed=1476798676.css"/>
<script type="text/javascript">/*<![CDATA[*/var NS='pa:laboratoare';var JSINFO = {"id":"pa:laboratoare:laborator-12","namespace":"pa:laboratoare","isadmin":0,"isauth":0};
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="../../../../lib/exe/js.php%3Ftseed=1476798676"></script>
<script type="text/x-mathjax-config">/*<![CDATA[*/MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ["$","$"], ["\\(","\\)"] ],
        displayMath: [ ["$$","$$"], ["\\[","\\]"] ],
        processEscapes: true
    }
});
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
<script type="text/javascript">/*<![CDATA[*/
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
		  
/*!]]>*/</script>
<script type="text/javascript">/*<![CDATA[*/
var pageTracker = _gat._getTracker("UA-38383934-1");
pageTracker._initData();
pageTracker._trackPageview();
		  
/*!]]>*/</script>
</head>
<body>
<div class="dokuwiki export">
<!-- TOC START -->
<div id="dw__toc">
<h3 class="toggle">Table of Contents</h3>
<div>

<ul class="toc">
<li class="level1"><div class="li"><a href="laborator-12.html#laborator_12algoritmi_aleatori">Laborator 12 : Algoritmi aleatori</a></div>
<ul class="toc">
<li class="level2"><div class="li"><a href="laborator-12.html#obiective_laborator">Obiective laborator</a></div></li>
<li class="level2"><div class="li"><a href="laborator-12.html#aplicatii_practice">Aplicații practice</a></div></li>
<li class="level2"><div class="li"><a href="laborator-12.html#descrierea_problemei_si_a_rezolvarilor">Descrierea problemei și a rezolvărilor</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="laborator-12.html#algoritmi_las_vegas">Algoritmi Las Vegas</a></div></li>
<li class="level3"><div class="li"><a href="laborator-12.html#algoritmi_monte_carlo">Algoritmi Monte Carlo</a></div></li>
</ul>
</li>
<li class="level2"><div class="li"><a href="laborator-12.html#concluzii_si_observatii">Concluzii și observații</a></div></li>
<li class="level2"><div class="li"><a href="laborator-12.html#referinte">Referințe</a></div></li>
<li class="level2"><div class="li"><a href="laborator-12.html#probleme">Probleme</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="laborator-12.html#k-means">K-means</a></div></li>
</ul></li>
</ul></li>
</ul>
</div>
</div>
<!-- TOC END -->

<h1 class="sectionedit1" id="laborator_12algoritmi_aleatori">Laborator 12 : Algoritmi aleatori</h1>
<div class="level1">

</div>
<!-- EDIT1 SECTION "Laborator 12 : Algoritmi aleatori" [1-49] -->
<h2 class="sectionedit2" id="obiective_laborator">Obiective laborator</h2>
<div class="level2">
<ul>
<li class="level1"><div class="li">Înțelegerea noțiunilor de bază legate de algoritmii aleatori – Algoritmi Las Vegas și Monte Carlo;</div>
</li>
<li class="level1"><div class="li">Familiarizarea cu rezolvarea folosind algoritmi aleatori a problemelor clasice;</div>
</li>
<li class="level1"><div class="li">Diversificarea perspectivei de analiză și rezolvare a problemelor.</div>
</li>
</ul>

</div>
<!-- EDIT2 SECTION "Obiective laborator" [50-347] -->
<h2 class="sectionedit3" id="aplicatii_practice">Aplicații practice</h2>
<div class="level2">

<p>
Algoritmii aleatori se împart în principal în 2 clase:
</p>
<ul>
<li class="level1"><div class="li">Algoritmi care rezolvă probleme de optim: soluția calculată de algoritm este garantat corectă, dar este aproximativă (nu este optimală). În acest caz, soluția suboptimală este considerată acceptabilă având o marjă de aproximare controlată probabilistic – <strong>algoritmi de aproximare, algoritmi genetici și algoritmi aleatori de tip Las Vegas</strong>;</div>
</li>
<li class="level1"><div class="li">Algoritmi care rezolvă o problema ce acceptă o singură soluție: se renunță la exactitatea rezolvării preferându-se o soluție rapidă care se apropie cu o probabilitatea suficient de mare de soluția exactă – corectitudinea <strong>nu</strong> este garantată – <strong>algoritmi aleatori de tip Monte Carlo și stocastici (Markov)</strong>.</div>
</li>
</ul>

<p>
Printre implicațiile practice ale algoritmilor aleatori se numără:
</p>
<ul>
<li class="level1"><div class="li">optimizarea diverșilor algoritmi, în general în vederea asigurării dispersiei corespunzătoare a valorilor;</div>
</li>
<li class="level1"><div class="li">diverse inițializări (ex. Algoritmi Genetici pentru indivizi) sau selecții de date după o distribuție prestabilită (în general Gaussiană);</div>
</li>
<li class="level1"><div class="li">reducerea complexității unor probleme specifice.</div>
</li>
</ul>

</div>
<!-- EDIT3 SECTION "Aplicații practice" [348-1526] -->
<h2 class="sectionedit4" id="descrierea_problemei_si_a_rezolvarilor">Descrierea problemei și a rezolvărilor</h2>
<div class="level2">

<p>
Primele aspecte care trebuie clarificate sunt caracteristicile algoritmilor aleatori:
</p>
<ul>
<li class="level1"><div class="li">necesitatea micșorării timpului de rezolvare a problemei prin relaxarea restricțiile impuse soluțiilor;</div>
</li>
<li class="level1"><div class="li">este suficientă o singură soluție care se apropie cu o probabilitate măsurabilă de soluția exactă;</div>
</li>
<li class="level1"><div class="li">în final se poate obține o soluție suboptimală cu o marjă de eroare garantată prin calcul probabilistic.</div>
</li>
</ul>

<p>
Generatorul de numere aleatorii se află la baza construcției și funcționării algoritmilor aleatori. Astfel, pentru rulări diferite există șansa ca algoritmul să se comporte diferite, chiar dacă datele de intrare, respectiv rezultatele sunt aceleași. Astfel, pentru același set de date de intrare, algoritmii familiei se comportă diferit, chiar dacă rezultatele sunt aceleași.
</p>

</div>
<!-- EDIT4 SECTION "Descrierea problemei și a rezolvărilor" [1527-2394] -->
<h3 class="sectionedit5" id="algoritmi_las_vegas">Algoritmi Las Vegas</h3>
<div class="level3">

<p>
<strong>Caracteristici:</strong>
</p>
<ul>
<li class="level1"><div class="li">Determină soluția corectă a problemei, însă timpul de rezolvare nu poate fi determinat cu exactitate;</div>
</li>
<li class="level1"><div class="li">Creșterea timpului de rezolvare implică creșterea probabilității de terminare a algoritmului;</div>
</li>
<li class="level1"><div class="li">După un timp infinit se ajunge la soluția optimă și algoritmul se termină sigur;</div>
</li>
<li class="level1"><div class="li">Probabilitatea de găsire a soluției crește extrem de repede încât să se determine soluția corectă într-un timp suficient de scurt.</div>
</li>
</ul>

<p>
<strong>Complexitate teoretică:</strong>
</p>
<pre class="code">f(n)=O(g(n)) daca ∃c&gt;0, n0 &gt; 0 a.i.: </pre>
<ul>
<li class="level1"><div class="li">∀n&gt;n0 0 &lt; f(n) &lt; cαg(n) cu o probabilitate de cel puțin 1 - n<sup>-α</sup> , α fixat și suficient de mare.</div>
</li>
</ul>

<p>
<strong>Implicații:</strong>
</p>

<p>
Procentul algoritmilor Las Vegas care consumă cel mult cαg(n) resurse de calcul din totalul unei familii de algoritmi de complexitate O(g(n)) este 1 - n<sup>-α</sup>. Pentru α suficient de mare există șanse foarte mici să se folosească un algoritm al familiei care nu respectă limita de complexitate.
</p>

<p>
<strong>Problemă:</strong>
</p>
<ul>
<li class="level1"><div class="li">Capitolele unei cărți sunt stocate într-un fișier text sub forma unei secvențe nevide de linii;</div>
</li>
<li class="level1"><div class="li">Fiecare secvență este precedată de o linie contor ce indică numărul de linii din secvență, iar specificul indică fiecare astfel de secvență este lungă;</div>
</li>
<li class="level1"><div class="li">Fiecare linie din fișier este terminată prin CR,LF;</div>
</li>
<li class="level1"><div class="li">Toate liniile din secvență au aceeași lungime;</div>
</li>
<li class="level1"><div class="li">Fiecare secvență de linii conține o linie (titlul capitolului) ce se repetă și care apare în cel puțin q = 10% din numărul de linii al secvenței.</div>
</li>
</ul>

<p>
<strong>Cerință:</strong>
</p>
<ul>
<li class="level1"><div class="li">Pentru fiecare secvență de linii să se tipărească titlul capitolului (linia care se repetă).</div>
</li>
</ul>

<p>
Complexitate variantă iterativă: O(n<sup>2</sup>) în cazul cel mai defavorabil
</p>

<p>
<strong>Rezolvare aleatoare:</strong>
</p>
<pre class="code cpp">selectie_linii<span class="br0">&#40;</span>n,Secv<span class="br0">&#41;</span> <span class="co1">// Pp n = dim secv &gt; 100</span>
    <span class="kw1">while</span> <span class="br0">&#40;</span><span class="nu0">1</span><span class="br0">&#41;</span>
        i <span class="sy1">=</span> random<span class="br0">&#40;</span><span class="nu0">0</span>,n<span class="sy2">-</span><span class="nu0">1</span><span class="br0">&#41;</span> <span class="co1">// selectez o linie</span>
        j <span class="sy1">=</span> random<span class="br0">&#40;</span><span class="nu0">0</span>,n<span class="sy2">-</span><span class="nu0">1</span><span class="br0">&#41;</span> <span class="co1">// si inca una</span>
        <span class="kw1">if</span> <span class="br0">&#40;</span>i <span class="sy3">!</span><span class="sy1">=</span> j <span class="sy3">&amp;&amp;</span> linie<span class="br0">&#40;</span>i,Secv<span class="br0">&#41;</span> <span class="sy1">=</span> linie<span class="br0">&#40;</span>j,Secv<span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="co1">// le compar</span>
            <span class="kw1">return</span> linie<span class="br0">&#40;</span>i,Secv<span class="br0">&#41;</span> <span class="co1">// am gasit linia</span></pre>

<p>
Complexitate variantă aleatoare: O(lg<sup>-1</sup>(1/a)lg(n))=O(lg(n)), unde a = 1 - q(q-1)/10000, q=10 – probabilitatea de regăsire a titlului capitolului.
</p>

<p>
<strong>Observații:</strong>
</p>

<p>
De exemplu pentru n=100 și q=10%, după 3500 de iterații, probabilitatea ca soluția să fie corectă poate fi considerată 1; dacă q=30%, atunci numărul de iterații devine 500. Aproprierea probabilității de 1 este atât de mare încât precizia de calcul cu 12 zecimale nu mai asigură obținerea valorii exacte și, practic, terminarea algoritmului devine certă.
</p>

<p>
Algoritmul se comportă foarte bine chiar și atunci când în condițiile teoretice nu sunt respectate întrucât avem de-a face cu numere pseudo-aleatorii și secvența de linii nu este formată aleator.
</p>

</div>
<!-- EDIT5 SECTION "Algoritmi Las Vegas" [2395-5245] -->
<h3 class="sectionedit6" id="algoritmi_monte_carlo">Algoritmi Monte Carlo</h3>
<div class="level3">

<p>
<strong>Caracteristici:</strong>
</p>
<ul>
<li class="level1"><div class="li">Determină o soluție a problemei care e garantat corectă doar după un timp infinit de rezolvare – soluție aproximativă;</div>
</li>
<li class="level1"><div class="li">Presupun un număr finit de iterații după care răspunsul nu este garantat corect;</div>
</li>
<li class="level1"><div class="li">Creșterea timpului de rezolvare implică creșterea probabilității ca soluția găsită să fie corectă;</div>
</li>
<li class="level1"><div class="li">Soluția găsită într-un timp acceptabil este aproape sigur corectă (există o probabilitate mică ca soluţia să nu fie corectă).</div>
</li>
</ul>

<p>
<strong>Complexitate teoretică:</strong>
</p>
<pre class="code">f(n)=O(g(n)) daca ∃c&gt;0, n0 &gt; 0 a.i.: </pre>

<p>
∀n&gt;n0 0 &lt; f(n) &lt; cαg(n) cu o probabilitate de cel puțin 1 - n<sup>-α</sup> , α fixat și suficient de mare.
</p>
<ul>
<li class="level1"><div class="li">Probabilitatea ca soluția determinată de algoritm să fie corectă este de cel puțin 1 - n<sup>-α</sup>.</div>
</li>
</ul>

<p>
<strong>Implicații:</strong>
</p>

<p>
Procentul algoritmilor Monte Carlo care consumă cel mult cαg(n) resurse de calcul din totalul unei familii de algoritmi de complexitate O(g(n))  pentru a găsi o soluție corectă cu o probabilitate de cel puțin 1 - n<sup>-α</sup> este 1 - n<sup>-α</sup>. Pentru α suficient de mare există șanse foarte mici să se folosească un algoritm al familiei care nu respectă limita de complexitate și nu se termină cu o soluție corectă.
</p>

<p>
<strong>Problemă:</strong>
</p>
<ul>
<li class="level1"><div class="li">Testarea dacă un număr dat n este prim.</div>
</li>
</ul>

<p>
Complexitate variantă clasică: O(√n)=O(<sup>k/2</sup>)  unde k = nr. de biți ocupați de n
</p>

<p>
Rezolvare aleatoare folosind teorema lui Fermat (Dacă n este prim atunci pentu ∀ 0 &lt; x &lt; n, x<sup>n-1</sup> mod n = 1):
</p>
<pre class="code cpp">prim1<span class="br0">&#40;</span>n,α<span class="br0">&#41;</span> <span class="co1">// detectează daca n e număr prim</span>
    <span class="kw1">if</span> <span class="br0">&#40;</span>n <span class="sy1">&lt;=</span> <span class="nu0">1</span> <span class="sy3">||</span> n mod <span class="nu0">2</span> <span class="sy1">==</span> <span class="nu0">0</span><span class="br0">&#41;</span> <span class="kw1">return</span> <span class="kw2">false</span>
    limit <span class="sy1">=</span> limita_calcul<span class="br0">&#40;</span>n,α<span class="br0">&#41;</span> <span class="co1">//nr min pași pt sol corectă cu P=1-n^-α</span>
    <span class="kw1">for</span> <span class="br0">&#40;</span>i <span class="sy1">=</span> <span class="nu0">0</span> <span class="sy4">;</span> i <span class="sy1">&lt;</span> limit <span class="sy4">;</span> i<span class="sy2">++</span><span class="br0">&#41;</span>
        x <span class="sy1">=</span> random<span class="br0">&#40;</span><span class="nu0">1</span>,n<span class="sy2">-</span><span class="nu0">1</span><span class="br0">&#41;</span> <span class="co1">// aleg un număr oarecare </span>
        <span class="kw1">if</span> <span class="br0">&#40;</span>pow_mod<span class="br0">&#40;</span>x,n<span class="br0">&#41;</span> <span class="sy3">!</span><span class="sy1">=</span> <span class="nu0">1</span><span class="br0">&#41;</span> <span class="kw1">return</span> <span class="kw2">false</span> <span class="co1">// T. Fermat</span>
    <span class="kw1">return</span> <span class="kw2">true</span>
&nbsp;
pow_mod<span class="br0">&#40;</span>x,n<span class="br0">&#41;</span> <span class="co1">// calculează xn-1 mod n</span>
    r <span class="sy1">=</span> <span class="nu0">1</span>
    <span class="kw1">for</span> <span class="br0">&#40;</span>m <span class="sy1">=</span> n – <span class="nu0">1</span> <span class="sy4">;</span> m <span class="sy1">&gt;</span> <span class="nu0">0</span> <span class="sy4">;</span> m <span class="sy1">=</span> m <span class="sy2">/</span> <span class="nu0">2</span><span class="br0">&#41;</span>
        <span class="kw1">if</span> <span class="br0">&#40;</span>m mod <span class="nu0">2</span> <span class="sy3">!</span><span class="sy1">=</span> <span class="nu0">0</span><span class="br0">&#41;</span> <span class="co1">// testez daca m e par sau nu</span>
            r <span class="sy1">=</span> x<span class="sy2">*</span>r mod n 
        x <span class="sy1">=</span> <span class="br0">&#40;</span>x<span class="sy2">*</span>x<span class="br0">&#41;</span> mod n
    <span class="kw1">return</span> r<span class="sy4">;</span></pre>

<p>
Problema acestei abordări constă în faptul că nu putem stabili cu exactitate care este limita de calcul.
</p>

<p>
Pornind de la următoarea teoremă: Pentru orice număr prim ecuația x<sup>2</sup> mod n = 1 are exact 2 soluții: x<sub>1</sub> egal 1 și x<sub>2</sub> egal n – 1, obținem următoarea definiție pentru X = martor al divizibilității lui n : Fie n &gt; 1 și 0 &lt; x &lt; n două numere astfel încât x<sup>n-1</sup> mod n != 1 sau x<sup>2</sup> mod n != 1, x != 1 si x != n – 1.
</p>
<pre class="code cpp">prim2<span class="br0">&#40;</span>n,α<span class="br0">&#41;</span>
    <span class="kw1">if</span><span class="br0">&#40;</span>n <span class="sy1">&lt;=</span> <span class="nu0">1</span> <span class="sy3">||</span> n mod <span class="nu0">2</span> <span class="sy1">==</span> <span class="nu0">0</span><span class="br0">&#41;</span> <span class="kw1">return</span> <span class="kw2">false</span>
    limit <span class="sy1">=</span> limita_calcul<span class="br0">&#40;</span>n,α<span class="br0">&#41;</span>
    <span class="kw1">for</span> <span class="br0">&#40;</span>i <span class="sy1">=</span> <span class="nu0">0</span> <span class="sy4">;</span> i <span class="sy1">&lt;</span> limit <span class="sy4">;</span> i<span class="sy2">++</span><span class="br0">&#41;</span>
        x <span class="sy1">=</span> random<span class="br0">&#40;</span><span class="nu0">1</span>, n<span class="sy2">-</span><span class="nu0">1</span><span class="br0">&#41;</span>
    <span class="kw1">if</span> <span class="br0">&#40;</span>martor_div<span class="br0">&#40;</span>x,n<span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="kw1">return</span> <span class="kw2">false</span>
    <span class="kw1">return</span> <span class="kw2">true</span><span class="sy4">;</span>
&nbsp;
martor_div<span class="br0">&#40;</span>x,n<span class="br0">&#41;</span> <span class="co1">// determina daca X=martor al divizibilitatii lui n</span>
    r <span class="sy1">=</span> <span class="nu0">1</span><span class="sy4">;</span> y <span class="sy1">=</span> x<span class="sy4">;</span>
    <span class="kw1">for</span><span class="br0">&#40;</span>m <span class="sy1">=</span> n – <span class="nu0">1</span> <span class="sy4">;</span> m <span class="sy1">&gt;</span> <span class="nu0">0</span> <span class="sy4">;</span> m <span class="sy1">=</span> m <span class="sy2">/</span> <span class="nu0">2</span><span class="br0">&#41;</span> <span class="co1">// puterea </span>
        <span class="kw1">if</span> <span class="br0">&#40;</span>m mod <span class="nu0">2</span> <span class="sy3">!</span><span class="sy1">=</span> <span class="nu0">0</span><span class="br0">&#41;</span> <span class="co1">// putere impara </span>
            r <span class="sy1">=</span> y <span class="sy2">*</span> r mod n
        z <span class="sy1">=</span> y <span class="co1">// salvez valoarea lui y</span>
        y <span class="sy1">=</span> y <span class="sy2">*</span> y mod n <span class="co1">// calculez y2 mod n</span>
        <span class="kw1">if</span> <span class="br0">&#40;</span>y <span class="sy1">==</span> <span class="nu0">1</span> <span class="sy3">&amp;&amp;</span> z <span class="sy3">!</span><span class="sy1">=</span> <span class="nu0">1</span> <span class="sy3">&amp;&amp;</span> z <span class="sy3">!</span><span class="sy1">=</span> n<span class="sy2">-</span><span class="nu0">1</span><span class="br0">&#41;</span><span class="co1">//verific teorema anterioară</span>
            <span class="kw1">return</span> <span class="nu0">1</span>
    <span class="kw1">return</span> r <span class="sy3">!</span><span class="sy1">=</span> <span class="nu0">1</span> <span class="co1">// teorema Fermat</span></pre>

<p>
Complexitate: O(lg<sup>2</sup>n)=O(k<sup>2</sup>)
</p>

</div>
<!-- EDIT6 SECTION "Algoritmi Monte Carlo" [5246-8572] -->
<h2 class="sectionedit7" id="concluzii_si_observatii">Concluzii și observații</h2>
<div class="level2">

<p>
Metodele descrise pot fi aplicate și se adresează unei plaje largi de probleme, iar abordările prezentate pot duce la scăderi drastice a timpilor de execuție.
</p>

</div>
<!-- EDIT7 SECTION "Concluzii și observații" [8573-8776] -->
<h2 class="sectionedit8" id="referinte">Referințe</h2>
<div class="level2">

<p>
[1] C. Giumale – Introducere în Analiza Algoritmilor – cap. 6.1
</p>

<p>
[2] T. H. Cormen &amp; all – Introducere în algoritmi – cap. 8.3, 1990
</p>

<p>
[3] <a href="http://www.soe.ucsc.edu/classes/cmps102/Spring04/TantaloAsymp.pdf" class="urlextern" title="http://www.soe.ucsc.edu/classes/cmps102/Spring04/TantaloAsymp.pdf"  rel="nofollow">http://www.soe.ucsc.edu/classes/cmps102/Spring04/TantaloAsymp.pdf</a>
</p>

<p>
[4] <a href="http://www.mersenne.org/" class="urlextern" title="http://www.mersenne.org/"  rel="nofollow">http://www.mersenne.org/</a>
</p>

</div>
<!-- EDIT8 SECTION "Referințe" [8777-9053] -->
<h2 class="sectionedit9" id="probleme">Probleme</h2>
<div class="level2">

</div>
<!-- EDIT9 SECTION "Probleme" [9054-9075] -->
<h3 class="sectionedit10" id="k-means">K-means</h3>
<div class="level3">

<p>
Fie n puncte într-un spațiu bidimensional. Se dorește o grupare a acestora în k clustere - un grup de puncte situate într-o vecinătate spațială care să maximizeze coeziunea intra-cluster și să asigure o cuplare slabă inter-clustere.
</p>

<p>
Spre exemplu, pentru setul de puncte:
</p>

<p>
<code>(2, 5), (2, 9), (3, 2), (3, 3), (3, 4), (3, 10), (4, 1), (5, 1), (8, 2), (8, 3), (9, 4), (10, 5), (10, 6), (10, 7)</code>
</p>

<p>
Se poate observa o grupare naturală în 3 clustere:
</p>

<p>
<a href="../../../../_detail/pa/laboratoare/l12.jpg%3Fid=pa%253Alaboratoare%253Alaborator-12.html" class="media" title="pa:laboratoare:l12.jpg"><img src="../../../../_media/pa/laboratoare/l12.jpg" class="mediacenter" alt="" /></a>
</p>

<p>
Coeziunea internă este determinată drept 1 / media distanțelor către clustroid (punctul din cluster cel mai apropiat de toate celelalte noduri), iar cuplarea inter-clustere este 1 / distanța dintre clustere (distanța dintre clustroizii aferenți). Pașii algoritmului k-Means sunt următorii (pentru N și k date):
</p>
<ol>
<li class="level1"><div class="li"> Se selectează k puncte random din spațiu care vor fi centroizii inițiali ai clusterelor.</div>
</li>
<li class="level1"><div class="li"> Se efectuează iterativ următorii pași cât timp atribuirile fiecărui nod la un cluster rămân neschimbate:</div>
<ol>
<li class="level2"><div class="li"> Asignarea fiecărui nod unui cluster (distanța minimă euclidiană către centroizii din pasul curent este minimă);</div>
</li>
<li class="level2"><div class="li"> Recalcularea centroidului drept media aritmetică a coordonatelor punctelor asignate.</div>
</li>
</ol>
</li>
</ol>

<p>
Pentru un set de date și un k stabilit se vor determina clusterele aferente.
Se va implementa și o optimizare a selecției inițiale de puncte pornind de la principiul că acestea ar trebui să fie geografic cât mai dispersate (se dorește maximizarea distanței între centroizii inițiali; mai multe detalii la [1]).
</p>

<p>
[1] <a href="http://en.wikipedia.org/wiki/K-means%2B%2B#Initialization_algorithm" class="urlextern" title="http://en.wikipedia.org/wiki/K-means%2B%2B#Initialization_algorithm"  rel="nofollow">http://en.wikipedia.org/wiki/K-means%2B%2B#Initialization_algorithm</a>
</p>

</div>
<!-- EDIT10 SECTION "K-means" [9076-] --></div>
</body>
</html>
