    
    

<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
  <meta charset="utf-8" />
  <title>pa:laboratoare:laborator-04</title>
<meta name="generator" content="DokuWiki"/>
<meta name="robots" content="index,follow"/>
<meta name="date" content="2016-03-19T08:08:42+0200"/>
<meta name="keywords" content="pa,laboratoare,laborator-04"/>
<link rel="search" type="application/opensearchdescription+xml" href="../../../../lib/exe/opensearch.php" title="CS Open CourseWare"/>
<link rel="start" href="../../../../../courses.1.html"/>
<link rel="alternate" type="application/rss+xml" title="Recent Changes" href="../../../../feed.php"/>
<link rel="alternate" type="application/rss+xml" title="Current Namespace" href="../../../../feed.php%3Fmode=list&amp;ns=pa:laboratoare"/>
<link rel="alternate" type="text/html" title="Plain HTML" href="laborator-04.html"/>
<link rel="canonical" href="../../../../pa/laboratoare/laborator-04.html"/>
<link rel="stylesheet" type="text/css" href="../../../../lib/exe/css.php%3Ft=arctic&amp;tseed=1476798676.css"/>
<script type="text/javascript">/*<![CDATA[*/var NS='pa:laboratoare';var JSINFO = {"id":"pa:laboratoare:laborator-04","namespace":"pa:laboratoare","isadmin":0,"isauth":0};
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="../../../../lib/exe/js.php%3Ftseed=1476798676"></script>
<script type="text/x-mathjax-config">/*<![CDATA[*/MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ["$","$"], ["\\(","\\)"] ],
        displayMath: [ ["$$","$$"], ["\\[","\\]"] ],
        processEscapes: true
    }
});
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
<script type="text/javascript">/*<![CDATA[*/
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
		  
/*!]]>*/</script>
<script type="text/javascript">/*<![CDATA[*/
var pageTracker = _gat._getTracker("UA-38383934-1");
pageTracker._initData();
pageTracker._trackPageview();
		  
/*!]]>*/</script>
</head>
<body>
<div class="dokuwiki export">
<!-- TOC START -->
<div id="dw__toc">
<h3 class="toggle">Table of Contents</h3>
<div>

<ul class="toc">
<li class="level1"><div class="li"><a href="laborator-04.html#laborator_4backtracking_si_optimizari">Laborator 4: Backtracking și optimizări</a></div>
<ul class="toc">
<li class="level2"><div class="li"><a href="laborator-04.html#obiective_laborator">Obiective laborator</a></div></li>
<li class="level2"><div class="li"><a href="laborator-04.html#importanta_aplicatii_practice">Importanţă – aplicaţii practice</a></div></li>
<li class="level2"><div class="li"><a href="laborator-04.html#descrierea_problemei_si_a_rezolvarilor">Descrierea problemei și a rezolvărilor</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="laborator-04.html#problema_satisfacerii_constrangerilor">Problema satisfacerii constrângerilor</a></div></li>
<li class="level3"><div class="li"><a href="laborator-04.html#euristici">Euristici</a></div></li>
<li class="level3"><div class="li"><a href="laborator-04.html#tehnici_prospective">Tehnici prospective</a></div></li>
</ul>
</li>
<li class="level2"><div class="li"><a href="laborator-04.html#concluzii_si_observatii">Concluzii și observații</a></div></li>
<li class="level2"><div class="li"><a href="laborator-04.html#sudoku">Sudoku</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="laborator-04.html#backtracking_5p">1. Backtracking [5p]</a></div></li>
<li class="level3"><div class="li"><a href="laborator-04.html#backtracking_si_o_metoda_prospectiva_preferabil_predictie_partiala_sau_completa_5p">2. Backtracking şi o metodă prospectivă (preferabil predictie parțială sau completă) [5p]</a></div></li>
<li class="level3"><div class="li"><a href="laborator-04.html#euristica_2p">3. Euristică [2p]</a></div></li>
</ul>
</li>
<li class="level2"><div class="li"><a href="laborator-04.html#referinte">Referințe</a></div></li>
</ul></li>
</ul>
</div>
</div>
<!-- TOC END -->

<h1 class="sectionedit1" id="laborator_4backtracking_si_optimizari">Laborator 4: Backtracking și optimizări</h1>
<div class="level1">

</div>
<!-- EDIT1 SECTION "Laborator 4: Backtracking și optimizări" [1-57] -->
<h2 class="sectionedit2" id="obiective_laborator">Obiective laborator</h2>
<div class="level2">
<ul>
<li class="level1"><div class="li">Înțelegerea noțiunilor de bază legate de backtracking și optimizările aferente;</div>
</li>
<li class="level1"><div class="li">Conștientizarea necesității îmbunătățirii versiunii simple de backtracking și beneficiile fiecărei abordări în parte;</div>
</li>
<li class="level1"><div class="li">Familiarizarea atât cu problema satisfacerii constrângerilor, cât și cu metode prospective, euristici.</div>
</li>
</ul>

</div>
<!-- EDIT2 SECTION "Obiective laborator" [58-422] -->
<h2 class="sectionedit3" id="importanta_aplicatii_practice">Importanţă – aplicaţii practice</h2>
<div class="level2">

<p>
Răspunsul general și imediat: orice problemă care presupune o căutare în spațiul stărilor. De asemenea, majoritatea problemelor din Inteligență Artificială pot fi reduse la problema satisfacerii constrângerilor, iar metodele prospective, respectiv euristicile pot fi aplicate într-o multitudine de probleme, fiind în general valabile.
</p>

</div>
<!-- EDIT3 SECTION "Importanţă – aplicaţii practice" [423-821] -->
<h2 class="sectionedit4" id="descrierea_problemei_si_a_rezolvarilor">Descrierea problemei și a rezolvărilor</h2>
<div class="level2">

<p>
Pornind de la strategiile clasice de parcurgere a spațiului de stări, algoritmii de tip backtracking practic enumeră un set de candidați parțiali, care, după completarea definitivă, pot deveni soluții potențiale ale problemei inițiale. Exact ca strategiile de parcurgere în lățime/adâncime și backtracking-ul are la bază expandarea unui nod curent, iar determinarea soluției se face într-o manieră incrementală. Prin natura sa, bkt-ul este recursiv, iar în arborele expandat top-down se aplică operații de tipul pruning (tăiere) dacă soluția parțială nu este validă.
</p>

<p>
Notațiile utilizate sunt următoarele:
</p>
<ul>
<li class="level1"><div class="li">X<sub>1</sub>, …, X<sub>N</sub> variabilele problemei, N fiind numărul de variabile ale problemei;</div>
</li>
<li class="level1"><div class="li">D<sub>1</sub>, …, D<sub>N</sub> domeniile aferente fiecărei variabile;</div>
</li>
<li class="level1"><div class="li">U - întreg care reprezintă indicele variabilei curent selectate pentru a i se atribui o valoare;</div>
</li>
<li class="level1"><div class="li">F - vector indexat după indicii variabilelor, în care sunt memorate selecțiile de valori făcute de la prima variabila și până la variabila curentă</div>
</li>
</ul>

<p>
<a href="../../../../_detail/pa/laboratoare/p1_cr.png%3Fid=pa%253Alaboratoare%253Alaborator-04.html" class="media" title="pa:laboratoare:p1_cr.png"><img src="../../../../_media/pa/laboratoare/p1_cr.png%3Fw=600&amp;tok=2d09cc" class="media" alt="" width="600" /></a>
</p>

<p>
Reprezentarea grafică a unei relații pentru două variabile X<sub>1</sub> și X<sub>2</sub> cu domeniul {a, b, c} este următoarea:
</p>

<p>
<a href="../../../../_detail/pa/laboratoare/p2_cr.png%3Fid=pa%253Alaboratoare%253Alaborator-04.html" class="media" title="pa:laboratoare:p2_cr.png"><img src="../../../../_media/pa/laboratoare/p2_cr.png%3Fw=250&amp;tok=e47c5b" class="media" alt="" width="250" /></a>
</p>

<p>
O versiune generică a algoritmului de tip backtracking recursiv poate fi următoarea:
</p>
<pre class="code cpp">BKT <span class="br0">&#40;</span>U, F<span class="br0">&#41;</span>
<span class="kw1">if</span> U <span class="sy1">==</span> N <span class="co1">// dacă am determinat o soluție completă</span>
	Afișează valorile din vectorul F
	<span class="kw1">return</span>
foreach V of XU
	F<span class="br0">&#91;</span>U<span class="br0">&#93;</span> ← V
	<span class="kw1">if</span> Verifica <span class="br0">&#40;</span>U,F<span class="br0">&#41;</span> <span class="sy1">==</span> <span class="kw2">true</span> then
		BKT<span class="br0">&#40;</span>U<span class="sy2">+</span><span class="nu0">1</span>, F<span class="br0">&#41;</span>
&nbsp;
Verifică <span class="br0">&#40;</span>U,F<span class="br0">&#41;</span>
	test <span class="sy1">=</span> <span class="kw2">true</span>
	I ← U <span class="sy2">-</span> <span class="nu0">1</span>
	<span class="kw1">while</span> I <span class="sy1">&gt;</span> <span class="nu0">0</span>
		test <span class="sy1">=</span> Relație<span class="br0">&#40;</span>I, F<span class="br0">&#91;</span>I<span class="br0">&#93;</span>, U, F<span class="br0">&#91;</span>U<span class="br0">&#93;</span><span class="br0">&#41;</span> 
		I <span class="sy1">=</span> I <span class="sy2">-</span> <span class="nu0">1</span>
		<span class="kw1">if</span> test <span class="sy1">==</span> <span class="kw2">false</span>
			then <span class="kw1">break</span>
	<span class="kw1">return</span> test</pre>

<p>
<strong>Complexitatea algoritmului: complexitatea temporală</strong> este de <strong>O(B<sup>d</sup>)</strong>, iar cea <strong>spațială O(d)</strong>, unde <strong>B</strong> este <em>factor de ramificare</em> (numărul mediu de stări posibil ulterioare în care nodul curent poate fi expandat) și <strong>d</strong> este <em>adâncimea soluției</em>.
</p>

<p>
Pornind de la versiunea inițială de BKT, putem aduce o <strong>serie de îmbunătățiri</strong> în următoarele direcții:
</p>
<ul>
<li class="level1"><div class="li"> <strong>Algoritmi de îmbunătățire a consistenței reprezentării</strong> care vizează consistența locală a arcelor sau a căilor în graful de restricții</div>
</li>
<li class="level1"><div class="li"> <strong>Utilizarea euristicilor</strong> în vederea optimizării numărului de teste prin luarea în considerare a următoarelor scenarii:</div>
<ul>
<li class="level3"><div class="li"> <em>Ordonarea variabilelor</em></div>
</li>
<li class="level3"><div class="li"> <em>Ordonarea valorilor</em></div>
</li>
<li class="level3"><div class="li"> <em>Ordonarea testelor</em></div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> <strong>Algoritmi hibrizi</strong> care îmbunătățesc performanțele rezolvării prin reducerea numărului de teste; aici putem identifica următoarele subcategorii:</div>
<ul>
<li class="level3"><div class="li"> <em>Tehnici prospective:</em></div>
<ul>
<li class="level5"><div class="li"> Căutare cu predicție completă</div>
</li>
<li class="level5"><div class="li"> Căutare cu predicție parțială</div>
</li>
<li class="level5"><div class="li"> Căutare cu verificare predictivă</div>
</li>
</ul>
</li>
<li class="level3"><div class="li"> <em>Tehnici retrospective:</em></div>
<ul>
<li class="level5"><div class="li"> Backtracking cu salt</div>
</li>
<li class="level5"><div class="li"> Backtracking cu marcare</div>
</li>
</ul>
</li>
</ul>
</li>
</ul>

<p>
Dintre metodele enumerate mai sus ne vom concentra asupra <strong>CSP</strong> (Constraint Satisfaction Problem) cu îmbunătățirea aferentă a consistenței reprezentării și asupra tehnicilor prospective, existând în cazul ambelor o îmbunătățire sesizabilă la nivelul apelurilor recursive / al expandărilor efectuate / al intrărilor în stivă.
</p>

</div>
<!-- EDIT4 SECTION "Descrierea problemei și a rezolvărilor" [822-4172] -->
<h3 class="sectionedit5" id="problema_satisfacerii_constrangerilor">Problema satisfacerii constrângerilor</h3>
<div class="level3">

<p>
Problema satisfacerii restricțiilor, în formularea cea mai generală, presupune existența unei mulțimi de variabile, unor domenii de valori potențiale pentru fiecare variabilă și o multime de restricții care specifică combinațiile de valori acceptabile ale variabilelor (exact conceptul de relații definite anterior, cu tot cu restricțiile aferente). <strong>Scopul final</strong> îl reprezintă determinarea unei atribuiri de valori pentru fiecare variabila astfel încât toate restrictiile să fie satisfăcute. 
</p>

<p>
Problema satisfacerii restrictiilor este, în cazul general, o problema grea, deci <strong>NP-completă</strong>, exponențială în raport cu numărul de variabile ale problemei. Din perspectiva strategiilor de căutare într-un spațiu de stări, traducerea problemei ar fi următoarea: pornind din starea inițială a procesului care conține restricțiile identificate în descrierea inițială a problemei, se dorește atingerea unei stări finale care a fost restricționată “suficient” pentru a rezolva problema.
</p>

<p>
Pornind de la premisa că CSP este o problema de căutare din clasa problemelor NP, aspectul de interes al optimizării curente devine reducerea cât mai puternică a timpului / spațiului de căutare.
</p>

<p>
Fiind o problemă de căutare, rezolvarea problemei satisfacerii restricțiilor poate fi facută aplicând una din tehnicile de căutare a soluției în spațiul stărilor. Astfel, cea mai utilizată strategie de rezolvare a problemei CSP este backtracking-ul, variantă simplificată a căutării neinformate în adâncime. Aceasta strategie este preferată datorită economiei de spațiu atinse raportat la strategia de căutare în adâncime  - O(B*d) sau pe nivel – O (B<sup>d</sup>).
În fucție de particularizare și anume în funcție de necesitatea determinării unei soluții sau a tuturor soluțiilor, satisfacerea tuturor constrângerilor sau relaxarea unora, putem avea următoarele categorii:
</p>
<ul>
<li class="level1"><div class="li">CSP totală</div>
</li>
<li class="level1"><div class="li">CSP parțială</div>
</li>
<li class="level1"><div class="li">CSP binară – graf de restricții</div>
</li>
</ul>

<p>
Pentru noi, în cazul studiului de față, problemele de tipul CSP binare care pot fi reprezentate printr-un graf de restricții sunt de interes.
</p>

<p>
<strong>Un arc (X<sub>i</sub>, X<sub>j</sub>)</strong> într-un graf de restricții orientat se numeste <strong><em>arc-consistent</em></strong> dacă și numai dacă pentru orice valoare x ∈ D<sub>i</sub>, domeniul variabilei X<sub>i</sub>, există o valoare y ∈ D<sub>j</sub>, domeniul variabilei X<sub>j</sub>, astfel incat R<sub>i,j</sub>(x,y). <strong>Graful de restrictii orientat</strong> rezultat se numește <strong><em>arc-consistent</em></strong>.
</p>

<p>
O cale de lungime <em>m</em> prin nodurile i<sub>0</sub>,…,i<sub>m</sub> ale unui graf de restricții orientat se numeste <strong><em>m-cale-consistentă</em></strong> dacă și numai dacă pentru orice valoare x ∈ D<sub>i0</sub>, domeniul variabilei i<sub>0</sub> și o valoare y ∈ D<sub>im</sub>, domeniul variabilei i<sub>m</sub>, pentru care R<sub>i0,im</sub>(x,y), există o secvență de valori z<sub>1</sub> ∈ D<sub>i1 … zm-1</sub> ∈ D<sub>im-1</sub> astfel încât R<sub>i0,i1</sub>(x,z<sub>1</sub>), …, R<sub>im-1,im</sub>(z<sub>m-1</sub>,y). <strong><em>Graful de restrictii orientat</em></strong> rezultat se numește <strong><em>m-arc-consistent</em></strong>.
</p>

<p>
<strong>Arc-consistența unui graf de restricții</strong> se verifica folosind următorii algoritmi:
</p>
<pre class="code cpp">Verifică <span class="br0">&#40;</span>Xk, Xm<span class="br0">&#41;</span>
	<span class="kw3">delete</span> <span class="sy1">=</span> <span class="kw2">false</span>
	foreach x ∈ Dk
		<span class="kw1">if</span> nu există nici o valoare y ∈ Dm astfel încât Rk,m<span class="br0">&#40;</span>x,y<span class="br0">&#41;</span> 
			elimină x din Dk 
			<span class="kw3">delete</span> <span class="sy1">=</span> <span class="kw2">true</span>
	<span class="kw1">return</span> <span class="kw3">delete</span>
&nbsp;
AC<span class="sy2">-</span><span class="nu0">1</span><span class="sy4">:</span>
&nbsp;
Crează Q ← <span class="br0">&#123;</span> <span class="br0">&#40;</span>Xi, Xj<span class="br0">&#41;</span> <span class="sy3">|</span> <span class="br0">&#40;</span>Xi, Xj<span class="br0">&#41;</span> ∈ Mulțime arce, i≠j<span class="br0">&#125;</span> 
repeat
	modificat <span class="sy1">=</span> <span class="kw2">false</span>
	foreach <span class="br0">&#40;</span>Xi, Xj<span class="br0">&#41;</span> ∈ Q
		modificat <span class="sy1">=</span> modificat or Verifică<span class="br0">&#40;</span>Xi, Xj<span class="br0">&#41;</span>
until modificat<span class="sy1">==</span><span class="kw2">false</span>
&nbsp;
AC<span class="sy2">-</span><span class="nu0">3</span><span class="sy4">:</span>
&nbsp;
Crează Q ← <span class="br0">&#123;</span> <span class="br0">&#40;</span>Xi, Xj<span class="br0">&#41;</span> <span class="sy3">|</span> <span class="br0">&#40;</span>Xi, Xj<span class="br0">&#41;</span> ∈ Multime arce, i≠j<span class="br0">&#125;</span> 
<span class="kw1">while</span> Q nu este vida
	Elimină din Q un arc <span class="br0">&#40;</span>Xk, Xm<span class="br0">&#41;</span>
	<span class="kw1">if</span> Verifică<span class="br0">&#40;</span>Xk, Xm<span class="br0">&#41;</span>then
		Q ← Q ∪ <span class="br0">&#123;</span> <span class="br0">&#40;</span>Xi, Xk<span class="br0">&#41;</span> <span class="sy3">|</span> <span class="br0">&#40;</span>Xi, Xk<span class="br0">&#41;</span> ∈ Multime arce, i≠k,m<span class="br0">&#125;</span></pre>

<p>
Pornind de la următoarele notații:
</p>
<ul>
<li class="level1"><div class="li">N - numărul de variabile;</div>
</li>
<li class="level1"><div class="li">a - cardinalitatea maximă a domeniilor de valori ale variabilelor;</div>
</li>
<li class="level1"><div class="li">e - numărul de restricții.</div>
</li>
</ul>

<p>
complexitățile algoritmilor precedenți sunt următoarele:
</p>
<ul>
<li class="level1"><div class="li">Algoritmului de realizare a arc-consistentei - AC-1 are în cazul cel mai defavorabil complexitatea <strong>O(a<sup>2</sup>*N*e)</strong></div>
</li>
<li class="level1"><div class="li">Algoritmului de realizare a arc-consistentei - AC-3: complexitate timp este <strong>O(e*a<sup>3</sup>)</strong>; complexitate spatiu: <strong>O(e+N*a)</strong></div>
</li>
<li class="level1"><div class="li">Algoritmului de realizare a arc-consistentei - AC-4 care presupune o îmbunătățire a complexității în timp: <strong>O(e*a<sup>2</sup>)</strong></div>
</li>
<li class="level1"><div class="li">Algoritmul de realizare a 2-cale-consistentei - PC-4: complexitate timp <strong>O(N<sup>3</sup>*a<sup>3</sup>)</strong></div>
</li>
</ul>

</div>
<!-- EDIT5 SECTION "Problema satisfacerii constrângerilor" [4173-8847] -->
<h3 class="sectionedit6" id="euristici">Euristici</h3>
<div class="level3">

<p>
<strong>Ordonarea variabilelor</strong> urmărește reordonarea variabilelor legate prin restricții explicite (specificate de mulțimea de restricții definită în problemă) astfel încât numărul de operații ulterioare să fie minim. Astfel sunt preferate mai întâi variabilele care apar într-un număr mare de restricții și au domenii de valori cu cardinalitate mică.
</p>

<p>
<strong>Ordonarea valorilor</strong> pleacă de la premisa că nu toate valorile din domeniul variabilelor apar în toate restricțiile. Și în acest caz sunt preferate mai întâi variabilele cele mai restricționate, cu cele mai puține atribuiri posibile.
</p>

<p>
<strong>Ordonarea testelor</strong> presupune începerea cu variabila precedentă cea mai restricționată.
</p>

</div>
<!-- EDIT6 SECTION "Euristici" [8848-9580] -->
<h3 class="sectionedit7" id="tehnici_prospective">Tehnici prospective</h3>
<div class="level3">

<p>
Principiul este simplu: fiecare pas spre soluție nu trebuie să ducă la blocare. Astfel, la fiecare atribuire a variabilei curente cu o valoare corespunzătoare, toate variabilele sunt verificate pentru a depista eventuale condiții de blocare. Anumite valori ale variabilelor neinstanțiate pot fi eliminate deoarece nu vor putea să facă parte din soluție niciodată.
Următorii algoritmi analizați implementează strategia de căutare neinformată cu realizarea unor grade diferite de k-consistență.
</p>

<p>
<strong>Backtracking cu predicție completă</strong>
</p>
<pre class="code cpp">Predicție<span class="br0">&#40;</span>U, F, D<span class="br0">&#41;</span>
foreach L of D<span class="br0">&#91;</span>U<span class="br0">&#93;</span>
F<span class="br0">&#91;</span>U<span class="br0">&#93;</span> ← L
<span class="kw1">if</span> U <span class="sy1">&lt;</span> N then
	DNEW ← Verifică_Inainte <span class="br0">&#40;</span>U, L, D<span class="br0">&#41;</span>
	<span class="kw1">if</span> DNEW <span class="sy3">!</span><span class="sy1">=</span> null
		then DNEW  ← Verifica _Viitoare <span class="br0">&#40;</span>U, DNEW<span class="br0">&#41;</span>
	<span class="kw1">if</span> DNEW <span class="sy3">!</span><span class="sy1">=</span> null
		then Predictie <span class="br0">&#40;</span>U<span class="sy2">+</span><span class="nu0">1</span>, F, DNEW<span class="br0">&#41;</span>
&nbsp;
Verifica_Înainte <span class="br0">&#40;</span>U, L, D<span class="br0">&#41;</span>
inițializează DNEW
<span class="kw1">for</span> U2 <span class="sy1">=</span> U<span class="sy2">+</span><span class="nu0">1</span>..<span class="me1">N</span>
	foreach L2 of D<span class="br0">&#91;</span>U2<span class="br0">&#93;</span>
		<span class="kw1">if</span> Relatie<span class="br0">&#40;</span>U, L, U2, L2<span class="br0">&#41;</span> <span class="sy1">==</span> <span class="kw2">true</span> 
			then introduce L2 in DNEW<span class="br0">&#91;</span>U2<span class="br0">&#93;</span>
	daca DNEW<span class="br0">&#91;</span>U2<span class="br0">&#93;</span> vidă
		atunci <span class="kw1">return</span> null
<span class="kw1">return</span> DNEW
&nbsp;
Verifica_Viitoare <span class="br0">&#40;</span>U, DNEW<span class="br0">&#41;</span>
<span class="kw1">for</span> U1 <span class="sy1">=</span> U<span class="sy2">+</span><span class="nu0">1</span>..<span class="me1">N</span>
	foreach L1 of DNEW<span class="br0">&#91;</span>U1<span class="br0">&#93;</span>
		<span class="kw1">for</span> U2 <span class="sy1">=</span> U<span class="sy2">+</span><span class="nu0">1</span>..<span class="me1">N</span>
			foreach L2 of DNEW<span class="br0">&#91;</span>U2<span class="br0">&#93;</span>
				<span class="kw1">if</span> Relatie <span class="br0">&#40;</span>U1, L1, U2, L2<span class="br0">&#41;</span> <span class="sy1">==</span> <span class="kw2">true</span>
				then <span class="kw1">break</span> L2
			<span class="kw1">if</span> nu s<span class="sy2">-</span>a gasit o valoare consistenta pentru U2 then
				elimina L1 din DNEW<span class="br0">&#91;</span>U1<span class="br0">&#93;</span>
				<span class="kw1">break</span> U2
	<span class="kw1">if</span> DNEW<span class="br0">&#91;</span>U1<span class="br0">&#93;</span> vidă then <span class="kw1">return</span> null
<span class="kw1">return</span> DNEW</pre>

<p>
<strong>Backtracking-ul cu predictie parțială</strong> presupune modificarea doar a funcției Verifică_Viitoare din prisma domeniului de vizibilitate a variabilei U<sub>2</sub> care acum variază exclusiv de la U<sub>1</sub>+1, nu direct de la U+1. Rezultatul imediat este înjumătățirea numărului de operații efectuate la nivelul funcției.
</p>
<pre class="code cpp">Verifica_Viitoare <span class="br0">&#40;</span>U, DNEW<span class="br0">&#41;</span>
…
<span class="kw1">for</span> U1 <span class="sy1">=</span> U<span class="sy2">+</span><span class="nu0">1</span>..<span class="me1">N</span>
	foreach L1 of DNEW<span class="br0">&#91;</span>U1<span class="br0">&#93;</span>
		<span class="kw1">for</span> U2 <span class="sy1">=</span> U1<span class="sy2">+</span><span class="nu0">1</span>..<span class="me1">N</span>
			foreach L2 of DNEW<span class="br0">&#91;</span>U2<span class="br0">&#93;</span>
				…</pre>

<p>
<strong>Backtracking-ul cu verificare predictivă</strong> elimină apelul Verifica_Viitoare(U, DNEW) complet din funcția de Predicție
</p>
<pre class="code cpp">Predicție<span class="br0">&#40;</span>U, F, D<span class="br0">&#41;</span>
…
		DNEW ← Verifică_Inainte <span class="br0">&#40;</span>U, D<span class="br0">&#91;</span>U<span class="br0">&#93;</span>, D<span class="br0">&#41;</span>
		<span class="co1">// if DNEW != null</span>
		<span class="co1">//	then DNEW  ← Verifica _Viitoare (U, DNEW)</span>
		<span class="kw1">if</span> DNEW <span class="sy3">!</span><span class="sy1">=</span> null
			…</pre>

<p>
Discuția care se ridică imediat este care dintre cele 3 metode este mai eficientă? Părerile sunt împărțite în sensul că uneori costul rafinărilor ulterioare poate fi mai mare decât costul expandării efective a nodului curent, dar totodată se poate obține o reducere semnificativă a numărului de apeluri recursive prin eliminarea unor soluții neviabile. Certitudinea este că oricare dintre aceste metode reduce corespunzător numărul de intrări în stivă, dar trebuie luat în considerare în funcție de specificul problemei și costul operației de Verifica_Viitoare.
</p>

<p>
Un aspect important este că toate cele trei variante de tehnici prospective pot fi îmbunatatite prin introducerea de euristicii, lucru echivalent cu o reordonare dinamică a variabilelor la fiecare avans în căutare. Experimental, s-a dovedit că introducerea acestor euristici (ex. selecția următoarei variabile urmărind ca aceasta să aibă cele mai puține valori rămase în domeniul propriu) furnizează rezultate foarte bune.
</p>

</div>
<!-- EDIT7 SECTION "Tehnici prospective" [9581-12742] -->
<h2 class="sectionedit8" id="concluzii_si_observatii">Concluzii și observații</h2>
<div class="level2">

<p>
Metodele descrise pot fi aplicate pe o plajă largă de probleme, iar optimizările prezentate pot duce la scăderi drastice ai timpilor de execuție. Combinarea anumitor metode, precum tehnici prospective cu euristici duce la rezultate și mai bune, demonstrate în practică. 
Astfel, majoritatea problemelor care presupun parcurgeri în spațiul stărilor pot fi abordate pornind de la unul dintre algoritmii descriși.
</p>

</div>
<!-- EDIT8 SECTION "Concluzii și observații" [12743-13205] -->
<h2 class="sectionedit9" id="sudoku">Sudoku</h2>
<div class="level2">

<p>
<p><div class="noteimportant">
La finalul laboratorului, încărcați soluțiile <a href="http://cs.curs.pub.ro/2015/mod/assign/view.php?id=5040" class="urlextern" title="http://cs.curs.pub.ro/2015/mod/assign/view.php?id=5040"  rel="nofollow">aici</a>.

</div></p>
</p>

<p>
Jocul clasic rezolvat prin BKT la nivelul căruia aplicăm diverse optimizări este Sudoku. Astfel, avem o matrice 9 X 9 subdivizată în 9 sub-matrici identice de dimensiuni 3 X 3, denumite regiuni. 
</p>

<p>
Regula jocului este simplă: fiecare rând, coloană sau regiune nu trebuie să conţină decât o dată cifrele de la unu la nouă. Formulat altfel, fiecare ansamblu trebuie să conţină cifrele de la unu la nouă o singură dată.
</p>

</div>
<!-- EDIT9 SECTION "Sudoku" [13206-14948] -->
<h3 class="sectionedit10" id="backtracking_5p">1. Backtracking [5p]</h3>
<div class="level3">

<p>
Să se rezolve problema folosind tehnica backtracking.
</p>

</div>
<!-- EDIT10 SECTION "1. Backtracking [5p]" [14949-15036] -->
<h3 class="sectionedit11" id="backtracking_si_o_metoda_prospectiva_preferabil_predictie_partiala_sau_completa_5p">2. Backtracking şi o metodă prospectivă (preferabil predictie parțială sau completă) [5p]</h3>
<div class="level3">

</div>
<!-- EDIT11 SECTION "2. Backtracking şi o metodă prospectivă (preferabil predictie parțială sau completă) [5p]" [15037-15301] -->
<h3 class="sectionedit12" id="euristica_2p">3. Euristică [2p]</h3>
<div class="level3">

<p>
Modificați codul anterior: implementați o euristică la alegere și explicați efectele acesteia asupra timpului de execuție și a numarului de intrări în recursivitate.
</p>

<p>
<p><div class="noteclassic">
Pentru fiecare solutie anterioară se va analiza impactul la nivelul timpului total de execuție (care pot fi influențați și de alte procese din sistemul de operare, respectiv alocări și procese interne ale JVM, etc.), precum și al numărului de intrări în recursivitate.

</div></p>
</p>

</div>
<!-- EDIT12 SECTION "3. Euristică [2p]" [15302-15803] -->
<h2 class="sectionedit13" id="referinte">Referințe</h2>
<div class="level2">

<p>
[1] Curs BLIA, Prof. Ing. Adina Magda Florea
</p>

<p>
[2] Introducere in Algoritmi, Thomas H. Cormen; Charles E. Leiserson, Ronald R. Rivest, Cliff Stein (1990)
</p>

<p>
[3] The Art of Computer Programming, Donald E. Knuth (1968)
</p>

<p>
[4] CSP Tutorial <a href="http://4c.ucc.ie/web/outreach/tutorial.html" class="urlextern" title="http://4c.ucc.ie/web/outreach/tutorial.html"  rel="nofollow">http://4c.ucc.ie/web/outreach/tutorial.html</a>
</p>

<p>
[5] The Complexity of Some Polynomial Network Consitency Algorithms for Constraint Satisfaction Problems disponibil la <a href="http://cse.unl.edu/~choueiry/Documents/AC-MackworthFreuder.pdf" class="urlextern" title="http://cse.unl.edu/~choueiry/Documents/AC-MackworthFreuder.pdf"  rel="nofollow">http://cse.unl.edu/~choueiry/Documents/AC-MackworthFreuder.pdf</a>
</p>

<p>
[6] <a href="http://en.wikipedia.org/wiki/Backtracking" class="urlextern" title="http://en.wikipedia.org/wiki/Backtracking"  rel="nofollow">http://en.wikipedia.org/wiki/Backtracking</a>
</p>

<p>
[7] <a href="http://en.wikipedia.org/wiki/Constraint_satisfaction_problem" class="urlextern" title="http://en.wikipedia.org/wiki/Constraint_satisfaction_problem"  rel="nofollow">http://en.wikipedia.org/wiki/Constraint_satisfaction_problem</a>
</p>

</div>
<!-- EDIT13 SECTION "Referințe" [15804-] --></div>
</body>
</html>
