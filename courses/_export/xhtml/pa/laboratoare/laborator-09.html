    
    

<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
  <meta charset="utf-8" />
  <title>pa:laboratoare:laborator-09</title>
<meta name="generator" content="DokuWiki"/>
<meta name="robots" content="index,follow"/>
<meta name="date" content="2016-04-24T20:16:38+0300"/>
<meta name="keywords" content="pa,laboratoare,laborator-09"/>
<link rel="search" type="application/opensearchdescription+xml" href="../../../../lib/exe/opensearch.php" title="CS Open CourseWare"/>
<link rel="start" href="../../../../../courses.1.html"/>
<link rel="alternate" type="application/rss+xml" title="Recent Changes" href="../../../../feed.php"/>
<link rel="alternate" type="application/rss+xml" title="Current Namespace" href="../../../../feed.php%3Fmode=list&amp;ns=pa:laboratoare"/>
<link rel="alternate" type="text/html" title="Plain HTML" href="laborator-09.html"/>
<link rel="canonical" href="../../../../pa/laboratoare/laborator-09.html"/>
<link rel="stylesheet" type="text/css" href="../../../../lib/exe/css.php%3Ft=arctic&amp;tseed=1476798676.css"/>
<script type="text/javascript">/*<![CDATA[*/var NS='pa:laboratoare';var JSINFO = {"id":"pa:laboratoare:laborator-09","namespace":"pa:laboratoare","isadmin":0,"isauth":0};
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="../../../../lib/exe/js.php%3Ftseed=1476798676"></script>
<script type="text/x-mathjax-config">/*<![CDATA[*/MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ["$","$"], ["\\(","\\)"] ],
        displayMath: [ ["$$","$$"], ["\\[","\\]"] ],
        processEscapes: true
    }
});
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
<script type="text/javascript">/*<![CDATA[*/
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
		  
/*!]]>*/</script>
<script type="text/javascript">/*<![CDATA[*/
var pageTracker = _gat._getTracker("UA-38383934-1");
pageTracker._initData();
pageTracker._trackPageview();
		  
/*!]]>*/</script>
</head>
<body>
<div class="dokuwiki export">
<!-- TOC START -->
<div id="dw__toc">
<h3 class="toggle">Table of Contents</h3>
<div>

<ul class="toc">
<li class="level1"><div class="li"><a href="laborator-09.html#laborator_9_-_arbori_minimi_de_acoperire">Laborator 9 - Arbori Minimi de Acoperire</a></div>
<ul class="toc">
<li class="level2"><div class="li"><a href="laborator-09.html#obiective_laborator">Obiective laborator</a></div></li>
<li class="level2"><div class="li"><a href="laborator-09.html#importanta_aplicatii_practice">Importanţă – aplicaţii practice</a></div></li>
<li class="level2"><div class="li"><a href="laborator-09.html#descrierea_problemei_si_a_rezolvarilor">Descrierea problemei şi a rezolvărilor</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="laborator-09.html#algoritmul_kruskal">Algoritmul Kruskal</a></div></li>
</ul>
</li>
<li class="level2"><div class="li"><a href="laborator-09.html#pseudocod">Pseudocod</a></div></li>
<li class="level2"><div class="li"><a href="laborator-09.html#exemplu_de_rulare">Exemplu de rulare</a></div></li>
<li class="level2"><div class="li"><a href="laborator-09.html#complexitate">Complexitate</a></div>
<ul class="toc">
<li class="clear">
<ul class="toc">
<li class="level4"><div class="li"><a href="laborator-09.html#algoritmul_prim">Algoritmul Prim</a></div></li>
</ul>
</li>
</ul>
</li>
<li class="level2"><div class="li"><a href="laborator-09.html#pseudocod1">Pseudocod</a></div></li>
<li class="level2"><div class="li"><a href="laborator-09.html#exemplu_de_rulare1">Exemplu de rulare</a></div></li>
<li class="level2"><div class="li"><a href="laborator-09.html#complexitate1">Complexitate</a></div></li>
<li class="level2"><div class="li"><a href="laborator-09.html#concluzii">Concluzii</a></div></li>
<li class="level2"><div class="li"><a href="laborator-09.html#referinte">Referinţe</a></div></li>
</ul>
</li>
<li class="level1"><div class="li"><a href="laborator-09.html#probleme">Probleme</a></div>
<ul class="toc">
<li class="clear">
<ul class="toc">
<li class="level3"><div class="li"><a href="laborator-09.html#cablare_optima_in_retele_de_date_10p">1.	Cablare optimă în rețele de date (10p)</a></div></li>
</ul></li>
</ul></li>
</ul>
</div>
</div>
<!-- TOC END -->

<h1 class="sectionedit1" id="laborator_9_-_arbori_minimi_de_acoperire">Laborator 9 - Arbori Minimi de Acoperire</h1>
<div class="level1">

</div>
<!-- EDIT1 SECTION "Laborator 9 - Arbori Minimi de Acoperire" [1-56] -->
<h2 class="sectionedit2" id="obiective_laborator">Obiective laborator</h2>
<div class="level2">
<ul>
<li class="level1"><div class="li">Însuşirea conceptului de arbore minim de acoperire;</div>
</li>
<li class="level1"><div class="li">Înţelegerea modului de funcţionare a algoritmilor de determinare a unui arbore minim de acoperire prezentaţi;</div>
</li>
<li class="level1"><div class="li">Aplicarea algoritmilor în rezolvarea problemelor;</div>
</li>
</ul>

</div>
<!-- EDIT2 SECTION "Obiective laborator" [57-317] -->
<h2 class="sectionedit3" id="importanta_aplicatii_practice">Importanţă – aplicaţii practice</h2>
<div class="level2">

<p>
Găsirea unui arbore minim de acoperire pentru un graf are aplicaţii în domenii cât se poate de variate:
</p>
<ul>
<li class="level1"><div class="li">Reţele (de calculatoare, telefonie, cablu TV, electricitate, drumuri): se doreşte interconectarea mai multor puncte, cu un cost redus şi atunci este utilă cunoaşterea arborelui care conectează toate punctele, cu cel mai mic cost posibil. STP(Spanning Tree Protocol) este un protocol de rutare care previne apariţia buclelor într-un <abbr title="Local Area Network">LAN</abbr>, şi se bazează pe crearea unui arbore de acoperire. Singurele legături active sunt cele care apar în acest arbore, iar astfel se evită buclele.</div>
</li>
<li class="level1"><div class="li">Segmentarea imaginilor: împărţirea unei imagini în regiuni de pixeli cu proprietăţi asemănătoare. E utilă mai apoi în analiza medicală a unei zone afectate de o tumoare de exemplu.</div>
</li>
<li class="level1"><div class="li">Algoritmi de aproximare pt probleme NP-dure: problema comis-voiajorului, arbori Steiner.</div>
</li>
<li class="level1"><div class="li">Clustering: pentru detectarea de clustere cu forme neregulate [8], [9].</div>
</li>
</ul>

</div>
<!-- EDIT3 SECTION "Importanţă – aplicaţii practice" [318-1334] -->
<h2 class="sectionedit4" id="descrierea_problemei_si_a_rezolvarilor">Descrierea problemei şi a rezolvărilor</h2>
<div class="level2">

<p>
Dându-se un graf conex neorientat G =(V, E), se numeşte arbore de acoperire al lui G un subgraf G’=(V, E’)  care conţine toate vârfurile grafului G şi o submulţime minimă de muchii E’⊆ E cu proprietatea că uneşte toate vârfurile şi nu conţine cicluri. Cum G’ este conex şi aciclic, el este arbore. Pentru un graf oarecare, există mai mulţi arbori de acoperire.
</p>

<p>
Dacă asociem o matrice de costuri, w, pentru muchiile din G, fiecare arbore de acoperire va avea asociat un cost egal cu suma costurilor muchiilor conţinute. Un arbore care are costul asociat mai mic sau egal cu costul oricărui alt arbore de acoperire se numeşte arbore minim de acoperire (minimum spanning tree) al grafului G. Un graf poate avea mai mulţi arbori minimi de acoperire. Dacă toate costurile muchiilor sunt diferite, există un singur AMA. 
Primul algoritm pentru determinarea unui arbore minim de acoperire a fost scris în 1926 de Otakar Boruvka. În prezent, cei mai folosiţi algoritmi sunt Prim şi Kruskal. Toţi trei sunt algoritmi greedy, şi rulează în timp polinomial. La fiecare pas, pentru a construi arborele se alege cea mai bună variantă posibilă la momentul respectiv. Generic, algoritmul de determinare a unui AMA se poate scrie astfel:
</p>
<pre class="code cpp">ArboreMinimDeAcoperire<span class="br0">&#40;</span>G<span class="br0">&#40;</span>V, E<span class="br0">&#41;</span>, c<span class="br0">&#41;</span>
	MuchiiAMA <span class="sy1">=</span> ∅<span class="sy4">;</span>
	<span class="kw1">while</span> <span class="br0">&#40;</span>MuchiiAMA nu reprezintă muchiile unui arbore minim de acoperire<span class="br0">&#41;</span>
		găseşte o muchie <span class="br0">&#40;</span>u, v<span class="br0">&#41;</span> care este sigură pentru MuchiiAMA<span class="sy4">;</span>
		MuchiiAMA <span class="sy1">=</span> MuchiiAMA ∪ <span class="br0">&#123;</span><span class="br0">&#40;</span>u, v<span class="br0">&#41;</span><span class="br0">&#125;</span><span class="sy4">;</span>
	<span class="kw1">return</span> MuchiiAMA<span class="sy4">;</span></pre>

<p>
O muchie sigură este o muchie care se poate adăuga unei submulţimi de muchii ale unui arbore minim de acoperire, astfel încât noua mulţime obţinută să aparţină tot unui arbore minim de acoperire. Iniţial, MuchiiAMA este o mulţime vidă. La fiecare pas, se adaugă câte o muchie sigură, deci MuchiiAMA rămâne o submulţime a unui AMA. În consecinţă, la sfarşitul rulării algoritmului (când muchiile din mulţime unesc toate nodurile din graf), MuchiiAMA va conţine de fapt arborele minim de acoperire dorit.
</p>

</div>
<!-- EDIT4 SECTION "Descrierea problemei şi a rezolvărilor" [1335-3456] -->
<h3 class="sectionedit5" id="algoritmul_kruskal">Algoritmul Kruskal</h3>
<div class="level3">

<p>
Algoritmul a fost dezvoltat în 1956 de Joseph Kruskal. Determinarea arborelui minim de acoperire se face prin reuniuni de subarbori minimi de acoperire. Iniţial, se consideră că fiecare nod din graf este un arbore. Apoi, la fiecare pas se selectează muchia de cost minim care uneşte doi subarbori disjuncţi, şi se realizează unirea celor doi subarbori. Muchia respectivă se adaugă la mulţimea MuchiiAMA, care la sfârşit va conţine chiar muchiile din arborele minim de acoperire. 
</p>

</div>
<!-- EDIT5 SECTION "Algoritmul Kruskal" [3457-3982] -->
<h2 class="sectionedit6" id="pseudocod">Pseudocod</h2>
<div class="level2">
<pre class="code cpp">Kruskal<span class="br0">&#40;</span>G<span class="br0">&#40;</span>V, E<span class="br0">&#41;</span>, w<span class="br0">&#41;</span>
MuchiiAMA <span class="sy1">&lt;</span><span class="sy2">-</span> ∅<span class="sy4">;</span>
<span class="kw1">for</span> each v in V <span class="kw1">do</span>
	MakeSet<span class="br0">&#40;</span>v<span class="br0">&#41;</span><span class="sy4">;</span>	<span class="co1">//fiecare nod e un arbore diferit</span>
sort<span class="br0">&#40;</span>E<span class="br0">&#41;</span><span class="sy4">;</span>		<span class="co1">//sortează muchiile în ordine crescătoare a costului</span>
<span class="kw1">for</span> each <span class="br0">&#40;</span>u,v<span class="br0">&#41;</span> in E <span class="kw1">do</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span>FindSet<span class="br0">&#40;</span>u<span class="br0">&#41;</span> <span class="sy3">!</span><span class="sy1">=</span> FindSet<span class="br0">&#40;</span>v<span class="br0">&#41;</span><span class="br0">&#41;</span> then	<span class="co1">//capetele muchiei fac parte //din subarbori disjuncţi</span>
		MuchiiAMA <span class="sy1">=</span> MuchiiAMA ∪ <span class="br0">&#123;</span><span class="br0">&#40;</span>u, v<span class="br0">&#41;</span><span class="br0">&#125;</span><span class="sy4">;</span>	<span class="co1">//adaugă muchia la arbore</span>
		Union<span class="br0">&#40;</span>u, v<span class="br0">&#41;</span><span class="sy4">;</span>    <span class="co1">//uneşte subarborii corespunzători lui u şi v</span>
<span class="kw1">return</span> MuchiiAMA<span class="sy4">;</span></pre>

<p>
Bucla principală for poate fi înlocuită cu o buclă while, în care se verifică dacă în MuchiiAMA există mai puţin de |V| - 1 muchii, pentru că orice arbore de acoperire are |V| - 1 muchii, iar la fiecare pas se adaugă o muchie sigură.
</p>

</div>
<!-- EDIT6 SECTION "Pseudocod" [3983-4710] -->
<h2 class="sectionedit7" id="exemplu_de_rulare">Exemplu de rulare</h2>
<div class="level2">

<p>
Se consideră graful  din figura următoare:
</p>

<p>
Fiecare subarbore va fi colorat diferit. Cum iniţial fiecare nod reprezintă un subarbore, nodurile au culori diferite. Pe măsură ce subarborii sunt uniţi, nodurile aparţinând aceluiaşi subarbore vor fi coloraţi identic. Costurile muchiilor sunt sortate în ordine crescătoare.
</p>

<p>
<a href="../../../../_detail/pa/laboratoare/92.jpg%3Fid=pa%253Alaboratoare%253Alaborator-09.html" class="media" title="pa:laboratoare:92.jpg"><img src="../../../../_media/pa/laboratoare/92.jpg" class="mediacenter" alt="" /></a>
</p>

<p>
<strong>Pas 1</strong>
</p>

<p>
Se alege prima muchie, (1,4). Se observă că uneşte subarborii {1} şi {4}, deci muchia e adăugată la MuchiiAMA, iar cei doi subarbori se unesc.
<a href="../../../../_detail/pa/laboratoare/93.jpg%3Fid=pa%253Alaboratoare%253Alaborator-09.html" class="media" title="pa:laboratoare:93.jpg"><img src="../../../../_media/pa/laboratoare/93.jpg" class="mediacenter" alt="" /></a>
MuchiiAMA = {(1,4)}.
</p>

<p>
<strong>Pas 2</strong>
</p>

<p>
Următoarea muchie este (7,8), care uneşte {7} şi {8}. Se adaugă la MuchiiAMA şi se unesc cei doi subarbori.
<a href="../../../../_detail/pa/laboratoare/94.jpg%3Fid=pa%253Alaboratoare%253Alaborator-09.html" class="media" title="pa:laboratoare:94.jpg"><img src="../../../../_media/pa/laboratoare/94.jpg" class="mediacenter" alt="" /></a>
MuchiiAMA = {(1,4),(7,8)}.
</p>

<p>
<strong>Pas 3</strong>
</p>

<p>
Următoarea muchie este (5,6), care uneşte {5} şi {6}. Se adaugă la MuchiiAMA şi se unesc cei doi subarbori.
<a href="../../../../_detail/pa/laboratoare/95.jpg%3Fid=pa%253Alaboratoare%253Alaborator-09.html" class="media" title="pa:laboratoare:95.jpg"><img src="../../../../_media/pa/laboratoare/95.jpg" class="mediacenter" alt="" /></a>
MuchiiAMA = {(1,4),(7,8),(5,6)}.
</p>

<p>
<strong>Pas 4</strong>
</p>

<p>
Următorul cost este 4. Se observă că muchiile (1,2) şi (2,4) au costul 4 şi unesc {2} cu {1,4}. Se adaugă la MuchiiAMA una dintre cele două muchii, fie ea (1,2), şi se unesc cei doi subarbori. Alegerea muchiei (2,4) va duce la găsirea unui alt AMA. [Am spus anterior că un graf poate avea mai mulţi arbori minimi de acoperire, cu acelaşi cost, dacă există muchii diferite cu acelaşi cost.]
<a href="../../../../_detail/pa/laboratoare/96.jpg%3Fid=pa%253Alaboratoare%253Alaborator-09.html" class="media" title="pa:laboratoare:96.jpg"><img src="../../../../_media/pa/laboratoare/96.jpg" class="mediacenter" alt="" /></a>
MuchiiAMA = {(1,4),(7,8),(5,6),(1,2)}.
</p>

<p>
<strong>Pas 5</strong>
</p>

<p>
Următoarea muchie de cost minim este (5,8), care uneşte {5,6} şi {7,8}. Se adaugă la MuchiiAMA şi se unesc cei doi subarbori, rezultând {5,6,7,8}.
<a href="../../../../_detail/pa/laboratoare/97.jpg%3Fid=pa%253Alaboratoare%253Alaborator-09.html" class="media" title="pa:laboratoare:97.jpg"><img src="../../../../_media/pa/laboratoare/97.jpg" class="mediacenter" alt="" /></a>
MuchiiAMA = {(1,4),(7,8),(5,6),(1,2), (5,8)}.
</p>

<p>
<strong>Pas 6</strong>
</p>

<p>
Muchia (5,7), care are cel mai mic cost actual, are ambele extremităţi în subarborele {5,6,7,8}. În consecinţă, nu se efectuează nicio schimbare.
</p>

<p>
MuchiiAMA = {(1,4),(7,8),(5,6),(1,2),(5,8)}.
</p>

<p>
<strong>Pas 7</strong>
</p>

<p>
Următorul cost este 7. Se observă că muchiile (1,6) şi (4,5) au costul 7 şi unesc subarborii {1,2,4} şi {5,6,7,8}. Se adaugă la MuchiiAMA (1,6), şi se unesc cei doi subarbori. Alegerea muchiei (4,5) va duce la găsirea unui alt AMA.
<a href="../../../../_detail/pa/laboratoare/98.jpg%3Fid=pa%253Alaboratoare%253Alaborator-09.html" class="media" title="pa:laboratoare:98.jpg"><img src="../../../../_media/pa/laboratoare/98.jpg" class="mediacenter" alt="" /></a>
MuchiiAMA = {(1,4),(7,8),(5,6),(1,2),(5,8),(1,6)}.
</p>

<p>
<strong>Pas 8</strong>
</p>

<p>
Muchia (4,6) de cost 8 are capetele în acelaşi subarbore, deci nu se produc schimări.
</p>

<p>
MuchiiAMA = {(1,4),(7,8),(5,6),(1,2),(5,8),(1,6)}.
</p>

<p>
<strong>Pas 9</strong>
</p>

<p>
Muchia (1,3) de cost 9 uneşte cei doi subarbori rămaşi, {1,2,4,5,6,7,8} şi {3}. Deci după unire obţinem un singur arbore. (1,3) se adaugă la MuchiiAMA, care va conţine acum 7 muchii, iar algoritmul se opreşte. 
<a href="../../../../_detail/pa/laboratoare/91.jpg%3Fid=pa%253Alaboratoare%253Alaborator-09.html" class="media" title="pa:laboratoare:91.jpg"><img src="../../../../_media/pa/laboratoare/91.jpg" class="mediacenter" alt="" /></a>
Arborele minim de acoperire obţinut este {(1,4),(7,8),(5,6),(1,2),(5,8),(1,6), (1,3)}.Costul său se calculează însumând costurile tuturor muchiilor:
</p>

<p>
Cost(MuchiiAMA) = 1 + 2 + 3 + 4 + 5 + 7 + 9 = 31 
</p>

<p>
Alţi arbori minimi de acoperire pentru exemplul propus sunt:
* {(1,4),(7,8),(5,6),(1,2),(5,8),(4,5), (1,3)}
* {(1,4),(7,8),(5,6),(2,4),(5,8),(1,6), (1,3)}
* {(1,4),(7,8),(5,6),(2,4),(5,8),(4,5), (1,3)}.
</p>

<p>
Pentru alte exemple explicate consultaţi [2], [3] şi [5].
</p>

</div>
<!-- EDIT7 SECTION "Exemplu de rulare" [4711-7844] -->
<h2 class="sectionedit8" id="complexitate">Complexitate</h2>
<div class="level2">

<p>
Timpul de execuţie depinde de implementarea structurilor de date pentru mulţimi disjuncte. Vom presupune că se foloseşte o pădure cu mulţimi disjuncte[cor]. Iniţializarea se face într-un timp O(|V|). Sortarea muchiilor în funcţie de cost se face în O(|E|log|E|). În bucla principală se execută |E| operaţii care presupun două operaţii de găsire a subarborilor din care fac parte extremităţile muchiilor şi eventual o reuniune a acestor arbori, într-un timp O(|E|log|E|). 
</p>

<p>
Deci complexitatea totală este: O(|V|) + O(|E|log|E|) + O(|E|log|E|) = O(|E|log|E|).
</p>

<p>
Cum |E|⇐ |V|2, şi log(|V|2) = 2log(|V|) = log(|V|), rezultă o complexitate O(|E|log|V|).
</p>

</div>

<h4 id="algoritmul_prim">Algoritmul Prim</h4>
<div class="level4">

<p>
Algoritmul a fost prima oară dezvoltat în 1930 de matematicianul ceh Vojtěch Jarnik, şi independent în 1957 de informaticianul Robert Prim, al cărui nume l-a luat. Algoritmul consideră iniţial că fiecare nod este un subarbore independent, ca şi Kruskal. Însă spre deosebire de acesta, nu se construiesc mai mulţi subarbori care se unesc şi în final ajung să formeze AMA, ci există un arbore principal, iar la fiecare pas se adaugă acestuia muchia cu cel mai mic cost care uneşte un nod din arbore cu un nod din afara sa. Nodul rădăcină al arborelui principal se alege arbitrar. Când s-au adăugat muchii care ajung în toate nodurile grafului, s-a obţinut AMA dorit. Abordarea seamănă cu algoritmul Dijkstra de găsire a drumului minim între două noduri ale unui graf.
</p>

<p>
Pentru o implementare eficientă, următoarea muchie de adăugat la arbore trebuie să fie uşor de selectat. Vârfurile care nu sunt în arbore trebuie sortate în funcţie de distanţa până la acesta (de fapt costul minim al unei muchii care leagă nodul dat de un nod din interiorul arborelui). Se poate folosi pentru aceasta o structură de heap. Presupunând că (u, v) este muchia de cost minim care uneşte nodul u cu un nod v din arbore, se vor reţine două informaţii:
</p>
<ul>
<li class="level1"><div class="li"> d[u] = w[u,v] distanţa de la u la arbore</div>
</li>
<li class="level1"><div class="li"> p[u] = v predecesorul lui u în drumul minim de la arbore la u.</div>
</li>
</ul>

<p>
La fiecare pas se va selecta nodul u cel mai apropiat de arborele principal, reunind apoi arborele principal cu subarborele corespunzător nodului selectat. Se verifică apoi dacă există noduri mai apropiate de u decât de nodurile care erau anterior în arbore, caz în care trebuie modificate distanţele dar şi predecesorul. Modificarea unei distanţe impune şi refacerea structurii de heap.
</p>

</div>
<!-- EDIT8 SECTION "Complexitate" [7845-10366] -->
<h2 class="sectionedit9" id="pseudocod1">Pseudocod</h2>
<div class="level2">
<pre class="code cpp">Prim<span class="br0">&#40;</span>G<span class="br0">&#40;</span>V,E<span class="br0">&#41;</span>, w, root<span class="br0">&#41;</span>
<span class="nu0">1</span>.	<span class="me1">MuchiiAMA</span> <span class="sy1">&lt;</span><span class="sy2">-</span> ∅<span class="sy4">;</span>
<span class="nu0">2</span>.	<span class="kw1">for</span> each u in V <span class="kw1">do</span>
<span class="nu0">3</span>.		<span class="me1">d</span><span class="br0">&#91;</span>u<span class="br0">&#93;</span> <span class="sy1">=</span> INF<span class="sy4">;</span>	<span class="co1">//iniţial distanţele sunt infinit</span>
<span class="nu0">4</span>.		<span class="me1">p</span><span class="br0">&#91;</span>u<span class="br0">&#93;</span> <span class="sy1">=</span> NIL<span class="sy4">;</span>	<span class="co1">//şi nu există predecesori</span>
<span class="nu0">5</span>.	<span class="me1">d</span><span class="br0">&#91;</span>root<span class="br0">&#93;</span> <span class="sy1">=</span> <span class="nu0">0</span><span class="sy4">;</span>	<span class="co1">//distanţa de la rădăcină la arbore e 0</span>
<span class="nu0">6</span>.	<span class="me1">H</span> <span class="sy1">=</span> Heap<span class="br0">&#40;</span>V,d<span class="br0">&#41;</span><span class="sy4">;</span>	<span class="co1">//se construieşte heap-ul</span>
<span class="nu0">7</span>.	<span class="kw1">while</span> <span class="br0">&#40;</span>H not empty<span class="br0">&#41;</span> <span class="kw1">do</span>	<span class="co1">//cât timp mai sunt noduri neadăugate</span>
<span class="nu0">8</span>.		<span class="me1">u</span> <span class="sy1">=</span> GetMin<span class="br0">&#40;</span>H<span class="br0">&#41;</span><span class="sy4">;</span>	<span class="co1">//se selectează cel mai apropiat nod u</span>
<span class="nu0">9</span>.		<span class="me1">MuchiiAMA</span> <span class="sy1">=</span> MuchiiAMA ∪ <span class="br0">&#123;</span><span class="br0">&#40;</span>u, p<span class="br0">&#91;</span>u<span class="br0">&#93;</span><span class="br0">&#41;</span><span class="br0">&#125;</span><span class="sy4">;</span><span class="co1">//se adaugă muchia care uneşte u cu un nod din arborele principal </span>
<span class="nu0">10</span>.		<span class="kw1">for</span> each v in Adj<span class="br0">&#40;</span>u<span class="br0">&#41;</span> <span class="kw1">do</span>
		<span class="co1">//pentru toate nodurile adiacente lui u se verifică dacă</span>
		<span class="co1">//trebuie făcute modificări</span>
<span class="nu0">11</span>.			<span class="kw1">if</span> w<span class="br0">&#91;</span>u<span class="br0">&#93;</span><span class="br0">&#91;</span>v<span class="br0">&#93;</span> <span class="sy1">&lt;</span> d<span class="br0">&#91;</span>v<span class="br0">&#93;</span> then
<span class="nu0">12</span>.				<span class="me1">d</span><span class="br0">&#91;</span>v<span class="br0">&#93;</span> <span class="sy1">=</span> w<span class="br0">&#91;</span>u<span class="br0">&#93;</span><span class="br0">&#91;</span>v<span class="br0">&#93;</span><span class="sy4">;</span>
<span class="nu0">13</span>.				<span class="me1">p</span><span class="br0">&#91;</span>v<span class="br0">&#93;</span> <span class="sy1">=</span> u<span class="sy4">;</span>
<span class="nu0">14</span>.				<span class="me1">Heapify</span><span class="br0">&#40;</span>v, H<span class="br0">&#41;</span><span class="sy4">;</span>	<span class="co1">//refacerea structurii de heap</span>
<span class="nu0">15</span>.	<span class="me1">MuchiiAMA</span> <span class="sy1">=</span> MuchiiAMA \ <span class="br0">&#123;</span><span class="br0">&#40;</span>root, p<span class="br0">&#91;</span>root<span class="br0">&#93;</span><span class="br0">&#41;</span><span class="br0">&#125;</span><span class="sy4">;</span>
<span class="nu0">16</span>.	<span class="kw1">return</span> MuchiiAMA<span class="sy4">;</span></pre>

</div>
<!-- EDIT9 SECTION "Pseudocod" [10367-11226] -->
<h2 class="sectionedit10" id="exemplu_de_rulare1">Exemplu de rulare</h2>
<div class="level2">

<p>
Se consideră graful folosit pentru exemplificarea algoritmului Kruskal.
</p>

<p>
Iniţial fiecare nod reprezintă un arbore independent, şi are o culoare unică. Se alege ca rădăcină a arborelui principal nodul 1. 
</p>

<p>
<a href="../../../../_detail/pa/laboratoare/99.jpg%3Fid=pa%253Alaboratoare%253Alaborator-09.html" class="media" title="pa:laboratoare:99.jpg"><img src="../../../../_media/pa/laboratoare/99.jpg" class="mediacenter" alt="" /></a>
<strong>Pas 1</strong>
</p>

<p>
Se alege muchia de cost minim care uneşte rădăcina cu un alt nod: (1,4) de cost 1 si se adaugă arborelui principal.
<a href="../../../../_detail/pa/laboratoare/910.jpg%3Fid=pa%253Alaboratoare%253Alaborator-09.html" class="media" title="pa:laboratoare:910.jpg"><img src="../../../../_media/pa/laboratoare/910.jpg" class="mediacenter" alt="" /></a>
MuchiiAMA = {(1,4)}.
</p>

<p>
<strong>Pas 2</strong>
</p>

<p>
Se alege muchia de cost minim care uneşte 1 sau 4 cu un alt nod. (1,2) şi (2,4) au ambele costul 4. Se alege una dintre ele, fie ea (1,2).
<a href="../../../../_detail/pa/laboratoare/911.jpg%3Fid=pa%253Alaboratoare%253Alaborator-09.html" class="media" title="pa:laboratoare:911.jpg"><img src="../../../../_media/pa/laboratoare/911.jpg" class="mediacenter" alt="" /></a>
MuchiiAMA = {(1,4),(1,2)}.
</p>

<p>
<strong>Pas 3</strong>
</p>

<p>
Se alege următoarea muchie care uneşte {1,4,2} cu alt nod. (1,6) şi (4,5) au acelaşi cost, dar adaugă arborelui noduri diferite. La acest pas se selectează de exemplu (1,6). Selectând la acest pas (4,5) s-ar obţine un alt arbore de acoperire.
<a href="../../../../_detail/pa/laboratoare/912.jpg%3Fid=pa%253Alaboratoare%253Alaborator-09.html" class="media" title="pa:laboratoare:912.jpg"><img src="../../../../_media/pa/laboratoare/912.jpg" class="mediacenter" alt="" /></a>
MuchiiAMA = {(1,4),(1,2),(1,6)}.
</p>

<p>
<strong>Pas 4</strong>
</p>

<p>
Se caută muchia de cost minim care uneşte {1,4,2,6} cu un alt nod, şi se găseşte (6,5) de cost 3. Nodul 5 va fi adăugat arborelui principal.
<a href="../../../../_detail/pa/laboratoare/913.jpg%3Fid=pa%253Alaboratoare%253Alaborator-09.html" class="media" title="pa:laboratoare:913.jpg"><img src="../../../../_media/pa/laboratoare/913.jpg" class="mediacenter" alt="" /></a>
MuchiiAMA = {(1,4),(1,2),(1,6),(6,5)}.
</p>

<p>
<strong>Pas 5</strong>
</p>

<p>
Se alege muchia de cost minim care uneşte {1,4,2,6,5} cu un alt nod. (5,8) de cost 5 se adaugă listei de muchii.
<a href="../../../../_detail/pa/laboratoare/914.jpg%3Fid=pa%253Alaboratoare%253Alaborator-09.html" class="media" title="pa:laboratoare:914.jpg"><img src="../../../../_media/pa/laboratoare/914.jpg" class="mediacenter" alt="" /></a>
MuchiiAMA = {(1,4),(1,2),(1,6),(5,6),(5,8)}
</p>

<p>
<strong>Pas 6</strong>
</p>

<p>
Se alege muchia de cost minim (8,7) care uneşte {1,4,2,6,5,8} cu nodul 7.
<a href="../../../../_detail/pa/laboratoare/915.jpg%3Fid=pa%253Alaboratoare%253Alaborator-09.html" class="media" title="pa:laboratoare:915.jpg"><img src="../../../../_media/pa/laboratoare/915.jpg" class="mediacenter" alt="" /></a>
MuchiiAMA = {(1,4),(1,2),(1,6),(5,6),(5,8),(8,7)}.
</p>

<p>
<strong>Pas 7</strong>
<a href="../../../../_detail/pa/laboratoare/916.jpg%3Fid=pa%253Alaboratoare%253Alaborator-09.html" class="media" title="pa:laboratoare:916.jpg"><img src="../../../../_media/pa/laboratoare/916.jpg" class="mediacenter" alt="" /></a>
Se alege muchia (1,3) de cost 9, care uneşte arborele principal cu ultimul nod ramas, şi se adaugă mulţimii de muchii. Cum toate nodurile sunt acoperite, am obţinut un arbore minim de acoperire.
</p>

<p>
MuchiiAMA = {(1,4),(1,2),(1,6),(5,6),(5,8),(8,7),(1,3)}.
</p>

<p>
Cost(MuchiiAMA) = 1 + 4 + 7 + 3 + 5 + 2 + 9 = 31 
</p>

<p>
Alţi arbori minimi de acoperire pentru exemplul propus se pot obţine alegând diferit muchiile cu acelaşi cost (vezi paşii 2 şi 3) .
</p>

<p>
Pentru alte exemple explicate consultaţi [2], [4] şi [6].
</p>

</div>
<!-- EDIT10 SECTION "Exemplu de rulare" [11227-13373] -->
<h2 class="sectionedit11" id="complexitate1">Complexitate</h2>
<div class="level2">

<p>
Iniţializările se fac în O(|V|). Bucla principală while se execută de |V| ori. Procedura GetMin() are nevoie de un timp de ordinul O(lg|V|), deci toate apelurile vor dura O(|V|lg|V|). Bucla for este executată în total de O(|E|) ori, deoarece suma tuturor listelor de adiacenţă este 2|E|. Modificarea distanţei, a predecesorului, şi refacerea heapului se execută într-un timp de O(1), O(1) şi respectiv O(lg|V|). Deci în total bucla interioară for durează O(|E|lg|V|).
</p>

<p>
În consecinţă, timpul total de rulare este O(|V|lg|V|+|E|lg|V|), adică O(|E|lg|V|). Aceeaşi complexitate s-a obţinut şi pentru algoritmul Kruskal. Totuşi, timpul de execuţie al algoritmului Prin se poate îmbunătăţi până la O(|E|+|V|lg|V|), folosind heap-uri Fibonacci.
</p>

</div>
<!-- EDIT11 SECTION "Complexitate" [13374-14170] -->
<h2 class="sectionedit12" id="concluzii">Concluzii</h2>
<div class="level2">

<p>
Un arbore minim de acoperire al unui graf este un arbore care conţine toate nodurile, şi în plus acestea sunt conectate prin muchii care asigură un cost total minim. Determinarea unui arbore minim de acoperire pentru un graf este o problemă cu aplicaţii în foarte multe domenii: reţele, clustering, prelucrare de imagini. Cei mai cunoscuţi algoritmi, Prim şi Kruskal, rezolvă problema în timp polinomial. Performanţa algoritmilor depinde de modul de reprezentare a structurilor de date folosite. 
</p>

</div>
<!-- EDIT12 SECTION "Concluzii" [14171-14704] -->
<h2 class="sectionedit13" id="referinte">Referinţe</h2>
<div class="level2">

<p>
[1] – <a href="http://en.wikipedia.org/wiki/Minimum_spanning_tree" class="urlextern" title="http://en.wikipedia.org/wiki/Minimum_spanning_tree"  rel="nofollow">http://en.wikipedia.org/wiki/Minimum_spanning_tree</a>
</p>

<p>
[2] – T. Cormen, C. Leiserson, R. Rivest, C. Stein – Introducere în Algoritmi, cap. 24
</p>

<p>
[3] – <a href="http://en.wikipedia.org/wiki/Kruskal%27s_algorithm" class="urlextern" title="http://en.wikipedia.org/wiki/Kruskal%27s_algorithm"  rel="nofollow">http://en.wikipedia.org/wiki/Kruskal%27s_algorithm</a>
</p>

<p>
[4] – <a href="http://en.wikipedia.org/wiki/Prim%27s_algorithm" class="urlextern" title="http://en.wikipedia.org/wiki/Prim%27s_algorithm"  rel="nofollow">http://en.wikipedia.org/wiki/Prim%27s_algorithm</a>
</p>

<p>
[5] – <a href="http://w3.cs.upt.ro/~calin/resources/sdaa/kruskal.ppt" class="urlextern" title="http://w3.cs.upt.ro/~calin/resources/sdaa/kruskal.ppt"  rel="nofollow">http://w3.cs.upt.ro/~calin/resources/sdaa/kruskal.ppt</a>
</p>

<p>
[6] – <a href="http://www.cs.upt.ro/~calin/resources/sdaa/prim.ppt" class="urlextern" title="http://www.cs.upt.ro/~calin/resources/sdaa/prim.ppt"  rel="nofollow">http://www.cs.upt.ro/~calin/resources/sdaa/prim.ppt</a>
</p>

<p>
[7] – <a href="http://www.cs.princeton.edu/~wayne/kleinberg-tardos/04mst.pdf" class="urlextern" title="http://www.cs.princeton.edu/~wayne/kleinberg-tardos/04mst.pdf"  rel="nofollow">http://www.cs.princeton.edu/~wayne/kleinberg-tardos/04mst.pdf</a>
</p>

<p>
[8] – <a href="http://hc.ims.u-tokyo.ac.jp/JSBi/journal/GIW01/GIW01F03.pdf" class="urlextern" title="http://hc.ims.u-tokyo.ac.jp/JSBi/journal/GIW01/GIW01F03.pdf"  rel="nofollow">http://hc.ims.u-tokyo.ac.jp/JSBi/journal/GIW01/GIW01F03.pdf</a>
</p>

<p>
[9] – <a href="http://www4.ncsu.edu/~zjorgen/ictai06.pdf" class="urlextern" title="http://www4.ncsu.edu/~zjorgen/ictai06.pdf"  rel="nofollow">http://www4.ncsu.edu/~zjorgen/ictai06.pdf</a>
</p>

<p>
[10] – C. Giumale – Introducere în Analiza Algoritmilor, cap.5.5
</p>

</div>
<!-- EDIT13 SECTION "Referinţe" [14705-15417] -->
<h1 class="sectionedit14" id="probleme">Probleme</h1>
<div class="level1">

</div>
<!-- EDIT14 SECTION "Probleme" [15418-15441] -->
<h3 class="sectionedit15" id="cablare_optima_in_retele_de_date_10p">1.	Cablare optimă în rețele de date (10p)</h3>
<div class="level3">

<p>
<p><div class="notewarning">
După rezolvarea problemei, toți studenții trebuie să încarce o arhivă cu sursele rezolvării pe Moodle (click <a href="http://cs.curs.pub.ro/2015/mod/assign/view.php?id=5540" class="urlextern" title="http://cs.curs.pub.ro/2015/mod/assign/view.php?id=5540"  rel="nofollow">aici</a>) pentru a li se puncta laboratorul.

</div></p>
</p>

<p>
Prietenul nostru Andrei a fost asignat drept noul șef al departamentul de rețelistică al companiei Nuke Cola. Sediul companiei are arondate N-1 sucursale, iar Andrei trebuie să asigure conectivitate între toate locațiile folosind o lungime minimă de fibră optică, lucru care duce implicit la reducerea costurilor totale. (AMA) <strong>[5P]</strong>
</p>

<p>
În cazul în care directorul general nu este de acord cu planul său, Andrei vrea să aibă un plan de backup, acesta reprezentând cea de-a doua cea mai bună soluție din punctul de vedere al lungimii totale de fibră optică utilizată. (AMA2) <strong>[5P]</strong>
</p>

<p>
Vă rugăm să îl ajutați pe Andrei să găsească configurația optimă având drept intrare distanțele între locațiile care pot fi conectate direct una cu cealaltă.
</p>

<p>
Implementati problema folosind, la alegere, algoritmii lui Prim sau Kruskal, motivând alegerea.
</p>

<p>
Ca alternativă la AMA2, puteţi implementa cealaltă variantă de AMA, faţă de cea folosită iniţial.
</p>

<p>
Posibil fisier de intrare (exemplul din laborator):
</p>
<pre class="code cpp"><span class="co2"># explicatii format </span>
<span class="co2"># n=numar varfuri m=numar muchii</span>
<span class="co2"># m randuri, cate unul pentru fiecare muchie: start end cost</span>
<span class="nu0">8</span> <span class="nu0">13</span>  
<span class="nu0">1</span> <span class="nu0">2</span> <span class="nu0">4</span> 
<span class="nu0">1</span> <span class="nu0">3</span> <span class="nu0">9</span>
<span class="nu0">1</span> <span class="nu0">4</span> <span class="nu0">1</span>
<span class="nu0">1</span> <span class="nu0">6</span> <span class="nu0">7</span>
<span class="nu0">2</span> <span class="nu0">3</span> <span class="nu0">12</span>
<span class="nu0">2</span> <span class="nu0">4</span> <span class="nu0">4</span>
<span class="nu0">3</span> <span class="nu0">8</span> <span class="nu0">13</span>
<span class="nu0">4</span> <span class="nu0">5</span> <span class="nu0">7</span>
<span class="nu0">4</span> <span class="nu0">6</span> <span class="nu0">8</span>
<span class="nu0">5</span> <span class="nu0">6</span> <span class="nu0">3</span>
<span class="nu0">5</span> <span class="nu0">7</span> <span class="nu0">6</span>
<span class="nu0">5</span> <span class="nu0">8</span> <span class="nu0">5</span>
<span class="nu0">7</span> <span class="nu0">8</span> <span class="nu0">2</span></pre>

</div>
<!-- EDIT15 SECTION "1.	Cablare optimă în rețele de date (10p)" [15442-] --></div>
</body>
</html>
