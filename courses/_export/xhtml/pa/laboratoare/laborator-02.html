    
    

<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
  <meta charset="utf-8" />
  <title>pa:laboratoare:laborator-02</title>
<meta name="generator" content="DokuWiki"/>
<meta name="robots" content="index,follow"/>
<meta name="date" content="2016-03-14T17:23:20+0200"/>
<meta name="keywords" content="pa,laboratoare,laborator-02"/>
<link rel="search" type="application/opensearchdescription+xml" href="../../../../lib/exe/opensearch.php" title="CS Open CourseWare"/>
<link rel="start" href="../../../../../courses.1.html"/>
<link rel="alternate" type="application/rss+xml" title="Recent Changes" href="../../../../feed.php"/>
<link rel="alternate" type="application/rss+xml" title="Current Namespace" href="../../../../feed.php%3Fmode=list&amp;ns=pa:laboratoare"/>
<link rel="alternate" type="text/html" title="Plain HTML" href="laborator-02.html"/>
<link rel="canonical" href="../../../../pa/laboratoare/laborator-02.html"/>
<link rel="stylesheet" type="text/css" href="../../../../lib/exe/css.php%3Ft=arctic&amp;tseed=1476798676.css"/>
<script type="text/javascript">/*<![CDATA[*/var NS='pa:laboratoare';var JSINFO = {"id":"pa:laboratoare:laborator-02","namespace":"pa:laboratoare","isadmin":0,"isauth":0};
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="../../../../lib/exe/js.php%3Ftseed=1476798676"></script>
<script type="text/x-mathjax-config">/*<![CDATA[*/MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ["$","$"], ["\\(","\\)"] ],
        displayMath: [ ["$$","$$"], ["\\[","\\]"] ],
        processEscapes: true
    }
});
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
<script type="text/javascript">/*<![CDATA[*/
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
		  
/*!]]>*/</script>
<script type="text/javascript">/*<![CDATA[*/
var pageTracker = _gat._getTracker("UA-38383934-1");
pageTracker._initData();
pageTracker._trackPageview();
		  
/*!]]>*/</script>
</head>
<body>
<div class="dokuwiki export">
<!-- TOC START -->
<div id="dw__toc">
<h3 class="toggle">Table of Contents</h3>
<div>

<ul class="toc">
<li class="level1"><div class="li"><a href="laborator-02.html#laborator_2_3greedy_si_programare_dinamica">Laborator 2 &amp; 3: Greedy și Programare Dinamică</a></div>
<ul class="toc">
<li class="level2"><div class="li"><a href="laborator-02.html#obiective_laborator">Obiective laborator</a></div></li>
<li class="level2"><div class="li"><a href="laborator-02.html#importanta_aplicatii_practice">Importanță – aplicații practice</a></div></li>
<li class="level2"><div class="li"><a href="laborator-02.html#prezentarea_generala_a_problemei">Prezentarea generală a problemei</a></div></li>
<li class="level2"><div class="li"><a href="laborator-02.html#greedy">Greedy</a></div></li>
<li class="level2"><div class="li"><a href="laborator-02.html#exemplu_de_problema_rezolvabila_cu_tehnica_greedy">Exemplu de problema rezolvabilă cu tehnica Greedy</a></div></li>
<li class="level2"><div class="li"><a href="laborator-02.html#problema_spectacolelor">Problema spectacolelor</a></div></li>
<li class="level2"><div class="li"><a href="laborator-02.html#problema_cuielor">Problema cuielor</a></div></li>
<li class="level2"><div class="li"><a href="laborator-02.html#programare_dinamica">Programare Dinamică</a></div></li>
<li class="level2"><div class="li"><a href="laborator-02.html#problema_rucsacului">Problema rucsacului</a></div></li>
<li class="level2"><div class="li"><a href="laborator-02.html#exemple_de_probleme">Exemple de probleme</a></div></li>
<li class="level2"><div class="li"><a href="laborator-02.html#al_n-lea_termen_fibonacci">Al N-lea termen Fibonacci</a></div></li>
<li class="level2"><div class="li"><a href="laborator-02.html#concluzii_si_observatii">Concluzii şi observații</a></div></li>
</ul>
</li>
<li class="level1"><div class="li"><a href="laborator-02.html#probleme_laborator">Probleme laborator</a></div>
<ul class="toc">
<li class="level2"><div class="li"><a href="laborator-02.html#laborator_2">Laborator 2</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="laborator-02.html#problema_1_2p">Problema 1. [2p]</a></div>
<ul class="toc">
<li class="level4"><div class="li"><a href="laborator-02.html#problema_rucsacului_varianta_continua">Problema rucsacului (varianta continuă)</a></div></li>
</ul>
</li>
<li class="level3"><div class="li"><a href="laborator-02.html#problema_2_4p">Problema 2. [4p]</a></div>
<ul class="toc">
<li class="level4"><div class="li"><a href="laborator-02.html#planificarea_temelor_de_catre_studenti">Planificarea temelor de către studenți</a></div></li>
</ul>
</li>
<li class="level3"><div class="li"><a href="laborator-02.html#problema_3_4p">Problema 3. [4p]</a></div>
<ul class="toc">
<li class="level4"><div class="li"><a href="laborator-02.html#numere_de_tip_palindrom">Numere de tip palindrom</a></div></li>
</ul>
</li>
</ul>
</li>
<li class="level2"><div class="li"><a href="laborator-02.html#laborator_3">Laborator 3</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="laborator-02.html#problema_1_2p1">Problema 1. [2p]</a></div>
<ul class="toc">
<li class="level4"><div class="li"><a href="laborator-02.html#problema_rucsacului_varianta_discreta">Problema Rucsacului (varianta discretă)</a></div></li>
</ul>
</li>
<li class="level3"><div class="li"><a href="laborator-02.html#problema_2_4p1">Problema 2. [4p]</a></div>
<ul class="toc">
<li class="level4"><div class="li"><a href="laborator-02.html#aranjarea_cartilor_in_biblioteca">Aranjarea cărților în bibliotecă</a></div></li>
</ul>
</li>
<li class="level3"><div class="li"><a href="laborator-02.html#problema_3_4p1">Problema 3. [4p]</a></div>
<ul class="toc">
<li class="level4"><div class="li"><a href="laborator-02.html#parantezarea_unei_expresii_booleene">Parantezarea unei expresii booleene</a></div></li>
</ul>
</li>
</ul>
</li>
<li class="level2"><div class="li"><a href="laborator-02.html#referinte">Referințe</a></div></li>
</ul></li>
</ul>
</div>
</div>
<!-- TOC END -->

<h1 class="sectionedit1" id="laborator_2_3greedy_si_programare_dinamica">Laborator 2 &amp; 3: Greedy și Programare Dinamică</h1>
<div class="level1">

</div>
<!-- EDIT1 SECTION "Laborator 2 & 3: Greedy și Programare Dinamică" [1-64] -->
<h2 class="sectionedit2" id="obiective_laborator">Obiective laborator</h2>
<div class="level2">
<ul>
<li class="level1"><div class="li">Înțelegerea noțiunilor de bază legate de tehnicile greedy și programare dinamică;	</div>
</li>
<li class="level1"><div class="li">Însușirea abilităților de analiză în vederea conceperii algoritmilor de tip greedy și programare dinamică pentru rezolvarea diferitelor probleme;</div>
</li>
<li class="level1"><div class="li">Însușirea abilităților de implementare a algoritmilor bazați pe greedy și programare dinamică.</div>
</li>
</ul>

</div>
<!-- EDIT2 SECTION "Obiective laborator" [65-451] -->
<h2 class="sectionedit3" id="importanta_aplicatii_practice">Importanță – aplicații practice</h2>
<div class="level2">

<p>
În general tehnicile de tip Greedy sau Programare Dinamică sunt folosite pentru rezolvarea problemelor de optimizare. Acestea pot adresa probleme în sine sau pot fi subprobleme dintr-un algoritm mai mare. De exemplu, algoritmul Dijkstra pentru determinarea drumului minim pe un graf alege la fiecare pas un nod nou urmărind algoritmul greedy.
</p>

<p>
Exista însă probleme care ne pot induce în eroare. Astfel, există probleme în care urmărind criteriul Greedy nu ajungem la soluția optimă. Este foarte important să identificăm cazurile când se poate aplica Greedy și cazurile când este nevoie de altceva. Alteori această soluție neoptimă este o aproximare suficientă pentru ce avem nevoie. Problemele NP-complete necesita multă putere de calcul pentru a găsi optimul absolut. Pentru a optimiza aceste calcule mulți algoritmi folosesc decizii Greedy și găsesc un optim foarte aproape de cel absolut.
</p>

<p>
Programarea dinamică are un câmp larg de aplicare, aici amintind genetica (sequence alignment), teoria grafurilor (algoritmul Floyd-Warshall), metode de antrenare a rețelelor neurale (Adaptive Critic training strategy), limbaje formale și automate (algoritmul Cocke-Younger-Kasami, care analizează dacă și în ce fel un șir poate fi generat de o gramatică independent de context), implementarea bazelor de date (algoritmul Selinger pentru optimizarea interogării relaționale) etc.
</p>

</div>
<!-- EDIT3 SECTION "Importanță – aplicații practice" [452-1912] -->
<h2 class="sectionedit4" id="prezentarea_generala_a_problemei">Prezentarea generală a problemei</h2>
<div class="level2">

</div>
<!-- EDIT4 SECTION "Prezentarea generală a problemei" [1913-1959] -->
<h2 class="sectionedit5" id="greedy">Greedy</h2>
<div class="level2">

<p>
“greedy” = “lacom”. Algoritmii de tip greedy vor să construiască într-un mod cât mai rapid soluția unei probleme. Ei se caracterizează prin luarea unor decizii rapide care duc la găsirea unei soluții potențiale a problemei. Nu întotdeauna asemenea decizii rapide duc la o soluție optimă; astfel ne vom concentra atenția pe identificarea acelor anumite tipuri de probleme pentru care se pot obține soluții optime.
</p>

<p>
Algoritmii greedy se numără printre cei mai direcți algoritmi posibili. Ideea de bază este simplă: având o problema de optimizare, de calcul al unui cost minim sau maxim, se va alege la fiecare pas decizia cea mai favorabilă, fără a evalua global eficiența soluţiei. În general exista mai multe soluții posibile ale problemei. Dintre acestea se pot selecta doar anumite soluții optime, conform unor anumite criterii. Scopul este de a găsi una dintre acestea sau dacă nu este posibil, atunci o soluție cât mai apropiată, conform criteriului optimal impus.
</p>

<p>
Trebuie înțeles faptul ca rezultatul obținut este optim doar dacă un optim local conduce la un optim global. În cazul în care deciziile de la un pas influențează lista de decizii de la pasul următor, este posibila obținerea unei valori neoptimale. În astfel de cazuri, pentru găsirea unui optim absolut se ajunge la soluții supra-polinomiale. De aceea, dacă se optează pentru o astfel de soluție, algoritmul trebuie însoțit de o demonstrație de corectitudine.
Descrierea formală a unui algoritm greedy este următoarea:
</p>
<pre class="code cpp">function greedy<span class="br0">&#40;</span>C<span class="br0">&#41;</span>
<span class="co1">// C este mulțimea candidaților</span>
<span class="co1">// în S construim soluția</span>
S ← Ø
<span class="kw1">while</span> not solutie<span class="br0">&#40;</span>C<span class="br0">&#41;</span> and C≠Ø
x ← un element din C care minimizează<span class="sy2">/</span>maximizează select<span class="br0">&#40;</span>x<span class="br0">&#41;</span>
C ← C\<span class="br0">&#123;</span>x<span class="br0">&#125;</span>
<span class="kw1">if</span> fezabil<span class="br0">&#40;</span>S∪<span class="br0">&#123;</span>x<span class="br0">&#125;</span><span class="br0">&#41;</span> then S←S∪<span class="br0">&#123;</span>x<span class="br0">&#125;</span>
<span class="kw1">return</span> S</pre>

<p>
Este ușor de înțeles acum de ce acest algoritm se numește ”greedy”: la fiecare pas se alege cel mai bun candidat de la momentul respectiv, fără a studia alternativele disponibile în moment respectiv şi viabilitatea acestora în timp.
</p>

<p>
Dacă un candidat este inclus în soluție, rămâne acolo, fără a putea fi modificat, iar dacă este exclus din soluție, nu va mai putea fi niciodată selectat drept un potențial candidat.
</p>

</div>
<!-- EDIT5 SECTION "Greedy" [1960-4238] -->
<h2 class="sectionedit6" id="exemplu_de_problema_rezolvabila_cu_tehnica_greedy">Exemplu de problema rezolvabilă cu tehnica Greedy</h2>
<div class="level2">

<p>
Fie un șir de N numere pentru care se cere determinarea unui subșir de numere cu suma maximă. Un subșir al unui șir este format din caractere (nu neapărat consecutive) ale șirului respectiv, în ordinea în care acestea apar în șir.
</p>

<p>
Pentru numerele 1 -5 6 2 -2 4 răspunsul este 1 6 2 4 (suma 13).
</p>

<p>
Se observa ca tot ce avem de făcut este sa verificam fiecare număr dacă este pozitiv sau nu. În cazul pozitiv, îl introducem în subșirul soluție.
</p>

</div>
<!-- EDIT6 SECTION "Exemplu de problema rezolvabilă cu tehnica Greedy" [4239-4767] -->
<h2 class="sectionedit7" id="problema_spectacolelor">Problema spectacolelor</h2>
<div class="level2">

<p>
Se dau mai multe spectacole, prin timpii de start și timpii de final. Se cere o planificare astfel încât o persoană să poată vedea cât mai multe spectacole. Rezolvarea constă în sortarea spectacolelor crescător după timpii de final, apoi la fiecare pas se alege primul spectacol care are timpul de start mai mare decât ultimul timp de final. Timpul inițial de final este inițializat la -infinit (spectacolul care se termină cel mai devreme va fi mereu selectat, având timp de start mai mare decât timpul inițial). 
</p>

</div>
<!-- EDIT7 SECTION "Problema spectacolelor" [4768-5338] -->
<h2 class="sectionedit8" id="problema_cuielor">Problema cuielor</h2>
<div class="level2">

<p>
Fie N scânduri de lemn, descrise ca niște intervale închise cu capete reale. Găsiți o mulțime minimă de cuie astfel încât fiecare scândură să fie bătută de cel puțin un cui. Se cere poziția cuielor. Formulat matematic: găsiți o mulțime de puncte de cardinal minim M astfel încât pentru orice interval [a<sub>i</sub>, b<sub>i</sub>] din cele N, să existe un punct x din M care să aparțină intervalului [a<sub>i</sub>, b<sub>i</sub>]. Complexitate: O(N log N)
Exemplu:
</p>
<ul>
<li class="level1"><div class="li">intrare: N = 5, intervalele: [0, 2], [1, 7], [2, 6], [5, 14], [8, 16]</div>
</li>
<li class="level1"><div class="li">ieșire: M = {2, 14}</div>
</li>
<li class="level1"><div class="li">explicație: punctul 2 se afla în primele 3 intervale, iar punctul 14 în ultimele 2</div>
</li>
</ul>

<p>
Soluție: Se observa că dacă x este un punct din M care nu este capăt dreapta al nici unui interval, o translație a lui x la dreapta care îl duce în capătul dreapta cel mai apropiat nu va schimba intervalele care conțin punctul. Prin urmare, exista o mulțime de cardinal minim M pentru care toate punctele x sunt capete dreapta.
</p>

<p>
Astfel, vom crea mulțimea M folosind numai capete dreapta în felul următor:
</p>
<ul>
<li class="level1"><div class="li">cât timp au mai rămas intervale nemarcate:</div>
</li>
<li class="level1"><div class="li">selectăm cel mai mic capăt dreapta, B<sub>min</sub>; acesta trebuie să fie în M, deoarece este singurul punct care se afla în interiorul intervalului care se termină în B<sub>min</sub></div>
</li>
<li class="level1"><div class="li">marcăm toate intervalele nemarcate care conțin B<sub>min</sub></div>
</li>
<li class="level1"><div class="li">adăugăm B<sub>min</sub> la M</div>
</li>
</ul>

<p>
Pentru a obține o complexitate redusă, sortăm inițial toate cele 2N capete și le parcurgem de la stânga la dreapta. Pentru fiecare punct distingem cazurile:
</p>
<ul>
<li class="level1"><div class="li">dacă este capăt stânga, introducem intervalul în lista de „intervale în procesare” și trecem mai departe;</div>
</li>
<li class="level1"><div class="li">dacă este capăt dreapta și intervalul respectiv nu conține nici un punct din M, atunci am găsit cel mai mic capăt dreapta al unui interval nemarcat, introducem capătul în M și marcăm toate intervalele din lista de intervale în procesare;</div>
</li>
<li class="level1"><div class="li">dacă este capăt dreapta și intervalul din care face parte este deja marcat, trecem mai departe.</div>
</li>
</ul>

<p>
Complexitate:
</p>
<ul>
<li class="level1"><div class="li">sortare: O(N log N)</div>
</li>
<li class="level1"><div class="li">parcurgerea capetelor: O(N)</div>
</li>
<li class="level1"><div class="li">adăugarea și ștergerea unui interval din lista de intervale în procesare: O(1)</div>
</li>
<li class="level1"><div class="li">total: O(N log N)</div>
</li>
</ul>

</div>
<!-- EDIT8 SECTION "Problema cuielor" [5339-7627] -->
<h2 class="sectionedit9" id="programare_dinamica">Programare Dinamică</h2>
<div class="level2">

<p>
Similar cu Greedy, tehnica de Programare Dimanică este folosită pentru rezolvarea problemelor de optimizare. Programarea dinamică are un câmp larg de aplicare, aici amintind genetica (sequence alignment), teoria grafurilor (algoritmul Floyd-Warshall), metode de antrenare a rețelelor neurale (Adaptive Critic training strategy), limbaje formale și automate (algoritmul Cocke-Younger-Kasami, care analizează dacă și în ce fel un șir poate fi generat de o gramatică independent de context), implementarea bazelor de date (algoritmul Selinger pentru optimizarea interogării relaționale) etc.
</p>

<p>
Programare dinamică presupune rezolvarea unei probleme prin descompunerea ei în subprobleme şi rezolvarea acestora. Spre deosebire de divide et impera, subproblemele nu sunt disjuncte, ci se suprapun.
</p>

<p>
Pentru a evita recalcularea porțiunilor care se suprapun, rezolvarea se face pornind de la cele mai mici subprobleme şi folosindu-ne de rezultatul acestora calculăm subproblema imediat mai mare. Cele mai mici subprobleme sunt numite subprobleme unitare, acestea putând fi rezolvate într-o complexitate constantă, ex: cea mai mare subsecvență dintr-o mulțime de un singur element.
</p>

<p>
Pentru a nu recalcula soluțiile subproblemelor ce ar trebui rezolvate de mai multe ori, pe ramuri diferite, se reține soluția subproblemelor folosind o tabelă (matrice uni, bi sau multi-dimensională în funcție de problemă) cu rezultatul fiecărei subprobleme. Aceasta tehnica se numește <em>memoizare</em>.
</p>

<p>
Aceasta tehnică determina ”valoarea” soluției pentru fiecare din subprobleme. Mergând de la subprobleme mici la subprobleme din ce în ce mai mari ajungem la soluția optimă, la nivelul întregii probleme. Motivul pentru care aceasta tehnica se numește Programare Dinamică este datorată flexibilității ei, ”valoarea” schimbându-și înțelesul logic de la o problema la alta. În probleme de minimizarea costului, ”valoarea” este reprezentata de costul minim. In probleme care presupun identificarea unei componente maxime, ”valoarea” este caracterizată de dimensiunea componentei.
</p>

<p>
După calcularea valorii pentru toate subproblemele se poate determina efectiv mulțimea de elemente care compun soluția. „Reconstrucția” soluţiei se face mergând din subproblemă în subproblemă, începând de la problema cu valoarea optimă și ajungând în subprobleme unitare. Metoda și recurența variază de la problemă la problemă, dar în urma unor exerciții practice va deveni din ce în ce mai facil să le identificați.
</p>

<p>
Aplicând aceasta tehnică determinăm una din soluțiile optime, problema putând avea mai multe soluții optime. În cazul în care se dorește determinarea tuturor soluțiilor optime, algoritmul trebuie combinat cu unul de backtracking în vederea construcției soluțiilor.
</p>

<p>
Aplicarea acestei tehnici de programare poate fi descompusă în următoarea secvență de pași:
</p>
<ol>
<li class="level1"><div class="li"> Identificarea structurii și a metricilor utilizate în caracterizarea soluției optime;</div>
</li>
<li class="level1"><div class="li"> Determinarea unei metode de calcul recursiv pentru a afla valoarea fiecărei subprobleme;</div>
</li>
<li class="level1"><div class="li"> Calcularea “bottom-up” a acestei valori (de la subproblemele cele mai mici la cele mai mari);</div>
</li>
<li class="level1"><div class="li"> Reconstrucția soluției optime pornind de la rezultatele obținute anterior.</div>
</li>
</ol>

</div>
<!-- EDIT9 SECTION "Programare Dinamică" [7628-10973] -->
<h2 class="sectionedit10" id="problema_rucsacului">Problema rucsacului</h2>
<div class="level2">

<p>
O alta problemă clasică este problema rucsacului. Se dau niște obiecte care au o anumită greutate și un anumit cost, și un rucsac în care se poate pune maxim o greutate G. Se cere să se selecteze niște obiecte a.î. greutatea lor să fie maxim G și costul lor să fie maxim.
</p>

<p>
Soluția se construiește prin programare dinamică, D[i][j]= cel mai bun cost obținut pentru primele i obiecte, având greutatea maxim j. Relația de recurență este următoarea:  
</p>
<pre class="code">D[i][j] = maxim(D[i-1][j], D[i-1][j-G[i]]+C[i]), unde G[i] = greutatea obiectului i, iar C[i] = costul obiectului i. </pre>

<p>
 Ideea este următoarea: la soluția curentă ori nu adăugăm deloc obiectul i, și rămânem la costul pentru i-1 obiecte, ori adăugăm obiectul i, caz în care adăugăm costul lui la costul obținut pentru primele i-1 obiecte și greutate j-G[i].
</p>

</div>
<!-- EDIT10 SECTION "Problema rucsacului" [10974-11857] -->
<h2 class="sectionedit11" id="exemple_de_probleme">Exemple de probleme</h2>
<div class="level2">

<p>
Programarea Dinamică este cea mai flexibilă tehnica din programare. <strong>Cel mai ușor mod de a o înțelege presupune parcurgerea cât mai multor exemple.</strong>
</p>

<p>
O problema clasică de Programare Dinamică este determinarea celui mai lung subșir strict crescător dintr-un șir de numere. Un subșir al unui șir este format din caractere (nu neapărat consecutive) ale șirului respectiv, în ordinea în care acestea apar în șir.
</p>

<p>
Exemplu: pentru șirul 24 12 15 15 8 19 răspunsul este șirul 12 15 19
</p>

<p>
Se observa că dacă încercăm o abordare greedy nu putem stabili nici măcar elementul de început într-un mod corect. Totuși, problema se poate rezolva ”muncitorește” (forța brută) folosind un algoritm care alege toate combinațiile de numere din șir, validează că șirul obținut este strict crescător şi îl reține pe cel de lungime maximă, dar aceasta abordare are complexitatea temporală O(N!). Cu optimizări, este posibil sa se ajungă la O(2<sup>N</sup>).
</p>

<p>
O metoda de rezolvare mai eficientă folosește Programarea Dinamică. Începem prin a stabili pentru fiecare element lungimea celui mai lung subșir strict crescător care începe cu primul element și se termină în elementul respectiv. Numim aceasta valoare best<sub>i</sub> și aplicăm formula recursivă best<sub>i</sub> = 1 + max(best<sub>j</sub>), cu j&lt;i și elem<sub>j</sub> &lt; elem<sub>i</sub>.
</p>

<p>
Aplicând acest algoritm obținem:
</p>

<p>
elem 24 12 15 15 8 19
best  1  1  2  2 1  3
</p>

<p>
Pentru 24 sau 12 nu există nici un alt element în stânga lor strict mai mici decât ele, de aceea au best egal cu 1. Pentru elementele 15 se poate găsi în stânga lor 12 strict mai mic decât ele. Pentru 19 se găsește elementul 15 strict mai mic decât el. Cum 15 deja este capăt pentru un subșir soluție de 2 elemente, putem spune că 19 este capătul pentru un subșir soluție de 3 elemente.
</p>

<p>
Cum pentru fiecare element din mulțime trebuie să găsim un element mai mic decât el şi cu best maxim, avem o complexitate O(N) pentru fiecare element. În total rezultă o complexitate O(N<sup>2</sup>). Se pot obține şi rezolvări cu o complexitate mai mica folosind structuri de date avansate. Atât soluția în O(N<sup>2</sup>), cât si o soluție în O(N log N) poate fi găsită la <a href="http://infoarena.ro/problema/scmax" class="urlextern" title="http://infoarena.ro/problema/scmax"  rel="nofollow">[5]</a>. Tot acolo se poate găsi și o lista de probleme mai dificile ce folosesc tehnica Programării Dinamice, adaptată în diferite forme.
</p>

<p>
Pentru a găsi care sunt elementele ce alcătuiesc subșirul strict crescător putem să reținem și o „cale de întoarcere”. Reconstrucția astfel obținută are complexitatea O(N). Exemplu: subproblema care se termina în elementul 19 are subșirul de lungime maximă 3 şi a fost calculată folosind subproblema care se termină cu elementul 15 (oricare din ele). Subșirul de lungime maximă care se termină în 15 a fost calculat folosindu-ne de elementul 12. 12 marchează sfârșitul reconstrucției fiind cel mai mic element din subșir.
</p>

<p>
O problema care admite o varietate mare de soluții este cea a subsecvenței de sume maxime. Enunțul poate fi găsit la <a href="http://infoarena.ro/problema/ssm" class="urlextern" title="http://infoarena.ro/problema/ssm"  rel="nofollow">[6]</a>.
</p>

</div>
<!-- EDIT11 SECTION "Exemple de probleme" [11858-15082] -->
<h2 class="sectionedit12" id="al_n-lea_termen_fibonacci">Al N-lea termen Fibonacci</h2>
<div class="level2">

<p>
Șirul lui Fibonacci se definește ca fiind secvența de numere generată de recurența:
</p>

<p>
\begin{equation}
F_{N} = F_{N - 1} + F_{N - 2},\ cu\ F_{0} = 0\ și\ F_{1} = 1
\end{equation}
</p>

<p>
După cum se observă, pentru a calcula următorul element din șir ne sunt necesare doar precedentele 2 numere. De asemenea, după ce am calculat noul termen, trebuie să le reținem tot pe ultimele 2 pentru a putea reaplica în continuare aceeași metodă.
</p>

<p>
Practic, cunoscând $F_{N - 1}\ și\ F_{N - 2}$ vrem să obținem $ \left\{ \begin{align*} F_{N - 1} &amp;= F_{N - 1} \\ F_{N} &amp;= F_{N - 1} + F_{N - 2} \end{align*} \right. $
</p>

<p>
În format matriceal, sistemul devine:
</p>

<p>
\begin{equation}
\begin{bmatrix} F_{N - 1} \\ F_{N} \end{bmatrix} = A \cdot \begin{bmatrix} F_{N - 2} \\ F_{N - 1} \end{bmatrix},\ unde\ A = \begin{bmatrix} 0 &amp; 1 \\ 1 &amp; 1 \end{bmatrix}
\end{equation}
</p>

<p>
Punem în evidenta primii 2 pași ai algoritmului:
</p>

<p>
\begin{equation}
\begin{bmatrix} F_{1} \\ F_{2} \end{bmatrix} = A \cdot \begin{bmatrix} F_{0} \\ F_{1} \end{bmatrix}\\
\begin{bmatrix} F_{2} \\ F_{3} \end{bmatrix}
= A \cdot \begin{bmatrix} F_{1} \\ F_{2} \end{bmatrix}
= A \cdot \left( A \cdot \begin{bmatrix} F_{0} \\ F_{1} \end{bmatrix} \right)
= A^{2} \cdot \begin{bmatrix} F_{0} \\ F_{1} \end{bmatrix}
\end{equation}
</p>

<p>
Se poate demonstra prin inducție că:
</p>

<p>
\begin{equation}
\begin{bmatrix} F_{N - 1} \\ F_{N} \end{bmatrix} = A^{N - 1} \cdot \begin{bmatrix} F_{0} \\ F_{1} \end{bmatrix}
\end{equation}
</p>

<p>
În concluzie, pentru a determina cel de-al N-lea termen Fibonacci:
</p>
<ol>
<li class="level1"><div class="li"> calculăm $ A^{N - 1} $, în timp logaritmic</div>
</li>
<li class="level1"><div class="li"> înmulțim rezultatul de la pasul anterior cu vectorul alcătuit din primele 2 valori ale șirului</div>
</li>
</ol>

<p>
Complexitatea algoritmului este O(log N).
</p>

<p>
Observații:
</p>
<ul>
<li class="level1"><div class="li"> complexitatea calculelor matriceale poate afecta (prin constanta asociată) în mod semnificativ timpul de execuție</div>
</li>
<li class="level1"><div class="li"> deoarece valorile șirului cresc repede, calculele se pot efectua într-o clasă de resturi</div>
</li>
</ul>

<p>
Vă puteți testa implementarea acestei probleme la <a href="http://infoarena.ro/problema/kfib" class="urlextern" title="http://infoarena.ro/problema/kfib"  rel="nofollow">[8]</a>.
</p>

</div>
<!-- EDIT12 SECTION "Al N-lea termen Fibonacci" [15083-17179] -->
<h2 class="sectionedit13" id="concluzii_si_observatii">Concluzii şi observații</h2>
<div class="level2">

<p>
Aceste 2 tehnici sunt flexibile şi simpliste la nivel conceptul, dar cu ajutorul lor se pot rezolva probleme foarte complexe. În viitor este posibil să întâlniți algoritmi de Programare Dinamică pe arbori sau Greedy pe stări, unde fiecare stare este o matrice. Conceptele rămân neschimbate.
</p>

<p>
Aspectul cel mai important de reținut este că soluțiile găsite trebuie să reprezinte optimul global și nu doar local. Se pot confunda ușor problemele care se rezolvă cu Greedy cu cele care se rezolvă prin Programare Dinamică.
</p>

</div>
<!-- EDIT13 SECTION "Concluzii şi observații" [17180-17758] -->
<h1 class="sectionedit14" id="probleme_laborator">Probleme laborator</h1>
<div class="level1">

<p>
<p><div class="noteimportant">
Denumirile diferă între engleză și română! Nu știm din ce motive avem aceste diferențe între concepte și nici când au apărut pentru prima dată, dar considerăm că este bine să le cunoașteți. Atunci când citiți enunțuri în limba română sau engleză, ele se vor referi la lucruri diferite.
</p>

<p>
Daca avem un sir a1, a2, …, an atunci:
</p>
<ul>
<li class="level1"><div class="li"> <strong>subșir</strong> (<em>subsequence</em> in engleza) inseamna un vector <code>v = (a(i1), a(i2), …., a(ik))</code> unde <code>i1 &lt; i2 &lt; … &lt; ik</code>.</div>
</li>
<li class="level1"><div class="li"> <strong>subsecvență</strong> (<em>substring</em> in engleza) inseamna un subșir de forma <code>a(i), a(i+1), a(i+2), .., a(i+k)</code> adica un subsir cu elemente consecutive in sirul initial.</div>
</li>
</ul>

<p>

</div></p>
</p>

</div>
<!-- EDIT14 SECTION "Probleme laborator" [17759-18473] -->
<h2 class="sectionedit15" id="laborator_2">Laborator 2</h2>
<div class="level2">

</div>
<!-- EDIT15 SECTION "Laborator 2" [18474-18498] -->
<h3 class="sectionedit16" id="problema_1_2p">Problema 1. [2p]</h3>
<div class="level3">

</div>

<h4 id="problema_rucsacului_varianta_continua">Problema rucsacului (varianta continuă)</h4>
<div class="level4">

<p>
Un camion poate transporta T tone de material. Există n tipuri de materiale disponibile, fiecare caracterizat de greutatea G[i] disponibilă și de valoarea V[i] adusă de transportarea sa. Să se decidă ce cantități din fiecare material vor fi transportate pentru a aduce o valoare maximă.
</p>

</div>
<!-- EDIT16 SECTION "Problema 1. [2p]" [18499-18872] -->
<h3 class="sectionedit17" id="problema_2_4p">Problema 2. [4p]</h3>
<div class="level3">

</div>

<h4 id="planificarea_temelor_de_catre_studenti">Planificarea temelor de către studenți</h4>
<div class="level4">

<p>
Pe parcursul unui semestru, un student are de rezolvat n teme. Se cunoaște enunțul tuturor celor n teme de la începutul semestrului. Timpul de rezolvare pentru oricare dintre teme este de o săptămână și nu se poate lucra la mai multe teme în același timp. Pentru fiecare tema se cunoaște un termen limita d[i] (exprimat în săptămâni) și un punctaj w[i]. Nicio fracțiune din punctaj nu se mai poate obține după expirarea termenului limită. Să se definească o planificare de realizare a temelor, în așa fel încât punctajul obținut să fie maxim.
</p>

</div>
<!-- EDIT17 SECTION "Problema 2. [4p]" [18873-19521] -->
<h3 class="sectionedit18" id="problema_3_4p">Problema 3. [4p]</h3>
<div class="level3">

</div>

<h4 id="numere_de_tip_palindrom">Numere de tip palindrom</h4>
<div class="level4">

<p>
Se dorește construirea a două numere de tip palindrom, primul de lungime L, al doilea de lungime &gt; 0 astfel încât suma lor să fie minimă. Cele două numere de tip palindrom nu pot să înceapă cu cifra 0. Pentru construirea lor, se dau numărul L și numărul de apariții al fiecărei cifre în cele două numere (adică c[i] = nr. de apariții al cifrei i în primul numărul + nr. de apariții al cifrei i în al doilea număr).
</p>

<p>
<p><div class="notetip">
Exemplu:
</p>
<pre class="code">L = 4
c[] = {1, 2, 2, 0, 0, 2, 0, 0, 2, 2}

Soluţie:
Palindroamele care se doresc a fi generate sunt 1250521, respectiv 8998
cu suma minimă 1259519</pre>

<p>

</div></p>
</p>

</div>
<!-- EDIT18 SECTION "Problema 3. [4p]" [19522-23223] -->
<h2 class="sectionedit19" id="laborator_3">Laborator 3</h2>
<div class="level2">

</div>
<!-- EDIT19 SECTION "Laborator 3" [23224-23248] -->
<h3 class="sectionedit20" id="problema_1_2p1">Problema 1. [2p]</h3>
<div class="level3">

</div>

<h4 id="problema_rucsacului_varianta_discreta">Problema Rucsacului (varianta discretă)</h4>
<div class="level4">

<p>
Un camion poate transporta <strong>T</strong> tone de mobilă. Există <strong>n</strong> piese de mobilă, fiecare caracterizată de greutatea <strong>G[i]</strong> și de valoarea <strong>V[i]</strong> adusă de transportarea sa. Să se decida ce piese de mobila vor fi transportate pentru a aduce o valoare maximă (soluție optimă).
</p>

<p>
<p><div class="notetip">
Exemplu:
</p>

<p>
Fie cantitatea maximă admisă T = 10, şi un număr de piese de mobilă din care putem alege egal cu 6.
Piesele de mobilă sunt descrise de perechi de forma (greutate, valoare), după cum urmează:
(3, 7), (3, 4), (1, 2), (1, 9), (2, 4), (1, 5).
</p>

<p>
Profitul maxim pe care îl putem obţine este 29 şi acesta se realizează dacă vom transporta obiectele de mobilier cu indecşii 1, 2, 4, 5 şi 6. 
</p>

<p>

</div></p>
</p>

</div>
<!-- EDIT20 SECTION "Problema 1. [2p]" [23249-24044] -->
<h3 class="sectionedit21" id="problema_2_4p1">Problema 2. [4p]</h3>
<div class="level3">

</div>

<h4 id="aranjarea_cartilor_in_biblioteca">Aranjarea cărților în bibliotecă</h4>
<div class="level4">

<p>
Se dau <strong>n</strong> dulapuri aflate într-o bibliotecă, precum și numărul cărților din fiecare dulap. Se doreşte mutarea dulapurilor (cu toate cărțile aferente) într-o nouă bibliotecă (păstrând ordinea din biblioteca inițială), astfel încât primul dulap este mutat întotdeauna, iar celelalte dulapuri se mută doar dacă nu sunt așezate unul lângă celălalt în biblioteca inițială. De asemenea, se dorește soluția care maximizează numărul cărților din noua bibliotecă. <em> Complexitate temporală dorită: O(n) </em>
</p>

</div>
<!-- EDIT21 SECTION "Problema 2. [4p]" [24045-25072] -->
<h3 class="sectionedit22" id="problema_3_4p1">Problema 3. [4p]</h3>
<div class="level3">

</div>

<h4 id="parantezarea_unei_expresii_booleene">Parantezarea unei expresii booleene</h4>
<div class="level4">

<p>
Se dă o expresie booleană exprimată prin stringurile <em> “true”, “false”, “and”, “or”, “xor” </em>. Număraţi modurile în care se pot aşeza paranteze astfel încât rezultatul să fie “true”.  
</p>

<p>
Spre exemplu, pentru expresia:
</p>
<pre class="code"> true and false xor true </pre>

<p>
există două modalităţi de parantezare, astfel încât rezultatul să fie “true”:
<p><div class="notetip">
</p>
<pre class="code">((true and false) xor true) </pre>

<p>
sau
</p>
<pre class="code">true and (false xor true))</pre>

<p>

</div></p>
</p>

</div>
<!-- EDIT22 SECTION "Problema 3. [4p]" [25073-29161] -->
<h2 class="sectionedit23" id="referinte">Referințe</h2>
<div class="level2">

<p>
[1] <a href="http://en.wikipedia.org/wiki/Greedy_algorithm" class="urlextern" title="http://en.wikipedia.org/wiki/Greedy_algorithm"  rel="nofollow">http://en.wikipedia.org/wiki/Greedy_algorithm</a>
</p>

<p>
[2] <a href="http://en.wikipedia.org/wiki/Dynamic_programming" class="urlextern" title="http://en.wikipedia.org/wiki/Dynamic_programming"  rel="nofollow">http://en.wikipedia.org/wiki/Dynamic_programming</a>
</p>

<p>
[3] <a href="http://ww3.algorithmdesign.net/handouts/Greedy.pdf" class="urlextern" title="http://ww3.algorithmdesign.net/handouts/Greedy.pdf"  rel="nofollow">http://ww3.algorithmdesign.net/handouts/Greedy.pdf</a>
</p>

<p>
[4] <a href="http://ww3.algorithmdesign.net/handouts/DynamicProgramming.pdf" class="urlextern" title="http://ww3.algorithmdesign.net/handouts/DynamicProgramming.pdf"  rel="nofollow">http://ww3.algorithmdesign.net/handouts/DynamicProgramming.pdf</a>
</p>

<p>
[5] <a href="http://infoarena.ro/problema/scmax" class="urlextern" title="http://infoarena.ro/problema/scmax"  rel="nofollow">http://infoarena.ro/problema/scmax</a>
</p>

<p>
[6] <a href="http://infoarena.ro/problema/ssm" class="urlextern" title="http://infoarena.ro/problema/ssm"  rel="nofollow">http://infoarena.ro/problema/ssm</a>
</p>

<p>
[7] Capitolul IV din Introducere în Algoritmi de către T. H. Cormen, C. E. Leiserson, R. L. Rivest, C. Stein
</p>

</div>
<!-- EDIT23 SECTION "Referințe" [29162-] --></div>
</body>
</html>
