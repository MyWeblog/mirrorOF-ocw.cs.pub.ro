    
    

<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
  <meta charset="utf-8" />
  <title>pa:laboratoare:laborator-10</title>
<meta name="generator" content="DokuWiki"/>
<meta name="robots" content="index,follow"/>
<meta name="date" content="2016-05-12T12:34:44+0300"/>
<meta name="keywords" content="pa,laboratoare,laborator-10"/>
<link rel="search" type="application/opensearchdescription+xml" href="../../../../lib/exe/opensearch.php" title="CS Open CourseWare"/>
<link rel="start" href="../../../../../courses.1.html"/>
<link rel="alternate" type="application/rss+xml" title="Recent Changes" href="../../../../feed.php"/>
<link rel="alternate" type="application/rss+xml" title="Current Namespace" href="../../../../feed.php%3Fmode=list&amp;ns=pa:laboratoare"/>
<link rel="alternate" type="text/html" title="Plain HTML" href="laborator-10.html"/>
<link rel="canonical" href="../../../../pa/laboratoare/laborator-10.html"/>
<link rel="stylesheet" type="text/css" href="../../../../lib/exe/css.php%3Ft=arctic&amp;tseed=1476798676.css"/>
<script type="text/javascript">/*<![CDATA[*/var NS='pa:laboratoare';var JSINFO = {"id":"pa:laboratoare:laborator-10","namespace":"pa:laboratoare","isadmin":0,"isauth":0};
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="../../../../lib/exe/js.php%3Ftseed=1476798676"></script>
<script type="text/x-mathjax-config">/*<![CDATA[*/MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ["$","$"], ["\\(","\\)"] ],
        displayMath: [ ["$$","$$"], ["\\[","\\]"] ],
        processEscapes: true
    }
});
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
<script type="text/javascript">/*<![CDATA[*/
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
		  
/*!]]>*/</script>
<script type="text/javascript">/*<![CDATA[*/
var pageTracker = _gat._getTracker("UA-38383934-1");
pageTracker._initData();
pageTracker._trackPageview();
		  
/*!]]>*/</script>
</head>
<body>
<div class="dokuwiki export">
<!-- TOC START -->
<div id="dw__toc">
<h3 class="toggle">Table of Contents</h3>
<div>

<ul class="toc">
<li class="level1"><div class="li"><a href="laborator-10.html#laborator_10_-_flux_maxim">Laborator 10 - Flux Maxim</a></div>
<ul class="toc">
<li class="level2"><div class="li"><a href="laborator-10.html#obiective_laborator">Obiective laborator</a></div></li>
<li class="level2"><div class="li"><a href="laborator-10.html#importanta_aplicatii_practice">Importanţă – aplicaţii practice</a></div></li>
<li class="level2"><div class="li"><a href="laborator-10.html#descrierea_problemei_si_a_rezolvarilor">Descrierea problemei şi a rezolvărilor</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="laborator-10.html#algoritmul_ford-fulkerson">Algoritmul Ford-Fulkerson</a></div></li>
<li class="level3"><div class="li"><a href="laborator-10.html#implementarea_edmonds-karp">Implementarea Edmonds-Karp</a></div></li>
</ul>
</li>
<li class="level2"><div class="li"><a href="laborator-10.html#variatii_ale_problemei_clasice">Variații ale problemei clasice</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="laborator-10.html#surse_si_destinatii_multiple">Surse si destinații multiple</a></div></li>
<li class="level3"><div class="li"><a href="laborator-10.html#cuplaj_bipartit_maxim">Cuplaj bipartit maxim</a></div></li>
<li class="level3"><div class="li"><a href="laborator-10.html#retea_cu_noduri_ce_nu_conserva_fluxul">Rețea cu noduri ce nu conservă fluxul</a></div></li>
<li class="level3"><div class="li"><a href="laborator-10.html#retea_cu_limite_inferioare_de_capacitate">Rețea cu limite inferioare de capacitate</a></div></li>
</ul>
</li>
<li class="level2"><div class="li"><a href="laborator-10.html#concluzii_si_observatii">Concluzii și observații</a></div></li>
<li class="level2"><div class="li"><a href="laborator-10.html#referinte">Referinte</a></div></li>
<li class="level2"><div class="li"><a href="laborator-10.html#probleme">Probleme</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="laborator-10.html#networking_9_pct">Networking (9 pct)</a></div></li>
<li class="level3"><div class="li"><a href="laborator-10.html#generare_de_graf_orientat_3_pct">Generare de graf orientat (3 pct)</a></div></li>
</ul></li>
</ul></li>
</ul>
</div>
</div>
<!-- TOC END -->

<h1 class="sectionedit1" id="laborator_10_-_flux_maxim">Laborator 10 - Flux Maxim</h1>
<div class="level1">

</div>
<!-- EDIT1 SECTION "Laborator 10 - Flux Maxim" [1-41] -->
<h2 class="sectionedit2" id="obiective_laborator">Obiective laborator</h2>
<div class="level2">
<ul>
<li class="level1"><div class="li">formalizarea noțiunilor de rețea de transport și flux în rețea</div>
</li>
<li class="level1"><div class="li">prezentarea unei metode de rezolvare a problemei de flux maxim</div>
</li>
<li class="level1"><div class="li">analiza unei implementări a metodei oferite</div>
</li>
</ul>

</div>
<!-- EDIT2 SECTION "Obiective laborator" [42-260] -->
<h2 class="sectionedit3" id="importanta_aplicatii_practice">Importanţă – aplicaţii practice</h2>
<div class="level2">

<p>
Un graf orientat poate fi utilizat pentru modelarea unui proces de transport într-o rețea între un producător <em>s</em> și un consumator <em>t</em>. Destinația nu poate consuma mai mult decât se produce, iar cantitatea trimisă pe o cale nu poate depăși capacitatea sa de transport.
</p>

<p>
Rețelele de transport pot modela curgerea lichidului în sisteme cu țevi, deplasarea pieselor pe benzi rulante, deplasarea curentului prin rețele electrice, transmiterea informațiilor prin rețele de comunicare etc.
</p>

</div>
<!-- EDIT3 SECTION "Importanţă – aplicaţii practice" [261-815] -->
<h2 class="sectionedit4" id="descrierea_problemei_si_a_rezolvarilor">Descrierea problemei şi a rezolvărilor</h2>
<div class="level2">

<p>
O problemă des întâlnită într-o rețea de transport este cea a găsirii fluxului maxim posibil prin arcele rețelei astfel încât:
</p>

<p>
1. să nu fie depășite capacitățile arcelor
</p>

<p>
2. fluxul să se conserve în drumul său de la <em>s</em> la <em>t</em>
</p>

<p>
<strong>Definiție 1</strong>
</p>

<p>
O rețea de transport este un graf orientat <code>G = (V,E)</code> cu proprietățile:
</p>

<p>
1. există două noduri speciale în <code>V</code>: <em>s</em> este nodul sursă (sau producătorul) și <em>t</em> este nodul terminal (sau consumatorul).
</p>

<p>
2. este definită o funcție totală de capacitate <code>c: V×V → R+</code> astfel încât:
</p>
<ul>
<li class="level1"><div class="li"> <code>c (u,v) = 0</code> dacă <code>(u,v) ∉ E</code></div>
</li>
<li class="level1"><div class="li"> <code>c (u,v) ≥ 0</code> daca <code>(u,v) ∈ E</code></div>
</li>
</ul>

<p>
3. pentru orice nod <code>v ∈ V \ {s,t}</code> există cel puțin o cale <code>s —&gt; v —&gt; t</code>.
</p>

<p>
<strong>Definiție 2</strong>
</p>

<p>
Numim flux în rețeaua <code>G = (V,E )</code> o funcție totală <code>f: V×V → R</code> cu proprietățile:
</p>

<p>
1. Restricție de capacitate:
</p>
<ul>
<li class="level1"><div class="li"> <code>f(u,v) ≤ c(u,v), ∀(u,v) ∈ V</code> - fluxul printr-un arc nu poate depăși capacitatea acestuia</div>
</li>
</ul>

<p>
2. Antisimetrie:
</p>
<ul>
<li class="level1"><div class="li"> <code>f(u,v) = -f(v,u) , ∀u ∈ V, ∀v ∈ V</code></div>
</li>
</ul>

<p>
3. Conservarea fluxului:
</p>
<ul>
<li class="level1"><div class="li"> <code>Σ f(u,v) = 0, ∀u ∈ V ∖ {s,t}, v ∈ V</code></div>
</li>
</ul>

<p>
Un flux negativ de la u la v este unul virtual, el nu reprezintă un transport efectiv, ci doar sugerează că există un transport fizic de la v la u (este o convenție asemănătoare cu cea făcută pentru intensitățile curenților într-o rețea electrică). Ultima proprietate ne spune că la trecerea printr-un nod fluxul se conservă: suma fluxurilor ce intră într-un nod este 0 (ținând cont de convenția de semn stabilită). 
</p>

<p>
Numim <strong>capacitate reziduală</strong> a unui arc
</p>

<p>
<code>c<sub>f</sub> (u,v) = c(u,v) - f(u,v)</code>
</p>

<p>
și o interpretăm ca fiind cantitatea de flux adițional care poate fi transportat de la <em>u</em> la <em>v</em>, fără a
depăși capacitatea <code>c(u,v)</code>.
</p>

<p>
Exemplu:
</p>

<p>
<a href="../../../../_detail/pa/laboratoare/101.png%3Fid=pa%253Alaboratoare%253Alaborator-10.html" class="media" title="pa:laboratoare:101.png"><img src="../../../../_media/pa/laboratoare/101.png%3Fw=350&amp;tok=c535f8" class="mediacenter" alt="" width="350" /></a>
</p>

<p>
Daca avem arcul <code>(u,v) ∈ V</code> cu <code>c(u,v) = 15</code> și <code>f(u,v) = 10</code>, se pot transporta <code>c<sub>f</sub>(u,v) = 5</code> unități suplimentare fără a încălca restricția de capacitate. Dar, conform definiției, deși arcul <code>(v,u) ∉ V</code> vom avea totuși o capacitate reziduală <code>c<sub>f</sub>(v,u) = c(v,u) – f(v,u) = 0 − (−10) = 10</code>: as putea transporta <code>10</code> unități în sens opus care să le anuleze pe cele 10 ale fluxului direct pe muchia <code>(u,v)</code>.
</p>

<p>
<strong>Definiție 3</strong>
</p>

<p>
Fie o rețea de flux <code>G = (V,E)</code>, iar <em>f</em> fluxul prin <code>G</code>. Numim rețea reziduală a lui <code>G</code>, indusă de <em>f</em>, o rețea de flux notată cu <code>G<sub>f</sub> = (V, E<sub>f</sub>)</code>, astfel încât
</p>
<ul>
<li class="level1"><div class="li"> <code>E<sub>f</sub> = {(u,v) ∈ V ∣ c<sub>f</sub>(u,v) = c(u,v) − f(u,v) &gt; 0}</code></div>
</li>
</ul>

<p>
Este important de observat că <code>E<sub>f</sub></code> și <code>E</code> pot fi disjuncte: un arc rezidual <code>(u,v)</code> apare în rețeaua reziduală doar dacă capacitatea sa este strict pozitivă (ceea ce nu implică existența arcului în rețeaua originală).
</p>

<p>
Un drum de ameliorare este o cale <code>(u1, u2, …, uk)</code>, unde <code>u1 = s</code> și <code>uk = t</code>, în graful rezidual cu <code>c<sub>f</sub>(ui, ui+1) &gt; 0, ∀i=1,2,…,k−1</code>. Practic, un drum de ameliorare va reprezenta o cale în graf prin care se mai poate pompa flux adițional de la sursa la destinație.
</p>

<p>
Așa cum era de intuit, capacitatea reziduală a unui drum de ameliorare p este cantitatea maximă de flux ce se poate transporta de-a lungul lui:
</p>
<ul>
<li class="level1"><div class="li"> <code>c<sub>f</sub>(p) = min{c<sub>f</sub>(u,v) ∣ (u,v) ∈ p}</code></div>
</li>
</ul>

<p>
Acum că am introdus noțiunile necesare pentru formalizarea problemei de flux maxim într-un graf, putem să prezentăm și cea mai utilizată metodă de rezolvare.
</p>

</div>
<!-- EDIT4 SECTION "Descrierea problemei şi a rezolvărilor" [816-4447] -->
<h3 class="sectionedit5" id="algoritmul_ford-fulkerson">Algoritmul Ford-Fulkerson</h3>
<div class="level3">

<p>
Aceasta este o metodă iterativă de găsire a fluxului maxim într-un graf care pleacă de la ideea: cât timp mai există un drum de ameliorare (o cale de la sursă la destinație) pot pompa pe această cale un flux suplimentar egal cu capacitatea reziduală a căii.
</p>

<p>
Acest algoritm reprezintă mai mult un șablon de rezolvare pentru că nu detaliază modul în care se alege drumul de ameliorare din rețeaua reziduală.
</p>
<pre class="code cpp">Ford_Fulkerson
    Input G<span class="br0">&#40;</span>V,E<span class="br0">&#41;</span>, s, t
    Output <span class="sy3">|</span>fmax<span class="sy3">|</span>
    <span class="sy3">|</span>fmax<span class="sy3">|</span> ← <span class="nu0">0</span>
    f<span class="br0">&#123;</span>u,v<span class="br0">&#41;</span> ← <span class="nu0">0</span>, ∀<span class="br0">&#40;</span>u,v<span class="br0">&#41;</span> ∈ V×V
    <span class="kw1">while</span> ∃a path p<span class="br0">&#40;</span>s <span class="sy2">---</span><span class="sy1">&gt;</span> t<span class="br0">&#41;</span> in Gf such that cf<span class="br0">&#40;</span>u,v<span class="br0">&#41;</span> <span class="sy1">&gt;</span> <span class="nu0">0</span>, ∀<span class="br0">&#40;</span>u,v<span class="br0">&#41;</span> ∈ p
        find cf<span class="br0">&#40;</span>p<span class="br0">&#41;</span> <span class="sy1">=</span> min<span class="br0">&#123;</span>cf<span class="br0">&#40;</span>u,v<span class="br0">&#41;</span> <span class="sy3">|</span> cf<span class="br0">&#40;</span>u,v<span class="br0">&#41;</span> ∈ p<span class="br0">&#125;</span>
        <span class="sy3">|</span>fmax<span class="sy3">|</span> <span class="sy2">+</span><span class="sy1">=</span> cf<span class="br0">&#40;</span>p<span class="br0">&#41;</span>
        for<span class="sy2">-</span>each <span class="br0">&#40;</span>u,v<span class="br0">&#41;</span> ∈ p
            f<span class="br0">&#40;</span>u,v<span class="br0">&#41;</span> ← f<span class="br0">&#40;</span>u,v<span class="br0">&#41;</span> <span class="sy2">+</span> cf<span class="br0">&#40;</span>p<span class="br0">&#41;</span>
            f<span class="br0">&#40;</span>v,u<span class="br0">&#41;</span> ← −f<span class="br0">&#40;</span>u,v<span class="br0">&#41;</span>
    <span class="kw1">return</span> <span class="sy3">|</span>fmax<span class="sy3">|</span></pre>

<p>
Complexitatea va fi <code>O(E * f max)</code> pentru că în ciclul while putem găsi, în cel mai rău caz, doar cai care duc la creșterea fluxului cu doar o unitate la fiecare pas.
</p>

<p>
Ne punem acum problema dacă acest algoritm este corect, dacă la final vom avea cu adevărat fluxul maxim posibil prin graf. Corectitudinea algoritmului derivă imediat din teorema <strong>Flux maxim - tăietura minimă</strong>.
</p>

<p>
Numim o <strong>tăietură a unui graf</strong> o partiție <code>(S,T)</code> a nodurilor sale cu proprietatea <code>s ∈ S</code> si <code>t ∈ T</code>. 
</p>

<p>
<strong>Teorema flux maxim – tăietura minimă: </strong>
</p>

<p>
Pentru o rețea de flux <code>G(V,E)</code> următoarele afirmații sunt echivalente:
</p>

<p>
1. <code>f</code> este fluxul maxim în <code>G</code>
</p>

<p>
2. Rețeaua reziduală <code>G<sub>f</sub></code> nu conține drumuri de ameliorare
</p>

<p>
3. Există o tăietură <code>(S,T)</code> a lui <code>G</code> astfel încât fluxul net prin tăietură este egal cu capacitatea acelei tăieturi.
</p>

<p>
<strong>Obs:</strong> Prin orice tăietură fluxul este egal cu cel maxim pentru că nu există o altă cale pe care ar putea ajunge flux de la sursă la destinație și care să nu treacă prin tăietură (ar încălca tocmai definiția ei); sau, altfel spus, valoarea unui flux într-o rețea este dată de fluxul oricărei tăieturi. Astfel, fluxul total va fi mărginit de cea mai mică capacitate a unei tăieturi. Dacă este îndeplinit punctul 3. al teoremei atunci știm că acea tăietură nu poate fi decât una de capacitate minimă. Ultima incercare de a gasi o cale de la sursa la drena va rezulta in gasirea doar a elementelor marginite de o astfel de taietura.
</p>

<p>
Exemplu:
</p>

<p>
Rețeaua inițială:
<a href="../../../../_detail/pa/laboratoare/102.png%3Fid=pa%253Alaboratoare%253Alaborator-10.html" class="media" title="pa:laboratoare:102.png"><img src="../../../../_media/pa/laboratoare/102.png%3Fw=350&amp;tok=6baa58" class="mediacenter" alt="" width="350" /></a>
</p>

<p>
Rețeaua reziduală:
<a href="../../../../_detail/pa/laboratoare/103.png%3Fid=pa%253Alaboratoare%253Alaborator-10.html" class="media" title="pa:laboratoare:103.png"><img src="../../../../_media/pa/laboratoare/103.png%3Fw=350&amp;tok=adf601" class="mediacenter" alt="" width="350" /></a>
</p>

<p>
Observăm că deși muchia <code>(d,c)</code> are capacitate 0 în rețeaua originală (ea nu ar putea transporta flux) în rețeaua reziduală avem <code>c(d,c) = 1</code> ceea ce îi permite să facă parte din drumul de ameliorare <code>p1 = (s, a, b, d, c, t)</code> de capacitate <code>c<sub>f</sub>(p1) = 1</code>, astfel că adăugarea acestui flux suplimentar pe muchia <code>(d,c)</code> nu va duce la încălcarea restricției de capacitate; sau am fi putut alege drumul <code>p2=(s, a, c, t)</code> cu <code>c<sub>f</sub>(p2) = 1</code> sau <code>p3 = (s,a,b,d,t)</code> cu <code>c<sub>f</sub>(p3) = 1</code>.
Performanța algoritmului ține de modul în care va fi ales drumul de ameliorare, se poate întâmpla ca pentru <code>|fmax|</code> de valoarea mare o alegere nepotrivită să ducă la timpi de execuție foarte mari. 
</p>

</div>
<!-- EDIT5 SECTION "Algoritmul Ford-Fulkerson" [4448-7736] -->
<h3 class="sectionedit6" id="implementarea_edmonds-karp">Implementarea Edmonds-Karp</h3>
<div class="level3">

<p>
Așa cum am văzut, algoritmul Ford-Fulkerson nu definește o metodă de alegere a drumului de ameliorare pe baza căruia se modifică fluxul în graf. Implementarea Edmonds-Karp alege întotdeauna cea mai scurtă cale folosind o căutare în lățime în graful rezidual unde fiecare arc are ponderea 1. Se poate demonstra că lungimea căilor găsite astfel crește monoton cu fiecare nouă ameliorare.
</p>
<pre class="code cpp">Edmonds<span class="sy2">-</span>Karp
    Input G<span class="br0">&#40;</span>V,E<span class="br0">&#41;</span>, s, t
    Output <span class="sy3">|</span>fmax<span class="sy3">|</span>
    <span class="sy3">|</span>fmax<span class="sy3">|</span> ← <span class="nu0">0</span>
    f<span class="br0">&#40;</span>u,v<span class="br0">&#41;</span> ← <span class="nu0">0</span>, ∀<span class="br0">&#40;</span>u,v<span class="br0">&#41;</span> ∈ V×V
    <span class="kw1">while</span> <span class="kw2">true</span>
        p<span class="br0">&#40;</span>s ⇢ t<span class="br0">&#41;</span> ← BFS<span class="br0">&#40;</span>Gf,s,t<span class="br0">&#41;</span>
        <span class="kw1">if</span> not ∃p<span class="br0">&#40;</span>s ⇢ t<span class="br0">&#41;</span>
            <span class="kw1">break</span><span class="sy4">;</span>
        find cf<span class="br0">&#40;</span>p<span class="br0">&#41;</span> <span class="sy1">=</span> min<span class="br0">&#123;</span>cf<span class="br0">&#40;</span>u,v<span class="br0">&#41;</span> ∣ cf<span class="br0">&#40;</span>u,v<span class="br0">&#41;</span> ∈ p<span class="br0">&#125;</span>
        <span class="sy3">|</span>fmax<span class="sy3">|</span> <span class="sy2">+</span><span class="sy1">=</span> cf<span class="br0">&#40;</span>p<span class="br0">&#41;</span>
        for<span class="sy2">-</span>each <span class="br0">&#40;</span>u,v<span class="br0">&#41;</span> ∈ p
            f<span class="br0">&#40;</span>u,v<span class="br0">&#41;</span> ← f<span class="br0">&#40;</span>u,v<span class="br0">&#41;</span> <span class="sy2">+</span> cf<span class="br0">&#40;</span>p<span class="br0">&#41;</span>
            f<span class="br0">&#40;</span>v,u<span class="br0">&#41;</span> ← −f<span class="br0">&#40;</span>u,v<span class="br0">&#41;</span>
        <span class="kw1">return</span> <span class="sy3">|</span>fmax<span class="sy3">|</span></pre>

<p>
Plecând de la ideea că drumurile de ameliorare găsite au lungimi din ce în ce mai mari se poate arăta că în această implementare fluxul se mărește de cel mult <code>O(V*E)</code> ori ([1], pag.513). 
</p>

<p>
Complexitatea algoritmului va fi <code>O(V*E<sup>2</sup>)</code>. Să luăm un exemplu de rulare al acestui algoritm. Vom considera starea rețelei după ce a fost găsita prima cale de pompare flux(inițial toate arcele sunt etichetate cu 0/0 conform notației stabilite):
</p>

<p>
<a href="../../../../_detail/pa/laboratoare/104.png%3Fid=pa%253Alaboratoare%253Alaborator-10.html" class="media" title="pa:laboratoare:104.png"><img src="../../../../_media/pa/laboratoare/104.png%3Fw=500&amp;tok=9ee42a" class="mediacenter" alt="" width="500" /></a>
</p>

<p>
<strong>Obs:</strong> In cazul ultimului drum de ameliorare găsit in exemplul dat, se observa ca deși nu exista muchia <code>(d,c)</code> se simulează un flux pe aceasta printr-unul negativ in sens opus.
</p>

</div>
<!-- EDIT6 SECTION "Implementarea Edmonds-Karp" [7737-9294] -->
<h2 class="sectionedit7" id="variatii_ale_problemei_clasice">Variații ale problemei clasice</h2>
<div class="level2">

<p>
In rețelele clasice studiate pana acum aveam o sursa unica care putea produce oricât, destinația unica consuma oricât, orice nod intermediar conserva fluxul, iar singura constrângere a muchiilor era limitarea superioara a fluxului prin capacitate. Sa vedem cum putem generaliza aceste condiții si daca rețelele obținute ar putea fi reduse la una clasica.
</p>

</div>
<!-- EDIT7 SECTION "Variații ale problemei clasice" [9295-9702] -->
<h3 class="sectionedit8" id="surse_si_destinatii_multiple">Surse si destinații multiple</h3>
<div class="level3">

<p>
<a href="../../../../_detail/pa/laboratoare/105.png%3Fid=pa%253Alaboratoare%253Alaborator-10.html" class="media" title="pa:laboratoare:105.png"><img src="../../../../_media/pa/laboratoare/105.png%3Fw=350&amp;tok=e19c43" class="mediacenter" alt="" width="350" /></a>
</p>

<p>
Se observă ca putem reduce acest graf la cel cunoscut prin adăugarea unei meta-surse legată de sursele mici prin muchii de capacitate nelimitata si analog un meta-terminal cu aceleași proprietăți. Global comportamentul rețelei de flux nu se va schimba.
</p>

</div>
<!-- EDIT8 SECTION "Surse si destinații multiple" [9703-10040] -->
<h3 class="sectionedit9" id="cuplaj_bipartit_maxim">Cuplaj bipartit maxim</h3>
<div class="level3">

<p>
Fiind dat un graf neorientat <code>G = (V,E)</code>, un cuplaj este o submultime de muchii <code>M</code> inclusa in <code>E</code> astfel incat pentru toate varfurile <code>v ∈ V</code>, exista cel mult o muchie in <code>M</code> incidenta in <code>v</code>. Spunem ca un varf  <code>v ∈ M</code> este cuplat de cuplajul <code>M</code> daca exista o muchie in <code>M</code> incidenta in <code>v</code>. Un cuplaj maxim este un cuplaj de cardinalitate maxima. In cazul grafurilor bipartite, multimea de varfuri poate fi partitionata in <code>V = L U R</code>, unde <code>L</code> si <code>R</code> sunt disjuncte si toate muchiile din <code>E</code> sunt intre <code>L</code> si <code>R</code>. Problema poate fi rezolvata cu ajutorul notiunii de flux, construind reteaua de transport <code>G&#039; = (V&#039;,E&#039;)</code> pentru graful bipartit <code>G</code>. Vom alege sursa <em>s</em> si destinatia <em>t</em> ca fiind noi varfuri care nu sunt in <code>V</code> si vom construi <code>V&#039; = V U {s,t}</code>. Arcele orientate ale lui <code>G</code>&#039; sunt date de:
</p>
<ul>
<li class="level1"><div class="li"> <code>E&#039; = { (s, u) : u ∈ L } U { (u, v) : u ∈ L, v ∈ R si (u, v) ∈ E} U { (v, t) : v ∈ R}</code></div>
</li>
</ul>

<p>
Pentru a completa constructia, vom atribui fiecarei muchii din E&#039; capacitatea unitate.
</p>

</div>
<!-- EDIT9 SECTION "Cuplaj bipartit maxim" [10041-11126] -->
<h3 class="sectionedit10" id="retea_cu_noduri_ce_nu_conserva_fluxul">Rețea cu noduri ce nu conservă fluxul</h3>
<div class="level3">

<p>
Spre deosebire de <em>s</em> si <em>t</em> care produc/consumă oricât, un nod intermediar ar putea produce sau consuma o cantitate constanta de flux la trecerea prin el. In acest caz vom avea un invariant la nivel de nod care ia forma:
</p>
<ul>
<li class="level1"><div class="li"> <code>f<sub>in</sub> − f<sub>out</sub> = di</code>, unde <code>di</code> este cantitatea produsă suplimentar (<code>&gt; 0</code>) sau solicitată (<code>&lt; 0</code>) de un nod. </div>
</li>
</ul>

<p>
Am putea transforma egalitatea in:
</p>
<ul>
<li class="level1"><div class="li"> <code>(f<sub>in</sub> + |di|) – f<sub>out</sub> = 0</code> , dacă <code>di &lt; 0</code></div>
</li>
<li class="level1"><div class="li"> <code>f<sub>in</sub> − ( f<sub>out</sub> + |di|) =  0</code> , daca <code>di &gt; 0</code></div>
</li>
</ul>

<p>
Altfel spus, un nod ce consumă flux poate fi transformat intr-unul ce conservă fluxul și are un in-arc adițional de capacitate <code>|di|</code>, iar unul ce produce flux va avea un out-arc de aceeași capacitate.
</p>

<p>
La nivelul unei rețele întregi se adaugă un nod sursă cu muchii către toate nodurile ce consumau flux si un nod destinație dinspre toate nodurile ce produceau flux. 
</p>

<p>
Exemplu:
</p>

<p>
<a href="../../../../_detail/pa/laboratoare/106.png%3Fid=pa%253Alaboratoare%253Alaborator-10.html" class="media" title="pa:laboratoare:106.png"><img src="../../../../_media/pa/laboratoare/106.png%3Fw=250&amp;tok=fa8b4c" class="mediacenter" alt="" width="250" /></a>
</p>

<p>
se va transforma in:
</p>

<p>
<a href="../../../../_detail/pa/laboratoare/107.png%3Fid=pa%253Alaboratoare%253Alaborator-10.html" class="media" title="pa:laboratoare:107.png"><img src="../../../../_media/pa/laboratoare/107.png%3Fw=250&amp;tok=29dfca" class="mediacenter" alt="" width="250" /></a>
</p>

</div>
<!-- EDIT10 SECTION "Rețea cu noduri ce nu conservă fluxul" [11127-12230] -->
<h3 class="sectionedit11" id="retea_cu_limite_inferioare_de_capacitate">Rețea cu limite inferioare de capacitate</h3>
<div class="level3">

<p>
Există cazuri în care aș vrea ca datele de pe muchiile rețelei sa facă parte dintr-un anumit interval <code>[inf, sup]</code>. Pe o astfel de muchie fluxul trebuie să respecte inegalitatea <code>inf ≤ f ≤ sup</code>
</p>

<p>
Plecând tot de la condițiile de conservare la nivel de nod putem translata intervalul <code>[inf, sup]</code> în <code>[0, sup-inf]</code> și să considerăm că nodul sursă a consumat <code>inf</code> unități de flux iar nodul destinație a produs <code>inf</code> unități. Din exterior entitatea alcătuită din doua noduri și o muchie este văzută ca acționând în același fel asupra fluxului ce o traversează.
</p>

<p>
Iată un exemplu de transformare:
</p>

<p>
<a href="../../../../_detail/pa/laboratoare/108.png%3Fid=pa%253Alaboratoare%253Alaborator-10.html" class="media" title="pa:laboratoare:108.png"><img src="../../../../_media/pa/laboratoare/108.png%3Fw=250&amp;tok=53e784" class="mediacenter" alt="" width="250" /></a>
</p>

<p>
Bineînțeles că toate aceste transformări pot fi combinate pentru a se ajunge la rețeaua de flux clasică.
</p>

</div>
<!-- EDIT11 SECTION "Rețea cu limite inferioare de capacitate" [12231-13070] -->
<h2 class="sectionedit12" id="concluzii_si_observatii">Concluzii și observații</h2>
<div class="level2">

<p>
Laboratorul de față s-a vrut a fi doar o introducere în domeniul fluxurilor într-un graf – modalitate de a reprezenta probleme de circulație a materialelor atât de frecvent întâlnite. In [1] și [2] găsiți și alți algoritmi interesanți împreună cu studiul complexității lor (algoritmul de pompare preflux, algoritmul „mutare-in-fata”). Spre exemplu, cel mai bun algoritm în prezent pentru cuplajul bipartit maxim se executa in <code>O(√V*E)</code>.
</p>

</div>
<!-- EDIT12 SECTION "Concluzii și observații" [13071-13576] -->
<h2 class="sectionedit13" id="referinte">Referinte</h2>
<div class="level2">

<p>
[1] Introducere in algoritmi, Thomas H. Cormen, Charles E. Leiserson, Ronald R. Rivest – Capitolul VI Algoritmi pe grafuri: Flux maxim
</p>

<p>
[2] Introducere in analiza algoritmilor, Cristian A. Giumale – Cap. V Algoritmi pr grafuri:
Fluxuri maxime intr-un graf
</p>

<p>
[3] Un articol de la MIT: <a href="http://web.mit.edu/15.053/www/AMP-Appendix-C.pdf" class="urlextern" title="http://web.mit.edu/15.053/www/AMP-Appendix-C.pdf"  rel="nofollow"> A Labeling Algorithm for the maximum flow network problem</a>
</p>

<p>
[4] Resurse wiki –
<a href="http://en.wikipedia.org/wiki/Edmonds%E2%80%93Karp_algorithm" class="urlextern" title="http://en.wikipedia.org/wiki/Edmonds%E2%80%93Karp_algorithm"  rel="nofollow"> Edmonds Karp</a> <a href="http://en.wikipedia.org/wiki/Max-flow_min-cut_theorem" class="urlextern" title="http://en.wikipedia.org/wiki/Max-flow_min-cut_theorem"  rel="nofollow"> Max Flow - Min Cut Theorem</a>
</p>

<p>
[5]
<a href="http://www.cs.princeton.edu/~wayne/cs423/lectures/max-flow-applications-4up.pdf" class="urlextern" title="http://www.cs.princeton.edu/~wayne/cs423/lectures/max-flow-applications-4up.pdf"  rel="nofollow"> Aplicatii flux maxim</a>
</p>

</div>
<!-- EDIT13 SECTION "Referinte" [13577-14301] -->
<h2 class="sectionedit14" id="probleme">Probleme</h2>
<div class="level2">

<p>
<p><div class="notewarning">
După rezolvarea problemei, toți studenții trebuie să încarce o arhivă cu sursele rezolvării pe Moodle (click <a href="http://cs.curs.pub.ro/2015/mod/assign/view.php?id=5853" class="urlextern" title="http://cs.curs.pub.ro/2015/mod/assign/view.php?id=5853"  rel="nofollow">aici</a>) pentru a li se puncta laboratorul.

</div></p>
</p>

</div>
<!-- EDIT14 SECTION "Probleme" [14302-14563] -->
<h3 class="sectionedit15" id="networking_9_pct">Networking (9 pct)</h3>
<div class="level3">

<p>
Pornind de la un graf orientat conex și două noduri <code>u</code> și <code>v</code> ale acestuia se cere să se determine următorele elemente:
[6p primul punct rezolvat + 3p al doilea]
</p>

<p>
a) Tăietura minimală a grafului afișată sub forma a unei mulțimi de cardinal minim de muchii ce trebuie eliminate pentru a deconecta <code>u</code> și <code>v</code>.
</p>

<p>
b) Pentru topologia dată, afișați numărul maxim de drumuri disjuncte între <code>u</code> și <code>v</code>, dar și drumurile în sine. Două drumuri sunt considerate disjuncte dacă nu au nicio muchie în comun
</p>

<p>
Graful din schelet:
</p>

<p>
<a href="../../../../_detail/pa/laboratoare/graf_flux.png%3Fid=pa%253Alaboratoare%253Alaborator-10.html" class="media" title="pa:laboratoare:graf_flux.png"><img src="../../../../_media/pa/laboratoare/graf_flux.png%3Fw=150&amp;tok=db3270" class="mediacenter" alt="" width="150" /></a>
</p>

</div>
<!-- EDIT15 SECTION "Networking (9 pct)" [14564-15186] -->
<h3 class="sectionedit16" id="generare_de_graf_orientat_3_pct">Generare de graf orientat (3 pct)</h3>
<div class="level3">

<p>
Se dă o listă de <code>N</code> noduri, pentru fiecare cunoscându-se gradul de intrare si de ieșire al acestora. Realizați un program care să construiască un graf <strong>orientat</strong> <code>G</code> cu <code>N</code> noduri, care să satisfaca gradele date. Nu se permite mai mult de o muchie între două noduri.<br/>

Exemplu:
</p>
<div class="table sectionedit17"><table class="inline">
	<tr class="row0">
		<th class="col0"> Nod </th><th class="col1"> Grad intrare </th><th class="col2"> Grad iesire </th>
	</tr>
	<tr class="row1">
		<td class="col0 centeralign">  1  </td><td class="col1 centeralign">  1  </td><td class="col2 centeralign">  3  </td>
	</tr>
	<tr class="row2">
		<td class="col0 centeralign">  2  </td><td class="col1 centeralign">  1  </td><td class="col2 centeralign">  2  </td>
	</tr>
	<tr class="row3">
		<td class="col0 centeralign">  3  </td><td class="col1 centeralign">  3  </td><td class="col2 centeralign">  1  </td>
	</tr>
	<tr class="row4">
		<td class="col0 centeralign">  4  </td><td class="col1 centeralign">  2  </td><td class="col2 centeralign">  1  </td>
	</tr>
</table></div>
<!-- EDIT17 TABLE [15530-15646] -->
<p>
O soluție posibilă de muchii:
</p>
<pre class="code">1 2
1 4
1 3
2 3
2 1
3 4
4 3</pre>

</div>
<!-- EDIT16 SECTION "Generare de graf orientat (3 pct)" [15187-] --></div>
</body>
</html>
