    
    

<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
  <meta charset="utf-8" />
  <title>so2:laboratoare:lab01</title>
<meta name="generator" content="DokuWiki"/>
<meta name="robots" content="index,follow"/>
<meta name="date" content="2016-03-02T08:24:48+0200"/>
<meta name="keywords" content="so2,laboratoare,lab01"/>
<link rel="search" type="application/opensearchdescription+xml" href="../../../../lib/exe/opensearch.php" title="CS Open CourseWare"/>
<link rel="start" href="../../../../../courses.1.html"/>
<link rel="alternate" type="application/rss+xml" title="Recent Changes" href="../../../../feed.php"/>
<link rel="alternate" type="application/rss+xml" title="Current Namespace" href="../../../../feed.php%3Fmode=list&amp;ns=so2:laboratoare"/>
<link rel="alternate" type="text/html" title="Plain HTML" href="lab01.html"/>
<link rel="canonical" href="../../../../so2/laboratoare/lab01.html"/>
<link rel="stylesheet" type="text/css" href="../../../../lib/exe/css.php%3Ft=arctic&amp;tseed=1476798676.css"/>
<script type="text/javascript">/*<![CDATA[*/var NS='so2:laboratoare';var JSINFO = {"id":"so2:laboratoare:lab01","namespace":"so2:laboratoare","isadmin":0,"isauth":0};
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="../../../../lib/exe/js.php%3Ftseed=1476798676"></script>
<script type="text/x-mathjax-config">/*<![CDATA[*/MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ["$","$"], ["\\(","\\)"] ],
        displayMath: [ ["$$","$$"], ["\\[","\\]"] ],
        processEscapes: true
    }
});
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
<script type="text/javascript">/*<![CDATA[*/
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
		  
/*!]]>*/</script>
<script type="text/javascript">/*<![CDATA[*/
var pageTracker = _gat._getTracker("UA-38383934-1");
pageTracker._initData();
pageTracker._trackPageview();
		  
/*!]]>*/</script>
</head>
<body>
<div class="dokuwiki export">
<!-- TOC START -->
<div id="dw__toc">
<h3 class="toggle">Table of Contents</h3>
<div>

<ul class="toc">
<li class="level1"><div class="li"><a href="lab01.html#laborator_1_-_introducere">Laborator 1 - Introducere</a></div>
<ul class="toc">
<li class="level2"><div class="li"><a href="lab01.html#obiectivele_laboratorului">Obiectivele laboratorului</a></div></li>
<li class="level2"><div class="li"><a href="lab01.html#cuvinte_cheie">Cuvinte cheie</a></div></li>
<li class="level2"><div class="li"><a href="lab01.html#materiale_ajutatoare">Materiale ajutătoare</a></div></li>
<li class="level2"><div class="li"><a href="lab01.html#desfasurarea_laboratorului">Desfășurarea laboratorului</a></div></li>
<li class="level2"><div class="li"><a href="lab01.html#suport_de_laborator">Suport de laborator</a></div></li>
<li class="level2"><div class="li"><a href="lab01.html#navigarea_codului_sursa">Navigarea codului sursă</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="lab01.html#cscope">cscope</a></div></li>
<li class="level3"><div class="li"><a href="lab01.html#lxr_cross-reference">LXR Cross-Reference</a></div></li>
<li class="level3"><div class="li"><a href="lab01.html#sourceweb">SourceWeb</a></div></li>
</ul>
</li>
<li class="level2"><div class="li"><a href="lab01.html#depanare">Depanare</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="lab01.html#gdb_linux">gdb (Linux)</a></div></li>
<li class="level3"><div class="li"><a href="lab01.html#obtinerea_unui_stack_trace">Obținerea unui stack trace</a></div></li>
</ul>
</li>
<li class="level2"><div class="li"><a href="lab01.html#documentatie">Documentație</a></div></li>
<li class="level2"><div class="li"><a href="lab01.html#exercitii">Exerciții</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="lab01.html#precizari">Precizări</a></div></li>
<li class="level3"><div class="li"><a href="lab01.html#boot-area_masinii_virtuale">1. Boot-area mașinii virtuale</a></div></li>
<li class="level3"><div class="li"><a href="lab01.html#adaugarea_si_utilizarea_unui_disc_virtual">2. Adăugarea și utilizarea unui disc virtual</a></div></li>
<li class="level3"><div class="li"><a href="lab01.html#gdb_si_qemu">3. GDB și qemu</a></div></li>
<li class="level3"><div class="li"><a href="lab01.html#gdb_spelunking">4. GDB spelunking</a></div></li>
<li class="level3"><div class="li"><a href="lab01.html#cscope_spelunking">5. cscope spelunking</a></div></li>
<li class="level3"><div class="li"><a href="lab01.html#solutii">Soluții</a></div></li>
</ul></li>
</ul></li>
</ul>
</div>
</div>
<!-- TOC END -->

<h1 class="sectionedit1" id="laborator_1_-_introducere">Laborator 1 - Introducere</h1>
<div class="level1">

</div>
<!-- EDIT1 SECTION "Laborator 1 - Introducere" [1-41] -->
<h2 class="sectionedit2" id="obiectivele_laboratorului">Obiectivele laboratorului</h2>
<div class="level2">
<ul>
<li class="level1"><div class="li"> prezentarea regulilor și modului de desfășurare a laboratorului de Sisteme de Operare 2</div>
</li>
<li class="level1"><div class="li"> prezentarea suportului de laborator</div>
</li>
<li class="level1"><div class="li"> prezentarea kernel-ului Linux și a resurselor aferente</div>
</li>
</ul>

</div>
<!-- EDIT2 SECTION "Obiectivele laboratorului" [42-276] -->
<h2 class="sectionedit3" id="cuvinte_cheie">Cuvinte cheie</h2>
<div class="level2">
<ul>
<li class="level1"><div class="li"> kernel, kernel programming</div>
</li>
<li class="level1"><div class="li"> Linux, vanilla, <a href="http://www.kernel.org" class="urlextern" title="http://www.kernel.org"  rel="nofollow">http://www.kernel.org</a></div>
</li>
<li class="level1"><div class="li"> cscope, LXR</div>
</li>
<li class="level1"><div class="li"> gdb, /proc/kcore, addr2line, dump_stack</div>
</li>
</ul>

</div>
<!-- EDIT3 SECTION "Cuvinte cheie" [277-438] -->
<h2 class="sectionedit4" id="materiale_ajutatoare">Materiale ajutătoare</h2>
<div class="level2">
<ul>
<li class="level1"><div class="li"> <a href="http://elf.cs.pub.ro/so2/res/laboratoare/lab01-slides.pdf" class="urlextern" title="http://elf.cs.pub.ro/so2/res/laboratoare/lab01-slides.pdf"  rel="nofollow">Slide-uri de suport pentru laborator</a></div>
</li>
</ul>

</div>
<!-- EDIT4 SECTION "Materiale ajutătoare" [439-577] -->
<h2 class="sectionedit5" id="desfasurarea_laboratorului">Desfășurarea laboratorului</h2>
<div class="level2">

<p>
Laboratorul de Sisteme de Operare 2 este un laborator de kernel programming și driver development. Obiectivele laboratorului sunt:
</p>
<ul>
<li class="level1"><div class="li"> aprofundarea noțiunilor prezentate la curs</div>
</li>
<li class="level1"><div class="li"> prezentarea interfețelor de programare la nivelul nucleului (kernel <abbr title="Application Programming Interface">API</abbr>)</div>
</li>
<li class="level1"><div class="li"> dezvoltarea deprinderilor de documentare, dezvoltare și depanare pe un mediu freestanding</div>
</li>
<li class="level1"><div class="li"> dobândirea de cunoștințe și deprinderi pentru dezvoltarea driverelor</div>
</li>
</ul>

<p>
Un laborator va prezenta un anumit set de noțiuni, aplicații și comenzi specifice unei problematici date. Laboratorul va debuta cu o prezentare (fiecare laborator va avea ca suport un set de slide-uri) (15 minute) urmând ca restul timpului să fie alocat rezolvării de exerciții de laborator (80 de minute).
</p>

<p>
Pentru o desfășurare cât mai bună a laboratorului, vă recomandăm parcurgea slide-urilor aferente. Pentru înțelegerea deplină a laboratorului, recomandăm parcurgerea suportului de laborator. Pentru aprofundare, folosiți documentația de suport.
</p>

</div>
<!-- EDIT5 SECTION "Desfășurarea laboratorului" [578-1622] -->
<h2 class="sectionedit6" id="suport_de_laborator">Suport de laborator</h2>
<div class="level2">
<ul>
<li class="level1"><div class="li"> Linux</div>
<ul>
<li class="level2"><div class="li"> <a href="http://www.amazon.com/Linux-Kernel-Development-Robert-Love/dp/0672329468/" class="urlextern" title="http://www.amazon.com/Linux-Kernel-Development-Robert-Love/dp/0672329468/"  rel="nofollow"> Linux Kernel Development, 3rd Edition</a></div>
</li>
<li class="level2"><div class="li"> <a href="http://free-electrons.com/doc/books/ldd3.pdf" class="urlextern" title="http://free-electrons.com/doc/books/ldd3.pdf"  rel="nofollow"> Linux Device Drivers, 3rd Edition</a></div>
</li>
<li class="level2"><div class="li"> <a href="http://www.amazon.com/Essential-Device-Drivers-Sreekrishnan-Venkateswaran/dp/0132396556" class="urlextern" title="http://www.amazon.com/Essential-Device-Drivers-Sreekrishnan-Venkateswaran/dp/0132396556"  rel="nofollow"> Essential Linux Device Drivers</a></div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> General</div>
<ul>
<li class="level2"><div class="li"> <a href="http://cursuri.cs.pub.ro/cgi-bin/mailman/listinfo/pso" class="urlextern" title="http://cursuri.cs.pub.ro/cgi-bin/mailman/listinfo/pso"  rel="nofollow"> lista de discuții</a> (<a href="http://blog.gmane.org/gmane.education.region.romania.operating-systems-design" class="urlextern" title="http://blog.gmane.org/gmane.education.region.romania.operating-systems-design"  rel="nofollow"> căutare în arhiva listei de discuții</a>)</div>
</li>
</ul>
</li>
</ul>

</div>
<!-- EDIT6 SECTION "Suport de laborator" [1623-2235] -->
<h2 class="sectionedit7" id="navigarea_codului_sursa">Navigarea codului sursă</h2>
<div class="level2">

</div>
<!-- EDIT7 SECTION "Navigarea codului sursă" [2236-2273] -->
<h3 class="sectionedit8" id="cscope">cscope</h3>
<div class="level3">

<p>
<a href="http://cscope.sourceforge.net/" class="urlextern" title="http://cscope.sourceforge.net/"  rel="nofollow">Cscope</a> este un program pentru parcurgerea eficientă a surselor C.  Pentru a-l folosi, trebuie generată o bază de date cscope din sursele existente.  Într-un tree Linux, este suficientă folosirea <code>make ARCH=x86 cscope</code>.  Precizarea arhitecturii prin variabila ARCH este opțională, dar recomandată; altfel, unele funcții dependente de arhitectură vor apărea de mai multe ori în baza de date.
</p>

<p>
Cscope poate fi folosit și stand-alone, dar este mult mai util în combinație cu un editor.  Pentru a folosi cscope cu Vim, este necesar să instalați ambele pachete și să adăugați următoarele linii în fișierul <code>.vimrc</code> (mașina din laborator are deja configurările făcute):
</p>
<pre class="code vim"><span class="kw1">if</span> <span class="kw3">has</span><span class="br0">&#40;</span><span class="st0">&quot;cscope&quot;</span><span class="br0">&#41;</span><span class="co1">
        &quot; Look for a 'cscope.out' file starting from the current directory,</span><span class="co1">
        &quot; going up to the root directory.</span>
        <span class="kw1">let</span> s<span class="sy0">:</span>dirs = <span class="kw3">split</span><span class="br0">&#40;</span><span class="kw3">getcwd</span><span class="br0">&#40;</span><span class="br0">&#41;</span>, <span class="st0">&quot;/&quot;</span><span class="br0">&#41;</span>
        <span class="kw1">while</span> s<span class="sy0">:</span>dirs <span class="sy0">!</span>= <span class="br0">&#91;</span><span class="br0">&#93;</span>
                <span class="kw1">let</span> s<span class="sy0">:</span><span class="kw2">path</span> = <span class="st0">&quot;/&quot;</span> <span class="sy0">.</span> <span class="kw3">join</span><span class="br0">&#40;</span>s<span class="sy0">:</span>dirs, <span class="st0">&quot;/&quot;</span><span class="br0">&#41;</span>
                <span class="kw1">if</span> <span class="br0">&#40;</span><span class="kw3">filereadable</span><span class="br0">&#40;</span>s<span class="sy0">:</span><span class="kw2">path</span> <span class="sy0">.</span> <span class="st0">&quot;/cscope.out&quot;</span><span class="br0">&#41;</span><span class="br0">&#41;</span>
                        <span class="kw1">execute</span> <span class="st0">&quot;cs add &quot;</span> <span class="sy0">.</span> s<span class="sy0">:</span><span class="kw2">path</span> <span class="sy0">.</span> <span class="st0">&quot;/cscope.out &quot;</span> <span class="sy0">.</span> s<span class="sy0">:</span><span class="kw2">path</span> <span class="sy0">.</span> <span class="st0">&quot; -v&quot;</span>
                        <span class="kw1">break</span>
                <span class="kw1">endif</span>
                <span class="kw1">let</span> s<span class="sy0">:</span>dirs = s<span class="sy0">:</span>dirs<span class="br0">&#91;</span><span class="sy0">:-</span><span class="nu0">2</span><span class="br0">&#93;</span>
        <span class="kw1">endwhile</span>
&nbsp;
        <span class="kw1">set</span> <span class="kw2">csto</span>=<span class="nu0">0</span><span class="co1">	&quot; Use cscope first, then ctags</span>
        <span class="kw1">set</span> <span class="kw2">cst</span><span class="co1">		&quot; Only search cscope</span>
        <span class="kw1">set</span> <span class="kw2">csverb</span><span class="co1">	&quot; Make cs verbose</span>
&nbsp;
        nmap <span class="sy0">&lt;</span>C<span class="sy0">-</span>\<span class="sy0">&gt;</span>s <span class="sy0">:</span>cs find s <span class="sy0">&lt;</span>C<span class="sy0">-</span>R<span class="sy0">&gt;</span>=<span class="kw3">expand</span><span class="br0">&#40;</span><span class="st0">&quot;&lt;cword&gt;&quot;</span><span class="br0">&#41;</span><span class="sy0">&lt;</span>CR<span class="sy0">&gt;</span><span class="kw2">&lt;CR&gt;</span>
        nmap <span class="sy0">&lt;</span>C<span class="sy0">-</span>\<span class="sy0">&gt;</span>g <span class="sy0">:</span>cs find g <span class="sy0">&lt;</span>C<span class="sy0">-</span>R<span class="sy0">&gt;</span>=<span class="kw3">expand</span><span class="br0">&#40;</span><span class="st0">&quot;&lt;cword&gt;&quot;</span><span class="br0">&#41;</span><span class="sy0">&lt;</span>CR<span class="sy0">&gt;</span><span class="kw2">&lt;CR&gt;</span>
        nmap <span class="sy0">&lt;</span>C<span class="sy0">-</span>\<span class="sy0">&gt;</span>c <span class="sy0">:</span>cs find c <span class="sy0">&lt;</span>C<span class="sy0">-</span>R<span class="sy0">&gt;</span>=<span class="kw3">expand</span><span class="br0">&#40;</span><span class="st0">&quot;&lt;cword&gt;&quot;</span><span class="br0">&#41;</span><span class="sy0">&lt;</span>CR<span class="sy0">&gt;</span><span class="kw2">&lt;CR&gt;</span>
        nmap <span class="sy0">&lt;</span>C<span class="sy0">-</span>\<span class="sy0">&gt;</span>t <span class="sy0">:</span>cs find t <span class="sy0">&lt;</span>C<span class="sy0">-</span>R<span class="sy0">&gt;</span>=<span class="kw3">expand</span><span class="br0">&#40;</span><span class="st0">&quot;&lt;cword&gt;&quot;</span><span class="br0">&#41;</span><span class="sy0">&lt;</span>CR<span class="sy0">&gt;</span><span class="kw2">&lt;CR&gt;</span>
        nmap <span class="sy0">&lt;</span>C<span class="sy0">-</span>\<span class="sy0">&gt;</span>e <span class="sy0">:</span>cs find e <span class="sy0">&lt;</span>C<span class="sy0">-</span>R<span class="sy0">&gt;</span>=<span class="kw3">expand</span><span class="br0">&#40;</span><span class="st0">&quot;&lt;cword&gt;&quot;</span><span class="br0">&#41;</span><span class="sy0">&lt;</span>CR<span class="sy0">&gt;</span><span class="kw2">&lt;CR&gt;</span>
        nmap <span class="sy0">&lt;</span>C<span class="sy0">-</span>\<span class="sy0">&gt;</span>f <span class="sy0">:</span>cs find f <span class="sy0">&lt;</span>C<span class="sy0">-</span>R<span class="sy0">&gt;</span>=<span class="kw3">expand</span><span class="br0">&#40;</span><span class="st0">&quot;&lt;cfile&gt;&quot;</span><span class="br0">&#41;</span><span class="sy0">&lt;</span>CR<span class="sy0">&gt;</span><span class="kw2">&lt;CR&gt;</span>
        nmap <span class="sy0">&lt;</span>C<span class="sy0">-</span>\<span class="sy0">&gt;</span>i <span class="sy0">:</span>cs find i <span class="sy0">^&lt;</span>C<span class="sy0">-</span>R<span class="sy0">&gt;</span>=<span class="kw3">expand</span><span class="br0">&#40;</span><span class="st0">&quot;&lt;cfile&gt;&quot;</span><span class="br0">&#41;</span><span class="kw2">&lt;CR&gt;</span><span class="sy0">$&lt;</span>CR<span class="sy0">&gt;</span>
        nmap <span class="sy0">&lt;</span>C<span class="sy0">-</span>\<span class="sy0">&gt;</span>d <span class="sy0">:</span>cs find d <span class="sy0">&lt;</span>C<span class="sy0">-</span>R<span class="sy0">&gt;</span>=<span class="kw3">expand</span><span class="br0">&#40;</span><span class="st0">&quot;&lt;cword&gt;&quot;</span><span class="br0">&#41;</span><span class="sy0">&lt;</span>CR<span class="sy0">&gt;</span><span class="kw2">&lt;CR&gt;</span><span class="co1">
&nbsp;
        &quot; Open a quickfix window for the following queries.</span>
        <span class="kw1">set</span> <span class="kw2">cscopequickfix</span>=s<span class="sy0">-</span>,c<span class="sy0">-</span>,d<span class="sy0">-</span>,i<span class="sy0">-</span>,t<span class="sy0">-</span>,e<span class="sy0">-</span>,g<span class="sy0">-</span>
<span class="kw1">endif</span></pre>

<p>
Script-ul caută un fișier numit <code>cscope.out</code> în directorul curent, sau în directoarele părinte ale acestuia.  Dacă Vim găsește acest fișier, puteți folosi combinația <code>Ctrl+]</code> sau <code>Ctrl+\ g</code> (combinația control-\, urmată de tasta g) pentru a sări direct la definiția cuvântului de sub cursor (funcție, variabilă, structură etc.).  Similar, puteți folosi <code>Ctrl+\ s</code> pentru a merge la locurile unde este folosit cuvântul de sub cursor.
</p>

<p>
Puteți lua un fișier <code>.vimrc</code> cscope-enabled (and other goodies) de la <a href="https://github.com/ddvlad/cfg/blob/master/_vimrc" class="urlextern" title="https://github.com/ddvlad/cfg/blob/master/_vimrc"  rel="nofollow">https://github.com/ddvlad/cfg/blob/master/_vimrc</a>.  Următoarele indicații se bazează pe acest fișier, dar au listate și comenzile de bază vim care obțin același efect.
</p>

<p>
Dacă există mai multe rezultate (de obicei există) vă puteți deplasa între ele folosind <code>F6</code> și <code>F5</code> (<code>:cnext</code> și <code>:cprev</code>) sau deschizând o subfereastră nouă cu rezultatele, folosind <code>:copen</code>. Ca să închideți subfereastra folosiți comanda <code>:cclose</code>.
</p>

<p>
Pentru a vă întoarce la locația precedentă, folosiți <code>Ctrl+o</code> (o, nu zero).  Comanda poate fi invocată de mai multe ori și funcționează chiar dacă cscope a schimbat fișierul pe care îl editați.
</p>

<p>
Pentru a merge la definiția unui simbol direct când porniți vim, folosiți <code>vim -t task_struct</code>. Sau, dacă ați deschis Vim și vreți ulterior să căutați un simbol după nume, puteți folosi comanda <code>:cs find g &lt;symbol_name&gt;</code> (unde <code>&lt;symbol_name&gt;</code> este numele simbolului.
</p>

<p>
Dacă ați găsit mai multe match-uri și dacă ați deschis o subfereastră cu toate match-urile (folosind <code>:copen</code>) și dacă sunteți în căutarea unui simbol de tip structură, este indicat să căutați în subfereastră (folosind <code>/</code> – <em>slash</em>) caracterul <code>{</code> (acoladă deschisă).
</p>

<p>
<p><div class="noteimportant">
Un sumar al comenzilor <code>cscope</code> îl puteți obține folosind <code>:cs help</code>.
</p>

<p>
Pentru mai multe informații, folosiți help-ul integrat al Vim: <code>:h cscope</code> sau <code>:h copen</code>.

</div></p>
</p>

<p>
Dacă sunteți utilizatori emacs, <a href="http://www.emacswiki.org/emacs/CScopeAndEmacs" class="urlextern" title="http://www.emacswiki.org/emacs/CScopeAndEmacs"  rel="nofollow">wiki-ul emacs</a> conține informații relevante pentru configurarea cscope.
</p>

<p>
Pentru o interfață mai simplă, <a href="http://sourceforge.net/projects/kscope/" class="urlextern" title="http://sourceforge.net/projects/kscope/"  rel="nofollow">Kscope</a> este un frontend pentru cscope care foloseşte QT. Este lightweight, foarte rapid și foarte ușor de folosit. Permite căutare folosind expresii regulate, grafuri de apel etc. Kscope nu mai este, în momentul de fața, menținut. Există şi un <a href="https://opendesktop.org/content/show.php/Kscope4?content=156987" class="urlextern" title="https://opendesktop.org/content/show.php/Kscope4?content=156987"  rel="nofollow">port</a> al versiunii 1.6 pentru Qt4 şi KDE 4 care păstrează integrarea editorului Kate şi este mai uşor de folosit decât ultima versiune prezentă pe SourceForge.
</p>

</div>
<!-- EDIT8 SECTION "cscope" [2274-7017] -->
<h3 class="sectionedit9" id="lxr_cross-reference">LXR Cross-Reference</h3>
<div class="level3">

<p>
LXR (LXR Cross-Reference) este un program care permite indexarea și referențierea simbolurilor din codul sursă a unui program prin intermediul unei interfețe web. Interfața web prezintă link-uri către locațiile din fișiere unde un simbol este definit sau utilizat. Site-ul de dezvoltare pentru LXR este <a href="http://sourceforge.net/projects/lxr" class="urlextern" title="http://sourceforge.net/projects/lxr"  rel="nofollow">acesta</a>. Utilitare asemănătoare sunt <a href="http://www.opensolaris.org/os/project/opengrok/" class="urlextern" title="http://www.opensolaris.org/os/project/opengrok/"  rel="nofollow">OpenGrok</a> și <a href="http://en.wikipedia.org/wiki/Gonzui" class="urlextern" title="http://en.wikipedia.org/wiki/Gonzui"  rel="nofollow">Gonzui</a>.
</p>

<p>
Deși LXR a fost inițial destinat surselor kernel-ului de Linux, este folosit și la sursele utilitarelor de la <a href="http://lxr.mozilla.org/" class="urlextern" title="http://lxr.mozilla.org/"  rel="nofollow">Mozilla</a>, <a href="http://apache.wirebrain.de/lxr/" class="urlextern" title="http://apache.wirebrain.de/lxr/"  rel="nofollow">Apache HTTP Server</a> și <a href="http://lxr.linux.no/freebsd/source" class="urlextern" title="http://lxr.linux.no/freebsd/source"  rel="nofollow">FreeBSD</a>.
</p>

<p>
Există o serie de site-uri care folosesc LXR pentru cross-referencing la sursele kernel-ului Linux, site-ul principal fiind <a href="http://lxr.linux.no/linux/" class="urlextern" title="http://lxr.linux.no/linux/"  rel="nofollow">site-ul inițial de dezvoltare</a>.  Care nu mai merge.  Puteți folosi <a href="http://lxr.free-electrons.com/" class="urlextern" title="http://lxr.free-electrons.com/"  rel="nofollow">http://lxr.free-electrons.com/</a>.
</p>

<p>
LXR permite căutarea după un identificator (simbol), după un text liber sau după un nume de fișier. Principala caracteristică și, în același timp, principalul avantaj furnizat este posibilitatea de găsire facilă a declarației oricărui identificator global. Se realizează astfel foarte rapid accesul la declarații de funcții, variabile, macrodefiniții și codul poate fi parcurs facil. De asemenea, faptul că se poate detecta ce zone de cod sunt afectate în momentul modificării unei variabile sau funcții prezintă un real ajutor în faza de dezvoltare și debug.
</p>

</div>
<!-- EDIT9 SECTION "LXR Cross-Reference" [7018-8657] -->
<h3 class="sectionedit10" id="sourceweb">SourceWeb</h3>
<div class="level3">

<p>
<a href="http://rprichard.github.io/sourceweb/" class="urlextern" title="http://rprichard.github.io/sourceweb/"  rel="nofollow">SourceWeb</a> este un indexer pentru cod sursă C și C++. Acesta se folosește de <a href="http://clang.llvm.org/docs/IntroductionToTheClangAST.html" class="urlextern" title="http://clang.llvm.org/docs/IntroductionToTheClangAST.html"  rel="nofollow">framework-ul</a> pus la dispoziție de compilatorul Clang pentru a indexa codul.
</p>

<p>
Principala diferență între cscope și SourceWeb este faptul că SourceWeb este, într-un fel, un compiler pass. SourceWeb nu indexează tot codul ci doar codul care a fost efectiv compilat de compilator. Astfel, dispar probleme precum ambiguități legate de care variantă a unei funcții definite în mai multe locuri e folosită. Dar asta înseamnă și că indexarea durează puțin mai mult deoarece fișierele compilate trebuie să mai treacă încă o dată prin indexer pentru a genera referințele.
</p>

<p>
Exemplu de folosire:
</p>
<pre class="code bash"><span class="kw2">make</span> oldconfig
sw-btrace <span class="kw2">make</span> <span class="re5">-j4</span>
sw-btrace-to-compile-db
sw-clang-indexer <span class="re5">--index-project</span>
sourceweb index</pre>

<p>
sw-btrace este un script care adaugă librăria libsw-btrace.so în LD_PRELOAD. Astfel, librăria este încărcată de fiecare proces pornit de make (în principiu, compilatorul) și înregistrează liniile de comandă cu care au fost pornite procesele și generează un fișier btrace.log. Acest fișier este apoi preluat de sw-btrace-to-compile-db care-l convertește într-un format definit de clang: <a href="http://clang.llvm.org/docs/JSONCompilationDatabase.html" class="urlextern" title="http://clang.llvm.org/docs/JSONCompilationDatabase.html"  rel="nofollow">JSON Compilation Database</a>.
</p>

<p>
Acest JSON Compilation Database rezultat din pașii de mai sus este apoi folosit de indexer care mai trece o dată prin fișierele compilate și generează indexul folosit de <abbr title="Graphical User Interface">GUI</abbr>.
</p>

<p>
Word of advice: nu indexați aceleași surse cu care lucrați, folosiți o copie pentru că SourceWeb nu are momentan capabilitatea de a regenera indexul pentru un singur fișier și va trebui să regenerați tot indexul.
</p>

</div>
<!-- EDIT10 SECTION "SourceWeb" [8658-10496] -->
<h2 class="sectionedit11" id="depanare">Depanare</h2>
<div class="level2">

<p>
Depanarea unui kernel este un proces mult mai dificil decât depanarea unui program, pentru că nu există tocmai suportul sistemului de operare. De aceea, acest lucru se realizează de obicei prin intermediul a două calculatoare conectate pe interfețele seriale.
</p>

</div>
<!-- EDIT11 SECTION "Depanare" [10497-10785] -->
<h3 class="sectionedit12" id="gdb_linux">gdb (Linux)</h3>
<div class="level3">

<p>
O metodă de debug mai simplă pe Linux, dar cu multe lipsuri este depanarea locală folosind <a href="http://www.gnu.org/software/gdb/" class="urlextern" title="http://www.gnu.org/software/gdb/"  rel="nofollow">gdb</a>, imaginea de kernel nearhivată (<code>vmlinux</code>) și <code>/proc/kcore</code> (imaginea în timp real a kernel-ului). Această metodă este folosită de obicei pentru inspecția kernel-ului și detectarea anumitor inconsistențe în timp ce acesta rulează. Metoda este utilă mai ales dacă s-a compilat kernel-ul cu optiunea <code>-g</code> de păstrare a informațiilor de debug. Nu pot fi folosite facilitățile de debug cunoscute cum sunt stabilirea de breakpoint-uri sau modificarea datelor.
</p>

<p>
Imaginea de kernel nearhivată oferă informații despre structurile de date și simbolurile existente:
</p>
<pre class="code bash"><span class="co4">so2@spook$ </span><span class="kw3">cd</span> <span class="sy0">/</span>usr<span class="sy0">/</span>src<span class="sy0">/</span>linux
<span class="co4">so2@spook$ </span><span class="kw2">file</span> vmlinux
vmlinux: ELF <span class="nu0">32</span>-bit LSB executable, Intel <span class="nu0">80386</span>, ...
<span class="co4">so2@spook$ </span><span class="kw2">nm</span> vmlinux <span class="sy0">|</span> <span class="kw2">grep</span> sys_call_table
c02e535c R sys_call_table
<span class="co4">so2@spook$ </span><span class="kw2">cat</span> System.map <span class="sy0">|</span> <span class="kw2">grep</span> sys_call_table
c02e535c R sys_call_table</pre>

<p>
Utilitarul <code>nm</code> este folosit pentru afișarea simbolurilor dintr-un cod obiect sau executabil. În cazul nostru, <code>vmlinux</code> este un fișier ELF. Alternativ se poate folosi <code>System.map</code> pentru afișarea informațiilor despre simbolurile din kernel.
</p>

<p>
Apoi folosim <code>gdb</code> pentru a inspecta simbolurile folosind imaginea nearhivată de kernel. O sesiune simplă de <code>gdb</code> este următoarea:
</p>
<pre class="code bash"><span class="co4">so2@spook$ </span><span class="kw3">cd</span> <span class="sy0">/</span>usr<span class="sy0">/</span>src<span class="sy0">/</span>linux
<span class="co4">so2@spook$ </span><span class="kw2">gdb</span> <span class="re5">--quiet</span> vmlinux
Using host libthread_db library <span class="st0">&quot;/lib/tls/libthread_db.so.1&quot;</span>.
<span class="br0">&#40;</span><span class="kw2">gdb</span><span class="br0">&#41;</span> x<span class="sy0">/</span>x 0xc02e535c
0xc02e535c <span class="sy0">&lt;</span>sys_call_table<span class="sy0">&gt;</span>:    0xc011bc58
<span class="br0">&#40;</span><span class="kw2">gdb</span><span class="br0">&#41;</span> x<span class="sy0">/</span><span class="nu0">16</span> 0xc02e535c
0xc02e535c <span class="sy0">&lt;</span>sys_call_table<span class="sy0">&gt;</span>:    0xc011bc58      0xc011482a      0xc01013d3     0xc014363d
0xc02e536c <span class="sy0">&lt;</span>sys_call_table+<span class="nu0">16</span><span class="sy0">&gt;</span>: 0xc014369f      0xc0142d4e      0xc0142de5     0xc011548b
0xc02e537c <span class="sy0">&lt;</span>sys_call_table+<span class="nu0">32</span><span class="sy0">&gt;</span>: 0xc0142d7d      0xc01507a1      0xc015042c     0xc0101431
0xc02e538c <span class="sy0">&lt;</span>sys_call_table+<span class="nu0">48</span><span class="sy0">&gt;</span>: 0xc014249e      0xc0115c6c      0xc014fee7     0xc0142725
<span class="br0">&#40;</span><span class="kw2">gdb</span><span class="br0">&#41;</span> x<span class="sy0">/</span>x sys_call_table
0xc011bc58 <span class="sy0">&lt;</span>sys_restart_syscall<span class="sy0">&gt;</span>:       0xffe000ba
<span class="br0">&#40;</span><span class="kw2">gdb</span><span class="br0">&#41;</span> x<span class="sy0">/</span>x <span class="sy0">&amp;</span>sys_call_table
0xc02e535c <span class="sy0">&lt;</span>sys_call_table<span class="sy0">&gt;</span>:    0xc011bc58
<span class="br0">&#40;</span><span class="kw2">gdb</span><span class="br0">&#41;</span> x<span class="sy0">/</span><span class="nu0">16</span> <span class="sy0">&amp;</span>sys_call_table
0xc02e535c <span class="sy0">&lt;</span>sys_call_table<span class="sy0">&gt;</span>:    0xc011bc58      0xc011482a      0xc01013d3     0xc014363d
0xc02e536c <span class="sy0">&lt;</span>sys_call_table+<span class="nu0">16</span><span class="sy0">&gt;</span>: 0xc014369f      0xc0142d4e      0xc0142de5     0xc011548b
0xc02e537c <span class="sy0">&lt;</span>sys_call_table+<span class="nu0">32</span><span class="sy0">&gt;</span>: 0xc0142d7d      0xc01507a1      0xc015042c     0xc0101431
0xc02e538c <span class="sy0">&lt;</span>sys_call_table+<span class="nu0">48</span><span class="sy0">&gt;</span>: 0xc014249e      0xc0115c6c      0xc014fee7     0xc0142725
<span class="br0">&#40;</span><span class="kw2">gdb</span><span class="br0">&#41;</span> x<span class="sy0">/</span>x sys_fork
0xc01013d3 <span class="sy0">&lt;</span>sys_fork<span class="sy0">&gt;</span>:  0x3824548b
<span class="br0">&#40;</span><span class="kw2">gdb</span><span class="br0">&#41;</span> disass sys_fork
Dump of assembler code <span class="kw1">for</span> <span class="kw1">function</span> sys_fork:
0xc01013d3 <span class="sy0">&lt;</span>sys_fork+<span class="nu0">0</span><span class="sy0">&gt;</span>:        mov    0x38<span class="br0">&#40;</span><span class="sy0">%</span>esp<span class="br0">&#41;</span>,<span class="sy0">%</span>edx
0xc01013d7 <span class="sy0">&lt;</span>sys_fork+<span class="nu0">4</span><span class="sy0">&gt;</span>:        mov    <span class="re4">$0</span>x11,<span class="sy0">%</span>eax
0xc01013dc <span class="sy0">&lt;</span>sys_fork+<span class="nu0">9</span><span class="sy0">&gt;</span>:        push   <span class="re4">$0</span>x0
0xc01013de <span class="sy0">&lt;</span>sys_fork+<span class="nu0">11</span><span class="sy0">&gt;</span>:       push   <span class="re4">$0</span>x0
0xc01013e0 <span class="sy0">&lt;</span>sys_fork+<span class="nu0">13</span><span class="sy0">&gt;</span>:       push   <span class="re4">$0</span>x0
0xc01013e2 <span class="sy0">&lt;</span>sys_fork+<span class="nu0">15</span><span class="sy0">&gt;</span>:       lea    0x10<span class="br0">&#40;</span><span class="sy0">%</span>esp<span class="br0">&#41;</span>,<span class="sy0">%</span>ecx
0xc01013e6 <span class="sy0">&lt;</span>sys_fork+<span class="nu0">19</span><span class="sy0">&gt;</span>:       call   0xc0111aab <span class="sy0">&lt;</span>do_fork<span class="sy0">&gt;</span>
0xc01013eb <span class="sy0">&lt;</span>sys_fork+<span class="nu0">24</span><span class="sy0">&gt;</span>:       add    <span class="re4">$0</span>xc,<span class="sy0">%</span>esp
0xc01013ee <span class="sy0">&lt;</span>sys_fork+<span class="nu0">27</span><span class="sy0">&gt;</span>:       ret
End of assembler dump.</pre>

<p>
Se observă că s-a folosit ca parametru pentru <code>gdb</code> imaginea de kernel nearhivată care rezidă în rădăcina surselor după compilare.
</p>

<p>
Câteva comenzi utilizate pentru debugging cu gdb sunt:
</p>
<ul>
<li class="level1"><div class="li"> <code>x</code> - Este folosită pentru afișarea conținutului zonei de memorie a cărei adresă este primită ca parametru (această adresă poate fi valoarea unei adrese fizice, un simbol sau adresa unui simbol). Poate primi ca parametri (precedați de <code>/</code>): formatul în care afișează datele (<code>x</code> pentru hexazecimal, <code>d</code> pentru zecimal, etc.), câte unități de memorie se afișează și dimensiunea unei unități de memorie. </div>
</li>
<li class="level1"><div class="li"> <code>disassemble</code> - Este folosită pentru dezasamblarea unei funcții.</div>
</li>
<li class="level1"><div class="li"> <code>p</code> - Este folosită pentru evaluarea și afișarea valorii unei expresii. Se poate specifica formatul în care se afișează datele (<code>/x</code> pentru hexazecimal, <code>/d</code> pentru zecimal, etc.).</div>
</li>
</ul>

<p>
Analiza imaginii de kernel este o analiză statică. Dacă dorim o analiză dinamică (o analiză a kernel-ului așa cum rulează el) vom folosi <code>/proc/kcore</code>; acesta este o imagine dinamică (în memorie) a kernel-ului.
</p>
<pre class="code bash"><span class="co4">so2@spook$ </span><span class="kw2">gdb</span> <span class="sy0">/</span>usr<span class="sy0">/</span>src<span class="sy0">/</span>linux<span class="sy0">/</span>vmlinux <span class="sy0">/</span>proc<span class="sy0">/</span>kcore
Core was generated by <span class="sy0">`</span><span class="re2">root</span>=<span class="sy0">/</span>dev<span class="sy0">/</span>hda3 ro<span class="st_h">'.
#0  0x00000000 in ?? ()
(gdb) p sys_call_table
$1 = -1072579496
(gdb) p /x sys_call_table
$2 = 0xc011bc58
(gdb) p /x &amp;sys_call_table
$3 = 0xc02e535c
(gdb) x/16 &amp;sys_call_table
0xc02e535c &lt;sys_call_table&gt;:    0xc011bc58      0xc011482a      0xc01013d3     0xc014363d
0xc02e536c &lt;sys_call_table+16&gt;: 0xc014369f      0xc0142d4e      0xc0142de5     0xc011548b
0xc02e537c &lt;sys_call_table+32&gt;: 0xc0142d7d      0xc01507a1      0xc015042c     0xc0101431
0xc02e538c &lt;sys_call_table+48&gt;: 0xc014249e      0xc0115c6c      0xc014fee7     0xc0142725</span></pre>

<p>
Folosirea imaginii dinamice a kernel-ului este utilă pentru detectarea de <a href="http://en.wikipedia.org/wiki/Rootkit" class="urlextern" title="http://en.wikipedia.org/wiki/Rootkit"  rel="nofollow">rootkit-uri</a>.
</p>
<ul>
<li class="level1"><div class="li"> <a href="http://linuxdriver.co.il/ldd3/linuxdrive3-CHP-4-SECT-6.html" class="urlextern" title="http://linuxdriver.co.il/ldd3/linuxdrive3-CHP-4-SECT-6.html"  rel="nofollow">Linux Device Drivers 3rd Edition - Debuggers and Related Tools</a></div>
</li>
<li class="level1"><div class="li"> <a href="http://www.securityfocus.com/infocus/1811" class="urlextern" title="http://www.securityfocus.com/infocus/1811"  rel="nofollow">Detecting Rootkits and Kernel-level Compromises in Linux</a></div>
</li>
<li class="level1"><div class="li"> <a href="http://user-mode-linux.sf.net/" class="urlextern" title="http://user-mode-linux.sf.net/"  rel="nofollow">User-Mode Linux</a></div>
</li>
</ul>

</div>
<!-- EDIT12 SECTION "gdb (Linux)" [10786-16098] -->
<h3 class="sectionedit13" id="obtinerea_unui_stack_trace">Obținerea unui stack trace</h3>
<div class="level3">

<p>
Uneori, veți dori informații despre calea de execuție prin care se ajunge într-o anumită situație.  Puteți determina această informație folosind <code>cscope</code> sau LXR, dar unele funcții sunt apelate din foarte multe căi de execuție, ceea ce face dificil raționamentul.
</p>

<p>
În asemenea situații este utilă obținerea unui stack trace, lucru simplu de făcut folosind funcția <code>dump_stack()</code>.
</p>

</div>
<!-- EDIT13 SECTION "Obținerea unui stack trace" [16099-16541] -->
<h2 class="sectionedit14" id="documentatie">Documentație</h2>
<div class="level2">

<p>
Dezvoltarea kernel-ului are un grad sporit de dificultate raportat la programarea din user space. <abbr title="Application Programming Interface">API</abbr>-ul diferit, complexitatea subsistemelor kernel-ului necesită o etapă de pregătire suplimentară. Documentația asociată este destul de eterogenă, fiind nevoie de inspectarea mai multor surse pentru a avea o înțelegere completă a unui aspect.
</p>

<p>
Principalele avantaje ale kernel-ului Linux sunt accesul la surse și sistemul deschis de dezvoltare. Drept urmare, Internet-ul oferă un număr mult mai mare de resurse de documentare a kernel-ului.
</p>

<p>
Câteva link-uri utile sunt prezentate mai jos:
</p>
<ul>
<li class="level1"><div class="li"> <a href="http://kernelnewbies.org" class="urlextern" title="http://kernelnewbies.org"  rel="nofollow">KernelNewbies</a></div>
</li>
<li class="level1"><div class="li"> <a href="http://kernelnewbies.org/KernelHacking" class="urlextern" title="http://kernelnewbies.org/KernelHacking"  rel="nofollow">KernelNewbies - Kernel Hacking</a></div>
</li>
<li class="level1"><div class="li"> <a href="http://www.tldp.org/HOWTO/KernelAnalysis-HOWTO.html" class="urlextern" title="http://www.tldp.org/HOWTO/KernelAnalysis-HOWTO.html"  rel="nofollow">Kernel Analysis - HOWTO</a></div>
</li>
<li class="level1"><div class="li"> <a href="http://web.archive.org/web/20090228191439/http://www.linuxhq.com/lkprogram.html" class="urlextern" title="http://web.archive.org/web/20090228191439/http://www.linuxhq.com/lkprogram.html"  rel="nofollow">Linux Kernel Programming</a></div>
</li>
<li class="level1"><div class="li"> <a href="http://en.wikibooks.org/wiki/Linux_kernel" class="urlextern" title="http://en.wikibooks.org/wiki/Linux_kernel"  rel="nofollow">Linux kernel - Wikibooks</a></div>
</li>
</ul>

<p>
Link-urile nu sunt exhaustive. Folosirea <a href="http://www.google.com" class="urlextern" title="http://www.google.com"  rel="nofollow">Internet-ului</a> și a <a href="http://lxr.free-electrons.com/" class="urlextern" title="http://lxr.free-electrons.com/"  rel="nofollow">surselor</a> este esențială.
</p>

</div>
<!-- EDIT14 SECTION "Documentație" [16542-17721] -->
<h2 class="sectionedit15" id="exercitii">Exerciții</h2>
<div class="level2">

</div>
<!-- EDIT15 SECTION "Exerciții" [17722-17745] -->
<h3 class="sectionedit16" id="precizari">Precizări</h3>
<div class="level3">

<p>
<p><div class="noteclassic">
</p>
<ul>
<li class="level1"><div class="li"> În general, pașii pentru dezvoltarea unui modul de kernel sunt următorii:</div>
<ul>
<li class="level2"><div class="li"> editarea codului sursă al modulului (pe mașina fizică);</div>
</li>
<li class="level2"><div class="li"> compilarea modulului (pe mașina fizică);</div>
</li>
<li class="level2"><div class="li"> regenerarea imaginii minimale pentru mașina virtuală.  Această imagine include kernel-ul, modulul vostru, busybox și eventual programe de test.  Modulul vostru și programele de test trebuie puse în directorul <code>/home/student/so2/qemu-vm/fsimg/root/</code>.</div>
</li>
<li class="level2"><div class="li"> pornirea mașinii virtuale folosind qemu.  Acest pas și cel precedent se execută automat lansând <code>make</code>.</div>
</li>
<li class="level2"><div class="li"> rularea testelor în mașina virtuală.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> În cazul folosirii cscope, folosiți unul dintre directoarele <code>/usr/src/linux-so2</code> sau <code>/home/student/so2/linux-3.13</code> (oricare, sunt symlink-uri unul la celălalt).  Dacă nu există deja un fișier <code>cscope.out</code>, îl puteți genera folosind <code>make ARCH=x86 cscope</code>.</div>
</li>
</ul>

<p>

</div></p>
</p>

<p>
<p><div class="noteimportant">
Înainte de a rezolva un subpunct, citiți cu <strong>atenție</strong> toate bullet-urile acestuia.

</div></p>
</p>

</div>
<!-- EDIT16 SECTION "Precizări" [17746-18795] -->
<h3 class="sectionedit17" id="boot-area_masinii_virtuale">1. Boot-area mașinii virtuale</h3>
<div class="level3">

<p>
Pe scurt, infrastructura mașinii virtuale:
</p>
<ul>
<li class="level1"><div class="li"> <code>/home/student/so2/qemu-vm</code> - script-uri și fișiere auxiliare pentru generarea și rularea mașinii virtuale qemu;</div>
</li>
<li class="level1"><div class="li"> <code>/home/student/so2/linux-3.13</code> - sursele kernel-ului Linux, de care aveți nevoie pentru a compila module.  Directorul include și fișierul <code>cscope.out</code>, pentru inspectarea facilă a surselor.</div>
</li>
<li class="level1"><div class="li"> <code>/usr/src/linux-so2</code>, symlink la <code>/home/student/so2/linux-3.13</code>.</div>
</li>
</ul>

<p>
<p><div class="noteclassic">
Când reproduceți setup-ul pe mașinile voastre, puteți dezarhiva în alte directoare.  Doar <code>/usr/src/linux-so2</code> trebuie să fie symlink către tree-ul cu sursele Linux.

</div></p>
</p>

<p>
Pentru a rula mașina virtuală este suficient să intrați în directorul <code>so2/qemu-vm/</code> și să rulați comanda make:
</p>
<pre class="code">student@eg106:~$ cd so2/qemu-vm/
student@eg106:~/so2/qemu-vm$ make</pre>

</div>
<!-- EDIT17 SECTION "1. Boot-area mașinii virtuale" [18796-19675] -->
<h3 class="sectionedit18" id="adaugarea_si_utilizarea_unui_disc_virtual">2. Adăugarea și utilizarea unui disc virtual</h3>
<div class="level3">

<p>
<p><div class="noteclassic">
Dacă nu aveți fișierul <code>mydisk.img</code>, îl puteți descărca de la adresa <a href="http://elf.cs.pub.ro/so2/res/mydisk.img" class="urlextern" title="http://elf.cs.pub.ro/so2/res/mydisk.img"  rel="nofollow">http://elf.cs.pub.ro/so2/res/mydisk.img</a>.

</div></p>
</p>

<p>
În subdirectorul <code>qemu-vm/</code> aveți un nou disc de mașină virtuală în cadrul fișierului <code>mydisk.img</code>. Vrem să adăugăm discul la mașina virtuală și să îl folosim în cadrul mașinii virtuale. 
</p>

<p>
Editați fișierul <code>Makefile</code> pentru a adăuga, la target-ul <code>run</code>, parametrul <code>-hdd mydisk.img</code>.  Rulați <code>make</code> pentru a boota mașina virtuală.
</p>

<p>
În cadrul mașinii virtuale configurați accesul la disc.
</p>

<p>
<p><div class="notetip">
Va trebui să creați manual intrarea aferentă noului disc în <code>/dev</code>.  În mod normal, udev face acest lucru automat, dar pe mașina virtuală nu rulează udev.
</p>

<p>
Pentru aceasta inspectați fișierul <code>/proc/partitions</code> și identificați major-ul și minor-ul discului <code>sdc</code>.  Nu este un typo, discul se va numi sdc, chiar dacă lui qemu i-ați transmis parametrul <code>-hdd</code>.
</p>

<p>
Având major-ul și minor-ul, utilizați <code>mknod</code> pentru a crea fișierul special de tip <strong>block</strong> <code>/dev/sdc</code>. Adică trebuie rulată comanda
</p>
<pre class="code">mknod /dev/sdc b 8 32</pre>

<p>

</div></p>
</p>

<p>
Creați directorul <code>/test</code> și încercați să montați noul disc:
</p>
<pre class="code">mkdir /test
mount /dev/sdc /test</pre>

<p>
Motivul pentru care nu putem monta discul este pentru că nu avem suport în kernel pentru sistemul de fișiere cu care este formatat discul <code>mydisk.img</code>. Va trebui să identificați sistemul de fișiere aferent discului <code>mydisk.img</code> și să compilați suport în kernel pentru acel sistem de fișiere.
</p>

<p>
Închideți mașina virtuală (închideți fereastra qemu, nu e nevoie să folosiți altă comandă).  Folosiți comanda <code>file</code> pe mașina fizică pentru a afla cu ce sistem de fișiere este formatat fișierul <code>mydisk.img</code>. Veți identifica sistemul de fișiere <code>btrfs</code>.
</p>

<p>
Va trebui să activați suportul de <code>btrfs</code> în kernel și să îl recompilați.
</p>

<p>
<p><div class="notetip">
Intrați în directorul <code>linux-3.13</code>.  Executați <code>make menuconfig</code> și intrați în secțiunea <em>File systems</em>.  Activați opțiunea <em>Btrfs file system support</em>. Va trebui să folosiți opțiune de tip <code>builtin</code> (<strong>nu</strong> modul) adică trebuie să apară <code>&lt;*&gt;</code> în dreptul opțiunii (<strong>nu</strong> <code>&lt;M&gt;</code>).
</p>

<p>
Salvați configurația realizată. Folosiți fișierul de configurare implicit <code>.config</code>.
</p>

<p>
Recompilați kernel-ul utilizând <code>make</code>.  Pentru a aștepta mai puțin, puteți utiliza opțiunea <code>-j</code> pentru a folosi mai multe job-uri în paralel.  În general se recomandă un număr de procese cu 1 mai mare decât numărul procesoarelor: <code>make -j5</code>.

</div></p>
</p>

<p>
După ce se încheie recompilarea, reveniți în directorul <code>qemu-vm</code> și lansați <code>make</code>.  Nu este nevoie să copiați nimic, pentru că fișierul <code>bzImage</code> este symlink către imaginea kernel-ului pe care tocmai l-ați recompilat.
</p>

<p>
Repetați operațiunile de <code>mknod</code>, <code>mkdir</code> și <code>mount</code>.  Având suport pentru sistemul de fișiere btrfs, acum mount se va termina cu succes.
</p>

<p>
<p><div class="noteclassic">
În elaborarea temelor nu este necesar să recompilați kernel-ul, veți folosi doar module.  Totuși, este important să fiți familiari cu configurarea și recompilarea unui kernel.
</p>

<p>
Dacă totuși aveți de gând să recompilați kernel-ul, faceți un back-up fișierului <code>bzImage</code> (urmați link-ul din <code>qemu-vm</code> pentru calea completă).  Astfel veți putea reveni la setup-ul inițial pentru a avea un mediu identic cu vmchecker.

</div></p>
</p>

</div>
<!-- EDIT18 SECTION "2. Adăugarea și utilizarea unui disc virtual" [19676-23194] -->
<h3 class="sectionedit19" id="gdb_si_qemu">3. GDB și qemu</h3>
<div class="level3">

<p>
Vă puteți atașa cu <code>gdb</code> la un sistem qemu în rulare, folosind comanda
</p>
<pre class="code bash"><span class="kw2">make</span> <span class="kw2">gdb</span></pre>

<p>
Am folosit comanda <code>qemu</code> cu parametrul <code>-s</code>, ceea ce înseamnă că ascultă pe portul 1234 de la GDB.  Putem face debugging folosind un <em>target remote</em> pentru GDB.  Makefile-ul existent are grijă de detalii.
</p>

<p>
Când atașați un debugger unui proces, procesul este suspendat.  Puteți pune breakpoints și inspecta starea curentă a procesului.
</p>

<p>
Atașați-vă la mașina virtuală <code>qemu</code> (folosind comanda <code>make gdb</code>) și puneți un breakpoint în funcția <code>sys_access</code> folosind în consola GDB comanda
</p>
<pre class="code">break sys_access</pre>

<p>
În acest moment mașina virtuală este suspendată. Pentru a continua execuția ei (până la eventualul apel al funcției <code>sys_access</code>) folosiți, în consola GDB comanda
</p>
<pre class="code">continue</pre>

<p>
În acest moment mașina virtuală este activă și are consola utilizabilă. Pentru a genera un apel de <code>sys_access</code>, lansați o comandă <code>ls</code>. Observați că mașina virtuală a fost din nou suspendată de GDB și a apărut mesajul aferent de apel al <code>sys_access</code> în cadrul GDB.
</p>

<p>
Urmăriți execuția codului, folosind <code>step instruction</code>, <code>continue</code> sau <code>next instruction</code>.  Probabil nu o să înțelegeți tot ce se întâmplă, utilizați comenzi precum <code>list</code> și <code>backtrace</code> pentru a urmări logic execuția.
</p>

<p>
<p><div class="notetip">
La prompt-ul <code>gdb</code>, puteți apăsa <code>ENTER</code> (fără altceva) pentru a rula ultima comandă încă o dată.

</div></p>
</p>

</div>
<!-- EDIT19 SECTION "3. GDB și qemu" [23195-24909] -->
<h3 class="sectionedit20" id="gdb_spelunking">4. GDB spelunking</h3>
<div class="level3">

<p>
Folosiți <code>GDB</code> pentru a obține următoarele informații sursa funcției care creează thread-uri de kernel (<code>kernel_thread</code>).
</p>

<p>
<p><div class="notetip">
Puteți folosi GDB pentru analiza statică a imaginii de kernel folosind, în directorul cu sursele kernel-ului, o comandă de forma
</p>
<pre class="code">gdb vmlinux</pre>

<p>
Parcurgeți secțiunea <a href="lab01.html#gdb_linux" title="so2:laboratoare:lab01 ↵" class="wikilink1">gdb (Linux)</a> din laborator.

</div></p>
</p>

<p>
Folosiți <code>GDB</code> pentru a afla adresa variabilei <code>jiffies</code> în memorie și conținutul acesteia. Variabila <code>jiffies</code> reține numărul de tick-uri (bătăi de ceas) de la pornirea sistemului,.
</p>

<p>
<p><div class="notetip">
Pentru a urmări valoarea variabilei <code>jiffies</code> folosiți analiza dinamică în GDB folosind comanda
</p>
<pre class="code">make gdb</pre>

<p>
 la fel ca la <a href="lab01.html#gdb_si_qemu" title="so2:laboratoare:lab01 ↵" class="wikilink1">exercițiul anterior</a>.
</p>

<p>
Parcurgeți secțiunea <a href="lab01.html#gdb_linux" title="so2:laboratoare:lab01 ↵" class="wikilink1">gdb (Linux)</a> din laborator.

</div></p>
</p>

</div>
<!-- EDIT20 SECTION "4. GDB spelunking" [24910-25780] -->
<h3 class="sectionedit21" id="cscope_spelunking">5. cscope spelunking</h3>
<div class="level3">

<p>
Folosiți cscope sau LXR în directorul <code>/usr/src/linux-so2/</code> pentru a determina locul de definire al unor structuri sau funcții.  
</p>

<p>
Fișierele index cscope sunt deja generate. Folosiți direct Vim și comenzile cscope pentru parcurgerea codului sursă.
</p>

<p>
Determinați fișierul în care sunt definite următoarele tipuri de date:
</p>
<ul>
<li class="level1"><div class="li"> <code>struct task_struct</code></div>
</li>
<li class="level1"><div class="li"> <code>struct semaphore</code></div>
</li>
<li class="level1"><div class="li"> <code>struct list_head</code></div>
</li>
<li class="level1"><div class="li"> <code>spinlock_t</code></div>
</li>
<li class="level1"><div class="li"> <code>struct file_system_type</code></div>
</li>
</ul>

<p>
<p><div class="notetip">
Pentru o structură se caută doar numele ei. Spre exemplu, în cazul <code>struct task_struct</code> se caută șirul <code>task_struct</code>.
</p>

<p>
De obicei veți obține mai multe match-uri caz în care:
</p>
<ol>
<li class="level1"><div class="li"> Listați toate match-urile folosind, în Vim, comanda <code>:copen</code>. Vă apare o fereastră secundară cu toate match-urile.</div>
</li>
<li class="level1"><div class="li"> Căutați match-ul potrivit (în care este definită structura) căutând după acoladă deschisă (<code>{</code>), un caracter sigur pe linia de definire a structurii. Pentru căutarea acoladei deschise folosiți, în Vim, construcția <code>/{</code>.</div>
</li>
<li class="level1"><div class="li"> Pe linia aferentă apăsați <code>Enter</code> ca să vă ajungă editorul în codul sursă unde e definită varibila.</div>
</li>
<li class="level1"><div class="li"> Închideți fereastra secundară folosind coamanda <code>:cclose</code>.</div>
</li>
</ol>

<p>

</div></p>
</p>

<p>
Determinați fișierul în care sunt declarate următoarele variabile globale la nivelul nucleului:
</p>
<ul>
<li class="level1"><div class="li"> <code>sys_call_table</code></div>
</li>
<li class="level1"><div class="li"> <code>file_systems</code></div>
</li>
<li class="level1"><div class="li"> <code>current</code></div>
</li>
<li class="level1"><div class="li"> <code>chrdevs</code></div>
</li>
</ul>

<p>
<p><div class="notetip">
Pentru aceasta folosiți în Vim o comandă de forma <code>:cs f g &lt;symbol&gt;</code> (unde construcția <code>&lt;symbol&gt;</code> reprezintă numele simbolului căutat).

</div></p>
</p>

<p>
Determinați fișierul în care sunt declarate următoarele funcții:
</p>
<ul>
<li class="level1"><div class="li"> <code>copy_from_user</code></div>
</li>
<li class="level1"><div class="li"> <code>vmalloc</code></div>
</li>
<li class="level1"><div class="li"> <code>schedule_timeout</code></div>
</li>
<li class="level1"><div class="li"> <code>add_timer</code></div>
</li>
</ul>

<p>
<p><div class="notetip">
Pentru aceasta folosiți în Vim o comandă de forma <code>:cs f g &lt;symbol&gt;</code> (unde construcția <code>&lt;symbol&gt;</code> reprezintă numele simbolului căutat).

</div></p>
</p>

<p>
Parcurgeți secvența de structuri:
</p>
<ol>
<li class="level1"><div class="li"> <code>struct task_struct</code></div>
</li>
<li class="level1"><div class="li"> <code>struct mm_struct</code></div>
</li>
<li class="level1"><div class="li"> <code>struct vm_area_struct</code></div>
</li>
<li class="level1"><div class="li"> <code>struct vm_operations_struct</code></div>
</li>
</ol>

<p>
Adică parcurgeți din aproape în aproape structurile: accesați o structură și apoi găsiți câmpuri cu tipul de date al următoarei structuri, accesați-o pe aceasta etc. Rețineți în ce fișiere sunt definite; o să vă fie utile la alte laboratoare.
</p>

<p>
<p><div class="notetip">
Pentru a căuta un simbol în Vim (cu suport <code>cscope</code>) atunci când sunteți plasați cu cursorul pe acesta, folosiți construcția <code>Ctrl+]</code>.
</p>

<p>
Pentru a reveni în match-ul anterior (înante de căutare/salt) folosiți construcția <code>Ctrl+o</code>. Pentru a avansa în căutare (pentru a reveni la match-urile de dinainte de <code>Ctrl+o</code>) folosiți construcția <code>Ctrl+i</code>.

</div></p>
</p>

<p>
La fel ca mai sus, parcurgeți secvența de apeluri de funcții:
</p>
<ol>
<li class="level1"><div class="li"> <code>bio_alloc</code></div>
</li>
<li class="level1"><div class="li"> <code>bio_alloc_bioset</code></div>
</li>
<li class="level1"><div class="li"> <code>bvec_alloc</code></div>
</li>
<li class="level1"><div class="li"> <code>kmem_cache_alloc</code></div>
</li>
<li class="level1"><div class="li"> <code>slab_alloc</code></div>
</li>
</ol>

<p>
<p><div class="notetip">
Citiți secțiunile <a href="lab01.html#cscope" title="so2:laboratoare:lab01 ↵" class="wikilink1">cscope</a> sau <a href="lab01.html#lxr_cross-reference" title="so2:laboratoare:lab01 ↵" class="wikilink1">LXR Cross-Reference</a> din laborator.

</div></p>
</p>

</div>
<!-- EDIT21 SECTION "5. cscope spelunking" [25781-28791] -->
<h3 class="sectionedit22" id="solutii">Soluții</h3>
<div class="level3">
<ul>
<li class="level1"><div class="li"> <a href="http://elf.cs.pub.ro/so2/res/laboratoare/lab01-sol.zip" class="urlextern" title="http://elf.cs.pub.ro/so2/res/laboratoare/lab01-sol.zip"  rel="nofollow">Soluții exerciții laborator 1</a></div>
</li>
</ul>

</div>
<!-- EDIT22 SECTION "Soluții" [28792-] --></div>
</body>
</html>
