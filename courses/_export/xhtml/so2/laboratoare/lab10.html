    
    

<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
  <meta charset="utf-8" />
  <title>so2:laboratoare:lab10</title>
<meta name="generator" content="DokuWiki"/>
<meta name="robots" content="index,follow"/>
<meta name="date" content="2016-06-04T18:24:31+0300"/>
<meta name="keywords" content="so2,laboratoare,lab10"/>
<link rel="search" type="application/opensearchdescription+xml" href="../../../../lib/exe/opensearch.php" title="CS Open CourseWare"/>
<link rel="start" href="../../../../../courses.1.html"/>
<link rel="alternate" type="application/rss+xml" title="Recent Changes" href="../../../../feed.php"/>
<link rel="alternate" type="application/rss+xml" title="Current Namespace" href="../../../../feed.php%3Fmode=list&amp;ns=so2:laboratoare"/>
<link rel="alternate" type="text/html" title="Plain HTML" href="lab10.html"/>
<link rel="canonical" href="../../../../../so2/laboratoare/lab10.html"/>
<link rel="stylesheet" type="text/css" href="../../../../lib/exe/css.php%3Ft=arctic&amp;tseed=1476798676.css"/>
<script type="text/javascript">/*<![CDATA[*/var NS='so2:laboratoare';var JSINFO = {"id":"so2:laboratoare:lab10","namespace":"so2:laboratoare","isadmin":0,"isauth":0};
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="../../../../lib/exe/js.php%3Ftseed=1476798676"></script>
<script type="text/x-mathjax-config">/*<![CDATA[*/MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ["$","$"], ["\\(","\\)"] ],
        displayMath: [ ["$$","$$"], ["\\[","\\]"] ],
        processEscapes: true
    }
});
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
<script type="text/javascript">/*<![CDATA[*/
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
		  
/*!]]>*/</script>
<script type="text/javascript">/*<![CDATA[*/
var pageTracker = _gat._getTracker("UA-38383934-1");
pageTracker._initData();
pageTracker._trackPageview();
		  
/*!]]>*/</script>
</head>
<body>
<div class="dokuwiki export">
<!-- TOC START -->
<div id="dw__toc">
<h3 class="toggle">Table of Contents</h3>
<div>

<ul class="toc">
<li class="level1"><div class="li"><a href="lab10.html#laborator_10_-_networking">Laborator 10 - Networking</a></div>
<ul class="toc">
<li class="level2"><div class="li"><a href="lab10.html#obiectivele_laboratorului">Obiectivele laboratorului</a></div></li>
<li class="level2"><div class="li"><a href="lab10.html#cuvinte_cheie">Cuvinte cheie</a></div></li>
<li class="level2"><div class="li"><a href="lab10.html#materiale_ajutatoare">Materiale ajutătoare</a></div></li>
<li class="level2"><div class="li"><a href="lab10.html#notiuni_teoretice">Noțiuni teoretice</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="lab10.html#networking_in_user-space">Networking în user-space</a></div></li>
</ul>
</li>
<li class="level2"><div class="li"><a href="lab10.html#linux_networking">Linux networking</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="lab10.html#structura_socket">Structura socket</a></div>
<ul class="toc">
<li class="level4"><div class="li"><a href="lab10.html#operatii_asupra_structurii_socket">Operații asupra structurii socket</a></div></li>
<li class="level4"><div class="li"><a href="lab10.html#campuri_ale_structurii_socket">Câmpuri ale structurii socket</a></div></li>
<li class="level4"><div class="li"><a href="lab10.html#structura_proto_ops">Structura proto_ops</a></div></li>
</ul>
</li>
<li class="level3"><div class="li"><a href="lab10.html#structura_sock">Structura sock</a></div></li>
<li class="level3"><div class="li"><a href="lab10.html#structura_sk_buff">Structura sk_buff</a></div></li>
<li class="level3"><div class="li"><a href="lab10.html#conversii">Conversii</a></div></li>
<li class="level3"><div class="li"><a href="lab10.html#netfilter">netfilter</a></div></li>
</ul>
</li>
<li class="level2"><div class="li"><a href="lab10.html#netcat">netcat</a></div></li>
<li class="level2"><div class="li"><a href="lab10.html#resurse_utile">Resurse utile</a></div></li>
</ul></li>
</ul>
</div>
</div>
<!-- TOC END -->

<h1 class="sectionedit1" id="laborator_10_-_networking">Laborator 10 - Networking</h1>
<div class="level1">

</div>
<!-- EDIT1 SECTION "Laborator 10 - Networking" [1-41] -->
<h2 class="sectionedit2" id="obiectivele_laboratorului">Obiectivele laboratorului</h2>
<div class="level2">
<ul>
<li class="level1"><div class="li"> Înțelegerea arhitecturii subsistemului de networking la nivelul nucleului Linux</div>
</li>
<li class="level1"><div class="li"> Deprinderea unor abilități practice de gestiune a pachetelor IP în cadrul unui filtru de pachete/firewall</div>
</li>
<li class="level1"><div class="li"> Familiarizarea cu modul de utilizare al sockeților la nivelul nucleului Linux</div>
</li>
</ul>

</div>
<!-- EDIT2 SECTION "Obiectivele laboratorului" [42-362] -->
<h2 class="sectionedit3" id="cuvinte_cheie">Cuvinte cheie</h2>
<div class="level2">
<ul>
<li class="level1"><div class="li">stiva TCP/IP</div>
</li>
<li class="level1"><div class="li">protocol</div>
</li>
<li class="level1"><div class="li">adresă IP</div>
</li>
<li class="level1"><div class="li">port</div>
</li>
<li class="level1"><div class="li">socket, BSD socket, INET socket</div>
</li>
<li class="level1"><div class="li">PF_INET, AF_INET</div>
</li>
<li class="level1"><div class="li">SOCK_STREAM, SOCK_DGRAM</div>
</li>
<li class="level1"><div class="li">IPPROTO_TCP, IPPROTO_UDP</div>
</li>
<li class="level1"><div class="li">interfața loopback</div>
</li>
<li class="level1"><div class="li">bind, connect, listen, accept</div>
</li>
<li class="level1"><div class="li">send, sendto, recv, recvfrom</div>
</li>
<li class="level1"><div class="li">struct socket, struct sock, struct sk_buff</div>
</li>
<li class="level1"><div class="li">htons, htonl, ntohs, ntohl</div>
</li>
</ul>

</div>
<!-- EDIT3 SECTION "Cuvinte cheie" [363-714] -->
<h2 class="sectionedit4" id="materiale_ajutatoare">Materiale ajutătoare</h2>
<div class="level2">
<ul>
<li class="level1"><div class="li"><a href="http://elf.cs.pub.ro/so2/res/laboratoare/lab10-slides.pdf" class="urlextern" title="http://elf.cs.pub.ro/so2/res/laboratoare/lab10-slides.pdf"  rel="nofollow">Slide-uri de suport pentru laborator</a></div>
</li>
<li class="level1"><div class="li"><a href="http://elf.cs.pub.ro/so2/res/extra/so2_reference.pdf" class="urlextern" title="http://elf.cs.pub.ro/so2/res/extra/so2_reference.pdf"  rel="nofollow">SO2 Reference Card</a></div>
</li>
</ul>

</div>
<!-- EDIT4 SECTION "Materiale ajutătoare" [715-931] -->
<h2 class="sectionedit5" id="notiuni_teoretice">Noțiuni teoretice</h2>
<div class="level2">

<p>
Dezvoltarea Internet-ului a dus la creșterea exponențială a aplicațiilor de rețea și, drept  consecință, la creșterea cerințelor de viteza și productivitate a subsistemului de rețea (networking) al unui sistem de operare. Subsistemul de networking nu este o componentă esențială a nucleului unui sistem de operare (kernel-ul de Linux poate fi compilat fără suport de rețea). Este, însă, destul de puțin probabil pentru un sistem de calcul (sau chiar un dispozitiv embedded) să conțină un sistem de operare fără suport de rețea, datorită nevoii de conectivitate. Atât sistemele Linux (Unix), cât și Windows folosesc <a href="http://en.wikipedia.org/wiki/TCP/IP_model" class="urlextern" title="http://en.wikipedia.org/wiki/TCP/IP_model"  rel="nofollow">stiva TCP/IP</a>. Nucleul acestora va conține implementate protocoalele până la nivelul transport inclusiv, urmând ca protocoalele de nivel aplicație să fie implementate în user-space (HTTP, <abbr title="File Transfer Protocol">FTP</abbr>, SSH, etc.).
</p>

</div>
<!-- EDIT5 SECTION "Noțiuni teoretice" [932-1867] -->
<h3 class="sectionedit6" id="networking_in_user-space">Networking în user-space</h3>
<div class="level3">

<p>
În user-space abstracția comunicației în rețea este socket-ul. Socket-ul abstractizează un canal de comunicație și este interfața de interacțiune cu stiva TCP/IP implementată în kernel. Unui socket IP i se asociază o adresă IP, protocolul de nivel transport utilizat (TCP, UDP etc) și un port. Apelurile uzuale pe un socket sunt: apelul de creare (<code>socket</code>), de inițializare (<code>bind</code>), de conectare (<code>connect</code>), de așteptare de conexiuni (<code>listen</code>, <code>accept</code>) și de închidere (<code>close</code>).
</p>

<p>
Comunicația în rețea se realizează prin intermediul apelurilor <code>read/write</code> sau <code>recv/send</code> pentru sockeți TCP, respectiv <code>recvfrom/sendto</code> pentru sockeți UDP. Operațiile de transmitere și recepție sunt transparente aplicației, lăsând la latitudinea nucleului încapsularea și transmiterea acestora în rețea. Este, însă, posibilă implementarea stivei TCP/IP în user-space folosind sockeți raw (opțiunea <code>PF_PACKET</code> la crearea unui socket), sau implementarea unui protocol de nivel aplicație în kernel (<a href="http://en.wikipedia.org/wiki/TUX_web_server" class="urlextern" title="http://en.wikipedia.org/wiki/TUX_web_server"  rel="nofollow">TUX web server</a>).
</p>

<p>
Pentru mai multe detalii despre programarea în user-space folosind sockeți, consultați <a href="http://www.beej.us/guide/bgnet/output/html/multipage/" class="urlextern" title="http://www.beej.us/guide/bgnet/output/html/multipage/"  rel="nofollow">Beej&#039;s Guide to Network Programming Using Internet Sockets</a> .
</p>

</div>
<!-- EDIT6 SECTION "Networking în user-space" [1868-3229] -->
<h2 class="sectionedit7" id="linux_networking">Linux networking</h2>
<div class="level2">

<p>
Kernel-ul Linux oferă trei structuri fundamentale pentru lucrul cu pachetele de rețea: <a href="http://lxr.free-electrons.com/source/include/linux/net.h?v=3.13#L95" class="urlextern" title="http://lxr.free-electrons.com/source/include/linux/net.h?v=3.13#L95"  rel="nofollow">struct socket</a>, <a href="http://lxr.free-electrons.com/source/include/net/sock.h?v=3.13#L219" class="urlextern" title="http://lxr.free-electrons.com/source/include/net/sock.h?v=3.13#L219"  rel="nofollow">struct sock</a> și <a href="http://lxr.free-electrons.com/source/include/linux/skbuff.h?v=3.13#L340" class="urlextern" title="http://lxr.free-electrons.com/source/include/linux/skbuff.h?v=3.13#L340"  rel="nofollow">struct sk_buff</a>.
</p>

<p>
Primele două reprezintă abstracții ale unui socket:
</p>
<ul>
<li class="level1"><div class="li"><a href="http://lxr.free-electrons.com/source/include/linux/net.h?v=3.13#L95" class="urlextern" title="http://lxr.free-electrons.com/source/include/linux/net.h?v=3.13#L95"  rel="nofollow">struct socket</a> este o abstracție foarte aproape de user-space, adică de <a href="http://en.wikipedia.org/wiki/Berkeley_sockets" class="urlextern" title="http://en.wikipedia.org/wiki/Berkeley_sockets"  rel="nofollow">socket-ii BSD</a> folosiți pentru programarea aplicațiilor de rețea.</div>
</li>
<li class="level1"><div class="li"><a href="http://lxr.free-electrons.com/source/include/net/sock.h?v=3.13#L219" class="urlextern" title="http://lxr.free-electrons.com/source/include/net/sock.h?v=3.13#L219"  rel="nofollow">struct sock</a> sau <em>INET socket</em> în terminologia Linux este reprezentarea la nivel rețea a unui socket.</div>
</li>
</ul>

<p>
Cele doua structuri sunt corelate: <code>struct socket</code> conține un câmp de INET socket, iar <code>struct sock</code> are un BSD socket care îl deține.
</p>

<p>
Structura <a href="http://lxr.free-electrons.com/source/include/linux/skbuff.h?v=3.13#L340" class="urlextern" title="http://lxr.free-electrons.com/source/include/linux/skbuff.h?v=3.13#L340"  rel="nofollow">struct sk_buff</a> este reprezentarea unui pachet de rețea și a stării acestuia. O astfel de structură este creată la sosirea unui pachet în kernel, fie din user-space, fie de la placa de rețea.
</p>

</div>
<!-- EDIT7 SECTION "Linux networking" [3230-4545] -->
<h3 class="sectionedit8" id="structura_socket">Structura socket</h3>
<div class="level3">

<p>
Structura <a href="http://lxr.free-electrons.com/source/include/linux/net.h?v=3.13#L95" class="urlextern" title="http://lxr.free-electrons.com/source/include/linux/net.h?v=3.13#L95"  rel="nofollow">struct socket</a> este reprezentarea în kernel a unui socket BSD, operațiile care pot fi executate asupra acestuia fiind similare cu cele expuse de kernel aplicațiilor (prin apeluri de sistem). Operațiile comune de lucru cu sockeții (creare, inițializare/bind, închidere, etc.), rezultă în apeluri de sistem specifice; acestea operează asupra unei structuri de tipul <code>struct socket</code>.
</p>

<p>
Operațiile asupra <a href="http://lxr.free-electrons.com/source/include/linux/net.h?v=3.13#L95" class="urlextern" title="http://lxr.free-electrons.com/source/include/linux/net.h?v=3.13#L95"  rel="nofollow">struct socket</a> sunt descrise în <a href="http://lxr.free-electrons.com/source/net/socket.c?v=3.13" class="urlextern" title="http://lxr.free-electrons.com/source/net/socket.c?v=3.13"  rel="nofollow">net/socket.c</a> și sunt independente de tipul de protocoale de mai jos. Structura <code>struct socket</code> este, astfel, o interfață generică peste implementări particulare de operații de rețea. De obicei, numele acestor operații încep cu șirul <code>sock_</code>.
</p>

</div>

<h4 id="operatii_asupra_structurii_socket">Operații asupra structurii socket</h4>
<div class="level4">

<p>
Operații asupra unui socket sunt:
</p>

</div>

<h5 id="crearea">Crearea</h5>
<div class="level5">

<p>
Crearea este asemănătoare apelului <code>socket</code> din user-space, dar socket-ul creat <a href="http://lxr.free-electrons.com/source/include/linux/net.h?v=3.13#L95" class="urlextern" title="http://lxr.free-electrons.com/source/include/linux/net.h?v=3.13#L95"  rel="nofollow">struct socket</a>, va fi întors în parametrul <code>res</code>:
</p>
<ul>
<li class="level1"><div class="li"><code>int </code><a href="http://lxr.free-electrons.com/source/net/socket.c?v=3.13#L1357" class="urlextern" title="http://lxr.free-electrons.com/source/net/socket.c?v=3.13#L1357"  rel="nofollow">sock_create</a><code>(int family, int type, int protocol, struct socket **res)</code></div>
<ul>
<li class="level2"><div class="li"> funcție apelată pentru crearea unui socket în urma unui apel de sistem <code>socket</code>;</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"><code>int </code><a href="http://lxr.free-electrons.com/source/net/socket.c?v=3.13#L1363" class="urlextern" title="http://lxr.free-electrons.com/source/net/socket.c?v=3.13#L1363"  rel="nofollow">sock_create_kern</a><code>(int family, int type, int protocol, struct socket **res)</code></div>
<ul>
<li class="level2"><div class="li"> funcție apelată pentru crearea unui socket în kernel;</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"><code>int </code><a href="http://lxr.free-electrons.com/source/net/socket.c?v=3.13#L1110" class="urlextern" title="http://lxr.free-electrons.com/source/net/socket.c?v=3.13#L1110"  rel="nofollow">sock_create_lite</a><code>(int family, int type, int protocol, struct socket **res)</code></div>
<ul>
<li class="level2"><div class="li"> funcție &#039;lite&#039; cu eliminarea verificării parametrilor.</div>
</li>
</ul>
</li>
</ul>

<p>
Parametrii acestor apeluri sunt următorii:
</p>
<ul>
<li class="level1"><div class="li"><code>family</code> reprezintă familia protocoalelor utilizate în transferul informației; de obicei, acestea încep cu șirul <code>PF_</code> (<em>Protocol Family</em>); constantele care reprezintă familia de protocoale utilizate se găsesc în <a href="http://lxr.free-electrons.com/source/include/linux/socket.h?v=3.13" class="urlextern" title="http://lxr.free-electrons.com/source/include/linux/socket.h?v=3.13"  rel="nofollow">linux/socket.h</a>, dintre care cea mai utilizată este <code>PF_INET</code>, pentru protocoalele TCP/IP.</div>
</li>
<li class="level1"><div class="li"><code>type</code> reprezintă tipul de socket; constantele utilizate pentru acest parametru se găsesc în <a href="http://lxr.free-electrons.com/source/include/linux/net.h?v=3.13" class="urlextern" title="http://lxr.free-electrons.com/source/include/linux/net.h?v=3.13"  rel="nofollow">linux/net.h</a>, dintre care cele mai utilizate sunt <code>SOCK_STREAM</code> pentru o comunicație bazată pe conexiune între sursă și destinație și <code>SOCK_DGRAM</code> pentru o comunicație fără conexiune.</div>
</li>
<li class="level1"><div class="li"><code>protocol</code> reprezintă protocolul utilizat și este în strânsă legătură cu parametrul type; constatele utilizate pentru acest parametru se găsesc în <a href="http://lxr.free-electrons.com/source/include/linux/in.h?v=3.13" class="urlextern" title="http://lxr.free-electrons.com/source/include/linux/in.h?v=3.13"  rel="nofollow">linux/in.h</a>, dintre care cele mai folosite sunt <code>IPPROTO_TCP</code> pentru TCP și <code>IPPROTO_UDP</code> pentru UDP.</div>
</li>
</ul>

<p>
Pentru crearea unui socket TCP în kernel se va apela:
</p>
<pre class="code c"><span class="kw4">struct</span> socket <span class="sy0">*</span>sock<span class="sy0">;</span>
<span class="kw4">int</span> err<span class="sy0">;</span>
err <span class="sy0">=</span> sock_create_kern<span class="br0">&#40;</span>PF_INET<span class="sy0">,</span> SOCK_STREAM<span class="sy0">,</span> IPPROTO_TCP<span class="sy0">,</span> <span class="sy0">&amp;</span>sock<span class="br0">&#41;</span><span class="sy0">;</span>
<span class="kw1">if</span><span class="br0">&#40;</span>err <span class="sy0">&lt;</span> <span class="nu0">0</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
    <span class="coMULTI">/* handle error */</span>
<span class="br0">&#125;</span></pre>

<p>
iar pentru crearea unui socket UDP:
</p>
<pre class="code c"><span class="kw4">struct</span> socket <span class="sy0">*</span>sock<span class="sy0">;</span>
<span class="kw4">int</span> err<span class="sy0">;</span>
err <span class="sy0">=</span> sock_create_kern<span class="br0">&#40;</span>PF_INET<span class="sy0">,</span> SOCK_DGRAM<span class="sy0">,</span> IPPROTO_UDP<span class="sy0">,</span> <span class="sy0">&amp;</span>sock<span class="br0">&#41;</span><span class="sy0">;</span>
<span class="kw1">if</span><span class="br0">&#40;</span>err <span class="sy0">&lt;</span> <span class="nu0">0</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
    <span class="coMULTI">/* error */</span>
<span class="br0">&#125;</span></pre>

<p>
Un exemplu de utilizare poate fi urmărit în codul handler-ului pentru apelul de sistem <a href="http://lxr.free-electrons.com/source/net/socket.c?v=3.13#L1369" class="urlextern" title="http://lxr.free-electrons.com/source/net/socket.c?v=3.13#L1369"  rel="nofollow">sys_socket</a>:
</p>
<pre class="code c">SYSCALL_DEFINE3<span class="br0">&#40;</span>socket<span class="sy0">,</span> <span class="kw4">int</span><span class="sy0">,</span> family<span class="sy0">,</span> <span class="kw4">int</span><span class="sy0">,</span> type<span class="sy0">,</span> <span class="kw4">int</span><span class="sy0">,</span> protocol<span class="br0">&#41;</span>
<span class="br0">&#123;</span>
	<span class="kw4">int</span> retval<span class="sy0">;</span>
	<span class="kw4">struct</span> socket <span class="sy0">*</span>sock<span class="sy0">;</span>
	<span class="kw4">int</span> flags<span class="sy0">;</span>
&nbsp;
	<span class="coMULTI">/* Check the SOCK_* constants for consistency.  */</span>
	BUILD_BUG_ON<span class="br0">&#40;</span>SOCK_CLOEXEC <span class="sy0">!=</span> O_CLOEXEC<span class="br0">&#41;</span><span class="sy0">;</span>
	BUILD_BUG_ON<span class="br0">&#40;</span><span class="br0">&#40;</span>SOCK_MAX <span class="sy0">|</span> SOCK_TYPE_MASK<span class="br0">&#41;</span> <span class="sy0">!=</span> SOCK_TYPE_MASK<span class="br0">&#41;</span><span class="sy0">;</span>
	BUILD_BUG_ON<span class="br0">&#40;</span>SOCK_CLOEXEC <span class="sy0">&amp;</span> SOCK_TYPE_MASK<span class="br0">&#41;</span><span class="sy0">;</span>
	BUILD_BUG_ON<span class="br0">&#40;</span>SOCK_NONBLOCK <span class="sy0">&amp;</span> SOCK_TYPE_MASK<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
	flags <span class="sy0">=</span> type <span class="sy0">&amp;</span> ~SOCK_TYPE_MASK<span class="sy0">;</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span>flags <span class="sy0">&amp;</span> ~<span class="br0">&#40;</span>SOCK_CLOEXEC <span class="sy0">|</span> SOCK_NONBLOCK<span class="br0">&#41;</span><span class="br0">&#41;</span>
		<span class="kw1">return</span> <span class="sy0">-</span>EINVAL<span class="sy0">;</span>
	type <span class="sy0">&amp;=</span> SOCK_TYPE_MASK<span class="sy0">;</span>
&nbsp;
	<span class="kw1">if</span> <span class="br0">&#40;</span>SOCK_NONBLOCK <span class="sy0">!=</span> O_NONBLOCK <span class="sy0">&amp;&amp;</span> <span class="br0">&#40;</span>flags <span class="sy0">&amp;</span> SOCK_NONBLOCK<span class="br0">&#41;</span><span class="br0">&#41;</span>
		flags <span class="sy0">=</span> <span class="br0">&#40;</span>flags <span class="sy0">&amp;</span> ~SOCK_NONBLOCK<span class="br0">&#41;</span> <span class="sy0">|</span> O_NONBLOCK<span class="sy0">;</span>
&nbsp;
	retval <span class="sy0">=</span> sock_create<span class="br0">&#40;</span>family<span class="sy0">,</span> type<span class="sy0">,</span> protocol<span class="sy0">,</span> <span class="sy0">&amp;</span>sock<span class="br0">&#41;</span><span class="sy0">;</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span>retval <span class="sy0">&lt;</span> <span class="nu0">0</span><span class="br0">&#41;</span>
		<span class="kw1">goto</span> out<span class="sy0">;</span>
&nbsp;
	retval <span class="sy0">=</span> sock_map_fd<span class="br0">&#40;</span>sock<span class="sy0">,</span> flags <span class="sy0">&amp;</span> <span class="br0">&#40;</span>O_CLOEXEC <span class="sy0">|</span> O_NONBLOCK<span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy0">;</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span>retval <span class="sy0">&lt;</span> <span class="nu0">0</span><span class="br0">&#41;</span>
		<span class="kw1">goto</span> out_release<span class="sy0">;</span>
&nbsp;
out<span class="sy0">:</span>
	<span class="coMULTI">/* It may be already another descriptor 8) Not kernel problem. */</span>
	<span class="kw1">return</span> retval<span class="sy0">;</span>
&nbsp;
out_release<span class="sy0">:</span>
	sock_release<span class="br0">&#40;</span>sock<span class="br0">&#41;</span><span class="sy0">;</span>
	<span class="kw1">return</span> retval<span class="sy0">;</span>
<span class="br0">&#125;</span></pre>

</div>

<h5 id="inchiderea">Închiderea</h5>
<div class="level5">

<p>
Închiderea conexiunii (pentru socket cu conexiune) și eliberarea resurselor asociate:
</p>
<ul>
<li class="level1"><div class="li"><code>void </code><a href="http://lxr.free-electrons.com/source/net/socket.c?v=3.13#L576" class="urlextern" title="http://lxr.free-electrons.com/source/net/socket.c?v=3.13#L576"  rel="nofollow">sock_release</a><code>(struct socket *sock)</code> - această funcție va apela funcția <code>release</code> din câmpul <code>ops</code> al structurii socket-ului:</div>
</li>
</ul>
<pre class="code c"><span class="kw4">void</span> sock_release<span class="br0">&#40;</span><span class="kw4">struct</span> socket <span class="sy0">*</span>sock<span class="br0">&#41;</span>
<span class="br0">&#123;</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span>sock<span class="sy0">-&gt;</span>ops<span class="br0">&#41;</span> <span class="br0">&#123;</span>
		<span class="kw4">struct</span> module <span class="sy0">*</span>owner <span class="sy0">=</span> sock<span class="sy0">-&gt;</span>ops<span class="sy0">-&gt;</span>owner<span class="sy0">;</span>
&nbsp;
		sock<span class="sy0">-&gt;</span>ops<span class="sy0">-&gt;</span>release<span class="br0">&#40;</span>sock<span class="br0">&#41;</span><span class="sy0">;</span>
		sock<span class="sy0">-&gt;</span>ops <span class="sy0">=</span> NULL<span class="sy0">;</span>
		module_put<span class="br0">&#40;</span>owner<span class="br0">&#41;</span><span class="sy0">;</span>
	<span class="br0">&#125;</span>
	<span class="co1">//...</span>
<span class="br0">&#125;</span></pre>

</div>

<h5 id="transmitereareceptia_unui_mesaj">Transmiterea/recepția unui mesaj</h5>
<div class="level5">

<p>
Transmiterea/recepția mesajelor se face cu ajutorul funcțiilor:
</p>
<ul>
<li class="level1"><div class="li"><code>int </code><a href="http://lxr.free-electrons.com/source/net/socket.c?v=3.13#L794" class="urlextern" title="http://lxr.free-electrons.com/source/net/socket.c?v=3.13#L794"  rel="nofollow">sock_recvmsg</a><code>(struct socket *sock, struct msghdr *msg, size_t size, int flags);</code></div>
</li>
<li class="level1"><div class="li"><code>int </code><a href="http://lxr.free-electrons.com/source/net/socket.c?v=3.13#L825" class="urlextern" title="http://lxr.free-electrons.com/source/net/socket.c?v=3.13#L825"  rel="nofollow">kernel_recvmsg</a><code>(struct socket *sock, struct msghdr *msg, struct kvec *vec, size_t num, size_t size, int flags);</code></div>
</li>
<li class="level1"><div class="li"><code>int </code><a href="http://lxr.free-electrons.com/source/net/socket.c?v=3.13#L643" class="urlextern" title="http://lxr.free-electrons.com/source/net/socket.c?v=3.13#L643"  rel="nofollow">sock_sendmsg</a><code>(struct socket *sock, struct msghdr *msg, size_t size);</code></div>
</li>
<li class="level1"><div class="li"><code>int </code><a href="http://lxr.free-electrons.com/source/net/socket.c?v=3.13#L672" class="urlextern" title="http://lxr.free-electrons.com/source/net/socket.c?v=3.13#L672"  rel="nofollow">kernel_sendmsg</a><code>(struct socket *sock, struct msghdr *msg, struct kvec *vec, size_t num, size_t size);</code></div>
</li>
</ul>

<p>
Funcțiile de transmitere/recepție de mesaj vor apela ulterior funcția <code>sendmsg/recvmsg</code> din câmpul <code>ops</code> al socket-ului. Funcțiile ce conțin <code>kernel_</code> ca prefix sunt folosite în cazul în care socket-ul este utilizat în cadrul kernel-ului.
</p>

<p>
Parametrii acestor funcții sunt următorii:
</p>
<ul>
<li class="level1"><div class="li"><code>msg</code>, o structura <a href="http://lxr.free-electrons.com/source/include/linux/socket.h?v=3.13#L47" class="urlextern" title="http://lxr.free-electrons.com/source/include/linux/socket.h?v=3.13#L47"  rel="nofollow">struct msghdr</a>, ce conține mesajul de transmis/recepționat. Dintre componentele importante ale acestei structuri avem:</div>
<ul>
<li class="level2"><div class="li"><code>msg_name</code>, <code>msg_namelen</code>, care pentru socket-i <code>UDP</code> trebuie completați cu adresa la care se transmite mesajul (<a href="http://lxr.free-electrons.com/source/include/uapi/linux/in.h?v=3.13#L213" class="urlextern" title="http://lxr.free-electrons.com/source/include/uapi/linux/in.h?v=3.13#L213"  rel="nofollow">struct sockaddr_in</a>)</div>
</li>
<li class="level2"><div class="li"><code>msg_iov</code>, <code>msg_iovlen</code>, datele de transmis, într-un vector de structuri <a href="http://lxr.free-electrons.com/source/include/uapi/linux/uio.h?v=3.13#L16" class="urlextern" title="http://lxr.free-electrons.com/source/include/uapi/linux/uio.h?v=3.13#L16"  rel="nofollow">struct iovec</a>. O structură <code>iovec</code> conține un pointer către buffer-ul ce conține datele și dimensiunea acestuia.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"><code>vec</code>, o structură <a href="http://lxr.free-electrons.com/source/include/linux/uio.h?v=3.13#L15" class="urlextern" title="http://lxr.free-electrons.com/source/include/linux/uio.h?v=3.13#L15"  rel="nofollow">kvec</a>, ce conține un pointer către buffer-ul ce conține datele și dimensiunea acestuia; după cum se poate observa, are o structură similară cu structura <a href="http://lxr.free-electrons.com/source/include/uapi/linux/uio.h?v=3.13#L16" class="urlextern" title="http://lxr.free-electrons.com/source/include/uapi/linux/uio.h?v=3.13#L16"  rel="nofollow">struct iovec</a> (structura <code>iovec</code> corespunde datelor user space, iar structura <code>kvec</code> corespunde datelor kernel space)</div>
</li>
</ul>

<p>
Modul de lucru cu funcțiile de transmitere poate fi urmărit în cadrul handler-ului pentru apelul de sistem <a href="http://lxr.free-electrons.com/source/net/socket.c?v=3.13#L1756" class="urlextern" title="http://lxr.free-electrons.com/source/net/socket.c?v=3.13#L1756"  rel="nofollow">sys_sendto</a>:
</p>
<pre class="code c">SYSCALL_DEFINE6<span class="br0">&#40;</span>sendto<span class="sy0">,</span> <span class="kw4">int</span><span class="sy0">,</span> fd<span class="sy0">,</span> <span class="kw4">void</span> __user <span class="sy0">*,</span> buff<span class="sy0">,</span> <span class="kw4">size_t</span><span class="sy0">,</span> len<span class="sy0">,</span>
                <span class="kw4">unsigned</span><span class="sy0">,</span> flags<span class="sy0">,</span> <span class="kw4">struct</span> sockaddr __user <span class="sy0">*,</span> addr<span class="sy0">,</span>
                <span class="kw4">int</span><span class="sy0">,</span> addr_len<span class="br0">&#41;</span>
<span class="br0">&#123;</span>
         <span class="kw4">struct</span> socket <span class="sy0">*</span>sock<span class="sy0">;</span>
         <span class="kw4">char</span> address<span class="br0">&#91;</span>MAX_SOCK_ADDR<span class="br0">&#93;</span><span class="sy0">;</span>
         <span class="kw4">int</span> err<span class="sy0">;</span>
         <span class="kw4">struct</span> msghdr msg<span class="sy0">;</span>
         <span class="kw4">struct</span> iovec iov<span class="sy0">;</span>
         <span class="kw4">int</span> fput_needed<span class="sy0">;</span>
         <span class="kw4">struct</span> file <span class="sy0">*</span>sock_file<span class="sy0">;</span>
&nbsp;
         sock_file <span class="sy0">=</span> fget_light<span class="br0">&#40;</span>fd<span class="sy0">,</span> <span class="sy0">&amp;</span>fput_needed<span class="br0">&#41;</span><span class="sy0">;</span>
         err <span class="sy0">=</span> <span class="sy0">-</span>EBADF<span class="sy0">;</span>
         <span class="kw1">if</span> <span class="br0">&#40;</span><span class="sy0">!</span>sock_file<span class="br0">&#41;</span>
                 <span class="kw1">goto</span> out<span class="sy0">;</span>
&nbsp;
         sock <span class="sy0">=</span> sock_from_file<span class="br0">&#40;</span>sock_file<span class="sy0">,</span> <span class="sy0">&amp;</span>err<span class="br0">&#41;</span><span class="sy0">;</span>
         <span class="kw1">if</span> <span class="br0">&#40;</span><span class="sy0">!</span>sock<span class="br0">&#41;</span>
                 <span class="kw1">goto</span> out_put<span class="sy0">;</span>
         iov.<span class="me1">iov_base</span> <span class="sy0">=</span> buff<span class="sy0">;</span>
         iov.<span class="me1">iov_len</span> <span class="sy0">=</span> len<span class="sy0">;</span>
         msg.<span class="me1">msg_name</span> <span class="sy0">=</span> NULL<span class="sy0">;</span>
         msg.<span class="me1">msg_iov</span> <span class="sy0">=</span> <span class="sy0">&amp;</span>iov<span class="sy0">;</span>
         msg.<span class="me1">msg_iovlen</span> <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span>
         msg.<span class="me1">msg_control</span> <span class="sy0">=</span> NULL<span class="sy0">;</span>
         msg.<span class="me1">msg_controllen</span> <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
         msg.<span class="me1">msg_namelen</span> <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
         <span class="kw1">if</span> <span class="br0">&#40;</span>addr<span class="br0">&#41;</span> <span class="br0">&#123;</span>
                 err <span class="sy0">=</span> move_addr_to_kernel<span class="br0">&#40;</span>addr<span class="sy0">,</span> addr_len<span class="sy0">,</span> address<span class="br0">&#41;</span><span class="sy0">;</span>
                 <span class="kw1">if</span> <span class="br0">&#40;</span>err <span class="sy0">&lt;</span> <span class="nu0">0</span><span class="br0">&#41;</span>
                         <span class="kw1">goto</span> out_put<span class="sy0">;</span>
                 msg.<span class="me1">msg_name</span> <span class="sy0">=</span> address<span class="sy0">;</span>
                 msg.<span class="me1">msg_namelen</span> <span class="sy0">=</span> addr_len<span class="sy0">;</span>
         <span class="br0">&#125;</span>
         <span class="kw1">if</span> <span class="br0">&#40;</span>sock<span class="sy0">-&gt;</span>file<span class="sy0">-&gt;</span>f_flags <span class="sy0">&amp;</span> O_NONBLOCK<span class="br0">&#41;</span>
                 flags <span class="sy0">|=</span> MSG_DONTWAIT<span class="sy0">;</span>
         msg.<span class="me1">msg_flags</span> <span class="sy0">=</span> flags<span class="sy0">;</span>
         err <span class="sy0">=</span> sock_sendmsg<span class="br0">&#40;</span>sock<span class="sy0">,</span> <span class="sy0">&amp;</span>msg<span class="sy0">,</span> len<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
out_put<span class="sy0">:</span>
         fput_light<span class="br0">&#40;</span>sock_file<span class="sy0">,</span> fput_needed<span class="br0">&#41;</span><span class="sy0">;</span>
out<span class="sy0">:</span>
         <span class="kw1">return</span> err<span class="sy0">;</span>
<span class="br0">&#125;</span></pre>

</div>

<h4 id="campuri_ale_structurii_socket">Câmpuri ale structurii socket</h4>
<div class="level4">

<p>
Structura <a href="http://lxr.free-electrons.com/source/include/linux/net.h?v=3.13#L95" class="urlextern" title="http://lxr.free-electrons.com/source/include/linux/net.h?v=3.13#L95"  rel="nofollow">struct socket</a>:
</p>
<pre class="code c"><span class="coMULTI">/**
  *  struct socket - general BSD socket
  *  @state: socket state (%SS_CONNECTED, etc)
  *  @type: socket type (%SOCK_STREAM, etc)
  *  @flags: socket flags (%SOCK_ASYNC_NOSPACE, etc)
  *  @ops: protocol specific socket operations
  *  @fasync_list: Asynchronous wake up list
  *  @file: File back pointer for gc
  *  @sk: internal networking protocol agnostic socket representation
  *  @wait: wait queue for several uses
  */</span>
<span class="kw4">struct</span> socket <span class="br0">&#123;</span>
        socket_state            state<span class="sy0">;</span>
        <span class="kw4">short</span>                   type<span class="sy0">;</span>
        <span class="kw4">unsigned</span> <span class="kw4">long</span>           flags<span class="sy0">;</span>
        <span class="coMULTI">/*
         * Please keep fasync_list &amp; wait fields in the same cache line
         */</span>
        <span class="kw4">struct</span> fasync_struct    <span class="sy0">*</span>fasync_list<span class="sy0">;</span>
        wait_queue_head_t       wait<span class="sy0">;</span>
&nbsp;
        <span class="kw4">struct</span> file             <span class="sy0">*</span>file<span class="sy0">;</span>
        <span class="kw4">struct</span> sock             <span class="sy0">*</span>sk<span class="sy0">;</span>
        <span class="kw4">const</span> <span class="kw4">struct</span> proto_ops  <span class="sy0">*</span>ops<span class="sy0">;</span>
<span class="br0">&#125;</span><span class="sy0">;</span></pre>

<p>
Câmpuri importante sunt:
</p>
<ul>
<li class="level1"><div class="li"><code>ops</code> - structura ce conține pointeri la funcțiile specifice protocolului implementat;</div>
</li>
<li class="level1"><div class="li"><code>sk</code> - <em>INET socket</em>-ul asociat.</div>
</li>
</ul>

</div>

<h4 id="structura_proto_ops">Structura proto_ops</h4>
<div class="level4">

<p>
Structura <a href="http://lxr.free-electrons.com/source/include/linux/net.h?v=3.13#L128" class="urlextern" title="http://lxr.free-electrons.com/source/include/linux/net.h?v=3.13#L128"  rel="nofollow">struct proto_ops</a> conține implementările operațiilor specifice protocolului implementat (<code>TCP</code>, <code>UDP</code>, etc.); funcțiile de aici vor fi apelate din funcțiile generice de lucru cu <a href="http://lxr.free-electrons.com/source/include/linux/net.h?v=3.13#L95" class="urlextern" title="http://lxr.free-electrons.com/source/include/linux/net.h?v=3.13#L95"  rel="nofollow">struct socket</a> (<a href="http://lxr.free-electrons.com/source/net/socket.c?v=3.13#L576" class="urlextern" title="http://lxr.free-electrons.com/source/net/socket.c?v=3.13#L576"  rel="nofollow">sock_release</a>, <a href="http://lxr.free-electrons.com/source/net/socket.c?v=3.13#L643" class="urlextern" title="http://lxr.free-electrons.com/source/net/socket.c?v=3.13#L643"  rel="nofollow">sock_sendmsg</a>, etc.)
</p>

<p>
Structura <a href="http://lxr.free-electrons.com/source/include/linux/net.h?v=3.13#L128" class="urlextern" title="http://lxr.free-electrons.com/source/include/linux/net.h?v=3.13#L128"  rel="nofollow">struct proto_ops</a> conține, așadar, o serie de pointeri de funcții pentru implementări specifice de protocol:
</p>
<pre class="code c"><span class="kw4">struct</span> proto_ops <span class="br0">&#123;</span>
	<span class="kw4">int</span>		family<span class="sy0">;</span>
	<span class="kw4">struct</span> module	<span class="sy0">*</span>owner<span class="sy0">;</span>
	<span class="kw4">int</span>		<span class="br0">&#40;</span><span class="sy0">*</span>release<span class="br0">&#41;</span>   <span class="br0">&#40;</span><span class="kw4">struct</span> socket <span class="sy0">*</span>sock<span class="br0">&#41;</span><span class="sy0">;</span>
	<span class="kw4">int</span>		<span class="br0">&#40;</span><span class="sy0">*</span>bind<span class="br0">&#41;</span>	     <span class="br0">&#40;</span><span class="kw4">struct</span> socket <span class="sy0">*</span>sock<span class="sy0">,</span>
				      <span class="kw4">struct</span> sockaddr <span class="sy0">*</span>myaddr<span class="sy0">,</span>
				      <span class="kw4">int</span> sockaddr_len<span class="br0">&#41;</span><span class="sy0">;</span>
	<span class="kw4">int</span>		<span class="br0">&#40;</span><span class="sy0">*</span>connect<span class="br0">&#41;</span>   <span class="br0">&#40;</span><span class="kw4">struct</span> socket <span class="sy0">*</span>sock<span class="sy0">,</span>
				      <span class="kw4">struct</span> sockaddr <span class="sy0">*</span>vaddr<span class="sy0">,</span>
				      <span class="kw4">int</span> sockaddr_len<span class="sy0">,</span> <span class="kw4">int</span> flags<span class="br0">&#41;</span><span class="sy0">;</span>
	<span class="kw4">int</span>		<span class="br0">&#40;</span><span class="sy0">*</span>socketpair<span class="br0">&#41;</span><span class="br0">&#40;</span><span class="kw4">struct</span> socket <span class="sy0">*</span>sock1<span class="sy0">,</span>
				      <span class="kw4">struct</span> socket <span class="sy0">*</span>sock2<span class="br0">&#41;</span><span class="sy0">;</span>
	<span class="kw4">int</span>		<span class="br0">&#40;</span><span class="sy0">*</span>accept<span class="br0">&#41;</span>    <span class="br0">&#40;</span><span class="kw4">struct</span> socket <span class="sy0">*</span>sock<span class="sy0">,</span>
				      <span class="kw4">struct</span> socket <span class="sy0">*</span>newsock<span class="sy0">,</span> <span class="kw4">int</span> flags<span class="br0">&#41;</span><span class="sy0">;</span>
	<span class="co1">//...</span></pre>

<p>
Inițializarea câmpului <code>ops</code> din <a href="http://lxr.free-electrons.com/source/include/linux/net.h?v=3.13#L95" class="urlextern" title="http://lxr.free-electrons.com/source/include/linux/net.h?v=3.13#L95"  rel="nofollow">struct socket</a> se realizează în funcția <a href="http://lxr.free-electrons.com/source/net/socket.c?v=3.13#L1244" class="urlextern" title="http://lxr.free-electrons.com/source/net/socket.c?v=3.13#L1244"  rel="nofollow">__sock_create</a>, prin apelul funcției <a href="http://lxr.free-electrons.com/source/include/linux/net.h?v=3.13#L192" class="urlextern" title="http://lxr.free-electrons.com/source/include/linux/net.h?v=3.13#L192"  rel="nofollow">create</a> specifică protocolului; un apel echivalent este următorul:
</p>
<pre class="code c"><span class="co1">//...</span>
        <span class="kw1">if</span> <span class="br0">&#40;</span><span class="br0">&#40;</span>err <span class="sy0">=</span> net_families<span class="br0">&#91;</span>family<span class="br0">&#93;</span><span class="sy0">-&gt;</span>create<span class="br0">&#40;</span>net<span class="sy0">,</span> sock<span class="sy0">,</span> protocol<span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="sy0">&lt;</span> <span class="nu0">0</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
                sock<span class="sy0">-&gt;</span>ops <span class="sy0">=</span> NULL<span class="sy0">;</span>
                <span class="kw1">goto</span> out_module_put<span class="sy0">;</span>
        <span class="br0">&#125;</span>
<span class="co1">//...</span></pre>

<p>
Se va realiza astfel instanțierea pointerilor de funcții cu apeluri specifice tipului de protocol asociat socket-ului. Apelurile <a href="http://lxr.free-electrons.com/source/net/socket.c?v=3.13#L2571" class="urlextern" title="http://lxr.free-electrons.com/source/net/socket.c?v=3.13#L2571"  rel="nofollow">sock_register</a> și <a href="http://lxr.free-electrons.com/source/net/socket.c?v=3.13#L2605" class="urlextern" title="http://lxr.free-electrons.com/source/net/socket.c?v=3.13#L2605"  rel="nofollow">sock_unregister</a> sunt folosite pentru completarea vectorului <a href="http://lxr.free-electrons.com/source/net/socket.c?v=3.13#L165" class="urlextern" title="http://lxr.free-electrons.com/source/net/socket.c?v=3.13#L165"  rel="nofollow">net_families</a>.
</p>

<p>
Pentru restul operațiilor cu socketi (în afară de creare, închidere și transmitere/recepție mesaj, prezentate mai sus, în secțiunea <a href="lab10.html#operatii_asupra_structurii_socket" title="so2:laboratoare:lab10 ↵" class="wikilink1">Operații asupra structurii socket</a>), se vor apela funcțiile date de pointerii din această structură. Spre exemplu, pentru operația <code>bind</code>, care asociază unui socket un port pe mașina locală, vom avea următoarea secvență de cod:
</p>
<pre class="code c"><span class="co2">#define MY_PORT 60000</span>
&nbsp;
<span class="kw4">struct</span> sockaddr_in addr <span class="sy0">=</span> <span class="br0">&#123;</span>
    .<span class="me1">sin_family</span> <span class="sy0">=</span> AF_INET<span class="sy0">,</span>
    .<span class="me1">sin_port</span> <span class="sy0">=</span> htons <span class="br0">&#40;</span>MY_PORT<span class="br0">&#41;</span><span class="sy0">,</span>
    .<span class="me1">sin_addr</span> <span class="sy0">=</span> <span class="br0">&#123;</span> htonl <span class="br0">&#40;</span>INADDR_LOOPBACK<span class="br0">&#41;</span> <span class="br0">&#125;</span>
<span class="br0">&#125;</span><span class="sy0">;</span>
&nbsp;
<span class="co1">//...</span>
&nbsp;
err <span class="sy0">=</span> sock<span class="sy0">-&gt;</span>ops<span class="sy0">-&gt;</span>bind <span class="br0">&#40;</span>sock<span class="sy0">,</span> <span class="br0">&#40;</span><span class="kw4">struct</span> sockaddr <span class="sy0">*</span><span class="br0">&#41;</span> <span class="sy0">&amp;</span>addr<span class="sy0">,</span> <span class="kw4">sizeof</span><span class="br0">&#40;</span>addr<span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy0">;</span>
<span class="kw1">if</span> <span class="br0">&#40;</span>err <span class="sy0">&lt;</span> <span class="nu0">0</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
    <span class="coMULTI">/* handle error */</span>
<span class="br0">&#125;</span>
<span class="co1">//...</span></pre>

<p>
După cum se poate observa, pentru transmiterea informațiilor legate de adresa și portul care se vor asocia socket-ului, se completează o structură <a href="http://lxr.free-electrons.com/source/include/uapi/linux/in.h?v=3.13#L213" class="urlextern" title="http://lxr.free-electrons.com/source/include/uapi/linux/in.h?v=3.13#L213"  rel="nofollow">struct sockaddr_in</a>. <sup><a href="lab10.html#fn__1" id="fnt__1" class="fn_top">1)</a></sup>
</p>

</div>
<!-- EDIT8 SECTION "Structura socket" [4546-17969] -->
<h3 class="sectionedit9" id="structura_sock">Structura sock</h3>
<div class="level3">

<p>
Structura <a href="http://lxr.free-electrons.com/source/include/net/sock.h?v=3.13#L219" class="urlextern" title="http://lxr.free-electrons.com/source/include/net/sock.h?v=3.13#L219"  rel="nofollow">struct sock</a> descrie un <em>INET socket</em>. O astfel de structură este asociată unui socket creat în user-space și, implicit, unei structuri <a href="http://lxr.free-electrons.com/source/include/linux/net.h?v=3.13#L95" class="urlextern" title="http://lxr.free-electrons.com/source/include/linux/net.h?v=3.13#L95"  rel="nofollow">struct socket</a>. Structura este folosită pentru a menține informații despre starea unei conexiuni. Câmpurile structurii și operațiile asociate încep, de obicei, cu șirul <code>sk_</code>. Câteva câmpuri sunt prezentate mai jos:
</p>
<pre class="code c"><span class="kw4">struct</span> sock <span class="br0">&#123;</span>
	<span class="co1">//...</span>
	<span class="kw4">unsigned</span> <span class="kw4">char</span>		sk_protocol<span class="sy0">;</span>
	<span class="kw4">unsigned</span> <span class="kw4">short</span>		sk_type<span class="sy0">;</span>
	<span class="co1">//...</span>
	<span class="kw4">struct</span> socket		<span class="sy0">*</span>sk_socket<span class="sy0">;</span>
	<span class="co1">//...</span>
	<span class="kw4">struct</span> sk_buff		<span class="sy0">*</span>sk_send_head<span class="sy0">;</span>
	<span class="co1">//...</span>
	<span class="kw4">void</span>			<span class="br0">&#40;</span><span class="sy0">*</span>sk_state_change<span class="br0">&#41;</span><span class="br0">&#40;</span><span class="kw4">struct</span> sock <span class="sy0">*</span>sk<span class="br0">&#41;</span><span class="sy0">;</span>
	<span class="kw4">void</span>			<span class="br0">&#40;</span><span class="sy0">*</span>sk_data_ready<span class="br0">&#41;</span><span class="br0">&#40;</span><span class="kw4">struct</span> sock <span class="sy0">*</span>sk<span class="sy0">,</span> <span class="kw4">int</span> bytes<span class="br0">&#41;</span><span class="sy0">;</span>
	<span class="kw4">void</span>			<span class="br0">&#40;</span><span class="sy0">*</span>sk_write_space<span class="br0">&#41;</span><span class="br0">&#40;</span><span class="kw4">struct</span> sock <span class="sy0">*</span>sk<span class="br0">&#41;</span><span class="sy0">;</span>
	<span class="kw4">void</span>			<span class="br0">&#40;</span><span class="sy0">*</span>sk_error_report<span class="br0">&#41;</span><span class="br0">&#40;</span><span class="kw4">struct</span> sock <span class="sy0">*</span>sk<span class="br0">&#41;</span><span class="sy0">;</span>
  	<span class="kw4">int</span>			<span class="br0">&#40;</span><span class="sy0">*</span>sk_backlog_rcv<span class="br0">&#41;</span><span class="br0">&#40;</span><span class="kw4">struct</span> sock <span class="sy0">*</span>sk<span class="sy0">,</span>
						  <span class="kw4">struct</span> sk_buff <span class="sy0">*</span>skb<span class="br0">&#41;</span><span class="sy0">;</span>
	<span class="kw4">void</span>                    <span class="br0">&#40;</span><span class="sy0">*</span>sk_destruct<span class="br0">&#41;</span><span class="br0">&#40;</span><span class="kw4">struct</span> sock <span class="sy0">*</span>sk<span class="br0">&#41;</span><span class="sy0">;</span>
<span class="br0">&#125;</span><span class="sy0">;</span></pre>
<ul>
<li class="level1"><div class="li"><code>sk_protocol</code> este tipul de protocol utilizat de socket;</div>
</li>
<li class="level1"><div class="li"><code>sk_type</code> este tipul de socket (<code>SOCK_STREAM</code>, <code>SOCK_DGRAM</code>, etc.)</div>
</li>
<li class="level1"><div class="li"><code>sk_socket</code> este socket-ul BSD care îl deține;</div>
</li>
<li class="level1"><div class="li"><code>sk_send_head</code> este lista de structuri <code>sk_buff</code> pentru transmitere;</div>
</li>
<li class="level1"><div class="li">pointerii de funcții de la sfârșit sunt callback-uri pentru diverse situații.</div>
</li>
</ul>

<p>
Inițializarea <code>struct sock</code> și atașarea acesteia la un socket BSD se face cu ajutorul callback-ului <a href="http://lxr.free-electrons.com/source/include/linux/net.h?v=3.13#L192" class="urlextern" title="http://lxr.free-electrons.com/source/include/linux/net.h?v=3.13#L192"  rel="nofollow">create</a> din <a href="http://lxr.free-electrons.com/source/net/socket.c?v=3.13#L165" class="urlextern" title="http://lxr.free-electrons.com/source/net/socket.c?v=3.13#L165"  rel="nofollow">net_families</a> (apelat in <a href="http://lxr.free-electrons.com/source/net/socket.c?v=3.13#L1244" class="urlextern" title="http://lxr.free-electrons.com/source/net/socket.c?v=3.13#L1244"  rel="nofollow">__sock_create</a>). Mai jos este prezentat modul de
inițializare a structurii <code>struct sock</code> pentru protocolul IP, în cadrul funcției <a href="http://lxr.free-electrons.com/source/net/ipv4/af_inet.c?v=3.13#L248" class="urlextern" title="http://lxr.free-electrons.com/source/net/ipv4/af_inet.c?v=3.13#L248"  rel="nofollow">inet_create</a>:
</p>
<pre class="code c"><span class="coMULTI">/*
  *	Create an inet socket.
  */</span>
&nbsp;
<span class="kw4">static</span> <span class="kw4">int</span> inet_create<span class="br0">&#40;</span><span class="kw4">struct</span> net <span class="sy0">*</span>net<span class="sy0">,</span> <span class="kw4">struct</span> socket <span class="sy0">*</span>sock<span class="sy0">,</span> <span class="kw4">int</span> protocol<span class="br0">&#41;</span>
<span class="br0">&#123;</span>
	<span class="kw4">struct</span> sock <span class="sy0">*</span>sk<span class="sy0">;</span>
&nbsp;
	<span class="co1">//...</span>
	err <span class="sy0">=</span> <span class="sy0">-</span>ENOBUFS<span class="sy0">;</span>
	sk <span class="sy0">=</span> sk_alloc<span class="br0">&#40;</span>net<span class="sy0">,</span> PF_INET<span class="sy0">,</span> GFP_KERNEL<span class="sy0">,</span> answer_prot<span class="br0">&#41;</span><span class="sy0">;</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span>sk <span class="sy0">==</span> NULL<span class="br0">&#41;</span>
		<span class="kw1">goto</span> out<span class="sy0">;</span>
&nbsp;
	err <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
	sk<span class="sy0">-&gt;</span>sk_no_check <span class="sy0">=</span> answer_no_check<span class="sy0">;</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span>INET_PROTOSW_REUSE <span class="sy0">&amp;</span> answer_flags<span class="br0">&#41;</span>
		sk<span class="sy0">-&gt;</span>sk_reuse <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span>
&nbsp;
	<span class="co1">//...</span>
	sock_init_data<span class="br0">&#40;</span>sock<span class="sy0">,</span> sk<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
	sk<span class="sy0">-&gt;</span>sk_destruct	   <span class="sy0">=</span> inet_sock_destruct<span class="sy0">;</span>
	sk<span class="sy0">-&gt;</span>sk_family	   <span class="sy0">=</span> PF_INET<span class="sy0">;</span>
	sk<span class="sy0">-&gt;</span>sk_protocol	   <span class="sy0">=</span> protocol<span class="sy0">;</span>
	sk<span class="sy0">-&gt;</span>sk_backlog_rcv <span class="sy0">=</span> sk<span class="sy0">-&gt;</span>sk_prot<span class="sy0">-&gt;</span>backlog_rcv<span class="sy0">;</span>
	<span class="co1">//...</span>
<span class="br0">&#125;</span></pre>

</div>
<!-- EDIT9 SECTION "Structura sock" [17970-20495] -->
<h3 class="sectionedit10" id="structura_sk_buff">Structura sk_buff</h3>
<div class="level3">

<p>
Structura <a href="http://lxr.free-electrons.com/source/include/linux/skbuff.h?v=3.13#L340" class="urlextern" title="http://lxr.free-electrons.com/source/include/linux/skbuff.h?v=3.13#L340"  rel="nofollow">struct sk_buff</a> (<em>socket buffer</em>) descrie un pachet de rețea. Câmpurile structurii conțin informații atât despre antetele și conținutul pachetelor cât și protocoalele utilizate, dispozitivul de rețea utilizat, pointeri către celelalte structuri <code>struct sk_buff</code>. O descriere sumară a conținutului structurii este prezentată mai jos:
</p>
<pre class="code c"> <span class="kw4">struct</span> sk_buff <span class="br0">&#123;</span>
         <span class="coMULTI">/* These two members must be first. */</span>
         <span class="kw4">struct</span> sk_buff          <span class="sy0">*</span>next<span class="sy0">;</span>
         <span class="kw4">struct</span> sk_buff          <span class="sy0">*</span>prev<span class="sy0">;</span>
&nbsp;
         <span class="kw4">struct</span> sock             <span class="sy0">*</span>sk<span class="sy0">;</span>
         ktime_t                 tstamp<span class="sy0">;</span>
         <span class="kw4">struct</span> net_device       <span class="sy0">*</span>dev<span class="sy0">;</span>
&nbsp;
         <span class="kw4">struct</span>  dst_entry       <span class="sy0">*</span>dst<span class="sy0">;</span>
         <span class="kw4">struct</span>  sec_path        <span class="sy0">*</span>sp<span class="sy0">;</span>
&nbsp;
         <span class="coMULTI">/*
          * This is the control buffer. It is free to use for every
          * layer. Please put your private variables there. If you
          * want to keep them across layers you have to do a skb_clone()
          * first. This is owned by whoever has the skb queued ATM.
          */</span>
         <span class="kw4">char</span>                    cb<span class="br0">&#91;</span><span class="nu0">48</span><span class="br0">&#93;</span><span class="sy0">;</span>
&nbsp;
         <span class="kw4">unsigned</span> <span class="kw4">int</span>            len<span class="sy0">,</span>
                                 data_len<span class="sy0">;</span>
         __u16                   mac_len<span class="sy0">,</span>
                                 hdr_len<span class="sy0">;</span>
&nbsp;
         <span class="coMULTI">/* ... */</span>
&nbsp;
         <span class="kw4">void</span>                    <span class="br0">&#40;</span><span class="sy0">*</span>destructor<span class="br0">&#41;</span><span class="br0">&#40;</span><span class="kw4">struct</span> sk_buff <span class="sy0">*</span>skb<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
         <span class="coMULTI">/* ... */</span>
&nbsp;
         sk_buff_data_t          transport_header<span class="sy0">;</span>
         sk_buff_data_t          network_header<span class="sy0">;</span>
         sk_buff_data_t          mac_header<span class="sy0">;</span>
&nbsp;
         <span class="coMULTI">/* These elements must be at the end, see alloc_skb() for details.  */</span>
         sk_buff_data_t          tail<span class="sy0">;</span>
         sk_buff_data_t          end<span class="sy0">;</span>
         <span class="kw4">unsigned</span> <span class="kw4">char</span>           <span class="sy0">*</span>head<span class="sy0">,</span>
                                 <span class="sy0">*</span>data<span class="sy0">;</span>
         <span class="kw4">unsigned</span> <span class="kw4">int</span>            truesize<span class="sy0">;</span>
         atomic_t                users<span class="sy0">;</span>
 <span class="br0">&#125;</span><span class="sy0">;</span></pre>

<p>
unde:
</p>
<ul>
<li class="level1"><div class="li"><code>next</code> și <code>prev</code> sunt pointeri către următorul, respectiv precedentul element din lista de buffer-e;</div>
</li>
<li class="level1"><div class="li"><code>dev</code> este device-ul care transmite sau primește buffer-ul;</div>
</li>
<li class="level1"><div class="li"><code>sk</code> este socket-ul asociat buffer-ului;</div>
</li>
<li class="level1"><div class="li"><code>destructor</code> este apelul callback de dealocare a buffer-ului;</div>
</li>
<li class="level1"><div class="li"><code>transport_header</code>, <code>network header</code> și <code>mac_header</code> sunt offset-uri între începutul pachetului si începutul diverselor headere din pachet. Ele sunt menținute intern de diversele niveluri de procesare prin care trece pachetul. Pentru a obține pointeri către headere, folosiți una din următoarele funcții: <a href="http://lxr.free-electrons.com/source/include/linux/tcp.h?v=3.13#L28" class="urlextern" title="http://lxr.free-electrons.com/source/include/linux/tcp.h?v=3.13#L28"  rel="nofollow">tcp_hdr</a>, <a href="http://lxr.free-electrons.com/source/include/linux/udp.h?v=3.13#L25" class="urlextern" title="http://lxr.free-electrons.com/source/include/linux/udp.h?v=3.13#L25"  rel="nofollow">udp_hdr</a>, <a href="http://lxr.free-electrons.com/source/include/linux/ip.h?v=3.13#L23" class="urlextern" title="http://lxr.free-electrons.com/source/include/linux/ip.h?v=3.13#L23"  rel="nofollow">ip_hdr</a>, etc. În principiu, fiecare protocol oferă o funcție de a obține o referință la header-ul respectivului protocol din cadrul unui pachet primit. De reținut: câmpul <code>network_header</code> nu este setat decât după ce pachetul ajunge la nivelul rețea, iar câmpul <code>transport_header</code> nu este setat decât după ce pachetul ajunge la nivelul transport.</div>
</li>
</ul>

<p>
Structura unui <a href="https://en.wikipedia.org/wiki/IPv4#Header" class="urlextern" title="https://en.wikipedia.org/wiki/IPv4#Header"  rel="nofollow">antet IP</a> (<a href="http://lxr.free-electrons.com/source/include/uapi/linux/ip.h?v=3.13#L85" class="urlextern" title="http://lxr.free-electrons.com/source/include/uapi/linux/ip.h?v=3.13#L85"  rel="nofollow">struct iphdr</a>) are următoarele câmpuri:
</p>
<pre class="code c"><span class="kw4">struct</span> iphdr <span class="br0">&#123;</span>
<span class="co2">#if defined(__LITTLE_ENDIAN_BITFIELD)</span>
         __u8    ihl<span class="sy0">:</span><span class="nu0">4</span><span class="sy0">,</span>
                 version<span class="sy0">:</span><span class="nu0">4</span><span class="sy0">;</span>
<span class="co2">#elif defined (__BIG_ENDIAN_BITFIELD)</span>
         __u8    version<span class="sy0">:</span><span class="nu0">4</span><span class="sy0">,</span>
                 ihl<span class="sy0">:</span><span class="nu0">4</span><span class="sy0">;</span>
<span class="co2">#else</span>
<span class="co2">#error  &quot;Please fix &lt;asm/byteorder.h&gt;&quot;</span>
<span class="co2">#endif</span>
         __u8    tos<span class="sy0">;</span>
         __be16  tot_len<span class="sy0">;</span>
         __be16  id<span class="sy0">;</span>
         __be16  frag_off<span class="sy0">;</span>
         __u8    ttl<span class="sy0">;</span>
         __u8    protocol<span class="sy0">;</span>
         __sum16 check<span class="sy0">;</span>
         __be32  saddr<span class="sy0">;</span>
         __be32  daddr<span class="sy0">;</span>
         <span class="coMULTI">/*The options start here. */</span>
<span class="br0">&#125;</span><span class="sy0">;</span></pre>

<p>
unde:
</p>
<ul>
<li class="level1"><div class="li"><code>protocol</code> reprezintă protocolul de nivel transport utilizat;</div>
</li>
<li class="level1"><div class="li"><code>saddr</code> reprezintă adresa IP a nodului sursă;</div>
</li>
<li class="level1"><div class="li"><code>daddr</code> reprezintă adresa IP a nodului destinație.</div>
</li>
</ul>

<p>
Structura unui <a href="https://en.wikipedia.org/wiki/Transmission_Control_Protocol#TCP_segment_structure" class="urlextern" title="https://en.wikipedia.org/wiki/Transmission_Control_Protocol#TCP_segment_structure"  rel="nofollow">antet TCP</a> (<a href="http://lxr.free-electrons.com/source/include/uapi/linux/tcp.h?v=3.13#L24" class="urlextern" title="http://lxr.free-electrons.com/source/include/uapi/linux/tcp.h?v=3.13#L24"  rel="nofollow">struct tcphdr</a>) are următoarele câmpuri:
</p>
<pre class="code c"><span class="kw4">struct</span> tcphdr <span class="br0">&#123;</span>
         __be16  source<span class="sy0">;</span>
         __be16  dest<span class="sy0">;</span>
         __be32  seq<span class="sy0">;</span>
         __be32  ack_seq<span class="sy0">;</span>
<span class="co2">#if defined(__LITTLE_ENDIAN_BITFIELD)</span>
         __u16   res1<span class="sy0">:</span><span class="nu0">4</span><span class="sy0">,</span>
                 doff<span class="sy0">:</span><span class="nu0">4</span><span class="sy0">,</span>
                 fin<span class="sy0">:</span><span class="nu0">1</span><span class="sy0">,</span>
                 syn<span class="sy0">:</span><span class="nu0">1</span><span class="sy0">,</span>
                 rst<span class="sy0">:</span><span class="nu0">1</span><span class="sy0">,</span>
                 psh<span class="sy0">:</span><span class="nu0">1</span><span class="sy0">,</span>
                 ack<span class="sy0">:</span><span class="nu0">1</span><span class="sy0">,</span>
                 urg<span class="sy0">:</span><span class="nu0">1</span><span class="sy0">,</span>
                 ece<span class="sy0">:</span><span class="nu0">1</span><span class="sy0">,</span>
                 cwr<span class="sy0">:</span><span class="nu0">1</span><span class="sy0">;</span>
<span class="co2">#elif defined(__BIG_ENDIAN_BITFIELD)</span>
         __u16   doff<span class="sy0">:</span><span class="nu0">4</span><span class="sy0">,</span>
                 res1<span class="sy0">:</span><span class="nu0">4</span><span class="sy0">,</span>
                 cwr<span class="sy0">:</span><span class="nu0">1</span><span class="sy0">,</span>
                 ece<span class="sy0">:</span><span class="nu0">1</span><span class="sy0">,</span>
                 urg<span class="sy0">:</span><span class="nu0">1</span><span class="sy0">,</span>
                 ack<span class="sy0">:</span><span class="nu0">1</span><span class="sy0">,</span>
                 psh<span class="sy0">:</span><span class="nu0">1</span><span class="sy0">,</span>
                 rst<span class="sy0">:</span><span class="nu0">1</span><span class="sy0">,</span>
                 syn<span class="sy0">:</span><span class="nu0">1</span><span class="sy0">,</span>
                 fin<span class="sy0">:</span><span class="nu0">1</span><span class="sy0">;</span>
<span class="co2">#else</span>
<span class="co2">#error  &quot;Adjust your &lt;asm/byteorder.h&gt; defines&quot;</span>
<span class="co2">#endif</span>
         __be16  window<span class="sy0">;</span>
         __sum16 check<span class="sy0">;</span>
         __be16  urg_ptr<span class="sy0">;</span>
<span class="br0">&#125;</span><span class="sy0">;</span></pre>
<ul>
<li class="level1"><div class="li"><code>source</code> reprezintă portul sursă</div>
</li>
<li class="level1"><div class="li"><code>dest</code> reprezintă portul destinație</div>
</li>
<li class="level1"><div class="li"><code>syn</code>, <code>ack</code>, <code>fin</code> sunt flag-uri folosite în protocolul TCP; pentru detalii studiați această <a href="http://www.eventhelix.com/Realtimemantra/Networking/Tcp.pdf" class="urlextern" title="http://www.eventhelix.com/Realtimemantra/Networking/Tcp.pdf"  rel="nofollow">diagramă</a>.</div>
</li>
</ul>

<p>
Structura unui <a href="https://en.wikipedia.org/wiki/User_Datagram_Protocol#Packet_structure" class="urlextern" title="https://en.wikipedia.org/wiki/User_Datagram_Protocol#Packet_structure"  rel="nofollow">antet UDP</a> (<a href="http://lxr.free-electrons.com/source/include/uapi/linux/udp.h?v=3.13#L22" class="urlextern" title="http://lxr.free-electrons.com/source/include/uapi/linux/udp.h?v=3.13#L22"  rel="nofollow">struct udphdr</a>) are următoarele câmpuri:
</p>
<pre class="code c"><span class="kw4">struct</span> udphdr <span class="br0">&#123;</span>
         __be16  source<span class="sy0">;</span>
         __be16  dest<span class="sy0">;</span>
         __be16  len<span class="sy0">;</span>
         __sum16 check<span class="sy0">;</span>
<span class="br0">&#125;</span><span class="sy0">;</span></pre>
<ul>
<li class="level1"><div class="li"><code>source</code> reprezintă portul sursă</div>
</li>
<li class="level1"><div class="li"><code>dest</code> reprezintă portul destinație</div>
</li>
</ul>

<p>
Un exemplu de accesare a informațiilor prezente în antetele unui pachet de rețea este următorul:
</p>
<pre class="code c"><span class="kw4">struct</span> sk_buff <span class="sy0">*</span>skb<span class="sy0">;</span>
&nbsp;
<span class="kw4">struct</span> iphdr <span class="sy0">*</span>iph <span class="sy0">=</span> ip_hdr<span class="br0">&#40;</span>skb<span class="br0">&#41;</span><span class="sy0">;</span>                 <span class="coMULTI">/* IP header */</span>
<span class="coMULTI">/* iph-&gt;saddr  - source IP address */</span>
<span class="coMULTI">/* iph-&gt;daddr  - destination IP address */</span>
<span class="kw1">if</span> <span class="br0">&#40;</span>iph<span class="sy0">-&gt;</span>protocol <span class="sy0">==</span> IPPROTO_TCP<span class="br0">&#41;</span> <span class="br0">&#123;</span>              <span class="coMULTI">/* TCP protocol */</span>
    <span class="kw4">struct</span> tcphdr <span class="sy0">*</span>tcph <span class="sy0">=</span> tcp_hdr<span class="br0">&#40;</span>skb<span class="br0">&#41;</span><span class="sy0">;</span>          <span class="coMULTI">/* TCP header */</span>
    <span class="coMULTI">/* tcph-&gt;source  - source TCP port */</span>
    <span class="coMULTI">/* tcph-&gt;dest    - destination TCP port */</span>
<span class="br0">&#125;</span> <span class="kw1">else</span> <span class="kw1">if</span> <span class="br0">&#40;</span>iph<span class="sy0">-&gt;</span>protocol <span class="sy0">==</span> IPPROTO_UDP<span class="br0">&#41;</span> <span class="br0">&#123;</span>       <span class="coMULTI">/* UDP protocol */</span>
    <span class="kw4">struct</span> udphdr <span class="sy0">*</span>udph <span class="sy0">=</span> udp_hdr<span class="br0">&#40;</span>skb<span class="br0">&#41;</span><span class="sy0">;</span>          <span class="coMULTI">/* UDP header */</span>
    <span class="coMULTI">/* udph-&gt;source  - source UDP port */</span>
    <span class="coMULTI">/* udph-&gt;dest    - destination UDP port */</span>
<span class="br0">&#125;</span></pre>

</div>
<!-- EDIT10 SECTION "Structura sk_buff" [20496-27016] -->
<h3 class="sectionedit11" id="conversii">Conversii</h3>
<div class="level3">

<p>
În sisteme diferite, există mai multe variante pentru ordonarea octeților într-un cuvânt (<a href="http://en.wikipedia.org/wiki/Endianness" class="urlextern" title="http://en.wikipedia.org/wiki/Endianness"  rel="nofollow">Endianness</a>), printre care: <a href="http://en.wikipedia.org/wiki/Endianness#Big-endian" class="urlextern" title="http://en.wikipedia.org/wiki/Endianness#Big-endian"  rel="nofollow">Big Endian</a> (cel mai semnificativ octet primul) și <a href="http://en.wikipedia.org/wiki/Endianness#Little-endian" class="urlextern" title="http://en.wikipedia.org/wiki/Endianness#Little-endian"  rel="nofollow">Little Endian</a> (cel mai puțin semnificativ octet primul). Având în vedere că o rețea interconectează sisteme cu platforme diferite, Internet-ul a impus o secvență standard pentru stocarea datelor numerice, numită <a href="http://en.wikipedia.org/wiki/Endianness#Endianness_in_networking" class="urlextern" title="http://en.wikipedia.org/wiki/Endianness#Endianness_in_networking"  rel="nofollow">network byte-order</a>. Spre deosebire, secvența octeților pentru reprezentarea datelor numerice pe calculatorul gazdă se numește host byte-order. Datele primite/trimise din/în rețea sunt în formatul network byte-order și trebuie facută conversia între acest format și host byte-order.
</p>

<p>
Pentru conversie există urmatoarele macrodefiniții:
</p>
<ul>
<li class="level1"><div class="li"><code>u16 </code><a href="http://lxr.free-electrons.com/source/include/linux/byteorder/generic.h?v=3.13#L140" class="urlextern" title="http://lxr.free-electrons.com/source/include/linux/byteorder/generic.h?v=3.13#L140"  rel="nofollow">htons</a><code>(u16 x)</code></div>
<ul>
<li class="level2"><div class="li">convertește un întreg pe 16 biți din host byte-order în network byte-order (<em>host to network short</em>)</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"><code>u32 </code><a href="http://lxr.free-electrons.com/source/include/linux/byteorder/generic.h?v=3.13#L138" class="urlextern" title="http://lxr.free-electrons.com/source/include/linux/byteorder/generic.h?v=3.13#L138"  rel="nofollow">htonl</a><code>(u32 x)</code></div>
<ul>
<li class="level2"><div class="li">convertește un întreg pe 32 de biți din host byte-order în network byte-order (<em>host to network long</em>)</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"><code>u16 </code><a href="http://lxr.free-electrons.com/source/include/linux/byteorder/generic.h?v=3.13#L141" class="urlextern" title="http://lxr.free-electrons.com/source/include/linux/byteorder/generic.h?v=3.13#L141"  rel="nofollow">ntohs</a><code>(u16 x)</code></div>
<ul>
<li class="level2"><div class="li">convertește un întreg pe 16 biți din network byte-order în host byte-order (<em>network to host short</em>)</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"><code>u32 </code><a href="http://lxr.free-electrons.com/source/include/linux/byteorder/generic.h?v=3.13#L139" class="urlextern" title="http://lxr.free-electrons.com/source/include/linux/byteorder/generic.h?v=3.13#L139"  rel="nofollow">ntohl</a><code>(u32 x)</code></div>
<ul>
<li class="level2"><div class="li">convertește un întreg pe 32 de biți din network byte-order în host byte-order (<em>network to host long</em>)</div>
</li>
</ul>
</li>
</ul>

</div>
<!-- EDIT11 SECTION "Conversii" [27017-28917] -->
<h3 class="sectionedit12" id="netfilter">netfilter</h3>
<div class="level3">

<p>
<a href="http://www.netfilter.org/" class="urlextern" title="http://www.netfilter.org/"  rel="nofollow">Netfilter</a> este denumirea interfeței de kernel pentru captura pachetelor de rețea cu scopul de modificare/analiză a acestora (pentru filtrare, NAT, etc.). Interfața <em>netfilter</em> este utilizată în user-space de <a href="http://www.frozentux.net/documents/iptables-tutorial/" class="urlextern" title="http://www.frozentux.net/documents/iptables-tutorial/"  rel="nofollow">iptables</a>.
</p>

<p>
În kernel-ul Linux, captura de pachete folosind netfilter se realizează prin atașarea unor hook-uri. Hook-urile pot fi precizate în diferite locații din traseul urmat de un pachet de rețea în kernel, în funcție de necesitate. O organigramă cu traseul urmat de un pachet și zonele posibile de plasare a unui hook găsiți <a href="http://linux-ip.net/nf/nfk-traversal.png" class="urlextern" title="http://linux-ip.net/nf/nfk-traversal.png"  rel="nofollow">aici</a>.
</p>

<p>
Header-ul inclus atunci când se folosește netfilter este <a href="http://lxr.free-electrons.com/source/include/linux/netfilter.h?v=3.13" class="urlextern" title="http://lxr.free-electrons.com/source/include/linux/netfilter.h?v=3.13"  rel="nofollow">linux/netfilter.h</a>.
</p>

<p>
Un hook se definește prin intermediul structurii <a href="http://lxr.free-electrons.com/source/include/linux/netfilter.h?v=3.13#L52" class="urlextern" title="http://lxr.free-electrons.com/source/include/linux/netfilter.h?v=3.13#L52"  rel="nofollow">struct nf_hook_ops</a>: 
</p>
<pre class="code c"><span class="kw4">struct</span> nf_hook_ops <span class="br0">&#123;</span>
	<span class="kw4">struct</span> list_head list<span class="sy0">;</span>
&nbsp;
	<span class="coMULTI">/* User fills in from here down. */</span>
	nf_hookfn <span class="sy0">*</span>hook<span class="sy0">;</span>
	<span class="kw4">struct</span> module <span class="sy0">*</span>owner<span class="sy0">;</span>
	<span class="kw4">int</span> pf<span class="sy0">;</span>
	<span class="kw4">int</span> hooknum<span class="sy0">;</span>
	<span class="coMULTI">/* Hooks are ordered in ascending priority. */</span>
	<span class="kw4">int</span> priority<span class="sy0">;</span>
<span class="br0">&#125;</span><span class="sy0">;</span></pre>

<p>
unde:
</p>
<ul>
<li class="level1"><div class="li"><code>pf</code> este tipul pachetului (<a href="http://lxr.free-electrons.com/source/include/linux/socket.h?v=3.13#L189" class="urlextern" title="http://lxr.free-electrons.com/source/include/linux/socket.h?v=3.13#L189"  rel="nofollow">PF_INET</a>, etc.);</div>
</li>
<li class="level1"><div class="li"><code>hooknum</code> este tipul de hook utilizat; pentru IP, acestea sunt definite în <a href="http://lxr.free-electrons.com/source/include/uapi/linux/netfilter_ipv4.h?v=3.13" class="urlextern" title="http://lxr.free-electrons.com/source/include/uapi/linux/netfilter_ipv4.h?v=3.13"  rel="nofollow">linux/netfilter_ipv4.h</a>: <pre class="code c"><span class="coMULTI">/* IP Hooks */</span>
<span class="coMULTI">/* After promisc drops, checksum checks. */</span>
<span class="co2">#define NF_INET_PRE_ROUTING	0</span>
<span class="coMULTI">/* If the packet is destined for this box. */</span>
<span class="co2">#define NF_INET_LOCAL_IN		1</span>
<span class="coMULTI">/* If the packet is destined for another interface. */</span>
<span class="co2">#define NF_INET_FORWARD		2</span>
<span class="coMULTI">/* Packets coming from a local process. */</span>
<span class="co2">#define NF_INET_LOCAL_OUT		3</span>
<span class="coMULTI">/* Packets about to hit the wire. */</span>
<span class="co2">#define NF_INET_POST_ROUTING	4</span>
<span class="co2">#define NF_INET_NUMHOOKS		5</span></pre>
</div>
</li>
<li class="level1"><div class="li"><code>priority</code> este prioritatea; prioritățile sunt definite în <a href="http://lxr.free-electrons.com/source/include/uapi/linux/netfilter_ipv4.h?v=3.13" class="urlextern" title="http://lxr.free-electrons.com/source/include/uapi/linux/netfilter_ipv4.h?v=3.13"  rel="nofollow">linux/netfilter_ipv4.h</a>: <pre class="code c"> <span class="kw2">enum</span> nf_ip_hook_priorities <span class="br0">&#123;</span>
         NF_IP_PRI_FIRST <span class="sy0">=</span> INT_MIN<span class="sy0">,</span>
         NF_IP_PRI_CONNTRACK_DEFRAG <span class="sy0">=</span> <span class="sy0">-</span><span class="nu0">400</span><span class="sy0">,</span>
         NF_IP_PRI_RAW <span class="sy0">=</span> <span class="sy0">-</span><span class="nu0">300</span><span class="sy0">,</span>
         NF_IP_PRI_SELINUX_FIRST <span class="sy0">=</span> <span class="sy0">-</span><span class="nu0">225</span><span class="sy0">,</span>
         NF_IP_PRI_CONNTRACK <span class="sy0">=</span> <span class="sy0">-</span><span class="nu0">200</span><span class="sy0">,</span>
         NF_IP_PRI_MANGLE <span class="sy0">=</span> <span class="sy0">-</span><span class="nu0">150</span><span class="sy0">,</span>
         NF_IP_PRI_NAT_DST <span class="sy0">=</span> <span class="sy0">-</span><span class="nu0">100</span><span class="sy0">,</span>
         NF_IP_PRI_FILTER <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">,</span>
         NF_IP_PRI_NAT_SRC <span class="sy0">=</span> <span class="nu0">100</span><span class="sy0">,</span>
         NF_IP_PRI_SELINUX_LAST <span class="sy0">=</span> <span class="nu0">225</span><span class="sy0">,</span>
         NF_IP_PRI_CONNTRACK_HELPER <span class="sy0">=</span> INT_MAX <span class="sy0">-</span> <span class="nu0">2</span><span class="sy0">,</span>
         NF_IP_PRI_NAT_SEQ_ADJUST <span class="sy0">=</span> INT_MAX <span class="sy0">-</span> <span class="nu0">1</span><span class="sy0">,</span>
         NF_IP_PRI_CONNTRACK_CONFIRM <span class="sy0">=</span> INT_MAX<span class="sy0">,</span>
         NF_IP_PRI_LAST <span class="sy0">=</span> INT_MAX<span class="sy0">,</span>
 <span class="br0">&#125;</span><span class="sy0">;</span></pre>
</div>
</li>
<li class="level1"><div class="li"><code>nhook_fn</code> este handler-ul apelat in momentul capturării unui pachet de rețea (în forma unei structuri <code>struct sk_buff</code>); prototipul este definit în <a href="http://lxr.free-electrons.com/source/include/linux/netfilter.h?v=3.13" class="urlextern" title="http://lxr.free-electrons.com/source/include/linux/netfilter.h?v=3.13"  rel="nofollow">linux/netfilter.h</a>: <pre class="code c"><span class="kw4">typedef</span> <span class="kw4">unsigned</span> <span class="kw4">int</span> nf_hookfn<span class="br0">&#40;</span><span class="kw4">const</span> <span class="kw4">struct</span> nf_hook_ops <span class="sy0">*</span>ops<span class="sy0">,</span>
			       <span class="kw4">struct</span> sk_buff <span class="sy0">*</span>skb<span class="sy0">,</span>
			       <span class="kw4">const</span> <span class="kw4">struct</span> net_device <span class="sy0">*</span>in<span class="sy0">,</span>
			       <span class="kw4">const</span> <span class="kw4">struct</span> net_device <span class="sy0">*</span>out<span class="sy0">,</span>
			       <span class="kw4">int</span> <span class="br0">&#40;</span><span class="sy0">*</span>okfn<span class="br0">&#41;</span><span class="br0">&#40;</span><span class="kw4">struct</span> sk_buff <span class="sy0">*</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy0">;</span></pre>
</div>
<ul>
<li class="level2"><div class="li"><code>skb</code> este pointer la pachet-ul de rețea capturat.</div>
</li>
<li class="level2"><div class="li">Se observă că se poate folosi același handler pentru mai multe hook-uri, deosebirea între acestea realizându-se cu ajutorul parametrului <code>hooknum</code>.</div>
</li>
<li class="level2"><div class="li">Un handler de captură poate întoarce una din <a href="http://lxr.free-electrons.com/source/include/uapi/linux/netfilter_ipv4.h?v=3.13#L57" class="urlextern" title="http://lxr.free-electrons.com/source/include/uapi/linux/netfilter_ipv4.h?v=3.13#L57"  rel="nofollow">constantele NF_*</a>: <pre class="code c"><span class="coMULTI">/* Responses from hook functions. */</span>
<span class="co2">#define NF_DROP 0</span>
<span class="co2">#define NF_ACCEPT 1</span>
<span class="co2">#define NF_STOLEN 2</span>
<span class="co2">#define NF_QUEUE 3</span>
<span class="co2">#define NF_REPEAT 4</span>
<span class="co2">#define NF_STOP 5</span></pre>
</div>
</li>
<li class="level2"><div class="li"><code>NF_DROP</code> este folosit pentru a filtra (ignora) un pachet, iar <code>NF_ACCEPT</code> este folosit pentru a accepta un pachet și a-l transmite mai departe.</div>
</li>
</ul>
</li>
</ul>

<p>
Înregistrarea/deînregistrarea unui hook se realizează cu ajutorul funcțiilor definite în <a href="http://lxr.free-electrons.com/source/include/linux/netfilter.h?v=3.13" class="urlextern" title="http://lxr.free-electrons.com/source/include/linux/netfilter.h?v=3.13"  rel="nofollow">linux/netfilter.h</a>: 
</p>
<pre class="code c"><span class="coMULTI">/* Function to register/unregister hook points. */</span>
<span class="kw4">int</span> nf_register_hook<span class="br0">&#40;</span><span class="kw4">struct</span> nf_hook_ops <span class="sy0">*</span>reg<span class="br0">&#41;</span><span class="sy0">;</span>
<span class="kw4">void</span> nf_unregister_hook<span class="br0">&#40;</span><span class="kw4">struct</span> nf_hook_ops <span class="sy0">*</span>reg<span class="br0">&#41;</span><span class="sy0">;</span>
<span class="kw4">int</span> nf_register_hooks<span class="br0">&#40;</span><span class="kw4">struct</span> nf_hook_ops <span class="sy0">*</span>reg<span class="sy0">,</span> <span class="kw4">unsigned</span> <span class="kw4">int</span> n<span class="br0">&#41;</span><span class="sy0">;</span>
<span class="kw4">void</span> nf_unregister_hooks<span class="br0">&#40;</span><span class="kw4">struct</span> nf_hook_ops <span class="sy0">*</span>reg<span class="sy0">,</span> <span class="kw4">unsigned</span> <span class="kw4">int</span> n<span class="br0">&#41;</span><span class="sy0">;</span></pre>
<ul>
<li class="level1"><div class="li"> <strong>Atenție!</strong> Există anumite restricții legate de utilizarea funcțiilor de extragere a antetelor dintr-un <code>struct sk_buff</code> dat ca parametru într-un hook netfilter. În timp ce antetul IP poate fi obținut de fiecare dată folosind <code>ip_hdr()</code>, antetele TCP și UDP pot fi obținute cu <code>tcp_hdr()</code>, respectiv <code>udp_hdr()</code> numai pentru pachete care pornesc dinspre sistem, și nu pentru cele care intră. În cazul din urmă, trebuie calculat manual offset-ul antetelor în pachet: <pre class="code c"><span class="co1">// Pentru pachete TCP (iph-&gt;protocol == IPPROTO_TCP)</span>
tcph <span class="sy0">=</span> <span class="br0">&#40;</span><span class="kw4">struct</span> tcphdr<span class="sy0">*</span><span class="br0">&#41;</span><span class="br0">&#40;</span><span class="br0">&#40;</span>__u32<span class="sy0">*</span><span class="br0">&#41;</span>iph <span class="sy0">+</span> iph<span class="sy0">-&gt;</span>ihl<span class="br0">&#41;</span><span class="sy0">;</span>
<span class="co1">// Pentru pachete UDP (iph-&gt;protocol == IPPROTO_UDP)</span>
udph <span class="sy0">=</span> <span class="br0">&#40;</span><span class="kw4">struct</span> udphdr<span class="sy0">*</span><span class="br0">&#41;</span><span class="br0">&#40;</span><span class="br0">&#40;</span>__u32<span class="sy0">*</span><span class="br0">&#41;</span>iph <span class="sy0">+</span> iph<span class="sy0">-&gt;</span>ihl<span class="br0">&#41;</span><span class="sy0">;</span></pre>
</div>
</li>
</ul>

<p>
Acest cod funcționează în toate situațiile de filtrare, și astfel este recomandată folosirea lui în locul funcțiilor de acces la antete.
</p>

<p>
Un exemplu de utilizare a unui hook netfilter este prezentat mai jos:
</p>
<pre class="code c"><span class="co2">#include &lt;linux/netfilter.h&gt;</span>
<span class="co2">#include &lt;linux/netfilter_ipv4.h&gt;</span>
&nbsp;
<span class="kw4">static</span> <span class="kw4">unsigned</span> <span class="kw4">int</span> my_nf_hookfn<span class="br0">&#40;</span><span class="kw4">const</span> <span class="kw4">struct</span> nf_hook_ops <span class="sy0">*</span>ops<span class="sy0">,</span>
				 <span class="kw4">struct</span> sk_buff <span class="sy0">*</span>skb<span class="sy0">,</span>
			 	 <span class="kw4">const</span> <span class="kw4">struct</span> net_device <span class="sy0">*</span>in<span class="sy0">,</span>
				 <span class="kw4">const</span> <span class="kw4">struct</span> net_device <span class="sy0">*</span>out<span class="sy0">,</span>
				 <span class="kw4">int</span> <span class="br0">&#40;</span><span class="sy0">*</span>okfn<span class="br0">&#41;</span><span class="br0">&#40;</span><span class="kw4">struct</span> sk_buff <span class="sy0">*</span><span class="br0">&#41;</span><span class="br0">&#41;</span>
<span class="br0">&#123;</span>
	<span class="coMULTI">/* process packet */</span>
	<span class="co1">//...</span>
&nbsp;
	<span class="kw1">return</span> NF_ACCEPT<span class="sy0">;</span>
<span class="br0">&#125;</span>
&nbsp;
<span class="kw4">static</span> <span class="kw4">struct</span> nf_hook_ops my_nfho <span class="sy0">=</span> <span class="br0">&#123;</span>
	.<span class="me1">owner</span>       <span class="sy0">=</span> THIS_MODULE<span class="sy0">,</span>
	.<span class="me1">hook</span>        <span class="sy0">=</span> my_nf_hookfn<span class="sy0">,</span>
	.<span class="me1">hooknum</span>     <span class="sy0">=</span> NF_INET_LOCAL_IN<span class="sy0">,</span>
	.<span class="me1">pf</span>          <span class="sy0">=</span> PF_INET<span class="sy0">,</span>
	.<span class="me1">priority</span>    <span class="sy0">=</span> NF_IP_PRI_FIRST
<span class="br0">&#125;</span><span class="sy0">;</span>
&nbsp;
<span class="kw4">int</span> __init my_hook_init<span class="br0">&#40;</span><span class="kw4">void</span><span class="br0">&#41;</span>
<span class="br0">&#123;</span>
	<span class="kw1">return</span> nf_register_hook<span class="br0">&#40;</span><span class="sy0">&amp;</span>my_nfho<span class="br0">&#41;</span><span class="sy0">;</span>
<span class="br0">&#125;</span>
&nbsp;
<span class="kw4">void</span> __exit my_hook_exit<span class="br0">&#40;</span><span class="kw4">void</span><span class="br0">&#41;</span>
<span class="br0">&#123;</span>
	nf_unregister_hook<span class="br0">&#40;</span><span class="sy0">&amp;</span>my_nfho<span class="br0">&#41;</span><span class="sy0">;</span>
<span class="br0">&#125;</span>
&nbsp;
module_init<span class="br0">&#40;</span>my_hook_init<span class="br0">&#41;</span><span class="sy0">;</span>
module_exit<span class="br0">&#40;</span>my_hook_exit<span class="br0">&#41;</span><span class="sy0">;</span></pre>

</div>
<!-- EDIT12 SECTION "netfilter" [28918-35008] -->
<h2 class="sectionedit13" id="netcat">netcat</h2>
<div class="level2">

<p>
Cand se dezvolta aplicații care includ o parte de networking, una din cele mai folosite unelte este netcat. Supranumit și “Swiss-army knife for TCP/IP”, netcat permite printre altele:
</p>
<ul>
<li class="level1"><div class="li">Inițierea de conexiuni TCP;</div>
</li>
<li class="level1"><div class="li">Așteptarea unei conexiuni TCP;</div>
</li>
<li class="level1"><div class="li">Trimiterea și primirea de pachete UDP;</div>
</li>
<li class="level1"><div class="li">Afișarea traficului sub forma de hexdump;</div>
</li>
<li class="level1"><div class="li">Execuția unui program la stabilirea conexiunii (de exemplu, un shell);</div>
</li>
<li class="level1"><div class="li">Setarea unor opțiuni speciale în pachetele trimise.</div>
</li>
</ul>

<p>
Pentru a iniția o conexiune TCP:
</p>
<pre class="code">nc hostname port</pre>

<p>
Pentru a asculta pe un port TCP:
</p>
<pre class="code">nc -l -p port</pre>

<p>
Primirea și trimiterea pachetelor UDP se realizează adăugând opțiunea <code>-u</code> în linia de comandă.
</p>

<p>
<strong>Observație:</strong> numele comenzii este <code>nc</code>; de multe ori <code>netcat</code> este un alias pentru această comandă. Există și alte implementări ale comenzii netcat, unele având parametrii puțin diferiți față de implementarea clasică. Consultați <code>man nc</code> sau rulați <code>nc -h</code> pentru a vedea modul de utilizare.
</p>

<p>
Pentru mai multe informații despre netcat, citiți acest <a href="http://team5150.com/~random/apps/netcat/Netcat_Tutorial.pdf" class="urlextern" title="http://team5150.com/~random/apps/netcat/Netcat_Tutorial.pdf"  rel="nofollow">tutorial</a>.
</p>

</div>
<!-- EDIT13 SECTION "netcat" [35009-36190] -->
<h2 class="sectionedit14" id="resurse_utile">Resurse utile</h2>
<div class="level2">
<ul>
<li class="level1"><div class="li"> Understanding Linux Network Internals</div>
</li>
<li class="level1"><div class="li"> <a href="http://www.cs.unh.edu/cnrg/gherrin/" class="urlextern" title="http://www.cs.unh.edu/cnrg/gherrin/"  rel="nofollow">Linux IP networking</a></div>
</li>
<li class="level1"><div class="li"> <a href="http://www.ecsl.cs.sunysb.edu/elibrary/linux/network/LinuxKernel.pdf" class="urlextern" title="http://www.ecsl.cs.sunysb.edu/elibrary/linux/network/LinuxKernel.pdf"  rel="nofollow">Linux Networking Kernel</a></div>
</li>
<li class="level1"><div class="li"> <a href="http://www.stllinux.org/meeting_notes/2001/0719/myTUX/" class="urlextern" title="http://www.stllinux.org/meeting_notes/2001/0719/myTUX/"  rel="nofollow">The TUX Web Server</a></div>
</li>
<li class="level1"><div class="li"> <a href="http://www.beej.us/guide/bgnet/output/html/multipage/" class="urlextern" title="http://www.beej.us/guide/bgnet/output/html/multipage/"  rel="nofollow">Beej&#039;s Guide to Network Programming Using Internet Sockets</a></div>
</li>
<li class="level1"><div class="li"> <a href="http://www.linuxjournal.com/article/7660" class="urlextern" title="http://www.linuxjournal.com/article/7660"  rel="nofollow">Kernel Korner - Network Programming in the Kernel</a></div>
</li>
<li class="level1"><div class="li"> <a href="http://www.phrack.org/issues.html?issue=61&amp;id=13&amp;mode=txt" class="urlextern" title="http://www.phrack.org/issues.html?issue=61&amp;id=13&amp;mode=txt"  rel="nofollow">Hacking the Linux Kernel Network Stack</a></div>
</li>
<li class="level1"><div class="li"> <a href="http://www.netfilter.org/" class="urlextern" title="http://www.netfilter.org/"  rel="nofollow">The netfilter.org project</a></div>
</li>
<li class="level1"><div class="li"> <a href="http://www.topsight.net/article.php?story=2003050621055083" class="urlextern" title="http://www.topsight.net/article.php?story=2003050621055083"  rel="nofollow">Using Netfilter hooks</a></div>
</li>
<li class="level1"><div class="li"> <a href="http://www.6test.edu.cn/~lujx/linux_networking/0131777203_ch19lev1sec3.html" class="urlextern" title="http://www.6test.edu.cn/~lujx/linux_networking/0131777203_ch19lev1sec3.html"  rel="nofollow">The Netfilter Architecture of Linux 2.4</a></div>
</li>
<li class="level1"><div class="li"> <a href="http://www.linuxfoundation.org/en/Net:Main_Page" class="urlextern" title="http://www.linuxfoundation.org/en/Net:Main_Page"  rel="nofollow">Linux Foundation Networking Page</a></div>
</li>
</ul>

</div>
<!-- EDIT14 SECTION "Resurse utile" [36191-] --><div class="footnotes">
<div class="fn"><sup><a href="lab10.html#fnt__1" id="fn__1" class="fn_bot">1)</a></sup> 
hton* – despre funcțiile <code>htons</code>, <code>htonl</code> vom discuta la secțiunea <a href="lab10.html#conversii" title="so2:laboratoare:lab10 ↵" class="wikilink1">Conversii</a>.</div>
</div>
</div>
</body>
</html>
