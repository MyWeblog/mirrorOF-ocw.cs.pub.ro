    
    

<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
  <meta charset="utf-8" />
  <title>so2:laboratoare:lab09:exercitii</title>
<meta name="generator" content="DokuWiki"/>
<meta name="robots" content="index,follow"/>
<meta name="date" content="2016-04-25T19:46:31+0300"/>
<meta name="keywords" content="so2,laboratoare,lab09,exercitii"/>
<link rel="search" type="application/opensearchdescription+xml" href="../../../../../lib/exe/opensearch.php" title="CS Open CourseWare"/>
<link rel="start" href="../../../../../../courses.1.html"/>
<link rel="alternate" type="application/rss+xml" title="Recent Changes" href="../../../../../feed.php"/>
<link rel="alternate" type="application/rss+xml" title="Current Namespace" href="../../../../../feed.php%3Fmode=list&amp;ns=so2:laboratoare:lab09"/>
<link rel="alternate" type="text/html" title="Plain HTML" href="exercitii.html"/>
<link rel="canonical" href="../../../../../so2/laboratoare/lab09/exercitii.html"/>
<link rel="stylesheet" type="text/css" href="../../../../../lib/exe/css.php%3Ft=arctic&amp;tseed=1476798676.css"/>
<script type="text/javascript">/*<![CDATA[*/var NS='so2:laboratoare:lab09';var JSINFO = {"id":"so2:laboratoare:lab09:exercitii","namespace":"so2:laboratoare:lab09","isadmin":0,"isauth":0};
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="../../../../../lib/exe/js.php%3Ftseed=1476798676"></script>
<script type="text/x-mathjax-config">/*<![CDATA[*/MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ["$","$"], ["\\(","\\)"] ],
        displayMath: [ ["$$","$$"], ["\\[","\\]"] ],
        processEscapes: true
    }
});
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
<script type="text/javascript">/*<![CDATA[*/
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
		  
/*!]]>*/</script>
<script type="text/javascript">/*<![CDATA[*/
var pageTracker = _gat._getTracker("UA-38383934-1");
pageTracker._initData();
pageTracker._trackPageview();
		  
/*!]]>*/</script>
</head>
<body>
<div class="dokuwiki export">
<!-- TOC START -->
<div id="dw__toc">
<h3 class="toggle">Table of Contents</h3>
<div>

<ul class="toc">
<li class="level1"><div class="li"><a href="exercitii.html#laborator_9exercitii">Laborator 9: Exerciții</a></div>
<ul class="toc">
<li class="level2"><div class="li"><a href="exercitii.html#p_myfs">[4p] myfs</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="exercitii.html#p_operatii_pentru_lucrul_cu_directoare_myfs">1. [2p] Operații pentru lucrul cu directoare (myfs)</a></div>
<ul class="toc">
<li class="level4"><div class="li"><a href="exercitii.html#testare">Testare</a></div></li>
</ul>
</li>
<li class="level3"><div class="li"><a href="exercitii.html#p_operatii_pentru_lucrul_cu_fisiere_myfs">2. [2p] Operații pentru lucrul cu fișiere (myfs)</a></div>
<ul class="toc">
<li class="level4"><div class="li"><a href="exercitii.html#testare1">Testare</a></div></li>
</ul>
</li>
</ul>
</li>
<li class="level2"><div class="li"><a href="exercitii.html#p_minfs">[7p] minfs</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="exercitii.html#p_operatia_iterate_minfs">3. [2p] Operația iterate (minfs)</a></div>
<ul class="toc">
<li class="level4"><div class="li"><a href="exercitii.html#testare2">Testare</a></div></li>
</ul>
</li>
<li class="level3"><div class="li"><a href="exercitii.html#p_operatia_lookup_minfs">4. [1.5p] Operația lookup (minfs)</a></div>
<ul class="toc">
<li class="level4"><div class="li"><a href="exercitii.html#testare3">Testare</a></div></li>
</ul>
</li>
<li class="level3"><div class="li"><a href="exercitii.html#p_operatia_create_minfs">5. [3.5p] Operația create (minfs)</a></div>
<ul class="toc">
<li class="level4"><div class="li"><a href="exercitii.html#testare4">Testare</a></div></li>
</ul>
</li>
</ul>
</li>
<li class="level2"><div class="li"><a href="exercitii.html#solutii">Soluții</a></div></li>
</ul></li>
</ul>
</div>
</div>
<!-- TOC END -->

<h1 class="sectionedit1" id="laborator_9exercitii">Laborator 9: Exerciții</h1>
<div class="level1">

<p>
Pentru desfășurarea laboratorului pornim de la <a href="http://elf.cs.pub.ro/so2/res/laboratoare/lab09-tasks.zip" class="urlextern" title="http://elf.cs.pub.ro/so2/res/laboratoare/lab09-tasks.zip"  rel="nofollow">arhiva de sarcini a laboratorului</a>. Descărcăm și decomprimăm arhiva în directorul <code>so2/</code> din directorul home al utilizatorului <code>student</code> de pe sistemul de bază (stația <code>mjolnir</code>):
</p>
<pre class="code bash"><span class="co4">student@mjolnir:~$ </span><span class="kw3">cd</span> so2<span class="sy0">/</span>
student<span class="sy0">@</span>mjolnir:~<span class="sy0">/</span>so2$ <span class="kw2">wget</span> http:<span class="sy0">//</span>elf.cs.pub.ro<span class="sy0">/</span>so2<span class="sy0">/</span>res<span class="sy0">/</span>laboratoare<span class="sy0">/</span>lab09-tasks.zip
student<span class="sy0">@</span>mjolnir:~<span class="sy0">/</span>so2$ <span class="kw2">unzip</span> lab09-tasks.zip
student<span class="sy0">@</span>mjolnir:~<span class="sy0">/</span>so2$ <span class="kw2">tree</span> lab09-tasks</pre>

<p>
În cadrul directorului <code>lab09-tasks/</code> se găsesc resursele necesare pentru dezvoltarea exercițiilor de mai jos: fișiere schelet de cod sursă, fișiere Makefile și Kbuild, scripturi și programe de test.
</p>

<p>
Vom dezvolta exercițiile pe sistemul fizic și apoi le vom testa pe <a href="../../../../../so2/resurse/masini-virtuale.html" class="wikilink1" title="so2:resurse:masini-virtuale">mașina virtuală QEMU</a>. După editarea și compilarea unui modul de kernel îl vom copia în directorul dedicat pentru mașina virtuală QEMU folosind o comandă de forma
</p>
<pre class="code bash"><span class="co4">student@mjolnir:~/so2$ </span><span class="kw2">cp</span> <span class="sy0">/</span>path<span class="sy0">/</span>to<span class="sy0">/</span>module.ko ~<span class="sy0">/</span>so2<span class="sy0">/</span>qemu-vm<span class="sy0">/</span>fsimg<span class="sy0">/</span>root<span class="sy0">/</span>modules<span class="sy0">/</span></pre>

<p>
 unde <code>/path/to/module.ko</code> este calea către fișierul obiect aferent modulului de kernel. Apoi vom porni, din directorul <code>~/so2/qemu-vm/</code> mașina virtuală QEMU folosind comanda
</p>
<pre class="code bash"><span class="co4">student@mjolnir:~/so2/qemu-vm$ </span><span class="kw2">make</span></pre>

<p>
După pornirea mașinii virtuale QEMU vom putea folosi comenzi în fereastra QEMU pentru a încărca și descărca modulul de kernel:
</p>
<pre class="code"># insmod modules/module-name.ko
# rmmod module/module-name</pre>

<p>
 unde <code>module-name</code> este numele modulului de kernel.
</p>

<p>
<p><div class="noteclassic">
Pentru dezvoltarea laboratorului, este recomandat să folosim trei terminale sau, mai bine, trei tab-uri de terminal. Pentru a deschide un nou tab de terminal folosim combinația de taste <code>Ctrl+Alt+t</code>. Cele trei tab-uri de terminal îndeplinesc următoarele roluri:
</p>
<ol>
<li class="level1"><div class="li"> În primul tab de terminal dezvoltăm modulul de kernel: editare, compilare, copiere în directorul dedicat pentru mașina virtaulă QEMU. Lucrăm în directorul aferent rezultat în urma decomprimării arhivei de sarcini a laboratorului.</div>
</li>
<li class="level1"><div class="li"> În al doilea tab de terminal pornim mașina virtuală QEMU și apoi testăm modulul de kernel: încărcare/descărcare modul, rulare teste. Lucrăm în directorul aferent mașinii virtuale: <code>~/so2/qemu-vm/</code>.</div>
</li>
<li class="level1"><div class="li"> În al treilea tab de terminal pornim un server UDP care să primească <a href="../../../../../so2/laboratoare/lab02.html#netconsole" class="wikilink1" title="so2:laboratoare:lab02">mesajele de netconsole</a>. Nu contează în ce director ne aflăm. Folosim comanda<pre class="code bash"><span class="co4">student@mjolnir:~$ </span>netcat <span class="re5">-lup</span> <span class="nu0">6666</span></pre>
</div>
</li>
</ol>

<p>

</div></p>
</p>

<p>
<p><div class="noteimportant">
Să parcurgeți întreg enunțul unui exercițiu înainte de a vă apuca de rezolvarea sa.
</p>

<p>
Atunci când primiți un val de erori și warning-uri, urmăriți <strong>prima</strong> eroare/warning și rezolvați-o pe aceea înainte de a vă apuca de celelalte erori.

</div></p>
</p>

</div>
<!-- EDIT1 SECTION "Laborator 9: Exerciții" [1-2909] -->
<h2 class="sectionedit2" id="p_myfs">[4p] myfs</h2>
<div class="level2">

<p>
Pentru exercițiile din continuare vom folosi sistemul de fișiere <code>myfs</code> a cărui dezvoltare am început-o <a href="../../../../../so2/laboratoare/lab09.html" class="wikilink1" title="so2:laboratoare:lab09">laboratorul trecut</a>. Ne-am oprit la montarea sistemului de fișiere iar acum vom continua cu operațiile pe directoare și fișiere obișnuite. La finalul acestor exerciții vom putea crea, modifica și șterge directoare și fișiere obișnuite.
</p>

<p>
Vom folosi preponderent structurile VFS <a href="http://lxr.free-electrons.com/source/include/linux/fs.h?v=3.13#L519" class="urlextern" title="http://lxr.free-electrons.com/source/include/linux/fs.h?v=3.13#L519"  rel="nofollow">inode</a> și <a href="http://lxr.free-electrons.com/source/include/linux/dcache.h?v=3.13#L108" class="urlextern" title="http://lxr.free-electrons.com/source/include/linux/dcache.h?v=3.13#L108"  rel="nofollow">dentry</a>. Structura <a href="http://lxr.free-electrons.com/source/include/linux/fs.h?v=3.13#L519" class="urlextern" title="http://lxr.free-electrons.com/source/include/linux/fs.h?v=3.13#L519"  rel="nofollow">inode</a> definește un fișier (de orice tip: obișnuit, director, link), în vreme ce structura <a href="http://lxr.free-electrons.com/source/include/linux/dcache.h?v=3.13#L108" class="urlextern" title="http://lxr.free-electrons.com/source/include/linux/dcache.h?v=3.13#L108"  rel="nofollow">dentry</a> definește un nume, adică o intrare într-un director (<em>directory entry</em>).
</p>

<p>
Pentru aceasta vom accesa subdirectorul <code>myfs/</code> din <a href="http://elf.cs.pub.ro/so2/res/laboratoare/lab09-tasks.zip" class="urlextern" title="http://elf.cs.pub.ro/so2/res/laboratoare/lab09-tasks.zip"  rel="nofollow">arhiva de sarcini a laboratorului</a>. Scheletul de cod conține rezolvarea laboratorului trecut; vom porni de la aceasta. Ca și în laboratorul trecut, vom folosi ca punct de plecare <a href="http://lxr.free-electrons.com/source/fs/ramfs?v=3.13" class="urlextern" title="http://lxr.free-electrons.com/source/fs/ramfs?v=3.13"  rel="nofollow">implementarea sistemului de fișiere ramfs</a>.
</p>

</div>
<!-- EDIT2 SECTION "[4p] myfs" [2910-4258] -->
<h3 class="sectionedit3" id="p_operatii_pentru_lucrul_cu_directoare_myfs">1. [2p] Operații pentru lucrul cu directoare (myfs)</h3>
<div class="level3">

<p>
Pentru început vom implementa operațiile de lucru cu directoare. Operația de creare a unui fișier sau ștergere a unui fișier este tot operație de lucru cu directoare; aceste operații duc la adăugarea sau ștergerea unei intrări în director (<em>dentry</em> – <em>directory entry</em>).
</p>

<p>
La finalul acestui exercițiu vom putea crea și șterge intrări în sistemul de fișiere. Nu vom putea citi și scrie în fișiere obișnuite; vom face acest lucru la exercițiul următor.
</p>

<p>
Urmăriți indicațiile marcate cu <code>TODO 1</code> care vă vor ghida pașii pe care trebuie să îi faceți.
</p>

<p>
Va trebui să precizați următoarele operații pentru directoare:
</p>
<ul>
<li class="level1"><div class="li"> creare de fișier (<code>create</code>)</div>
</li>
<li class="level1"><div class="li"> căutare (<code>lookup</code>)</div>
</li>
<li class="level1"><div class="li"> link (<code>link</code>)</div>
</li>
<li class="level1"><div class="li"> creare de director (<code>mkdir</code>)</div>
</li>
<li class="level1"><div class="li"> ștergere (<code>rmdir</code> și <code>unlink</code>)</div>
</li>
<li class="level1"><div class="li"> creare de nod (<code>mknod</code>)</div>
</li>
<li class="level1"><div class="li"> redenumire (<code>rename</code>)</div>
</li>
</ul>

<p>
Pentru aceasta, definiți structura <code>myfs_dir_inode_operations</code> în cod, unde este marcat <code>TODO 1&amp;2: Fill operations structures.</code> Pentru început definiți <strong>doar</strong> structura <code>myfs_dir_inode_operations</code>; structurile <code>myfs_file_inode_operations</code>, <code>myfs_file_operations</code> și <code>myfs_aops</code> le veți defini la <a href="exercitii.html#p_operatii_pentru_lucrul_cu_fisiere_myfs" title="so2:laboratoare:lab09:exercitii ↵" class="wikilink1">exercițiul următor</a>.
</p>

<p>
<p><div class="notetip">
Parcurgeți secțiunea <a href="../../../../../so2/laboratoare/lab09.html#operatii_asupra_inode-urilor_de_tip_director" class="wikilink1" title="so2:laboratoare:lab09">Operații asupra inode-urilor de tip director</a>.
</p>

<p>
Ca model urmăriți structura <a href="http://lxr.free-electrons.com/source/fs/ramfs/inode.c?v=3.13#L141" class="urlextern" title="http://lxr.free-electrons.com/source/fs/ramfs/inode.c?v=3.13#L141"  rel="nofollow">ramfs_dir_inode_operations</a>.

</div></p>
</p>

<p>
Implementați operațiile <code>mkdir</code> și <code>create</code> pe inode-urile director în cadrul funcțiilor <code>myfs_mkdir()</code> și <code>myfs_create</code>. Aceste operații vă vor permite, respectiv, crearea de directoare și de fișiere în sistemul de fișiere.
</p>

<p>
<p><div class="notetip">
Recomandăm modularizarea codului folosind o funcție <code>mknod</code>, pe care o veți putea folosi și la exercițiul următor.
</p>

<p>
Pentru citire și alocare de inode folosiți funcția <code>myfs_get_inode</code>, deja implementată.
</p>

<p>
Ca model urmăriți implementările din <a href="http://lxr.free-electrons.com/source/fs/ramfs/?v=3.7" class="urlextern" title="http://lxr.free-electrons.com/source/fs/ramfs/?v=3.7"  rel="nofollow">sistemul de fișiere ramfs</a>:
</p>
<ul>
<li class="level1"><div class="li"> <a href="http://lxr.free-electrons.com/source/fs/ramfs/inode.c?v=3.13#L90" class="urlextern" title="http://lxr.free-electrons.com/source/fs/ramfs/inode.c?v=3.13#L90"  rel="nofollow">ramfs_mknod</a></div>
</li>
<li class="level1"><div class="li"> <a href="http://lxr.free-electrons.com/source/fs/ramfs/inode.c?v=3.13#L109" class="urlextern" title="http://lxr.free-electrons.com/source/fs/ramfs/inode.c?v=3.13#L109"  rel="nofollow">ramfs_mkdir</a></div>
</li>
<li class="level1"><div class="li"> <a href="http://lxr.free-electrons.com/source/fs/ramfs/inode.c?v=3.13#L117" class="urlextern" title="http://lxr.free-electrons.com/source/fs/ramfs/inode.c?v=3.13#L117"  rel="nofollow">ramfs_create</a></div>
</li>
</ul>

<p>

</div></p>
</p>

<p>
Pentru celelalte funcții folosiți apeluri generice (<code>simple_*</code>) deja definite în VFS.
</p>

<p>
În cadrul funcției <code>myfs_get_inode</code> inițializați câmpurile de operații ale inode-urilor de tip director:
</p>
<ul>
<li class="level1"><div class="li"> <code>i_op</code> inițializat la adresa structurii <code>myfs_dir_inode_operations</code>;</div>
</li>
<li class="level1"><div class="li"> <code>i_fop</code> inițializat la adresa structurii <a href="http://lxr.free-electrons.com/source/fs/libfs.c?v=3.13#L192" class="urlextern" title="http://lxr.free-electrons.com/source/fs/libfs.c?v=3.13#L192"  rel="nofollow">simple_dir_operations</a>, predefinită în VFS.</div>
</li>
</ul>

<p>
<p><div class="notetip">
<code>i_op</code> este un pointer către o structură de tipul <a href="http://lxr.free-electrons.com/source/include/linux/fs.h?v=3.13#L1552" class="urlextern" title="http://lxr.free-electrons.com/source/include/linux/fs.h?v=3.13#L1552"  rel="nofollow">struct inode_operations</a> cu operații care au de-a face cu inode-ul, adică, pentru un director, crearea unei noi intrări, listarea intrărilor, ștergerea de intrări.
</p>

<p>
<code>i_fop</code> este un pointer către o structură de tipul <a href="http://lxr.free-electrons.com/source/include/linux/fs.h?v=3.13#L1521" class="urlextern" title="http://lxr.free-electrons.com/source/include/linux/fs.h?v=3.13#L1521"  rel="nofollow">struct file_operations</a> cu operații care au de-a face cu structura file aferentă inode-lui, adică operații de tipul read, write și lseek.

</div></p>
</p>

</div>

<h4 id="testare">Testare</h4>
<div class="level4">

<p>
O dată realizată modulul putem testa crearea de fișiere și directoare. Pentru aceasta, compilăm modulul de kernel și copiem fișierul rezultat (<code>myfs.ko</code>) și scripturile de testare (<code>test-myfs-{1,2}.sh</code>) în directorul aferent mașinii virtuale, apoi pornim mașina virtuală .
</p>

<p>
După ce pornim mașinavirtuală, inserăm modulul, creăm punctul de montare și montăm sistemul de fișiere:
</p>
<pre class="code"># insmod myfs.ko
# mkdir -p /mnt/myfs
# mount -t myfs none /mnt/myfs</pre>

<p>
Acum putem crea ierarhii de fișiere și subdirectoare în directorul montat (<code>/mnt/myfs</code>). Folosim comenzi precum cele de mai jos:
</p>
<pre class="code"># touch /mnt/myfs/peanuts.txt
# mkdir -p /mnt/myfs/mountain/forest
# touch /mnt/myfs/mountain/forest/tree.txt
# rm /mnt/myfs/mountain/forest/tree.txt
# rmdir /mnt/myfs/mountain/forest</pre>

<p>
În acest moment nu putem însă citi sau scrie în fișiere. La rularea comenzilor
</p>
<pre class="code"># echo &quot;chocolate&quot; &gt; /mnt/myfs/peanuts.txt
# cat /mnt/myfs/peanuts.txt</pre>

<p>
vom obține eroare. Aceasta se întâmplă pentru că nu am implementat operațiile pentru lucrul cu fișiere; vom face acest lucru în continuare.
</p>

<p>
Pentru a descărca modulul din kernel folosim comanda
</p>
<pre class="code">rmmod myfs</pre>

<p>
Pentru testarea funcționalităților oferite de modul putem folosi scriptul dedicat:
</p>
<pre class="code"># ./test-myfs-1.sh</pre>

<p>
Dacă implementarea este validă, nu vor fi afișate mesaje de eroare în urma rulării scriptului de mai sus.
</p>

</div>
<!-- EDIT3 SECTION "1. [2p] Operații pentru lucrul cu directoare (myfs)" [4259-9230] -->
<h3 class="sectionedit4" id="p_operatii_pentru_lucrul_cu_fisiere_myfs">2. [2p] Operații pentru lucrul cu fișiere (myfs)</h3>
<div class="level3">

<p>
Dorim să implementăm operațiile pentru lucrul cu fișiere, adică modificarea conținutului unui fișier: scrierea într-un fișier, modificarea conținutului, trunchierea unui fișier.
 Pentru aceasta veți preciza operațiile descrise în cadrul structurilor <a href="http://lxr.free-electrons.com/source/include/linux/fs.h?v=3.13#L1552" class="urlextern" title="http://lxr.free-electrons.com/source/include/linux/fs.h?v=3.13#L1552"  rel="nofollow">struct inode_operations</a>, <a href="http://lxr.free-electrons.com/source/include/linux/fs.h?v=3.13#L1521" class="urlextern" title="http://lxr.free-electrons.com/source/include/linux/fs.h?v=3.13#L1521"  rel="nofollow">struct file_operations</a> și <a href="http://lxr.free-electrons.com/source/include/linux/fs.h?v=3.13#L347" class="urlextern" title="http://lxr.free-electrons.com/source/include/linux/fs.h?v=3.13#L347"  rel="nofollow">struct address_space_operations</a> pentru fișier.
</p>

<p>
Urmăriți indicațiile marcate cu <code>TODO 2</code> care vă vor ghida pașii pe care trebuie să îi faceți.
</p>

<p>
Începeți cu definirea structurilor <code>myfs_file_inode_operations</code> și <code>myfs_file_operations</code>. Definirea structurilor o faceți mai jos în cod, unde este marcat <code>TODO 1 &amp; 2: Fill operations structures.</code>
</p>

<p>
<p><div class="notetip">
Parcurgeți secțiunea <a href="../../../../../so2/laboratoare/lab09.html#operatii_asupra_inode-urilor_de_tip_fisier" class="wikilink1" title="so2:laboratoare:lab09">Operații asupra inode-urilor de tip fișier</a>.
</p>

<p>
Folosiți funcțiile generice oferite de VFS.
</p>

<p>
Exemplu de implementare este <a href="http://lxr.free-electrons.com/source/fs/ramfs/?v=3.13" class="urlextern" title="http://lxr.free-electrons.com/source/fs/ramfs/?v=3.13"  rel="nofollow">sistemul de fișiere ramfs</a>. Urmăriți implementarea structurilor <a href="http://lxr.free-electrons.com/source/fs/ramfs/file-mmu.c?v=3.13#L52" class="urlextern" title="http://lxr.free-electrons.com/source/fs/ramfs/file-mmu.c?v=3.13#L52"  rel="nofollow">ramfs_file_inode_operations</a> și <a href="http://lxr.free-electrons.com/source/fs/ramfs/file-mmu.c?v=3.13#L40" class="urlextern" title="http://lxr.free-electrons.com/source/fs/ramfs/file-mmu.c?v=3.13#L40"  rel="nofollow">ramfs_file_operations</a>.

</div></p>
</p>

<p>
În cadrul funcției <code>myfs_get_inode</code> inițializați câmpurile de operații ale inode-urilor de tip fișier (<em>regular file</em>):
</p>
<ul>
<li class="level1"><div class="li"> <code>i_op</code> inițializat la <code>myfs_file_inode_operations</code>;</div>
</li>
<li class="level1"><div class="li"> <code>i_fop</code> inițializat la <code>myfs_file_operations</code>.</div>
</li>
</ul>

<p>
Continuați cu definirea structurii <code>myfs_aops</code>.
</p>

<p>
<p><div class="notetip">
Parcurgeți secțiunea <a href="../../../../../so2/laboratoare/lab09.html#operatii_asupra_inode-urilor_de_tip_fisier" class="wikilink1" title="so2:laboratoare:lab09">Operații asupra inode-urilor de tip fișier</a>.
</p>

<p>
Folosiți funcțiile generice oferite de VFS.
</p>

<p>
Exemplu de implementare este <a href="http://lxr.free-electrons.com/source/fs/ramfs/?v=3.13" class="urlextern" title="http://lxr.free-electrons.com/source/fs/ramfs/?v=3.13"  rel="nofollow">sistemul de fișiere ramfs</a>: structura <a href="http://lxr.free-electrons.com/source/fs/ramfs/file-mmu.c?v=3.13#L33" class="urlextern" title="http://lxr.free-electrons.com/source/fs/ramfs/file-mmu.c?v=3.13#L33"  rel="nofollow">ramfs_aops</a>.
</p>

<p>
Nu este nevoie să definiți funcție de tipul <code>set_page_dirty</code>.

</div></p>
</p>

<p>
Inițializați câmpul <code>i_mapping-&gt;a_ops</code> al structurii <a href="http://lxr.free-electrons.com/source/include/linux/fs.h?v=3.13#L519" class="urlextern" title="http://lxr.free-electrons.com/source/include/linux/fs.h?v=3.13#L519"  rel="nofollow">inode</a> la <code>myfs_aops</code>.
</p>

</div>

<h4 id="testare1">Testare</h4>
<div class="level4">

<p>
Pentru testare, folosim pașii descriși la exercițiul anterior. În plus față de acei pași acum vom putea citi, scrie și modifica un fișier folosind comenzi precum cele de mai jos:
</p>
<pre class="code"># echo &quot;chocolate&quot; &gt; /mnt/myfs/peanuts.txt
# cat /mnt/myfs/peanuts.txt</pre>

<p>
Pentru testarea funcționalităților oferite de modul putem folosi scriptul dedicat:
</p>
<pre class="code"># ./test-myfs-2.sh</pre>

<p>
Dacă implementarea este validă, nu vor fi afișate mesaje de eroare în urma rulării scriptului de mai sus.
</p>

</div>
<!-- EDIT4 SECTION "2. [2p] Operații pentru lucrul cu fișiere (myfs)" [9231-12217] -->
<h2 class="sectionedit5" id="p_minfs">[7p] minfs</h2>
<div class="level2">

<p>
Pentru exercițiile din continuare vom folosi sistemul de fișiere <code>minfs</code> a cărui dezvoltare am început-o <a href="../../../../../so2/laboratoare/lab09.html" class="wikilink1" title="so2:laboratoare:lab09">laboratorul trecut</a>. Este vorba de un sistem de fișiere cu suport pe disc. Ne-am oprit la montarea sistemului de fișiere iar acum vom continua cu operațiile pe directoare și fișiere obișnuite. La finalul acestor exerciții vom putea crea, și șterge intrări în sistemul de fișiere.
</p>

<p>
Vom folosi preponderent structurile VFS <a href="http://lxr.free-electrons.com/source/include/linux/fs.h?v=3.13#L519" class="urlextern" title="http://lxr.free-electrons.com/source/include/linux/fs.h?v=3.13#L519"  rel="nofollow">inode</a> și <a href="http://lxr.free-electrons.com/source/include/linux/dcache.h?v=3.13#L108" class="urlextern" title="http://lxr.free-electrons.com/source/include/linux/dcache.h?v=3.13#L108"  rel="nofollow">dentry</a>. Structura <a href="http://lxr.free-electrons.com/source/include/linux/fs.h?v=3.13#L519" class="urlextern" title="http://lxr.free-electrons.com/source/include/linux/fs.h?v=3.13#L519"  rel="nofollow">inode</a> definește un fișier (de orice tip: obișnuit, director, link), în vreme ce structura <a href="http://lxr.free-electrons.com/source/include/linux/dcache.h?v=3.13#L108" class="urlextern" title="http://lxr.free-electrons.com/source/include/linux/dcache.h?v=3.13#L108"  rel="nofollow">dentry</a> definește un nume, adică o intrare într-un director (<em>directory entry</em>).
</p>

<p>
Pentru aceasta vom accesa subdirectorul <code>minfs/</code> din <a href="http://elf.cs.pub.ro/so2/res/laboratoare/lab09-tasks.zip" class="urlextern" title="http://elf.cs.pub.ro/so2/res/laboratoare/lab09-tasks.zip"  rel="nofollow">arhiva de sarcini a laboratorului</a>. Scheletul de cod conține rezolvarea laboratorului trecut; vom porni de la aceasta. Ca și în laboratorul trecut, vom folosi ca punct de plecare <a href="http://lxr.free-electrons.com/source/fs/minix?v=3.13" class="urlextern" title="http://lxr.free-electrons.com/source/fs/minix?v=3.13"  rel="nofollow">implementarea sistemului de fișiere minix</a>.
</p>

<p>
Vom folosi utilitarul de formatare <code>mkfs.minfs</code> compilabil folosind fișierul Makefile aferent cu ajutorul comenzii
</p>
<pre class="code bash"><span class="kw2">make</span> <span class="re5">-f</span> Makefile.format</pre>

<p>
Utilitarul de formatare se aplică asupra unui disc al mașinii virtuale cu o comandă de forma
</p>
<pre class="code"># ./mkfs.minfs /dev/sdb</pre>

<p>
În urma formatării, discul capătă o structură precum cea din diagrama de mai jos:
<a href="../../../../../_detail/so2/laboratoare/lab10/minfs_arch.png%3Fid=so2%253Alaboratoare%253Alab09%253Aexercitii.html" class="media" title="so2:laboratoare:lab10:minfs_arch.png"><img src="../../../../../_media/so2/laboratoare/lab10/minfs_arch.png" class="mediacenter" title=" Layout MinFS" alt=" Layout MinFS" /></a>
</p>

<p>
Așa cum reiese din diagramă, <code>minfs</code> este un sistem de fișiere minimalist. <code>minfs</code> conține maxim 32 de inode-uri, fiecare inode având alocat un singur bloc; adică dimensiunea intrărilor este limitată la dimensiunea blocului. Superblocul conține o mască (<code>imap</code>) de 32 biți, fiecare bit indicând utilizarea inode-ului respectiv.
</p>

<p>
Rezolvarea exercițiilor este grupată în două seturi de pași. Pentru primul set de pași (exercițiile 3 și 4), vom folosi subdirectorul <code>minfs/stage1/</code>, iar pentru al doilea set de pași (exercițiul 5), vom folosi subdirectorul <code>minfs/stage2/</code>.
</p>

<p>
<p><div class="noteimportant">
Înainte de a începe să lucrați parcurgeți fișierul header <code>minfs/stage1/minfs.h</code>. În acest fișier se găsesc structurile și macro-urile care vor fi folosite în cadrul exercițiilor. Aceste structuri și macro-uri definesc sistemul de fișiere, așa cum este descris în diagrama de mai sus.

</div></p>
</p>

</div>
<!-- EDIT5 SECTION "[7p] minfs" [12218-14988] -->
<h3 class="sectionedit6" id="p_operatia_iterate_minfs">3. [2p] Operația iterate (minfs)</h3>
<div class="level3">

<p>
În primă fază ne dorim să putem lista conținutul directorului rădăcină. Pentru aceasta trebuie să putem citi intrările din directorul rădăcină, adică să implementăm operația <code>iterate</code>. Operația <code>iterate</code> este un câmp în cadrul structurii <code>minfs_dir_operations</code> (de tipul <span class="curid"><a href="../../../../../so2/laboratoare/lab09/exercitii.html" class="wikilink1" title="so2:laboratoare:lab09:exercitii">file_operations</a></span> și este implmenentată de funcția <code>minfs_readdir</code>. Această funcție trebuie să o implementăm.
</p>

<p>
Urmăriți indicațiile marcate cu <code>TODO 3</code> care vă vor ghida pașii pe care trebuie să îi faceți.
</p>

<p>
<p><div class="notetip">
Parcurgeți secțiunea <a href="../../../../../so2/laboratoare/lab09.html#operatii_asupra_inode-urilor_de_tip_director" class="wikilink1" title="so2:laboratoare:lab09">Operații asupra inode-urilor de tip director</a>.
</p>

<p>
Ca puncte de plecare, urmăriți funcția <a href="http://lxr.free-electrons.com/source/fs/minix/dir.c?v=3.13#L85" class="urlextern" title="http://lxr.free-electrons.com/source/fs/minix/dir.c?v=3.13#L85"  rel="nofollow">minix_readdir</a>. Funcția este destul de complicată, dar vă oferă o perspectivă a pașilor pe care îi aveți de făcut.
</p>

<p>
Urmăriți în <code>minfs.c</code> și <code>minfs.h</code> definițiile structurilor <code>struct minfs_inode_info</code>, <code>struct minfs_inode</code> și <code>struct minfs_dir_entry</code>. Le veți folosi pe parcursul implementării funcției <code>minfs_readdir</code>.

</div></p>
</p>

<p>
Obțineți inode-ul și structura <code>struct minfs_inode_info</code> aferente directorului. Structura <code>struct minfs_inode_info</code> este utilă pentru a afla blocul de date al directorului.
Din cadrul acestei structuri obțineți câmpul <code>data_block</code>, reprezentând indexul blocului de date pe disc.
</p>

<p>
<p><div class="notetip">
Pentru obținerea structurii <code>struct minfs_inode_info</code> folosiți <a href="http://lxr.free-electrons.com/source/scripts/kconfig/list.h?v=3.13#L33" class="urlextern" title="http://lxr.free-electrons.com/source/scripts/kconfig/list.h?v=3.13#L33"  rel="nofollow">list_entry</a> sau <a href="http://lxr.free-electrons.com/source/scripts/kconfig/list.h?v=3.13#L11" class="urlextern" title="http://lxr.free-electrons.com/source/scripts/kconfig/list.h?v=3.13#L11"  rel="nofollow">container_of</a>.

</div></p>
</p>

<p>
Folosiți <a href="http://lxr.free-electrons.com/source/include/linux/buffer_head.h?v=3.13#L297" class="urlextern" title="http://lxr.free-electrons.com/source/include/linux/buffer_head.h?v=3.13#L297"  rel="nofollow">sb_bread</a> pentru citirea blocului de date al directorului.
</p>

<p>
<p><div class="notetip">
Blocul de date al directorului este indicat de câmpul <code>data_block</code> al structurii <code>struct minfs_inode_info</code> aferentă directorului.
</p>

<p>
Datele din bloc sunt referite de câmpul <code>b_data</code> al structurii <a href="http://lxr.free-electrons.com/source/include/linux/buffer_head.h?v=3.13#L53" class="urlextern" title="http://lxr.free-electrons.com/source/include/linux/buffer_head.h?v=3.13#L53"  rel="nofollow">struct buffer_head</a> (codul uzual va fi <code>bh-&gt;b_data</code>). Acest bloc (fiind blocul de date al unui director) conține un vector de cel mult <code>MINFS_NUM_ENTRIES</code> intrări de tipul <code>struct minfs_dir_entry</code> (intrări de tip director (<em>dentry</em>-uri) specifice <code>minfs</code>). Folosiți casting la <code>struct minfs_dir_entry *</code> pentru a lucra cu datele din bloc.

</div></p>
</p>

<p>
Parcurgeți toate intrările din blocul de date și completați datele în buffer-ul utilizatorului în cadrul buclei <code>for</code> definite.
</p>

<p>
<p><div class="notetip">
Pentru fiecare index obțineți intrarea aferentă de tipul <code>struct minfs_dir_entry</code> prin folosirea aritmeticii de pointeri pe câmpul <code>bh-&gt;b_data</code>.
</p>

<p>
Ignorați dentry-urile care au câmpul <code>ino</code> egal cu <code>0</code>. Un astfel de dentry este un slot liber în lista de dentry-uri a directorului.
</p>

<p>
Pentru fiecare intrare validă se apelează funcția <code>dir_emit</code> cu parametrii corespunzători.
</p>

<p>
Urmăriți modul de apel din <a href="http://lxr.free-electrons.com/source/fs/qnx6/dir.c?v=3.13#L117" class="urlextern" title="http://lxr.free-electrons.com/source/fs/qnx6/dir.c?v=3.13#L117"  rel="nofollow">qnx6_readdir</a> și <a href="http://lxr.free-electrons.com/source/fs/minix/dir.c?v=3.13#L85" class="urlextern" title="http://lxr.free-electrons.com/source/fs/minix/dir.c?v=3.13#L85"  rel="nofollow">minix_readdir</a>.

</div></p>
</p>

</div>

<h4 id="testare2">Testare</h4>
<div class="level4">

<p>
O dată realizat modulul putem testa listarea conținutului directorului rădăcină. Pentru aceasta, compilăm modulul de kernel și copiem fișierul rezultat (<code>minfs.ko</code>), scripturile de testare (<code>test-minfs-{0,1}.sh</code>) și utilitarul de formatare (<code>mkfs.minfs</code>) în directorul aferent mașinii virtuale, apoi pornim mașina. După ce pornim mașina, formatăm discul <code>/dev/sdb</code>, creăm punctul de montare și montăm sistemul de fișiere:
</p>
<pre class="code"># ./mkfs.minfs /dev/sdb
# mkdir -p /mnt/minfs
# mount -t minfs /dev/sdb /mnt/minfs</pre>

<p>
Acum putem lista conținutul directorului rădăcină:
</p>
<pre class="code"># ls -l /mnt/minfs</pre>

<p>
Observăm că există deja un fișier (<code>a.txt</code>); acesta este creat de utilitarul de formatare.
</p>

<p>
Observăm, de asemenea, că nu ne este permisă afișerea de informații folosind comanda <code>ls</code>. Aceasta se întâmplă pentru că nu avem implementată funcția de <code>lookup</code>. O vom implementa în exercițiul următor.
</p>

<p>
Pentru testarea funcționalităților oferite de modul putem folosi scriptul dedicat:
</p>
<pre class="code"># ./test-minfs-0.sh
# ./test-minfs-1.sh</pre>

<p>
Dacă implementarea este validă, nu vor fi afișate mesaje de eroare în urma rulării scripturilor de mai sus.
</p>

</div>
<!-- EDIT6 SECTION "3. [2p] Operația iterate (minfs)" [14989-19529] -->
<h3 class="sectionedit7" id="p_operatia_lookup_minfs">4. [1.5p] Operația lookup (minfs)</h3>
<div class="level3">

<p>
Pentru listarea corespunzătoare a conținutului unui director este nevoie să implementăm funcționalitatea de căutare, adică operația <code>lookup</code>. Operația <code>lookup</code> este un câmp în cadrul structurii <code>minfs_dir_inode_operations</code> (de tipul <a href="http://lxr.free-electrons.com/source/include/linux/fs.h?v=3.13#L1552" class="urlextern" title="http://lxr.free-electrons.com/source/include/linux/fs.h?v=3.13#L1552"  rel="nofollow">inode_operations</a>) și este implementată de funcția <code>minfs_lookup</code>. Această funcție (<code>minfs_lookup</code>) trebuie să o implementăm. De fapt vom implementa funcția <code>minfs_find_entry</code> apelată de funcția <code>minfs_lookup</code>.
</p>

<p>
Urmăriți indicațiile marcate cu <code>TODO 4</code> care vă vor ghida pașii pe care trebuie să îi faceți.
</p>

<p>
<p><div class="notetip">
Parcurgeți secțiunea <a href="../../../../../so2/laboratoare/lab09.html#operatii_asupra_inode-urilor_de_tip_director" class="wikilink1" title="so2:laboratoare:lab09">Operații asupra inode-urilor de tip director</a>.
</p>

<p>
Ca punct de plecare, urmăriti funcțiile <a href="http://lxr.free-electrons.com/source/fs/qnx6/dir.c?v=3.13#L218" class="urlextern" title="http://lxr.free-electrons.com/source/fs/qnx6/dir.c?v=3.13#L218"  rel="nofollow">qnx6_find_entry</a> și <a href="http://lxr.free-electrons.com/source/fs/minix/dir.c?v=3.13#L147" class="urlextern" title="http://lxr.free-electrons.com/source/fs/minix/dir.c?v=3.13#L147"  rel="nofollow">minix_find_entry</a>.

</div></p>
</p>

<p>
În cadrul funcției <code>minfs_find_entry</code>, parcurgeți directorul în care se află intrarea <code>dentry</code>: <code>dentry-&gt;d_parent-&gt;d_inode</code>. Parcurgere înseamnă parcurgerea intrărilor din blocul de date al directorului și localizarea, dacă există, a intrării căutate.
</p>

<p>
<p><div class="notetip">
Din structura de tip <code>struct minfs_inode_info</code> aferent directorului, aflați indexul blocului și citiți-l. Veți accesa conținutul blocului folosind construcția <code>bh-&gt;b_data</code>.
</p>

<p>
Blocul de date al directorului conține un vector de cel mult <code>MINFS_NUM_ENTRIES</code> intrări de tipul <code>struct minfs_dir_entry</code>.  Folosiți aritmetică de pointeri pentru a obține intrări de tipul <code>struct minfs_dir_entry</code> din blocul de date (<code>bh-&gt;b_data</code>).
</p>

<p>
Verificați prezența numelui (stocat în variabila locală <code>name</code>) în director; adică dacă există o intrare în blocul de date al cărei nume să un șir egal cu șirul <code>name</code>. Folosiți <code>strcmp</code> pentru verificare.
</p>

<p>
Ignorați dentry-urile care au câmpul <code>ino</code> egal cu 0. Acele dentry-uri reprezintă slot-uri liber în lista de dentry-uri a directorului.
</p>

<p>
Rețineți în variabila <code>final_de</code> dentry-ul găsit. Dacă nu găsiți nici un dentry, atunci variabila <code>final_de</code> va avea valoarea <code>NULL</code>, valoare cu care a fost inițializată.

</div></p>
</p>

<p>
Actualizați câmpul <code>lookup</code> al structurii <code>minfs_dir_inode_operations</code>, structură de tipul <span class="curid"><a href="../../../../../so2/laboratoare/lab09/exercitii.html" class="wikilink1" title="so2:laboratoare:lab09:exercitii">inode_operations</a></span>.
</p>

</div>

<h4 id="testare3">Testare</h4>
<div class="level4">

<p>
Pentru testare, folosim pașii descriși la exercițiul anterior. La listarea în format lung (<code>ls -l</code>) a conținutului unui director (directorul rădăcină) vor fi afișate permiuni și alte informații specifice fișierului:
</p>
<pre class="code"># ls -l /mnt/minfs</pre>

<p>
Pentru testarea funcționalităților oferite de modul putem folosi scriptul dedicat:
</p>
<pre class="code"># ./test-minfs-0.sh
# ./test-minfs-1.sh</pre>

<p>
Dacă implementarea este validă, nu vor fi afișate mesaje de eroare în urma rulării scripturilor de mai sus.
</p>

<p>
<p><div class="noteclassic">
După ce montăm sistemul de fișiere folosind comanda
</p>
<pre class="code"># mount -t minfs /dev/sdb /mnt/minfs</pre>

<p>
încercăm să creăm un fișier folosind comanda
</p>
<pre class="code"># touch /mnt/minfs/peanuts.txt</pre>

<p>
Observăm că primi eroare pentru că nu am implementat operațiile de lucru pe directoare care permit crearea unui fișier. Vom face acest lucru la exercițiul următor.

</div></p>
</p>

</div>
<!-- EDIT7 SECTION "4. [1.5p] Operația lookup (minfs)" [19530-22966] -->
<h3 class="sectionedit8" id="p_operatia_create_minfs">5. [3.5p] Operația create (minfs)</h3>
<div class="level3">

<p>
Pentru a permite crearea unui fișier într-un director trebuie să implementăm operația de tip <code>create</code>. Operația <code>create</code> este un câmp în cadrul structurii <code>minfs_dir_inode_operations</code> (de tipul <span class="curid"><a href="../../../../../so2/laboratoare/lab09/exercitii.html" class="wikilink1" title="so2:laboratoare:lab09:exercitii">inode_operations</a></span> și este implmenentată de funcția <code>minfs_create</code>. Această funcție trebuie să o implementăm. De fapt vom implementa funcțiile <code>minfs_new_inode</code> (care creează și inițializează un inode) și <code>minfs_add_link</code> care adaugă un link (sau nume sau <em>dentry</em>) inode-ului creat.
</p>

<p>
Urmăriți indicațiile marcate cu <code>TODO 5</code> care vă vor ghida pașii pe care trebuie să îi faceți.
</p>

<p>
<p><div class="notetip">
Parcurgeți secțiunea <a href="../../../../../so2/laboratoare/lab09.html#operatii_asupra_inode-urilor_de_tip_director" class="wikilink1" title="so2:laboratoare:lab09">Operații asupra inode-urilor de tip director</a>.
</p>

<p>
Parcurgeți codul funcției <code>minfs_create</code> și scheletul funcțiilor <code>minfs_new_inode</code> și <code>minfs_add_link</code>.

</div></p>
</p>

<p>
Completați funcțiile <code>minfs_readdir</code> și <code>minfs_find_entry</code> cu implementarea de la exercițiul anterior.
</p>

<p>
Implementați funcția <code>minfs_new_inode</code>. În cadrul funcției veți crea (<a href="http://lxr.free-electrons.com/source/fs/inode.c?v=3.13#L880" class="urlextern" title="http://lxr.free-electrons.com/source/fs/inode.c?v=3.13#L880"  rel="nofollow">new_inode</a>) și veți inițializa un inode. Inițializarea se face cu datele de pe disc.
</p>

<p>
<p><div class="notetip">
Parcurgeți ca model funcția <a href="http://lxr.free-electrons.com/source/fs/minix/bitmap.c?v=3.13#L212" class="urlextern" title="http://lxr.free-electrons.com/source/fs/minix/bitmap.c?v=3.13#L212"  rel="nofollow">minix_new_inode</a>.
</p>

<p>
Găsiți primul inode liber din imap (<code>sbi-&gt;imap</code>). Folosiți operații de lucru pe biți (<a href="http://lxr.free-electrons.com/source/lib/find_next_bit.c?v=3.13#L139" class="urlextern" title="http://lxr.free-electrons.com/source/lib/find_next_bit.c?v=3.13#L139"  rel="nofollow">find_first_zero_bit</a> și <a href="http://lxr.free-electrons.com/source/include/asm-generic/bitops/non-atomic.h?v=3.13#L6" class="urlextern" title="http://lxr.free-electrons.com/source/include/asm-generic/bitops/non-atomic.h?v=3.13#L6"  rel="nofollow">__set_bit</a>). Parcurgeți secțiunea <a href="../../../../../so2/laboratoare/lab09.html#operatii_pe_bitmap-uri" class="wikilink1" title="so2:laboratoare:lab09">Operații pe bitmap-uri</a>.
</p>

<p>
Buffer-ul aferent supernodului (<code>sbi-&gt;sbh</code>) trebuie marcat <em>dirty</em>.
</p>

<p>
Trebuie să inițializați câmpurile uzuale, așa cum este inițializat și pentru sistemul de fișiere <code>myfs</code>. Inițializați câmpul <code>i_mode</code> la 0. Va fi inițializat ulterior în apelant.

</div></p>
</p>

<p>
Implementați funcția <code>minfs_add_link</code>. Funcția adaugă un nou dentry (<code>struct minfs_dir_entry</code>) în blocul de date al directorului părinte (<code>dentry-&gt;d_parent-&gt;d_inode</code>).
</p>

<p>
<p><div class="notetip">
Parcurgeți ca model funcția <a href="http://lxr.free-electrons.com/source/fs/minix/dir.c?v=3.13#L204" class="urlextern" title="http://lxr.free-electrons.com/source/fs/minix/dir.c?v=3.13#L204"  rel="nofollow">minix_add_link</a>.

</div></p>
</p>

<p>
În cadrul funcției <code>minfs_add_link</code> doriți să găsiți primul loc liber pentru dentry. Pentru aceasta veți parcurge blocul de date aferente directorului și veți găsi primul loc  liber, adică acel dentry pentru care câmpul <code>ino</code> are valoarea <code>0</code>.
</p>

<p>
<p><div class="notetip">
Pentru a putea lucra cu directorul, obțineți inode-ul <code>struct minfs_inode_info</code> aferente directorului părinte (inode-ul <code>dir</code>). <strong>Nu</strong> folosiți inode-ul <code>inode</code> pentru obținerea <code>struct_minfs_inode_info</code>; acel inode este inode-ul fișierului, nu al directorului părinte (cum este <code>dir</code>) în conținutul căruia trebuie să adăugați link-ul/dentry-ul. Pentru obținerea structurii <code>struct minfs_inode_info</code> folosiți <a href="http://lxr.free-electrons.com/source/scripts/kconfig/list.h?v=3.13#L11" class="urlextern" title="http://lxr.free-electrons.com/source/scripts/kconfig/list.h?v=3.13#L11"  rel="nofollow">container_of</a>.
</p>

<p>
Structura <code>struct minfs_inode_info</code> este utilă pentru a afla blocul de date al directorului (cel indicat de inode-ul <code>dentry-&gt;d_parent-&gt;d_inode</code>, adică de variabila <code>dir</code>). Din cadrul acestei structuri obțineți câmpul <code>data_block</code>, reprezentând indexul blocului de date pe disc. Acest bloc conține intrări în director. Folosiți <a href="http://lxr.free-electrons.com/source/include/linux/buffer_head.h?v=3.13#L292" class="urlextern" title="http://lxr.free-electrons.com/source/include/linux/buffer_head.h?v=3.13#L292"  rel="nofollow">sb_bread</a> pentru citirea blocului dat și apoi construcția <code>bh-&gt;b_data</code> pentru a referi datele din bloc. Blocul conține un vector de cel mult <code>MINFS_NUM_ENTRIES</code> intrări de tipul <code>struct minfs_dir_entry</code>.
</p>

<p>
Dacă toate intrările sunt ocupate, se întoarce <code>-ENOSPC</code>.
</p>

<p>
Obțineți numele intrării în forma unui șir de caractere (<code>char *</code>) în variabila <code>name</code>.
</p>

<p>
Parcurgeți intrările din bloc folosind variabila <code>de</code> și extrageți prima intrare liberă (cea pentru care câmpul <code>ino</code> este <code>0</code>). Dacă ați găsit loc liber, completați intrarea corespunzătoare: câmpul <code>ino</code> și câmpul <code>name</code> din variabila <code>de</code>. Puteți folosi <code>strcpy</code> sau <code>memcpy</code> pentru inițializarea numelui la conținutul variabilei <code>name</code>.

</div></p>
</p>

</div>

<h4 id="testare4">Testare</h4>
<div class="level4">

<p>
Pentru testare, folosim pașii descriși la exercițiul anterior. Acum vom putea crea fișiere în cadrul sistemului de fișiere:
</p>
<pre class="code bash"><span class="co4"># </span><span class="kw2">touch</span> <span class="sy0">/</span>mnt<span class="sy0">/</span>minfs<span class="sy0">/</span>peanuts.txt</pre>

<p>
Pentru testarea funcționalităților oferite de modul putem folosi scriptul dedicat:
</p>
<pre class="code"># ./test-minfs-2.sh</pre>

<p>
Dacă implementarea este validă, nu vor fi afișate mesaje de eroare în urma rulării scriptului de mai sus.
</p>

<p>
<p><div class="noteclassic">
Implementarea curentă nu este definitivă pentru sistemul de fișiere <code>minfs</code>. Pentru a fi completă, implementarea are nevoie de funcții de șters fișiere, create și șters directoare, redumit intrări și alterat conținutul unui fișier.

</div></p>
</p>

</div>
<!-- EDIT8 SECTION "5. [3.5p] Operația create (minfs)" [22967-28073] -->
<h2 class="sectionedit9" id="solutii">Soluții</h2>
<div class="level2">
<ul>
<li class="level1"><div class="li"> <a href="http://elf.cs.pub.ro/so2/res/laboratoare/lab09-sol.zip" class="urlextern" title="http://elf.cs.pub.ro/so2/res/laboratoare/lab09-sol.zip"  rel="nofollow">Soluții exerciții laborator 9</a></div>
</li>
</ul>

</div>
<!-- EDIT9 SECTION "Soluții" [28074-] --></div>
</body>
</html>
