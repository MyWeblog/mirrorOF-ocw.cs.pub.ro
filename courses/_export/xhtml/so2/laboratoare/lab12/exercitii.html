    
    

<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
  <meta charset="utf-8" />
  <title>so2:laboratoare:lab12:exercitii</title>
<meta name="generator" content="DokuWiki"/>
<meta name="robots" content="index,follow"/>
<meta name="date" content="2016-05-18T15:49:13+0300"/>
<meta name="keywords" content="so2,laboratoare,lab12,exercitii"/>
<link rel="search" type="application/opensearchdescription+xml" href="../../../../../lib/exe/opensearch.php" title="CS Open CourseWare"/>
<link rel="start" href="../../../../../../courses.1.html"/>
<link rel="alternate" type="application/rss+xml" title="Recent Changes" href="../../../../../feed.php"/>
<link rel="alternate" type="application/rss+xml" title="Current Namespace" href="../../../../../feed.php%3Fmode=list&amp;ns=so2:laboratoare:lab12"/>
<link rel="alternate" type="text/html" title="Plain HTML" href="exercitii.html"/>
<link rel="canonical" href="../../../../../so2/laboratoare/lab12/exercitii.html"/>
<link rel="stylesheet" type="text/css" href="../../../../../lib/exe/css.php%3Ft=arctic&amp;tseed=1476798676.css"/>
<script type="text/javascript">/*<![CDATA[*/var NS='so2:laboratoare:lab12';var JSINFO = {"id":"so2:laboratoare:lab12:exercitii","namespace":"so2:laboratoare:lab12","isadmin":0,"isauth":0};
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="../../../../../lib/exe/js.php%3Ftseed=1476798676"></script>
<script type="text/x-mathjax-config">/*<![CDATA[*/MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ["$","$"], ["\\(","\\)"] ],
        displayMath: [ ["$$","$$"], ["\\[","\\]"] ],
        processEscapes: true
    }
});
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
<script type="text/javascript">/*<![CDATA[*/
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
		  
/*!]]>*/</script>
<script type="text/javascript">/*<![CDATA[*/
var pageTracker = _gat._getTracker("UA-38383934-1");
pageTracker._initData();
pageTracker._trackPageview();
		  
/*!]]>*/</script>
</head>
<body>
<div class="dokuwiki export">
<!-- TOC START -->
<div id="dw__toc">
<h3 class="toggle">Table of Contents</h3>
<div>

<ul class="toc">
<li class="level1"><div class="li"><a href="exercitii.html#laborator_12exercitii">Laborator 12: Exerciții</a></div>
<ul class="toc">
<li class="level2"><div class="li"><a href="exercitii.html#p_intro">[0.5p] Intro</a></div></li>
<li class="level2"><div class="li"><a href="exercitii.html#p_bonuscompletare_formular_de_feedback">[1p] BONUS: Completare formular de feedback</a></div></li>
<li class="level2"><div class="li"><a href="exercitii.html#p_linux_device_model">[6.5p] Linux Device Model</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="exercitii.html#p_implementare_magistrala">1. [1p] Implementare magistrală</a></div></li>
<li class="level3"><div class="li"><a href="exercitii.html#p_conectare_driver_la_magistrala">2. [2p] Conectare driver la magistrală</a></div></li>
<li class="level3"><div class="li"><a href="exercitii.html#p_informatii_device-uri_de_pe_magistrala">2.1. [1.5p] Informații device-uri de pe magistrală</a></div></li>
<li class="level3"><div class="li"><a href="exercitii.html#p_atribute_device_drivere">3. [2p] Atribute device drivere</a></div></li>
</ul>
</li>
<li class="level2"><div class="li"><a href="exercitii.html#p_plug_and_play">[4p] Plug and Play</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="exercitii.html#p_conectarea_la_magistrala_pnp">4. [2p] Conectarea la magistrala PNP</a></div></li>
<li class="level3"><div class="li"><a href="exercitii.html#p_clase">5. [2p] Clase</a></div></li>
</ul>
</li>
<li class="level2"><div class="li"><a href="exercitii.html#extra">Extra</a></div></li>
<li class="level2"><div class="li"><a href="exercitii.html#solutii">Soluții</a></div></li>
</ul></li>
</ul>
</div>
</div>
<!-- TOC END -->

<h1 class="sectionedit1" id="laborator_12exercitii">Laborator 12: Exerciții</h1>
<div class="level1">

<p>
Pentru desfășurarea laboratorului pornim de la <a href="http://elf.cs.pub.ro/so2/res/laboratoare/lab12-tasks.zip" class="urlextern" title="http://elf.cs.pub.ro/so2/res/laboratoare/lab12-tasks.zip"  rel="nofollow">arhiva de sarcini a laboratorului</a>. Descărcăm și decomprimăm arhiva în directorul <code>so2/</code> din directorul home al utilizatorului <code>student</code> de pe sistemul de bază (stația <code>mjolnir</code>):
</p>
<pre class="code bash"><span class="co4">student@mjolnir:~$ </span><span class="kw3">cd</span> so2<span class="sy0">/</span>
student<span class="sy0">@</span>mjolnir:~<span class="sy0">/</span>so2$ <span class="kw2">wget</span> http:<span class="sy0">//</span>elf.cs.pub.ro<span class="sy0">/</span>so2<span class="sy0">/</span>res<span class="sy0">/</span>laboratoare<span class="sy0">/</span>lab12-tasks.zip
student<span class="sy0">@</span>mjolnir:~<span class="sy0">/</span>so2$ <span class="kw2">unzip</span> lab12-tasks.zip
student<span class="sy0">@</span>mjolnir:~<span class="sy0">/</span>so2$ <span class="kw2">tree</span> lab12-tasks</pre>

<p>
În cadrul directorului <code>lab12-tasks/</code> se găsesc resursele necesare pentru dezvoltarea exercițiilor de mai jos: fișiere schelet de cod sursă, fișiere Makefile și Kbuild, scripturi și programe de test.
</p>

<p>
Vom dezvolta exercițiile pe sistemul de bază (stația <code>mjolnir</code>) și apoi le vom testa pe <a href="../../../../../so2/resurse/masini-virtuale.html" class="wikilink1" title="so2:resurse:masini-virtuale">mașina virtuală QEMU</a>. După editarea și compilarea unui modul de kernel îl vom copia în directorul dedicat pentru mașina virtuală QEMU folosind o comandă de forma
</p>
<pre class="code bash"><span class="co4">student@mjolnir:~/so2$ </span><span class="kw2">cp</span> <span class="sy0">/</span>path<span class="sy0">/</span>to<span class="sy0">/</span>module.ko ~<span class="sy0">/</span>so2<span class="sy0">/</span>qemu-vm<span class="sy0">/</span>fsimg<span class="sy0">/</span>root<span class="sy0">/</span>modules<span class="sy0">/</span></pre>

<p>
 unde <code>/path/to/module.ko</code> este calea către fișierul obiect aferent modulului de kernel. Apoi vom porni, din directorul <code>~/so2/qemu-vm/</code> mașina virtuală QEMU folosind comanda
</p>
<pre class="code bash"><span class="co4">student@mjolnir:~/so2/qemu-vm$ </span><span class="kw2">make</span></pre>

<p>
După pornirea mașinii virtuale QEMU vom putea folosi comenzi în fereastra QEMU pentru a încărca și descărca modulul de kernel:
</p>
<pre class="code"># insmod modules/module-name.ko
# rmmod module/module-name</pre>

<p>
 unde <code>module-name</code> este numele modulului de kernel.
</p>

<p>
<p><div class="noteclassic">
Pentru dezvoltarea laboratorului, este recomandat să folosim trei terminale sau, mai bine, trei tab-uri de terminal. Pentru a deschide un nou tab de terminal folosim combinația de taste <code>Ctrl+Alt+t</code>. Cele trei tab-uri de terminal îndeplinesc următoarele roluri:
</p>
<ol>
<li class="level1"><div class="li"> În primul tab de terminal dezvoltăm modulul de kernel: editare, compilare, copiere în directorul dedicat pentru mașina virtaulă QEMU. Lucrăm în directorul aferent rezultat în urma decomprimării arhivei de sarcini a laboratorului.</div>
</li>
<li class="level1"><div class="li"> În al doilea tab de terminal pornim mașina virtuală QEMU și apoi testăm modulul de kernel: încărcare/descărcare modul, rulare teste. Lucrăm în directorul aferent mașinii virtuale: <code>~/so2/qemu-vm/</code>.</div>
</li>
<li class="level1"><div class="li"> În al treilea tab de terminal pornim un server UDP care să primească <a href="../../../../../so2/laboratoare/lab02.html#netconsole" class="wikilink1" title="so2:laboratoare:lab02">mesajele de netconsole</a>. Nu contează în ce director ne aflăm. Folosim comanda<pre class="code bash"><span class="co4">student@mjolnir:~$ </span>netcat <span class="re5">-lup</span> <span class="nu0">6666</span></pre>
</div>
</li>
</ol>

<p>

</div></p>
</p>

</div>
<!-- EDIT1 SECTION "Laborator 12: Exerciții" [1-2656] -->
<h2 class="sectionedit2" id="p_intro">[0.5p] Intro</h2>
<div class="level2">

<p>
<p><div class="notewarning">
Bonus - 1 punct: Vă invităm să evaluați activitatea echipei de SO2 și să precizați punctele tari și punctele slabe și sugestiile voastre de îmbunătățire a materiei. Feedback-ul vostru este foarte important pentru noi să creștem calitatea materiei în anii următori și să îmbunătățim materiile pe care le veți face în continuare.
Găsiți formularul de feedback în partea dreaptă a paginii principale de SO2 de pe cs.curs.pub.ro într-un frame numit “FEEDBACK”

</div></p>
</p>

<p>
Vă mulțumim!
Găsiți definițiile următoarelor simboluri în nucleul Linux:
</p>
<ul>
<li class="level1"><div class="li"> funcțiile <code>dev_name</code>, <code>dev_set_name</code>.</div>
</li>
<li class="level1"><div class="li"> funcțiile <code>pnp_device_probe</code>, <code>pnp_bus_match</code>, <code>pnp_register_driver</code> și variabila <code>pnp_bus_type</code>.</div>
</li>
</ul>

</div>
<!-- EDIT2 SECTION "[0.5p] Intro" [2657-3436] -->
<h2 class="sectionedit3" id="p_bonuscompletare_formular_de_feedback">[1p] BONUS: Completare formular de feedback</h2>
<div class="level2">

<p>
Apreciem opinia voastră legată de activitățile cursului de SO2. Ne ajută să îmbunătățim cursul și să facem materia cât mai accesibilă și interesantă. Pentru această vă rugăm să completați <a href="http://cs.curs.pub.ro/2015/blocks/simplehtml/view.php?courseid=149&amp;blockid=1468" class="urlextern" title="http://cs.curs.pub.ro/2015/blocks/simplehtml/view.php?courseid=149&amp;blockid=1468"  rel="nofollow">formularul de feedback de pe cs.curs.pub.ro</a> (trebuie să fiți autentificați și înrolați în cadrul cursului). Vă mulțumim!
</p>

</div>
<!-- EDIT3 SECTION "[1p] BONUS: Completare formular de feedback" [3437-3916] -->
<h2 class="sectionedit4" id="p_linux_device_model">[6.5p] Linux Device Model</h2>
<div class="level2">

<p>
În prima parte ne propunem să ne familiarizăm cu modelul <code>Linux Device Model</code> și reflectarea acestuia în userspace prin intermediul sistemului virtual de fișiere <code>sysfs</code>. Vom analiza implementarea magistralelor și modul în care device driverele se conectează la o magistrală. Pentru început, vom lucra cu o magistrală virtuală, definită în modulul <code>mybus.ko</code> din subdirectorul <code>virtual_bus/mybus/</code> la care vom atașa driverul <code>mydriver.ko</code> din subdirectorul <code>virtual_bus/mydriver</code>.
</p>

<p>
<p><div class="notetip">
În rezolvarea acestui exerciţiu vă veţi întâlni cu:
</p>
<ul>
<li class="level1"><div class="li"> <code>my_bus_type</code>(mybus.c): variabilă globală pentru tipul de magistrală</div>
</li>
<li class="level1"><div class="li"> <code>my_bus_device</code>(mybus.c): variabilă globală pentru dispozitivul magistralei</div>
</li>
<li class="level1"><div class="li"> <code>my_device</code>(virtual_bus.h): structură folosită pentru dispozitivele ce se conectează la magistrală</div>
</li>
<li class="level1"><div class="li"> <code>my_driver</code>(virtual_bus.h): structură folosită pentru driverul care lucrează cu dispozitivele ce se conectează la magistrală</div>
</li>
<li class="level1"><div class="li"> <code>dev_data</code>(mydriver.c): variabilă globală ce menţine datele necesare driverului</div>
</li>
</ul>

<p>

</div></p>
</p>

</div>
<!-- EDIT4 SECTION "[6.5p] Linux Device Model" [3917-5039] -->
<h3 class="sectionedit5" id="p_implementare_magistrala">1. [1p] Implementare magistrală</h3>
<div class="level3">

<p>
Intrați în directorul <code>virtual_bus/mybus</code>, unde găsiți implementarea unei magistrale <code>mybus</code>, așa cum este descrisă în laborator. Analizați conținutul fișierelor <code>mybus/mybus.c</code> și <code>include/virtual_bus.h</code>.
Observaţi că la încărcarea modulului se înregistrează atât o structură <a href="http://lxr.free-electrons.com/source/include/linux/device.h?v=3.13#L61" class="urlextern" title="http://lxr.free-electrons.com/source/include/linux/device.h?v=3.13#L61"  rel="nofollow">bus_type</a>, reprezentând tipul de magistrală, cât și o structură <a href="http://lxr.free-electrons.com/source/include/linux/device.h?v=3.13#L655" class="urlextern" title="http://lxr.free-electrons.com/source/include/linux/device.h?v=3.13#L655"  rel="nofollow">device</a>, reprezentând dispozitivul efectiv al magistralei. 
</p>

<p>
Compilați și inserați modulul.
Verificaţi că tipul de magistrală apare în /sys/bus, iar dispozitivul în /sys/devices.
Scoateți modulul şi observaţi că intrările din sysfs sunt înlăturate.
</p>

<p>
Modificați sursa astfel încât intrările pentru magistrală și dispozitivul asociat să fie <code>virtualbus</code>, respectiv <code>virtualbus0</code>.
</p>

<p>
<p><div class="notetip">
Recitiți secțiunile <a href="../../../../../so2/laboratoare/lab12.html#magistrale" class="wikilink1" title="so2:laboratoare:lab12">Magistrale</a> și <a href="../../../../../so2/laboratoare/lab12.html#dispozitive" class="wikilink1" title="so2:laboratoare:lab12">Dispozitive</a> din laborator.

</div></p>
</p>

<p>
Pentru verificare trebuie să se fi creat pe mașina virtuală în <code>/sys</code> intrările aferente magistralei (<code>virtualbus</code>) și dispozitivului părinte (<code>virtualbus0</code>):
</p>
<pre class="code"># ls /sys/bus/virtualbus/
# ls /sys/devices/virtualbus0/</pre>

</div>
<!-- EDIT5 SECTION "1. [1p] Implementare magistrală" [5040-6416] -->
<h3 class="sectionedit6" id="p_conectare_driver_la_magistrala">2. [2p] Conectare driver la magistrală</h3>
<div class="level3">

<p>
Intrați în directorul <code>virtual_bus/mydriver</code>, unde găsiți implementarea unui device driver de tip caracter.
</p>

<p>
Modificați sursa astfel încât să respecte modelul <code>Linux Device Model</code>. Dispozitivul <code>echo</code> se va conecta la magistrala virtualbus de la exercițiul anterior, având un driver asociat <code>echo</code>. Numele driverului și al dispozitivului trebuie să fie identice.
</p>

<p>
Urmăriți comentariile <code>TODO 2</code> din cod și exemplele de înregistrare dispozitiv/driver din laborator: <a href="../../../../../so2/laboratoare/lab12.html#dispozitive" class="wikilink1" title="so2:laboratoare:lab12">înregistrare dispozitiv</a>, <a href="../../../../../so2/laboratoare/lab12.html#drivere" class="wikilink1" title="so2:laboratoare:lab12">înregistrare driver</a>.
</p>

<p>
Pentru a vă conecta la magistrala <code>virtualbus</code>, va trebui să folosiți funcțiile și tipurile de driver/device exportate de aceasta.
</p>

<p>
În structura <code>struct my_device_data</code> adăugați un câmp de tipul <code>struct my_device</code> (tip de date definit în <code>include/virtual_bus.h</code>). Câmpurile structurii <code>my_device</code> vor fi inițializate în funcția <code>my_init</code>.
</p>

<p>
Definiți o variabilă de tipul <code>struct my_driver</code> şi inițializați pentru aceasta modulul şi numele driver-ului. Înregistraţi driverul în funcţia <code>my_init</code>.
</p>

<p>
<p><div class="notetip">
Parcurgeți secțiunea <a href="../../../../../so2/laboratoare/lab12.html#drivere" class="wikilink1" title="so2:laboratoare:lab12">Drivere</a> din laborator. Urmăriți exemplele de cod.

</div></p>
</p>

<p>
<p><div class="notetip">
Trebuie să înregistrați / deînregistrați variabilele de tipul <code>struct my_device</code> și <code>struct my_driver</code> în funcția de init / exit a modulului. Pentru aceasta folosiți funcțiile <code>my_register_driver</code> / <code>my_unregister_driver</code>, respectiv <code>my_register_device</code> / <code>my_unregister_device</code>, definite în fișierul <code>mybus.c</code>.

</div></p>
</p>

<p>
<p><div class="notetip">
Pentru a transmite primul argument (magistrala) funcției <code>bus_find_device</code> folosiți o expresie de forma <code>mydriver.driver.bus</code>.

</div></p>
</p>

<p>
În cadrul funcţiei <code>my_init</code>, iniţializaţi dispozitivul şi înregistraţi-l. Vor trebui completate cel puțin câmpurile <code>name</code> și <code>driver</code>.
</p>

<p>
De asemenea, puteți stoca un back pointer către <code>struct my_device_data</code> în câmpul <code>dev-&gt;p-&gt;driver_data</code>. Acest câmp e util pentru a putea accesa datele private (<code>my_device_data</code>) ale dispozitivului și din locurile în care aveți acces doar la structura generică <a href="http://lxr.free-electrons.com/source/include/linux/device.h?v=3.13#L655" class="urlextern" title="http://lxr.free-electrons.com/source/include/linux/device.h?v=3.13#L655"  rel="nofollow">struct device</a>. Fiind un câmp din <a href="http://lxr.free-electrons.com/source/drivers/base/base.h?v=3.13#L55" class="urlextern" title="http://lxr.free-electrons.com/source/drivers/base/base.h?v=3.13#L55"  rel="nofollow">datele private</a> ale dispozitivului, pentru a accesa <code>dev-&gt;p-&gt;driver_data</code> e recomandat să folosiți funcțiile (interfața) <a href="http://lxr.free-electrons.com/source/drivers/base/dd.c?v=3.13#L586" class="urlextern" title="http://lxr.free-electrons.com/source/drivers/base/dd.c?v=3.13#L586"  rel="nofollow">dev_set_drvdata</a>, <a href="http://lxr.free-electrons.com/source/drivers/base/dd.c?v=3.13#L578" class="urlextern" title="http://lxr.free-electrons.com/source/drivers/base/dd.c?v=3.13#L578"  rel="nofollow">dev_get_drvdata</a>.
</p>

<p>
<p><div class="notetip">
Parcurgeți secțiunea <a href="../../../../../so2/laboratoare/lab12.html#dispozitive" class="wikilink1" title="so2:laboratoare:lab12">Dispozitive</a> din laborator. Urmăriți exemplele de cod.

</div></p>
</p>

<p>
Compilaţi modulul şi copiaţi-l pe maşina virtuală, împreună cu modulul de la exerciţiul anterior.
</p>

<p>
<p><div class="notewarning">
Pentru a elimina warning-urile legate de nedefinirea funcțiilor de înregistrare/deînregistrare de dispozitiv, compilați ambele module din directorul părinte. Aveți în vedere să inserați modulul de la pasul anterior (<code>mybus.ko</code>) înaintea inserării modulului curent.

</div></p>
</p>

<p>
Pentru testare urmăriți intrările de dispozitiv (<code>echo</code>) și de driver (<code>echo</code>) în <code>/sys</code> pe mașina virtuală:
</p>
<pre class="code"># ls /sys/bus/virtualbus/devices/
# ls /sys/bus/virtualbus/drivers/
# ls /sys/devices/virtualbus0/</pre>

</div>
<!-- EDIT6 SECTION "2. [2p] Conectare driver la magistrală" [6417-9965] -->
<h3 class="sectionedit7" id="p_informatii_device-uri_de_pe_magistrala">2.1. [1.5p] Informații device-uri de pe magistrală</h3>
<div class="level3">

<p>
La sfârșitul inițilizării modulului <code>mydriver</code> (TODO 2.1), verificați dacă device-ul a fost atașat la magistrală. Pornind de la magistrala asociată, parcurgeți device-urile atașate și căutați-l pe cel cu numele <code>echo</code>. Afișați numele device-ului, dacă acesta a fost găsit.
</p>

<p>
<p><div class="notetip">
Pentru căutarea unui dispozitiv folosiți funcția <a href="http://lxr.free-electrons.com/source/drivers/base/bus.c?v=3.13#L348" class="urlextern" title="http://lxr.free-electrons.com/source/drivers/base/bus.c?v=3.13#L348"  rel="nofollow">bus_find_device_by_name</a>. Transmiteți <code>NULL</code> ca al doilea argument al funcției.
</p>

<p>
Obțineți structura de tip magistrală (<code>struct bus_type</code>) printr-o construcție de forma <code>my_driver.driver.bus</code>.
</p>

<p>
Numele device-ului întors de funcția <a href="http://lxr.free-electrons.com/source/drivers/base/bus.c?v=3.13#L348" class="urlextern" title="http://lxr.free-electrons.com/source/drivers/base/bus.c?v=3.13#L348"  rel="nofollow">bus_find_device_by_name</a> se poate obține cu funcția <a href="http://lxr.free-electrons.com/source/include/linux/device.h?v=3.13#L798" class="urlextern" title="http://lxr.free-electrons.com/source/include/linux/device.h?v=3.13#L798"  rel="nofollow">dev_name</a>.

</div></p>
</p>

<p>
Pentru verificare la inserarea modulului se va afișa mesaj cu numele dispozitivului.
</p>

</div>
<!-- EDIT7 SECTION "2.1. [1.5p] Informații device-uri de pe magistrală" [9966-11010] -->
<h3 class="sectionedit8" id="p_atribute_device_drivere">3. [2p] Atribute device drivere</h3>
<div class="level3">

<p>
Extindeți driverul echo de la exercițiul anterior prin adăugarea unui atribut <code>myattr</code> pentru dispozitivul creat, ce va conține majorul și minorul dispozitivului (<code>major:minor</code>). Acest atribut va fi expus prin interfaţa <code>sysfs</code> din directorul device-ului <code>echo</code>.
</p>

<p>
Urmăriți comentariile <code>TODO 3</code> din cod.
</p>

<p>
<p><div class="notetip">
Va trebui să declarați și să înregistrați o structură <a href="http://lxr.free-electrons.com/source/include/linux/device.h?v=3.13#L511" class="urlextern" title="http://lxr.free-electrons.com/source/include/linux/device.h?v=3.13#L511"  rel="nofollow"> device_attribute</a>. Puteți folosi macro-ul <a href="http://lxr.free-electrons.com/source/include/linux/device.h?v=3.13#L538" class="urlextern" title="http://lxr.free-electrons.com/source/include/linux/device.h?v=3.13#L538"  rel="nofollow">DEVICE_ATTR</a> ce va crea o structură cu numele <code>dev_attr_##_name</code>, unde <code>##_name</code> este numele atributului.
Pentru folosirea macro-ului va trebui să specificaţi, în această ordine:
</p>
<ul>
<li class="level1"><div class="li"> numele atributului</div>
</li>
<li class="level1"><div class="li"> permisiunile la acces la intrarea din sysfs aferentă atributului; folosiţi valoarea <code>0444</code>.</div>
</li>
<li class="level1"><div class="li"> o funcție <a href="http://lxr.free-electrons.com/source/include/linux/device.h?v=3.13#L514" class="urlextern" title="http://lxr.free-electrons.com/source/include/linux/device.h?v=3.13#L514"  rel="nofollow">show</a> ce afișează valoarea atributului pornind de la informațiile din <a href="http://lxr.free-electrons.com/source/include/linux/device.h?v=3.13#L655" class="urlextern" title="http://lxr.free-electrons.com/source/include/linux/device.h?v=3.13#L655"  rel="nofollow">struct device</a>.</div>
</li>
<li class="level1"><div class="li"> o funcţie <a href="http://lxr.free-electrons.com/source/include/linux/device.h?v=3.13#L516" class="urlextern" title="http://lxr.free-electrons.com/source/include/linux/device.h?v=3.13#L516"  rel="nofollow">store</a>, care în cazul vostru poate fi <code>NULL</code>.</div>
</li>
</ul>

<p>
În funcţia <a href="http://lxr.free-electrons.com/source/include/linux/device.h?v=3.13#L514" class="urlextern" title="http://lxr.free-electrons.com/source/include/linux/device.h?v=3.13#L514"  rel="nofollow">show</a>, puteți folosi macrodefinițiile <a href="http://lxr.free-electrons.com/source/include/linux/kdev_t.h?v=3.13#L9" class="urlextern" title="http://lxr.free-electrons.com/source/include/linux/kdev_t.h?v=3.13#L9"  rel="nofollow">MAJOR</a> și <a href="http://lxr.free-electrons.com/source/include/linux/kdev_t.h?v=3.13#L10" class="urlextern" title="http://lxr.free-electrons.com/source/include/linux/kdev_t.h?v=3.13#L10"  rel="nofollow">MINOR</a> pentru aflarea majorului și minorului. Aceste funcții primesc ca argument câmpul <code>dev</code> al structurii <code>struct cdev</code>. Câmpul de tipul <code>struct cdev</code> îl găsiți în structura de tipul <code>struct my_device_data</code>. Pentru a obține structura de tipul <code>struct my_device_data</code>, atunci când știți adresa unei variabile de tipul <code>struct device</code>, puteți folosi funcția <a href="http://lxr.free-electrons.com/source/drivers/base/dd.c?v=3.13#L578" class="urlextern" title="http://lxr.free-electrons.com/source/drivers/base/dd.c?v=3.13#L578"  rel="nofollow">dev_get_drvdata</a>.
</p>

<p>
Țineți cont să adăugați/eliminați atributul la inițializarea/dezactivarea modulului cu ajutorul funcțiilor <a href="http://lxr.free-electrons.com/source/drivers/base/core.c?v=3.13#L534" class="urlextern" title="http://lxr.free-electrons.com/source/drivers/base/core.c?v=3.13#L534"  rel="nofollow">device_create_file</a>, <a href="http://lxr.free-electrons.com/source/drivers/base/core.c?v=3.13#L558" class="urlextern" title="http://lxr.free-electrons.com/source/drivers/base/core.c?v=3.13#L558"  rel="nofollow">device_remove_file</a>.
</p>

<p>
Parcurgeți secțiunile <a href="../../../../../so2/laboratoare/lab12.html#magistrale" class="wikilink1" title="so2:laboratoare:lab12">Magistrale</a> și <a href="../../../../../so2/laboratoare/lab12.html#dispozitive" class="wikilink1" title="so2:laboratoare:lab12">Dispozitive</a> din laborator.

</div></p>
</p>

<p>
Pentru testare rulați comanda:
</p>
<pre class="code"># cat /sys/devices/virtualbus0/echo/myattr</pre>

<p>
Această comanda va conduce la rularea funcției <code>my_show</code>.
</p>

</div>
<!-- EDIT8 SECTION "3. [2p] Atribute device drivere" [11011-13713] -->
<h2 class="sectionedit9" id="p_plug_and_play">[4p] Plug and Play</h2>
<div class="level2">

</div>
<!-- EDIT9 SECTION "[4p] Plug and Play" [13714-13745] -->
<h3 class="sectionedit10" id="p_conectarea_la_magistrala_pnp">4. [2p] Conectarea la magistrala PNP</h3>
<div class="level3">

<p>
Intrați în directorul <code>parallel</code>, unde găsiți implementarea unui driver simplu pentru portul paralel.
Analizați conținutul fișierului <code>parallel.c</code>. Modificați sursa astfel încât să respecte modelul <code>Linux Device Model</code> și <code>plug and play</code>. Dispozitivul se va conecta la magistrala <code>PNP</code>.
</p>

<p>
<p><div class="notetip">
Înregistrați/deînregistrați structura <a href="http://lxr.free-electrons.com/source/include/linux/pnp.h?v=3.13#L370" class="urlextern" title="http://lxr.free-electrons.com/source/include/linux/pnp.h?v=3.13#L370"  rel="nofollow">pnp_driver</a> la încărcarea/descărcarea modulului cu ajutorul funcțiilor <a href="http://lxr.free-electrons.com/source/drivers/pnp/driver.c?v=3.13#L262" class="urlextern" title="http://lxr.free-electrons.com/source/drivers/pnp/driver.c?v=3.13#L262"  rel="nofollow">pnp_register_driver</a>, respectiv <a href="http://lxr.free-electrons.com/source/drivers/pnp/driver.c?v=3.13#L270" class="urlextern" title="http://lxr.free-electrons.com/source/drivers/pnp/driver.c?v=3.13#L270"  rel="nofollow">pnp_unregister_driver</a>.
</p>

<p>
Pentru a fi un driver <code>plug and play</code>, inițializarea dispozitivelor trebuie făcută în momentul în care acestea apar în sistem (la execuția funcției <code>parallel_pnp_probe</code>), iar deînregistrarea în momentul în care dispar din sistem (la execuția funcției <code>parallel_pnp_remove</code>).
</p>

<p>
Recitiți secțiunile <a href="../../../../../so2/laboratoare/lab12.html#magistrala_pnp" class="wikilink1" title="so2:laboratoare:lab12">Magistrala PNP</a> și <a href="../../../../../so2/laboratoare/lab12.html#operatii_pnp" class="wikilink1" title="so2:laboratoare:lab12">Operații plug and play</a> din laborator.

</div></p>
</p>

<p>
<p><div class="notetip">
Pentru înregistrarea și deînregistrarea unui dispozitiv folosiți funcțiile <code>register_parallel_dev</code> respectiv <code>unregister_parallel_dev</code> definite în cadrul scheletului de cod de laborator.

</div></p>
</p>

<p>
Pentru verificare, urmăriți conținutul din directorul aferent din sysfs:
</p>
<pre class="code"># ls /sys/bus/pnp/drivers/parallel</pre>

</div>
<!-- EDIT10 SECTION "4. [2p] Conectarea la magistrala PNP" [13746-15316] -->
<h3 class="sectionedit11" id="p_clase">5. [2p] Clase</h3>
<div class="level3">

<p>
Pornind de la modulul anterior, adăugați informațiile pentru o nouă clasă <code>parclass</code>, de care aparține modulul <code>paralel</code>.
</p>

<p>
<p><div class="notetip">
Definiți o structură <a href="http://lxr.free-electrons.com/source/include/linux/device.h?v=3.13#L323" class="urlextern" title="http://lxr.free-electrons.com/source/include/linux/device.h?v=3.13#L323"  rel="nofollow">class</a> și o structură <a href="http://lxr.free-electrons.com/source/include/linux/device.h?v=3.13#L655" class="urlextern" title="http://lxr.free-electrons.com/source/include/linux/device.h?v=3.13#L655"  rel="nofollow">device</a>.
</p>

<p>
Structura <a href="http://lxr.free-electrons.com/source/include/linux/device.h?v=3.13#L323" class="urlextern" title="http://lxr.free-electrons.com/source/include/linux/device.h?v=3.13#L323"  rel="nofollow">class</a> trebuie inițializată odată cu resursele driver-ului (la execuția funcției <code>parallel_init</code>) și eliminată la ieșirea driverului (<code>parallel_exit</code>). Va trebui să folosiţi funcţiile <a href="http://lxr.free-electrons.com/source/include/linux/device.h?v=3.14#L389" class="urlextern" title="http://lxr.free-electrons.com/source/include/linux/device.h?v=3.14#L389"  rel="nofollow">class_register</a> şi <a href="http://lxr.free-electrons.com/source/drivers/base/class.c?v=3.14#L211" class="urlextern" title="http://lxr.free-electrons.com/source/drivers/base/class.c?v=3.14#L211"  rel="nofollow">class_unregister</a>.
</p>

<p>
În plus, pentru fiecare dispozitiv trebuie inițializată o structură <a href="http://lxr.free-electrons.com/source/include/linux/device.h?v=3.13#L655" class="urlextern" title="http://lxr.free-electrons.com/source/include/linux/device.h?v=3.13#L655"  rel="nofollow">device</a> și înregistrată cu <a href="http://lxr.free-electrons.com/source/drivers/base/core.c?v=3.13#L1662" class="urlextern" title="http://lxr.free-electrons.com/source/drivers/base/core.c?v=3.13#L1662"  rel="nofollow">device_create</a> (la execuția funcției <code>parallel_pnp_probe</code>). La apelul funcţiei <a href="http://lxr.free-electrons.com/source/drivers/base/core.c?v=3.13#L1662" class="urlextern" title="http://lxr.free-electrons.com/source/drivers/base/core.c?v=3.13#L1662"  rel="nofollow">device_create</a>, folosiți pentru al patrulea parametru construcția <code>&amp;dev-&gt;dev</code>. Este câmpul de tipul <a href="http://lxr.free-electrons.com/source/include/linux/device.h?v=3.13#L655" class="urlextern" title="http://lxr.free-electrons.com/source/include/linux/device.h?v=3.13#L655"  rel="nofollow">struct device</a> al structurii <a href="http://lxr.free-electrons.com/source/include/linux/pnp.h?v=3.13#L243" class="urlextern" title="http://lxr.free-electrons.com/source/include/linux/pnp.h?v=3.13#L243"  rel="nofollow">struct pnp_dev</a>.
</p>

<p>
La înlăturarea dispozitivului (în funcţia <code>parallel_pnp_remove</code>) folosiți funcția <a href="http://lxr.free-electrons.com/source/drivers/base/core.c?v=3.13#L1750" class="urlextern" title="http://lxr.free-electrons.com/source/drivers/base/core.c?v=3.13#L1750"  rel="nofollow">device_destroy</a>.
</p>

<p>
Recitiți secțiunea <a href="../../../../../so2/laboratoare/lab12.html#clase" class="wikilink1" title="so2:laboratoare:lab12">Clase</a> din laborator.
</p>

<p>

</div></p>
</p>

<p>
Pentru verificare, urmăriți conținutul directorului aferent din sysfs:
</p>
<pre class="code"># ls /sys/class/parclass/</pre>

</div>
<!-- EDIT11 SECTION "5. [2p] Clase" [15317-17255] -->
<h2 class="sectionedit12" id="extra">Extra</h2>
<div class="level2">

</div>

<h5 id="karma_usb_hotplug">(+3 karma) USB Hotplug</h5>
<div class="level5">

<p>
În subdirectorul <code>usb_extra</code> găsiți o implementare minimală a unui driver USB. Analizați sursa <code>usb.c</code> și observați implementarea mecanismului de <code>Hotplug</code> si conectarea la magistrala <code>USB</code>. Observați asemănările cu interfața dintre magistralei <code>PNP</code> studiată în laborator și driverele asociate: <code>struct usb_driver</code> / <code>struct pnp_driver</code>, implementarea funcției <code>probe</code> (<code>skel_probe</code>), tabela <code>skel_table</code> cu care se inițializează câmpul <code>id_table</code> pentru a identifica device-urile compatibile, etc.
</p>

<p>
Conectați un device USB pe mașina fizică. Apelați <code>dmesg</code> sau <code>lsusb</code> pentru a identifica vendorId-ul și productId-ul device-ul atașat. 
</p>
<pre class="code bash">usb <span class="nu0">3</span>-<span class="nu0">2</span>: New USB device found, <span class="re2">idVendor</span>=1e3d, <span class="re2">idProduct</span>=<span class="nu0">6025</span></pre>

<p>
Modificați codul din <code>usb.c</code> pentru a crea un driver compatibil cu device-ul vostru. Compilați modulul și inserați-l pe mașina fizică (sau pe o mașină virtuală cu udev și acces la USB-ul gazdei). Reconectați device-ul USB. Ce observați la rularea comenzii dmesg?
</p>

<p>
Cel mai probabil device-ul va fi preluat de alt driver usb din sistem (e.x. usb_storage). În acest caz, puteți descărca temporar modulul concurent (rmmod usb_storage). Dacă device-ul se conectează la driverului <code>usb.ko</code>, puteți observa mesajul “USB Skeleton device now attached to USBSkel-0”, mesaj afișat de funcția <code>skel_probe</code>.   
</p>

<p>
Descărcați modulul. Creați o regulă <code>udev</code>, care la identificarea dispozitivului (după <code>ATTRS{idVendor}</code> și <code>ATTRS{idProduct}</code>), să încarce driverul <code>usb.ko</code>. Recitiți secțiunea <a href="../../../../../so2/laboratoare/lab12.html#hotplug" class="wikilink1" title="so2:laboratoare:lab12"> Hotplug</a> din laborator. Cu modulul descărcat, reconectați device-ul USB. Ce observați la rularea comenzilor <code>dmesg</code> și <code>lsmod</code>?
</p>

</div>
<!-- EDIT12 SECTION "Extra" [17256-19068] -->
<h2 class="sectionedit13" id="solutii">Soluții</h2>
<div class="level2">
<ul>
<li class="level1"><div class="li"> <a href="http://elf.cs.pub.ro/so2/res/laboratoare/lab12-sol.zip" class="urlextern" title="http://elf.cs.pub.ro/so2/res/laboratoare/lab12-sol.zip"  rel="nofollow">Soluții exerciții laborator 12</a></div>
</li>
</ul>

</div>
<!-- EDIT13 SECTION "Soluții" [19069-] --></div>
</body>
</html>
