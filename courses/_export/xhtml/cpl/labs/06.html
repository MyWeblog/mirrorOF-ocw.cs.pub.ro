    
    

<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
  <meta charset="utf-8" />
  <title>cpl:labs:06</title>
<meta name="generator" content="DokuWiki"/>
<meta name="robots" content="index,follow"/>
<meta name="date" content="2016-11-08T00:02:58+0200"/>
<meta name="keywords" content="cpl,labs,06"/>
<link rel="search" type="application/opensearchdescription+xml" href="../../../../lib/exe/opensearch.php" title="CS Open CourseWare"/>
<link rel="start" href="../../../../../courses.1.html"/>
<link rel="alternate" type="application/rss+xml" title="Recent Changes" href="../../../../feed.php"/>
<link rel="alternate" type="application/rss+xml" title="Current Namespace" href="../../../../feed.php%3Fmode=list&amp;ns=cpl:labs"/>
<link rel="alternate" type="text/html" title="Plain HTML" href="06.html"/>
<link rel="canonical" href="../../../../cpl/labs/06.html"/>
<link rel="stylesheet" type="text/css" href="../../../../lib/exe/css.php%3Ft=arctic&amp;tseed=1476798676.css"/>
<script type="text/javascript">/*<![CDATA[*/var NS='cpl:labs';var JSINFO = {"id":"cpl:labs:06","namespace":"cpl:labs","isadmin":0,"isauth":0};
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="../../../../lib/exe/js.php%3Ftseed=1476798676"></script>
<script type="text/x-mathjax-config">/*<![CDATA[*/MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ["$","$"], ["\\(","\\)"] ],
        displayMath: [ ["$$","$$"], ["\\[","\\]"] ],
        processEscapes: true
    }
});
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
<script type="text/javascript">/*<![CDATA[*/
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
		  
/*!]]>*/</script>
<script type="text/javascript">/*<![CDATA[*/
var pageTracker = _gat._getTracker("UA-38383934-1");
pageTracker._initData();
pageTracker._trackPageview();
		  
/*!]]>*/</script>
</head>
<body>
<div class="dokuwiki export">
<!-- TOC START -->
<div id="dw__toc">
<h3 class="toggle">Table of Contents</h3>
<div>

<ul class="toc">
<li class="level1"><div class="li"><a href="06.html#code_generation_structure_of_data_and_objects_in_memory">06. Code generation. Structure of data and objects in memory</a></div>
<ul class="toc">
<li class="level2"><div class="li"><a href="06.html#tipuri_de_sectiuni">Tipuri de secțiuni</a></div></li>
<li class="level2"><div class="li"><a href="06.html#tipuri_de_date">Tipuri de date</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="06.html#integer">integer</a></div></li>
<li class="level3"><div class="li"><a href="06.html#char">char</a></div></li>
<li class="level3"><div class="li"><a href="06.html#float">float</a></div></li>
<li class="level3"><div class="li"><a href="06.html#enum">enum</a></div></li>
<li class="level3"><div class="li"><a href="06.html#array">array</a></div></li>
<li class="level3"><div class="li"><a href="06.html#struct">struct</a></div></li>
<li class="level3"><div class="li"><a href="06.html#pointer">pointer</a></div></li>
<li class="level3"><div class="li"><a href="06.html#string">string</a></div></li>
<li class="level3"><div class="li"><a href="06.html#set">set</a></div></li>
<li class="level3"><div class="li"><a href="06.html#union">union</a></div></li>
<li class="level3"><div class="li"><a href="06.html#bitfield">bitfield</a></div></li>
<li class="level3"><div class="li"><a href="06.html#class">class</a></div></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><div class="li"><a href="06.html#inferenta_de_tipuri">Inferența de tipuri</a></div>
<ul class="toc">
<li class="level2"><div class="li"><a href="06.html#conversiile_de_tipuri">Conversiile de tipuri</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="06.html#conversii_numerice_explicite">conversii numerice explicite</a></div>
<ul class="toc">
<li class="level4"><div class="li"><a href="06.html#conversii_numerice_implicite">conversii numerice implicite</a></div></li>
</ul>
</li>
<li class="level3"><div class="li"><a href="06.html#conversii_de_pointeri_explicite">conversii de pointeri explicite</a></div></li>
<li class="level3"><div class="li"><a href="06.html#conversii_de_pointeri_implicite">conversii de pointeri implicite</a></div></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><div class="li"><a href="06.html#exercitii">Exerciții</a></div>
<ul class="toc">
<li class="level2"><div class="li"><a href="06.html#bonus">BONUS</a></div></li>
</ul></li>
</ul>
</div>
</div>
<!-- TOC END -->

<h1 class="sectionedit1" id="code_generation_structure_of_data_and_objects_in_memory">06. Code generation. Structure of data and objects in memory</h1>
<div class="level1">

<p>
În urma compilării și linkării unui program rezultă un fişier binar care, indiferent de formatul lui, este reprezentarea programului în memoria procesorului pentru care a fost compilat. Aceasta reprezentare conține în mod uzual mai multe secțiuni implicite, secțiuni care în funcție de format au diverse denumiri, dar scopul lor este asemănător.
</p>

</div>
<!-- EDIT1 SECTION "06. Code generation. Structure of data and objects in memory" [1-438] -->
<h2 class="sectionedit2" id="tipuri_de_sectiuni">Tipuri de secțiuni</h2>
<div class="level2">
<ul>
<li class="level1"><div class="li"> <code>secțiunea de cod</code> (<code>.code</code> sau <code>.text</code>) este secțiunea în care se păstrează, codificate binar, instrucțiunile pe care le va executa procesorul.</div>
</li>
<li class="level1"><div class="li"> <code>secțiunea de date</code> (<code>.data</code>) este secțiunea în care se aloca variabilele globale.</div>
</li>
<li class="level1"><div class="li"> <code>secțiunea de constante</code> (<code>.const</code> sau <code>.rodata</code>) este secțiunea în care se păstrează datele constante dintr-un program.</div>
</li>
<li class="level1"><div class="li"> <code>secțiunea de heap</code> (<code>.heap</code>) este secțiunea în care programatorul poate aloca dinamic memorie cu apeluri de tipul malloc sau new.</div>
</li>
<li class="level1"><div class="li"> <code>secțiunea de stiva</code> (<code>.stack</code>) este secțiunea folosita pentru pastrarea contextului specific fiecărei funcții (parametrii funcției, variabilele locale și alte date care nu sunt neapărat vizibile la nivelul programatorului).</div>
</li>
</ul>

<p>
Dimensiunea secțiunilor, poziționarea lor în memorie, precum și alte aspecte legate de modalitățile de accesare a lor sunt specifice fiecărei arhitecturi. Din motive de securitate, unele procesoare pot restricţiona accesul la scriere in sectiunea de constante, sau pot permite executia doar din secţiunea de cod.
</p>

<p>
Din punct de vedere a reprezentării datelor, aceste secțiuni găzduiesc diferite tipuri de date din punct de vedere a vizibilității lor în program:
</p>
<ul>
<li class="level1"><div class="li"> variabilele globale se vor regăsi în secțiunea de date</div>
</li>
<li class="level1"><div class="li"> constantele se vor regăsi în secțiunea de constante. Majoritatea compilatoarelor încadrează la aceasta secțiune și şirurile de caractere explicite.</div>
</li>
<li class="level1"><div class="li"> variabilele locale se vor regăsi fie într-un registru, fie pe stiva în contextul specific funcției de care aparțin. </div>
</li>
</ul>

<p>
În figura de mai jos este o <code>posibilă</code> distribuție a acestor secțiuni în memorie:
</p>
<pre class="code">.stack
 ...
.heap
.data
.const
.code</pre>

<p>
În afară de aceste secţiuni implicite, programatorul poate defini secţiuni noi, eventual plasate în zone de memorie specificate explicit.
</p>

</div>
<!-- EDIT2 SECTION "Tipuri de secțiuni" [439-2352] -->
<h2 class="sectionedit3" id="tipuri_de_date">Tipuri de date</h2>
<div class="level2">

<p>
Pentru a translata un program scris într-un limbaj de nivel înalt trebuie să oferim mecanisme de reprezentare a structurilor de date ale limbajului, care sunt în general mult mai complexe decât cele suportate nativ de procesorul pentru care se face translatarea. 
</p>

<p>
În continuare vom prezenta pe scurt câteva reprezentări posibile pentru cele mai folosite tipuri de date:
</p>

</div>
<!-- EDIT3 SECTION "Tipuri de date" [2353-2760] -->
<h3 class="sectionedit4" id="integer">integer</h3>
<div class="level3">

<p>
Ne aşteptăm în general ca arhitectura să ofere un suport substanțial pentru lucrul cu numere întregi. Operațiile pe întregi mai lungi sunt implementate prin mai multe load-uri, store-uri și operații de tip addc (add with carry), subb (substract with borrow). Operațiile pe numere întregi mai scurte (byte, short) sunt implementate prin load-uri urmate de operații de extindere a semnului.
</p>

</div>
<!-- EDIT4 SECTION "integer" [2761-3182] -->
<h3 class="sectionedit5" id="char">char</h3>
<div class="level3">

<p>
În general, caracterele se reprezintă pe un octet, de exemplu codificarea <abbr title="American Standard Code for Information Interchange">ASCII</abbr>. În C, tipul de date <code>char</code> nu este nici cu semn, nici fără semn (conform standardului). În situația în care programatorul folosește acest tip de date pentru a reprezenta numere pe 8 biți, atunci el va trebui să precizeze explicit dacă tipul de date este <code>signed</code> sau <code>unsigned</code>. Mai nou compilatoarele oferă suport și pentru caractere pe 2 octeți (de ex. Unicode) - aceste reprezentări cuprind și alte stiluri de scriere în afară de cel latin (Katakana, Hiragana, Chinese etc.). Codificările multibyte (de exemplu UTF-8: 8-bit Unicode) permit reprezentarea a mai mult de 256 de caractere păstrând compatibilitatea cu codificarea <abbr title="American Standard Code for Information Interchange">ASCII</abbr>.
</p>

</div>
<!-- EDIT5 SECTION "char" [3183-3944] -->
<h3 class="sectionedit6" id="float">float</h3>
<div class="level3">

<p>
Tipurile floating point au în general două sau trei formate - single, double și (ceva mai puțin frecvent) extended și ocupă până la 80 biți. Hardware-ul suporta tipul float în simplă precizie și de multe ori și dublă precizie. O excepție notabila este arhitectura Intel386 care nu suporta decât tipul extins pe 80 biți.
</p>

<p>
Pentru majoritatea arhitecturilor, e nevoie de suport software pentru operațiile în virgulă mobilă, de exemplu pentru tratarea cazurilor de overflow, underflow sau operaţii invalide. În unele cazuri - de exemplu pentru majoritatea microcontroller-urilor sau DSP-urilor - operațiile în virgula mobila sunt emulate în întregime de software, fiind implementate ca apeluri de funcții de bibliotecă.
</p>

</div>
<!-- EDIT6 SECTION "float" [3945-4707] -->
<h3 class="sectionedit7" id="enum">enum</h3>
<div class="level3">

<p>
Valorile din enum-uri sunt, în general, reprezentate ca numere întregi naturale consecutive, fără semn; de obicei tipul enum se mapează pe int.
</p>

</div>
<!-- EDIT7 SECTION "enum" [4708-4873] -->
<h3 class="sectionedit8" id="array">array</h3>
<div class="level3">

<p>
În general, array-urile pot avea mai mult de o dimensiune și, în funcție de limbaj, pot avea elemente doar de un tip fundamental (tip predefinit în limbaj) sau pot avea elemente de orice tip (definit de utilizator). În ambele cazuri, pot fi văzute ca blocuri n-dimensionale, cu fiecare dimensiune corespunzând unui indice. Ele sunt liniarizate fiind împărțite în &#039;felii&#039;, pe rânduri (sau în cazul Fortran-ului - pe coloane) și alocând spațiu de stocare pentru fiecare element în funcție de poziția lui în cadrul feliei. De exemplu, un vector declarat în Pascal:
</p>
<pre class="code pascal"> <span class="kw1">var</span> a<span class="sy1">:</span> <span class="kw4">array</span><span class="br0">&#91;</span><span class="nu0">1</span><span class="sy1">..</span><span class="nu0">10</span><span class="sy1">,</span> <span class="nu0">0</span><span class="sy1">..</span><span class="nu0">5</span><span class="br0">&#93;</span> <span class="kw1">of</span> <span class="kw4">integer</span><span class="sy1">;</span> </pre>

<p>
ocupă (10-1+1)*(5-0+1) = 60 de elemente.
a[1, 0] va fi elementul nr. 0
a[2, 0] va fi elementul nr. 6 etc.
În general, pentru un array Pascal:
</p>
<pre class="code pascal"> <span class="kw1">var</span> vect<span class="sy1">:</span> <span class="kw4">array</span><span class="br0">&#91;</span>lo1<span class="sy1">..</span><span class="me1">hi1</span><span class="sy1">,</span> lo2<span class="sy1">..</span><span class="me1">hi2</span><span class="sy1">,</span> <span class="sy1">...,</span> loN<span class="sy1">..</span><span class="me1">hiN</span><span class="br0">&#93;</span> <span class="kw1">of</span> <span class="kw1">type</span><span class="sy1">;</span> </pre>

<p>
adresa elementului vect[e1, e2, …., en] este:
&lt;latex&gt; base(vect) + size(type) * \sum_{i=1}^N (e_{i} - lo_{i})\prod_{j=1}^i (hi_{j}-lo_{j}+1) &lt;/latex&gt;
</p>

<p>
unde base(vect) e adresa primului element și size(type) e numărul de octeți ocupat de fiecare element. Uneori, pentru a spori eficienta, compilatorul rotunjește numărul de octeți ocupat de un element pana la o dimensiune care poate fi încărcată eficient din memorie.
</p>

</div>
<!-- EDIT8 SECTION "array" [4874-6189] -->
<h3 class="sectionedit9" id="struct">struct</h3>
<div class="level3">

<p>
Compilatoarele aleg să reprezinte aceste structuri:
</p>
<ul>
<li class="level1"><div class="li"> împachetat - cu elementele consecutive puse unul după altul în memorie, sau</div>
</li>
<li class="level1"><div class="li"> neîmpachetat - adică cu elementele aliniate</div>
</li>
</ul>

<p>
O greşeala foarte comuna este să se presupună ca elementele unui struct sunt întotdeauna poziționate unul după altul, de exemplu să recepționeze un șir de octeți dintr-un socket direct într-un struct, aşteptându-se să nu existe spații goale între membrii structurii. De observat că, deși nu se poate “prezice” cu siguranță spațiul care va fi inserat între membrii unei structuri, <a href="http://www.open-std.org/JTC1/SC22/WG14/" class="urlextern" title="http://www.open-std.org/JTC1/SC22/WG14/"  rel="nofollow"> standardul</a> C nu permite inversarea ordinii membrilor structurii și nici prezență de spații goale înainte de primul membru (vezi secțiunea 6.7.2.1 din <a href="http://www.open-std.org/JTC1/SC22/WG14/www/C99RationaleV5.10.pdf" class="urlextern" title="http://www.open-std.org/JTC1/SC22/WG14/www/C99RationaleV5.10.pdf"  rel="nofollow"> rationale</a>).
</p>

</div>
<!-- EDIT9 SECTION "struct" [6190-7081] -->
<h3 class="sectionedit10" id="pointer">pointer</h3>
<div class="level3">

<p>
Pointerii sunt nişte variabile ce conțin o adresă din memorie. Aspecte care poate nu sunt evidente pentru toată lumea:
</p>
<ul>
<li class="level1"><div class="li"> Dimensiunea unui pointer este dimensiunea unui cuvant din arhitectura pentru care s-a compilat (tipul de date <code>long</code> în C). Din punct de vedere al standardului C, nu este corect sa se presupuna ca un un pointer are aceeași dimensiune cu un număr <code>long</code>.</div>
</li>
<li class="level1"><div class="li"> “Tip *a” <strong>NU</strong> este echivalent cu “Tip a[ ]”. Majoritatea cred că a[5] este echivalent cu *(a+5) și crede că a declara o variabilă ca “pointer” este echivalent cu a o declara “array”. După cum s-a explicat mai sus - array-ul e un șir continuu de elemente de tipul “Tip”, pe când pointer-ul e o adresa la un element de tipul “Tip”. Rezultatul operatorului <code>sizeof</code> diferă.</div>
</li>
</ul>

<p>
În general translatoarele fac <code>cast</code> automat între pointer și array și de aceea diferența poate fi uneori greu de conştientizat.
</p>

<p>
Un exemplu și pentru reprezentarea și plasarea în memorie a array-urilor și pointerilor, inclusiv din punct de vedere al secțiunilor în care ajung aceste date este următorul:
</p>
<pre class="code c"><span class="kw4">char</span> st1<span class="br0">&#91;</span><span class="nu0">6</span><span class="br0">&#93;</span><span class="sy0">;</span>
<span class="kw4">char</span> st2<span class="br0">&#91;</span><span class="br0">&#93;</span> <span class="sy0">=</span> “ABCD”<span class="sy0">;</span>
<span class="kw4">const</span> <span class="kw4">char</span> <span class="sy0">*</span>st3 <span class="sy0">=</span> “<span class="nu0">1234</span>”<span class="sy0">;</span></pre>

<p>
<a href="../../../../_detail/cpl/labs/laborator-05-reprezentare-date.png%3Fid=cpl%253Alabs%253A06.html" class="media" title="cpl:labs:laborator-05-reprezentare-date.png"><img src="../../../../_media/cpl/labs/laborator-05-reprezentare-date.png%3Fw=480&amp;tok=de0792" class="mediacenter" alt="" width="480" /></a>
</p>

<p>
În acest caz:
</p>
<ul>
<li class="level1"><div class="li"> st1 este un array neinitializat, care va fi păstrat în secțiunea de date;</div>
</li>
<li class="level1"><div class="li"> st2 este un array initializat care va fi păstrat în secțiunea de date, dar valoarea sa de initializare va fi păstrată în secțiunea de constante și va fi copiată în secvența de startup corespunzătoare execuției programului;</div>
</li>
<li class="level1"><div class="li"> st3 este un pointer către un șir de caractere, șir de caractere care va fi păstrat în secțiunea de constante.</div>
</li>
</ul>

<p>
Operatia *st = 0 este permisă atât pentru st1 cât și pentru st2, având ca rezultat modificarea primei valori din cele 2 array-uri, în schimb ce *st3 = 0 nu este permis pentru ca ar presupune modificări în secțiunea de constante (operație ilegală).
</p>

</div>
<!-- EDIT10 SECTION "pointer" [7082-9053] -->
<h3 class="sectionedit11" id="string">string</h3>
<div class="level3">

<p>
Probabil cele mai cunoscute reprezentări:
</p>
<ul>
<li class="level1"><div class="li"> cea din Pascal - pe primul octet se ține dimensiunea șirului,</div>
</li>
<li class="level1"><div class="li"> cea din C - șirul de caractere este terminat cu caracterul NULL.</div>
</li>
</ul>

</div>
<!-- EDIT11 SECTION "string" [9054-9252] -->
<h3 class="sectionedit12" id="set">set</h3>
<div class="level3">

<p>
Șiruri de biți, un bit e 1 dacă elementul este în mulțime și 0 altfel. Dacă știm că un set este rar (adică are mult mai multe elemente posibile decât elemente efective) o reprezentare mai bună e un vector sortat de elemente sau un arbore binar de căutare.
</p>

</div>
<!-- EDIT12 SECTION "set" [9253-9536] -->
<h3 class="sectionedit13" id="union">union</h3>
<div class="level3">

<p>
O uniune este similara ca declarație cu o structură cu mențiunea că toți membrii unei uniuni sunt toți poziționați de la aceeași adresă în memorie; spațiul alocat în memorie pentru o uniune corespunde cu dimensiunea celui mai mare membru. Principala utilitate a uniunilor este aceea a conservării spațiului, deoarece permite posibilitatea de a stoca mai multe tipuri în același spațiu de memorie – uniunile sunt o formă incipientă de polimorfism. Tocmai datorita faptului ca toți membrii unei uniuni coexistă în același spațiu de memorie, este aproape imposibil pentru un compilator să facă o verificare ca tipul scris într-o uniune este și tipul citit din acea uniune; Verificarea faptul ca sunt folosiți corect membrii dintr-o uniune revine în totalitate programatorului.
</p>

</div>
<!-- EDIT13 SECTION "union" [9537-10360] -->
<h3 class="sectionedit14" id="bitfield">bitfield</h3>
<div class="level3">

<p>
Un bitfield este în general păstrat într-un cuvânt maşină, iar fiecare din biți este adresat nu prin poziția sa, ci prin numele asociat acestuia (sau acestora), exact ca atunci când se accesează un membru al unei structuri. Deși din punct de vedere a limbajului de programare folosirea de bitfield-uri rezolva probleme legate de manipularea de secvențe de biți și de împachetare a datelor care ocupă mai putin decât dimensiunea unui octet (sau cuvânt), din punct de vedere al codului generat (și implicit a compilatorului), bitfield-urile pot ridica foarte multe probleme: 
* codul de acces pentru fiecare bit al bitfield-ului poate fi foarte ineficient deoarece în general arhitecturile nu permit accese de memorie pe biți, ci pe cuvinte de memorie;
* trebuie avut grijă și la suprapunerile de acces la memorie ce pot aparea în cazul execuției în paralel a acceselor la biții dintr-un bitfield. 
</p>

<p>
<strong>ATENȚIE</strong>: ordinea biților într-un bitfield nu este garantată, compilatorul putând rearanja biții – de aceea, biții trebuie întotdeauna accesați prin membrul corespunzător din structura și niciodată prin poziția sa!
</p>

</div>
<!-- EDIT14 SECTION "bitfield" [10361-11538] -->
<h3 class="sectionedit15" id="class">class</h3>
<div class="level3">

<p>
Într-un limbaj orientat obiect, reprezentarea unei clase este legată de cea a unei structuri, în care se adaugă membri suplimentari. Pentru a implementa moştenirea și polimorfismul, reprezentarea unui obiect derivat conține subobiecte corespunzătoare claselor de baza. Din acest motiv, un pointer la obiectul derivat se poate converti către un pointer la obiectul de bază, ca în exemplul următor. De remarcat că, în cazul în care există mai multe clase de bază sau interfețe implementate, obiectul de bază se poate găsi la o altă adresă decât obiectul derivat.
</p>
<pre class="code c">class B <span class="br0">&#123;</span> 
  <span class="kw4">int</span> a<span class="sy0">,</span> b<span class="sy0">;</span> 
  virtual <span class="kw4">void</span> f<span class="br0">&#40;</span><span class="kw4">void</span><span class="br0">&#41;</span><span class="sy0">;</span>
<span class="br0">&#125;</span><span class="sy0">;</span>
&nbsp;
class B1 <span class="br0">&#123;</span>
  <span class="kw4">int</span> x<span class="sy0">,</span> y<span class="sy0">;</span>
  virtual <span class="kw4">void</span> z<span class="br0">&#40;</span><span class="kw4">void</span><span class="br0">&#41;</span><span class="sy0">;</span>
<span class="br0">&#125;</span><span class="sy0">;</span>
&nbsp;
class D<span class="sy0">:</span> B<span class="sy0">,</span> B1 <span class="br0">&#123;</span> 
  <span class="kw4">int</span> c<span class="sy0">,</span> d<span class="sy0">;</span>
  <span class="kw4">void</span> f<span class="br0">&#40;</span><span class="kw4">void</span><span class="br0">&#41;</span><span class="sy0">;</span>
  <span class="kw4">void</span> z<span class="br0">&#40;</span><span class="kw4">void</span><span class="br0">&#41;</span><span class="sy0">;</span> 
<span class="br0">&#125;</span><span class="sy0">;</span>
&nbsp;
D objD<span class="sy0">;</span> B1 <span class="sy0">*</span> ptrB1<span class="sy0">;</span>
PtrB1 <span class="sy0">=</span> <span class="sy0">&amp;</span>objD<span class="sy0">;</span>
ptrB1<span class="sy0">-&gt;</span>f<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>
<a href="../../../../_detail/cpl/labs/laborator-05-reprezentare-obiecte.png%3Fid=cpl%253Alabs%253A06.html" class="media" title="cpl:labs:laborator-05-reprezentare-obiecte.png"><img src="../../../../_media/cpl/labs/laborator-05-reprezentare-obiecte.png%3Fw=480&amp;tok=69ca31" class="mediacenter" alt="" width="480" /></a>
</p>

<p>
Reprezentarea unei clase poate conține un membru ascuns, un pointer către tabela funcțiilor virtuale (vtable). Există o tabelă asociată fiecărei clase, iar tabela clasei derivate are sub-tabele corespunzând claselor de bază. Un apel către o funcție virtuală implică două citiri din memorie – prima pentru a afla tabela corectă, a doua pentru a afla adresa funcției. Prin acest mecanism, pornind de la un pointer către o instanță a unei clasă de bază se poate apela o metodă a clasei derivate.
De remarcat:
</p>
<ul>
<li class="level1"><div class="li"> in C++, toate metodele sunt automat finale. Urmatorul exemplu arata o functie finala, una virtuala, si, respectiv, una pur virtuala:</div>
</li>
<li class="level1"><div class="li"> <pre class="code c">class foo
<span class="br0">&#123;</span>
<span class="kw4">int</span> bar1<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span> <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span> <span class="br0">&#125;</span><span class="sy0">;</span>
virtual <span class="kw4">int</span> bar2<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span> <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span> <span class="br0">&#125;</span><span class="sy0">;</span>
virtual <span class="kw4">int</span> bar3<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">&#125;</span></pre>
</div>
</li>
<li class="level1"><div class="li"> in Java, toate metodele sunt automat virtuale. Urmatorul exemplu arata o functie finala, una virtuala, si, respectiv, una pur virtuala:</div>
</li>
<li class="level1"><div class="li"> <pre class="code c">abstract class foo
<span class="br0">&#123;</span>
final <span class="kw4">int</span> bar1<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span> <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span> <span class="br0">&#125;</span> 
<span class="kw4">int</span> bar2<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span> <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span> <span class="br0">&#125;</span>
abstract <span class="kw4">int</span> bar3<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
<span class="br0">&#125;</span></pre>
</div>
</li>
</ul>

<p>
Vom vorbi mai mult despre generarea de cod pentru clase in laboratorul urmator.
</p>

</div>
<!-- EDIT15 SECTION "class" [11539-13563] -->
<h1 class="sectionedit16" id="inferenta_de_tipuri">Inferența de tipuri</h1>
<div class="level1">

<p>
Inferența de tipuri reprezintă posibilitatea de deducere automată, parțială sau integrală, a tipului valorii derivate dintr-o eventuală evaluare a unei expresii. Din moment ce acest proces are loc în timpul compilării, compilatorul este de obicei capabil sa „infere” tipul unei variabile sau semnătura de tip a unei funcții, fără adnotări explicite de tip. În multe cazuri este posibilă omiterea completă a adnotărilor de tipuri dintr-un program dacă sistemul de inferență de tipuri este suficient de robust, sau dacă programul sau limbajul de programare este suficient de simplu. 
De exemplu, pentru o functie simplă în C
</p>
<pre class="code c"><span class="kw4">int</span> increment<span class="br0">&#40;</span><span class="kw4">int</span> x<span class="br0">&#41;</span>
<span class="br0">&#123;</span>
    <span class="kw1">return</span> x <span class="sy0">+</span> <span class="nu0">1</span><span class="sy0">;</span>
<span class="br0">&#125;</span></pre>

<p>
Într-un limbaj fără declarația explicită a tipurilor, precum Python, sau Visual Basic, ea se poate scrie
</p>
<pre class="code python">increment<span class="br0">&#40;</span>x<span class="br0">&#41;</span>
<span class="br0">&#123;</span>
    <span class="kw1">return</span> x + <span class="nu0">1</span><span class="sy0">;</span>
<span class="br0">&#125;</span></pre>

<p>
Din faptul ca 1 este număr întreg și din faptul că adunarea este permisă doar între numere de același fel și că rezultatul adunării este tot număr de același fel cu ceilalți operanzi, se poate „infera” ca funcția de incrementare întoarce un număr întreg și, de asemenea, că primește o valoare întreagă.
</p>

<p>
Și in C# se pot defini variabile fără a specifica tipul, si acestea trebuie inițializate la definire. Exemplu:
</p>
<pre class="code c"> var lista <span class="sy0">=</span> new List<span class="sy0">&lt;</span>Int64<span class="sy0">&gt;</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span> </pre>

<p>
Pentru a obține informații corecte pentru inferența tipului unei expresii care nu are o adnotare de tip explicită, compilatorul poate fie să adune informații de tip din adnotările specifice sub-expresiilor ce formează expresia neadnotată, fie prin înțelegerea implicită a valorilor diferiților atomi ce formează expresia. 
</p>

<p>
De cele mai multe ori compilatoarele care fac inferență de tipuri folosesc o combinație complexă a acestor două metode.
</p>

<p>
Este posibil să existe cazuri care nu pot fi complet rezolvate de inferența de tipuri, de exemplu în cazul polimorfismului. Oricât de performantă ar fi inferența de tipuri, de multe ori, pentru dezambiguizări (atât pentru programator cât și pentru compilator), este bine să se folosească adnotări de tipuri.
</p>

<p>
Deşi inferența de tipuri este foarte des întâlnită în limbajele funcționale, exista și limbaje de programare clasice care prezintă anumite forme de inferență de tipuri. În cele ce urmează se vor face referiri la forme de inferență în limbajul C.
</p>

<p>
În limbajul C, inferența de tipuri este necesară în momentul în care într-o expresie, operanzii au tipuri diferite, iar operațiile asociate expresiei sunt valide pentru mai multe din tipurile implicate în expresie. În astfel de cazuri, se aplică intern conversii între tipurile operanzilor la alte tipuri care să permită corectitudinea operațiilor, pe operanzi omogeni (din punct de vedere al tipurilor). Astfel de conversii se numesc conversii implicite, iar omogenitatea tipurilor operanzilor este dictată de standardele limbajului de programare (de exemplu pentru C, standardul ANSI).
</p>

</div>
<!-- EDIT16 SECTION "Inferența de tipuri" [13564-16627] -->
<h2 class="sectionedit17" id="conversiile_de_tipuri">Conversiile de tipuri</h2>
<div class="level2">

<p>
Conversiile de tipuri se pot clasifica după mai multe criterii; cele mai reprezentative sunt:
* implicit sau explicit
* numerice sau de pointeri
</p>

<p>
Din combinația celor 2 criterii se pot obține 4 categorii de conversii destul de uzuale:
</p>

</div>
<!-- EDIT17 SECTION "Conversiile de tipuri" [16628-16899] -->
<h3 class="sectionedit18" id="conversii_numerice_explicite">conversii numerice explicite</h3>
<div class="level3">
<pre class="code c"> <span class="kw4">int</span> x <span class="sy0">=</span> <span class="br0">&#40;</span><span class="kw4">int</span><span class="br0">&#41;</span> <span class="nu16">3.3</span><span class="sy0">;</span> </pre>

<p>
O astfel de conversie, presupune extragerea părții întregi a unui număr în virgulă mobilă; deși din punct de vedere al programatorului o astfel de operațiune pare trivială, din punct de vedere al compilatorului nu este atât de simplu și presupune calcule destul de complexe (în funcție și de suportul de virgulă mobilă specific arhitecturii pentru care se compilează); de foarte multe ori, astfel de conversii presupun apeluri de funcții de bibliotecă care emulează funcționarea procesorului în virgulă mobilă. 
</p>

</div>

<h4 id="conversii_numerice_implicite">conversii numerice implicite</h4>
<div class="level4">

<p>
Aceste conversii presupun promovări ale anumitor operanzi dintr-o expresie la tipuri superioare (mai cuprinzătoare) tipului lor, acest lucru permițând efectuarea de operații pe tipuri care la prima vedere sunt neomogene ordinea promovării tipurilor numerice este următoarea:
</p>
<pre class="code">                      char -&gt; unsigned char -&gt;
                      short int -&gt; unsigned short int -&gt;
                      int -&gt; unsigned int -&gt;
                      long -&gt; unsigned long -&gt;
                      long long -&gt; unsigned long long -&gt;
                      float -&gt; double -&gt; long double</pre>

<p>
<strong>NOTĂ</strong> Operațiile în virgulă mobilă se fac întotdeauna la precizie maximă (double sau long double, în funcție de arhitectură), iar rezultatul este apoi convertit la tipul și precizia corespunzatoare
</p>
<pre class="code c"><span class="kw4">int</span> a <span class="sy0">=</span> <span class="nu0">7</span><span class="sy0">,</span> b <span class="sy0">=</span> <span class="nu0">2</span><span class="sy0">;</span>
<span class="kw4">double</span> x<span class="sy0">;</span>
x <span class="sy0">=</span> a <span class="sy0">*</span> <span class="nu0">1</span>. <span class="sy0">/</span> b<span class="sy0">;</span>
x <span class="sy0">=</span> a <span class="sy0">/</span> b <span class="sy0">*</span> <span class="nu0">1</span>.<span class="sy0">;</span>
x <span class="sy0">=</span> <span class="nu0">1</span>. <span class="sy0">*</span> a <span class="sy0">+</span> a <span class="sy0">/</span> b<span class="sy0">;</span></pre>

<p>
O prima expresie: „a * 1. / b”. Toate operațiile se fac pe double, datorita promovării treptate a fiecărui operand.
</p>
<ul>
<li class="level1"><div class="li"> „a * 1.” înmulțire între întreg și float – fiind operație floating point se va face cu dublă precizie –</div>
</li>
<li class="level1"><div class="li"> a va fi promovat la double, la fel ca și constanta „1.”</div>
</li>
<li class="level1"><div class="li"> rezultatul double al expresiei anterioare se va impărți la valoarea întreagă b, care va fi convertită și ea la double. </div>
</li>
<li class="level1"><div class="li"> rezultatul obținut este un double – variabila căreia îi este atribuit rezultatul este tot double, deci nu mai este nevoie și de alta conversie – dacă variabila era de alt tip, o alta conversie ar fi fost necesară.</div>
</li>
</ul>

<p>
a doua expresie este „a / b * 1.”
</p>
<ul>
<li class="level1"><div class="li"> „a / b” este o operație între numere întregi. rezultatul împărțirii va fi un număr întreg (adica 3).</div>
</li>
<li class="level1"><div class="li"> întregul obținut la operația anterioară se va inmulți cu „1.”, rezultând o înmulțire de numere double, precedată de conversia lui 3 în virgulă mobilă.</div>
</li>
</ul>

<p>
a treia expresie este „1. * a + a / b”
</p>
<ul>
<li class="level1"><div class="li"> „1. * a” este o operație în virgulă mobilă datorita precedentei operatorilor, </div>
</li>
<li class="level1"><div class="li"> „a / b” este o impărțire de întregi, cu rezultat întreg</div>
</li>
<li class="level1"><div class="li"> cea de-a treia operație este +, efectuata pe numere în virgulă mobilă (precedată de conversiile implicite de rigoare)</div>
</li>
</ul>

</div>
<!-- EDIT18 SECTION "conversii numerice explicite" [16900-19786] -->
<h3 class="sectionedit19" id="conversii_de_pointeri_explicite">conversii de pointeri explicite</h3>
<div class="level3">

<p>
Conversiile explicite de pointeri, spre deosebire de conversiile numerice, nu produc schimbări în date, ci doar în modalitatea de folosire a adresei la care se referă pointerul
</p>
<pre class="code c"><span class="kw4">int</span> x <span class="sy0">=</span> <span class="nu0">12345</span><span class="sy0">;</span>
<span class="kw4">float</span> <span class="sy0">*</span>p<span class="sy0">;</span>
p <span class="sy0">=</span> <span class="br0">&#40;</span><span class="kw4">float</span> <span class="sy0">*</span><span class="br0">&#41;</span> <span class="sy0">&amp;</span>x<span class="sy0">;</span></pre>

<p>
În acest caz, *p va fi o valoare în virgulă mobilă care are ca reprezentare binară valoarea din x.
</p>

</div>
<!-- EDIT19 SECTION "conversii de pointeri explicite" [19787-20174] -->
<h3 class="sectionedit20" id="conversii_de_pointeri_implicite">conversii de pointeri implicite</h3>
<div class="level3">

<p>
Conversiile implicite de pointeri se fac doar către pointeri de tip void * - orice altă conversie de pointeri, atât între diferite tipuri de pointeri, cât și de la tipul void * la orice alt tip, trebuie făcute explicit:
</p>
<pre class="code c"><span class="kw4">void</span> <span class="sy0">*</span>p<span class="sy0">;</span>
<span class="kw4">int</span> x<span class="sy0">;</span>
<span class="kw4">int</span> <span class="sy0">*</span>q<span class="sy0">;</span>
p <span class="sy0">=</span> <span class="sy0">&amp;</span>x<span class="sy0">;</span>
q <span class="sy0">=</span> <span class="br0">&#40;</span><span class="kw4">int</span> <span class="sy0">*</span><span class="br0">&#41;</span> p<span class="sy0">;</span></pre>

</div>
<!-- EDIT20 SECTION "conversii de pointeri implicite" [20175-20508] -->
<h1 class="sectionedit21" id="exercitii">Exerciții</h1>
<div class="level1">

<p>
<a href="../../../../_media/cpl/labs/lab06_skel.zip" class="media mediafile mf_zip" title="cpl:labs:lab06_skel.zip (4.2 KB)">Arhiva</a> laboratorului.
</p>
<ol>
<li class="level1"><div class="li"> De ce nu există diferențe pentru definițiile lui v între următoarele semnături de funcții? <pre class="code c"> <span class="kw4">void</span> f<span class="br0">&#40;</span><span class="kw4">int</span> <span class="sy0">*</span> v<span class="br0">&#41;</span><span class="sy0">;</span> </pre>

<p>
  și 
</p>
<pre class="code c"> <span class="kw4">void</span> g<span class="br0">&#40;</span><span class="kw4">int</span> v<span class="br0">&#91;</span><span class="br0">&#93;</span><span class="br0">&#41;</span><span class="sy0">;</span> </pre>
</div>
</li>
<li class="level1"><div class="li"> Intrati in directorul <code>diff_vec_ptr1</code>. Rulati <code>make</code> apoi rulati programul. Care este problema? Incercati sa explicati apoi rezolvati bug-ul. Puteti vedea acelasi comportament si ruland codul din directorul <code>diff_vec_ptr2</code>.</div>
</li>
<li class="level1"><div class="li"> Determinați (inspectând codul asm) cum sunt implementați <a href="http://gcc.gnu.org/onlinedocs/gcc/Variable-Length.html" class="urlextern" title="http://gcc.gnu.org/onlinedocs/gcc/Variable-Length.html"  rel="nofollow"> vectorii automatici de lungime variabilă</a>. Pentru vectori automatici de lungime constantă <code>sizeof(v)</code> reprezintă toată memoria alocată (în bytes) pentru acel vector - o constantă cunoscută la momentul compilării. Cum este implementat operatorul <code>sizeof</code> pentru vectori de lungime variabilă? Folosiți codul din directorul <code>alloca</code> din arhiva laboratorului.</div>
</li>
<li class="level1"><div class="li"> Scrieți un program care să determine ordinea secțiunilor în memorie.</div>
<ul>
<li class="level2"><div class="li"> <code>Hint</code>: Declarați obiecte în fiecare secțiune și verificați adresa.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Intrati in directorul <code>classes</code>. Fara a modifica functia main, faceti schimbari in fisierul <code>classes.cpp</code> astfel incat sa apara “different”. Scoateti cast-urile catre void *. De ce afiseaza din nou “same”?</div>
</li>
<li class="level1"><div class="li"> Modificați programul următor pentru a afișa <strong>structurile sunt identice</strong>:</div>
</li>
</ol>
<dl class="file">
<dt><a href="../../../code/cpl/labs/06%3Fcodeblock=15" title="Download Snippet" class="mediafile mf_c">ex8.c</a></dt>
<dd><pre class="code file c"><span class="co2">#include &lt;string.h&gt; //memcmp</span>
<span class="co2">#include &lt;stdio.h&gt;</span>
&nbsp;
<span class="kw4">struct</span> comp_ex <span class="br0">&#123;</span>
    <span class="kw4">char</span> c<span class="sy0">;</span>
    <span class="kw4">int</span> i<span class="sy0">;</span>
    <span class="kw4">short</span> s<span class="sy0">;</span>
<span class="br0">&#125;</span><span class="sy0">;</span>
&nbsp;
<span class="kw4">int</span> main<span class="br0">&#40;</span><span class="br0">&#41;</span>
<span class="br0">&#123;</span>
     <span class="kw4">struct</span> comp_ex sa<span class="sy0">,</span> sb<span class="sy0">;</span>
&nbsp;
     <span class="co1">// toate câmpurile din a și b sunt inițializate </span>
     sa.<span class="me1">c</span> <span class="sy0">=</span> sb.<span class="me1">c</span> <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span>
     sa.<span class="me1">i</span> <span class="sy0">=</span> sb.<span class="me1">i</span> <span class="sy0">=</span> <span class="nu0">2</span><span class="sy0">;</span>
     sa.<span class="me1">s</span> <span class="sy0">=</span> sb.<span class="me1">s</span> <span class="sy0">=</span> <span class="nu0">3</span><span class="sy0">;</span>
&nbsp;
     <span class="kw1">if</span> <span class="br0">&#40;</span><span class="nu0">0</span> <span class="sy0">==</span> <a href="http://www.opengroup.org/onlinepubs/009695399/functions/memcmp.html"><span class="kw3">memcmp</span></a><span class="br0">&#40;</span><span class="sy0">&amp;</span>sa<span class="sy0">,</span> <span class="sy0">&amp;</span>sb<span class="sy0">,</span> <span class="kw4">sizeof</span><span class="br0">&#40;</span><span class="kw4">struct</span> comp_ex<span class="br0">&#41;</span><span class="br0">&#41;</span><span class="br0">&#41;</span>
         <a href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span class="kw3">printf</span></a><span class="br0">&#40;</span><span class="st0">&quot;structurile sunt identice<span class="es1">\n</span>&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
     <span class="kw1">else</span>
         <a href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span class="kw3">printf</span></a><span class="br0">&#40;</span><span class="st0">&quot;structurile sunt diferite<span class="es1">\n</span>&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
     <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">&#125;</span></pre>
</dd></dl>

</div>
<!-- EDIT21 SECTION "Exerciții" [20509-22420] -->
<h2 class="sectionedit22" id="bonus">BONUS</h2>
<div class="level2">

<p>
Intrati in directorul <code>bonus</code>, compilati si rulati programul. De ce primim <code>Segmentation fault</code>? In ce sectiuni se gasesc “Hello 1”, “Hello 2”, pc1, respectiv pc2?
</p>

</div>
<!-- EDIT22 SECTION "BONUS" [22421-] --></div>
</body>
</html>
