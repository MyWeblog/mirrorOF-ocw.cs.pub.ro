    
    

<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
  <meta charset="utf-8" />
  <title>cpl:labs:03</title>
<meta name="generator" content="DokuWiki"/>
<meta name="robots" content="index,follow"/>
<meta name="date" content="2016-10-05T23:17:00+0300"/>
<meta name="keywords" content="cpl,labs,03"/>
<link rel="search" type="application/opensearchdescription+xml" href="../../../../lib/exe/opensearch.php" title="CS Open CourseWare"/>
<link rel="start" href="../../../../../courses.1.html"/>
<link rel="alternate" type="application/rss+xml" title="Recent Changes" href="../../../../feed.php"/>
<link rel="alternate" type="application/rss+xml" title="Current Namespace" href="../../../../feed.php%3Fmode=list&amp;ns=cpl:labs"/>
<link rel="alternate" type="text/html" title="Plain HTML" href="03.html"/>
<link rel="canonical" href="../../../../cpl/labs/03.html"/>
<link rel="stylesheet" type="text/css" href="../../../../lib/exe/css.php%3Ft=arctic&amp;tseed=1476798676.css"/>
<script type="text/javascript">/*<![CDATA[*/var NS='cpl:labs';var JSINFO = {"id":"cpl:labs:03","namespace":"cpl:labs","isadmin":0,"isauth":0};
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="../../../../lib/exe/js.php%3Ftseed=1476798676"></script>
<script type="text/x-mathjax-config">/*<![CDATA[*/MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ["$","$"], ["\\(","\\)"] ],
        displayMath: [ ["$$","$$"], ["\\[","\\]"] ],
        processEscapes: true
    }
});
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
<script type="text/javascript">/*<![CDATA[*/
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
		  
/*!]]>*/</script>
<script type="text/javascript">/*<![CDATA[*/
var pageTracker = _gat._getTracker("UA-38383934-1");
pageTracker._initData();
pageTracker._trackPageview();
		  
/*!]]>*/</script>
</head>
<body>
<div class="dokuwiki export">
<!-- TOC START -->
<div id="dw__toc">
<h3 class="toggle">Table of Contents</h3>
<div>

<ul class="toc">
<li class="level1"><div class="li"><a href="03.html#bison_advanced">03. Bison Advanced</a></div></li>
<li class="level1"><div class="li"><a href="03.html#bison">Bison</a></div>
<ul class="toc">
<li class="level2"><div class="li"><a href="03.html#structura_fisierului_de_specificatii">Structura fișierului de specificații</a></div></li>
<li class="level2"><div class="li"><a href="03.html#mai_multe_despre_actiunile_asociate_regulilor">Mai multe despre acțiunile asociate regulilor</a></div></li>
</ul>
</li>
<li class="level1"><div class="li"><a href="03.html#introducere_in_cmake">Introducere în CMake</a></div></li>
<li class="level1"><div class="li"><a href="03.html#introducere_in_lcpl">Introducere în LCPL</a></div>
<ul class="toc">
<li class="clear">
<ul class="toc">
<li class="level3"><div class="li"><a href="03.html#structura_unui_program_lcpl">Structura unui program LCPL</a></div></li>
<li class="level3"><div class="li"><a href="03.html#tipuri_de_date_si_clase_speciale">Tipuri de date și clase speciale</a></div>
<ul class="toc">
<li class="level4"><div class="li"><a href="03.html#clasa_object">Clasa Object</a></div></li>
<li class="level4"><div class="li"><a href="03.html#clasa_io">Clasa IO</a></div></li>
<li class="level4"><div class="li"><a href="03.html#clasa_string">Clasa String</a></div></li>
</ul>
</li>
<li class="level3"><div class="li"><a href="03.html#instructiuni">Instrucțiuni</a></div></li>
<li class="level3"><div class="li"><a href="03.html#expresii">Expresii</a></div></li>
<li class="level3"><div class="li"><a href="03.html#structura_lexicala">Structura lexicală</a></div></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><div class="li"><a href="03.html#exercitii_de_laborator_13p">Exerciții de laborator (13p)</a></div>
<ul class="toc">
<li class="clear">
<ul class="toc">
<li class="level3"><div class="li"><a href="03.html#continutul_mini-lcpl-parser">Conținutul mini-lcpl-parser</a></div></li>
<li class="level3"><div class="li"><a href="03.html#analizorul_lexical">Analizorul lexical</a></div></li>
<li class="level3"><div class="li"><a href="03.html#analizorul_sintactic">Analizorul sintactic</a></div></li>
<li class="level3"><div class="li"><a href="03.html#exercitiul_1_3p">Exercițiul 1 (3p)</a></div></li>
<li class="level3"><div class="li"><a href="03.html#exercitiul_2_3p">Exercițiul 2 (3p)</a></div></li>
<li class="level3"><div class="li"><a href="03.html#exercitiul_3_4p">Exercițiul 3 (4p)</a></div></li>
<li class="level3"><div class="li"><a href="03.html#exercitiul_bonus_4p">Exercițiul bonus (4p)</a></div></li>
</ul></li>
</ul></li>
</ul>
</div>
</div>
<!-- TOC END -->

<h1 class="sectionedit1" id="bison_advanced">03. Bison Advanced</h1>
<div class="level1">

<p>
În acest laborator vom aprofunda cunoștințele de bison și vom incepe să discutăm despre prima temă.
</p>

</div>
<!-- EDIT1 SECTION "03. Bison Advanced" [1-141] -->
<h1 class="sectionedit2" id="bison">Bison</h1>
<div class="level1">

<p>
Să reluăm cum comunică bison-ul cu flex-ul în vederea generării parser-ului.
</p>

<p>
În fișierul reprezentând input-ul pentru <code>bison</code> vom scrie funcția <code>main()</code>, în care vom apela <code>yyparse()</code>. Funcția <code>yyparse()</code> este deja implementată și o vom regăsi în fișierul .c al parserului.
</p>

<p>
<code>yyparse()</code> citește un șir de perechi <code>token/valoare</code> pe care le primește de la <code>yylex()</code>. 
</p>

<p>
<code>yylex()</code> citește caracterele dintr-un file pointer (FILE*) numit yyin. Dacă nu setați yyin, acesta va pointa către intrarea standard (stdin). Rezultatul este transmis către yyout, care, implicit, pointează către ieșirea standard (stdout). 
</p>

<p>
Fiecare apel către <code>yylex()</code> returnează un întreg, care reprezintă tipul token-ului (id unic). Astfel, bison-ul știe ce token a primit. Token-ul poate avea o valoare, care trebuie să fie pusă în variabila <code>yylval</code>.
</p>

<p>
Implicit, yylval este de tip <code>int</code>, tip care, însă, se poate schimba redefinind YYSTYPE în fișierul bison.
</p>

</div>
<!-- EDIT2 SECTION "Bison" [142-1158] -->
<h2 class="sectionedit3" id="structura_fisierului_de_specificatii">Structura fișierului de specificații</h2>
<div class="level2">

<p>
Structura fișierului de specificații o putem vedea ca fiind compusă din 3 zone:
</p>
<ul>
<li class="level1"><div class="li"> Declarații (C și bison)</div>
</li>
<li class="level1"><div class="li"> Regulile gramaticii</div>
</li>
<li class="level1"><div class="li"> Cod C</div>
</li>
</ul>

<p>
Vom detalia partea de declarații. 
Structura clasică/veche/inflexibilă a zonei de declarații :
</p>
<pre class="code C"><span class="sy0">%</span><span class="br0">&#123;</span>
  <span class="co2">#include &lt;stdio.h&gt;</span>
<span class="sy0">%</span><span class="br0">&#125;</span>
<span class="sy0">%</span><span class="kw4">union</span> <span class="br0">&#123;</span>
....
<span class="br0">&#125;</span></pre>

<p>
Există situații în care avem nevoie de cod C în partea de declarații și după zona de definiții bison.
Pentru a nu exista confuzii, s-a adăugat <code>%code</code> care poate fi urmat de calificatori:
</p>
<div class="table sectionedit4"><table class="inline">
	<tr class="row0">
		<td class="col0"> Directiva <strong>%code</strong> {code} </td><td class="col1"> Insereaza <code>code</code> în fișierul implementării parserului, intr-o zonă dependentă de limbaj </td>
	</tr>
	<tr class="row1">
		<td class="col0"> Directiva <strong>%code</strong> qualifier {code} </td><td class="col1"> Inserează codul într-o anumită locație, așa cum vom vedea mai jos </td>
	</tr>
</table></div>
<!-- EDIT4 TABLE [1720-1961] --><div class="table sectionedit5"><table class="inline">
	<tr class="row0">
		<th class="col0 leftalign"> Calificator      </th><th class="col1 leftalign"> Semnificație   </th>
	</tr>
	<tr class="row1">
		<td class="col0"> requires </td><td class="col1"> Scop: Aici se scrie codul de care depind YYSTYPE și YYLTYPE. Altfel spus, aici se definesc tipurile referite în directiva <code>%union</code>. Dacă folosiți <code>#define</code> pentru a rescrie valorile implicite date de Bison pentru YYSTYPE și YYLTYPE, tot aici îl veți pune. Locație: Fișierul header al parserului și fișierul .c înainte de definițiile implicite ale Bison-ului pentru YYSTYPE si YYLTYPE. </td>
	</tr>
	<tr class="row2">
		<td class="col0"> provides </td><td class="col1"> Scop: Aici se pun definiții și declarații auxiliare, ce sunt necesare altor module. Locație: În fișierul header al parserului și în fișierul .c, după definițiile implicite ale Bison-ului pentru YYSTYPE și YYLTYPE și după definiția tokenilor </td>
	</tr>
	<tr class="row3">
		<td class="col0"> top </td><td class="col1"> Scop: <code>%code</code> fără calificator și <code>%code requires</code> sunt de cele mai multe ori mai potrivite decat %top. Există, totuși, situații în care este necesar să inserăm cod chiar la începutul fisierului .c generat. De exemplu: <pre class="code C"><span class="sy0">%</span>code top <span class="br0">&#123;</span>
  <span class="co2">#define _GNU_SOURCE</span>
  <span class="co2">#include &lt;stdio.h&gt;</span>
<span class="br0">&#125;</span></pre>

<p>
 Locatie: La inceputul fisierului .c generat. 
</p>
</td>
	</tr>
	<tr class="row4">
		<td class="col0"> imports </td><td class="col1 leftalign"> folosit pentru Java  </td>
	</tr>
</table></div>
<!-- EDIT5 TABLE [1965-3087] -->
</div>
<!-- EDIT3 SECTION "Structura fișierului de specificații" [1159-3087] -->
<h2 class="sectionedit6" id="mai_multe_despre_actiunile_asociate_regulilor">Mai multe despre acțiunile asociate regulilor</h2>
<div class="level2">

<p>
Uneori este util să punem acțiuni în mijlocul regulilor. Aceste acțiuni se scriu la fel ca acțiunile de la sfârșitul regulilor, dar sunt executate înainte ca parser-ul să recunoască componentele situate după ele. 
</p>

<p>
O acțiune în mijlocul unei reguli poate să refere componentele care o preced folosind <code>$N</code>, dar nu poate să le refere pe cele care o succed (pentru că nu au fost recunoscute în momentul în care se execută acțiunea).
</p>

<p>
Acțiunea din mijlocul regulii reprezintă ea însăși o componentă a regulii. Aceasta contează când regula are atât o acțiune în mijloc, cât și una la sfârșit. În acest caz, cea de la sfârșit trebuie să numere și acțiunea din mijlocul regulii. 
</p>

<p>
Este posibil să asociem o valoare acțiunii din mijlocul regulii. Aceasta se face printr-o atribuire către <code>$$</code>, iar acțiunile regulii, care o succed, pot să-i refere valoarea cu <code>$&lt;tip&gt;N</code>. Avem nevoie de &lt;tip&gt; pentru că acesta nu a fost/nu poate fi declarat. 
<p><div class="noteclassic">Nu este posibil să setăm valoarea întoarsă de regulă într-o acțiune din mijlocul regulii, deoarece atribuirea către <code>$$</code> setează valoarea acțiunii curente. Singura metodă de a atribui o valoare întregii reguli este prin acțiunile de la sfârșitul regulii.
</div></p>
</p>

<p>
Regula de mai jos parsează o instructiune de tip <code>let</code>, 
</p>
<pre class="code C">let <span class="br0">&#40;</span>VARIABLE<span class="br0">&#41;</span> STATEMENT</pre>

<p>
care creează o variabilă temporară, VARIABLE, cu scopul <code>STATEMENT</code>.
</p>

<p>
Așadar, trebuie să punem variabila în tabela de simboli înaine ca STATEMENT să fie parsat și trebuie să o scoatem din tabelă după parsare. 
</p>
<pre class="code C">     stmt<span class="sy0">:</span>   LET <span class="st0">'('</span> var <span class="st0">')'</span>
                     <span class="br0">&#123;</span> $$ <span class="sy0">=</span> push_context <span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
                       declare_variable <span class="br0">&#40;</span>$<span class="nu19">3</span><span class="br0">&#41;</span><span class="sy0">;</span> <span class="br0">&#125;</span>
             stmt    <span class="br0">&#123;</span> $$ <span class="sy0">=</span> $<span class="nu19">6</span><span class="sy0">;</span>
                       pop_context <span class="br0">&#40;</span>$<span class="nu19">5</span><span class="br0">&#41;</span><span class="sy0">;</span> <span class="br0">&#125;</span></pre>

<p>
După ce s-a recunoscut <code> LET &#039;(&#039; var &#039;)&#039; </code>, este executată prima acțiune. Se salvează o copie a contextului curent (lista variabilelor disponibile). Apoi, se apelează <code>declare_variable</code> care adaugă <code>var</code> la lista curentă. În acest moment s-a terminat execuția acțiunii din mijlocul regulii, și se va parsa <code>stmt</code>. Această acțiune este componenta numărul 5 a regulii, iar <code>stmt</code> este componenta numărul 6. Dupa ce s-a parsat și <code>stmt</code> se execută acțiunea de la sfârșitul regulii, care scoate variabila din tabela de simboli. 
</p>

</div>
<!-- EDIT6 SECTION "Mai multe despre acțiunile asociate regulilor" [3088-5519] -->
<h1 class="sectionedit7" id="introducere_in_cmake">Introducere în CMake</h1>
<div class="level1">

<p>
CMake este un meta-sistem de build independent de platformă. Acesta citeste niște fișiere de configurare (<code>CMakeLists.txt</code>) care descriu procesul de build într-un <a href="https://cmake.org/Wiki/CMake/Language_Syntax" class="urlextern" title="https://cmake.org/Wiki/CMake/Language_Syntax"  rel="nofollow">limbaj specific</a>, și pe baza acestora generează toate fișierele necesare pentru a face build-ul folosind un anumit tool: make, Ninja, Eclipse, Visual Studio etc. Pentru a vedea sistemele de build suportate pe o anumită platformă, puteți rula <code>cmake -help</code> (secțiunea <code>Generators</code>).
</p>

<p>
CMake poate fi folosit fie din linie de comandă, fie cu ajutorul unor wrappere cu interfață grafică (de exemplu <code>ccmake</code> din pachetul <code>cmake-curses-gui</code>). În cadrul laboratorului vom folosi interfața din linie de comandă.
</p>
<pre class="code bash">cmake <span class="br0">&#91;</span>OPTIONS<span class="br0">&#93;</span> <span class="sy0">/</span>path<span class="sy0">/</span>to<span class="sy0">/</span>source<span class="sy0">/</span><span class="kw2">tree</span></pre>

<p>
Printre opțiunile cele mai utile sunt:
</p>
<ul>
<li class="level1"><div class="li"> <em>-G</em> pentru specificarea sistemului de build folosit (e.g. <code>cmake -G “Eclipse CDT4 - Ninja” /path/to/source/tree</code>)</div>
</li>
<li class="level1"><div class="li"> <em>-D</em> pentru definirea unor variabile utilizate de fișierele de configurare</div>
</li>
<li class="level1"><div class="li"> <em>-LH</em> pentru afișarea celor mai relevante variabile care pot fi definite pentru proiect</div>
</li>
</ul>

<p>
Variabilele utilizate de fișierele de configurare pot fi fie predefinite (de exemplu <code>cmake -DCMAKE_BUILD_TYPE=Debug</code>), fie specifice proiectului (de exemplu <code>cmake -DSOMETHING_THAT_DETERMINES_HOW_MY_PROJECT_IS_BUILT=magic</code>); observați lipsa spațiului între <em>-D</em> și numele variabilei (ca la definițiile pentru preprocesor).
</p>

<p>
Fișierele generate se vor afla în directorul de unde a fost rulat CMake. Este recomandat ca acesta să fie diferit de cel în care se află sursele proiectului.
</p>

</div>
<!-- EDIT7 SECTION "Introducere în CMake" [5520-7200] -->
<h1 class="sectionedit8" id="introducere_in_lcpl">Introducere în LCPL</h1>
<div class="level1">

<p>
În această secțiune vom prezenta un subset al limbajului LCPL, atât cât este necesar pentru rezolvarea exercițiului din laborator. Descrierea completă a limbajului o veți primi în prima temă.
</p>

</div>
<!-- EDIT8 SECTION "Introducere în LCPL" [7201-7438] -->
<h3 class="sectionedit9" id="structura_unui_program_lcpl">Structura unui program LCPL</h3>
<div class="level3">

<p>
Codul LCPL este organizat in clase, similar cu Java si C++. Un program LCPL este definit în întregime într-un fișier. Un fișier poate conține mai multe clase. Definiția unei clase este: ([…] reprezintă construcții opționale)
</p>
<pre class="code">class &lt;nume&gt; [inherits &lt;nume&gt;]
    &lt;membri&gt;
end;</pre>

<p>
Clasele conțin zero sau mai mulți membri ce pot fi atribute sau metode. 
</p>

<p>
Un atribut reprezintă date interne clasei și nu poate fi accesat direct decât din interiorul clasei. Pentru accesul din exterior se vor folosi metodele. Declarația unui atribut are forma:
</p>
<pre class="code">&lt;tip&gt; &lt;nume&gt; [= &lt;expresie&gt;];</pre>

<p>
Atributele unei clase se declară in secțiunea <code>var … end;</code>. Pot exista mai multe asemenea secțiuni într-o clasă. Atributele definite într-o secțiune sunt vizibile pe toată lungimea clasei (chiar și înainte de apariția în text a secțiunii în care au fost definite). Fiecare atribut are un tip care trebuie declarat explicit de programator și poate fi declarat împreună cu o inițializare.
</p>
<pre class="code">var
    Factorial f = new Factorial;
end;</pre>

<p>
Declarația unei metode are forma:
</p>
<pre class="code">&lt;nume&gt; [&lt;argumente&gt;] [-&gt; &lt;tip&gt;] : &lt;corp&gt; end;</pre>

<p>
Tipul unei metode reprezintă lista argumentelor acesteia, separate prin caracterul &#039;,&#039;, precum și tipul întors de metodă. În cazul în care metoda nu întoarce o expresie, tipul întors lipsește din definiția metodei. În cazul în care metoda nu are argumente, lista lor lipsește din definiția metodei.
</p>
<pre class="code">
# metoda cu un argument si care intoarce un rezultat de tip Int
fact Int n -&gt; Int :
    if n &lt; 1 then
        1;
    else
        n * [fact n-1];
    end;
end;

# metoda fara argumente si care nu intoarce nici un rezultat
main :
    [out [f.fact 10]];
end;</pre>

</div>
<!-- EDIT9 SECTION "Structura unui program LCPL" [7439-9241] -->
<h3 class="sectionedit10" id="tipuri_de_date_si_clase_speciale">Tipuri de date și clase speciale</h3>
<div class="level3">

<p>
Tipurile de date din LCPL sunt numerele întregi (<code>Int</code>) și clasele. O clasă poate moșteni de la o singură superclasă (folosind <code>inherits</code> urmat de numele clasei părinte). Numele unei clase este vizibil în tot programul. 
Există trei clase speciale in LCPL: <code>Object</code>, <code>IO</code> și <code>String</code>. 
</p>

</div>

<h4 id="clasa_object">Clasa Object</h4>
<div class="level4">

<p>
Clasa <code>Object</code> este rădăcina ierarhiei de clase. Pe ea sunt definite următoarele metode:
</p>
<pre class="code"># termina fortat programul
abort

# intoarce numele clasei originale a obiectului
typeName -&gt; String # 

# realizeaza o copie de suprafata a obiectului
copy -&gt; Object</pre>

</div>

<h4 id="clasa_io">Clasa IO</h4>
<div class="level4">

<p>
Pentru a avea acces la standard input și output se vor folosi metodele din clasa <code>IO</code>, prin intermediul unui obiect de acest tip. Metodele definite pe clasa <code>IO</code> sunt următoarele:
</p>
<pre class="code"># tipareste un sir la standard output
out String message -&gt; IO

# citeste standard input pana la sfarsitul liniei
in -&gt; String</pre>

</div>

<h4 id="clasa_string">Clasa String</h4>
<div class="level4">

<p>
Clasa <code>String</code> reprezintă șirurile de caractere. Metodele ei sunt:
</p>
<pre class="code"># intoarce lungimea sirului de caractere
length -&gt; Int

# converteste un sir de caractere la un intreg
toInt -&gt; Int</pre>

</div>
<!-- EDIT10 SECTION "Tipuri de date și clase speciale" [9242-10459] -->
<h3 class="sectionedit11" id="instructiuni">Instrucțiuni</h3>
<div class="level3">

<p>
Corpul unei metode este format dintr-un bloc de instrucțiuni. Acestea pot fi expresii aritmetice, logice sau pe șiruri, instanțieri de obiecte, apeluri de metode, atribuiri și instrucțiuni de control. Toate instrucțiunile ce apar în corpul unei metode sunt terminate prin &#039;;&#039;.
Dacă o metodă întoarce o valoare, corpul acesteia trebuie să se termine cu o intstrucțiune al cărei tip corespunde celui întors de metodă. De exemplu, metoda <code>fact</code> de mai sus întoarce valoarea instrucțiunii <code>if</code>, de tip <code>Int</code>.
</p>

</div>
<!-- EDIT11 SECTION "Instrucțiuni" [10460-11011] -->
<h3 class="sectionedit12" id="expresii">Expresii</h3>
<div class="level3">

<p>
Cele mai simple expresii din limbaj sunt constantele. Ele pot fi întregi sau șiruri de caractere.
</p>

<p>
Apelul unei metode, <code>dispatch</code>, se realizează folosind una din construcțiile:
</p>
<pre class="code">[&lt;expr&gt;.&lt;id&gt; &lt;expr&gt; ... &lt;expr&gt;] # apel de metoda cu argumente pe obiectul care este rezultatul &lt;expr&gt; 
[&lt;expr&gt;.&lt;id&gt;] # apel de metoda fara argumente pe obiectul care este rezultatul &lt;expr&gt;
[&lt;id&gt; &lt;expr&gt; ... &lt;expr&gt;] # apel de metoda cu argumente pe obiectul curent
[&lt;id&gt;] # apel de metoda fara argumente pe obiectul curent</pre>

<p>
La un apel de metodă cu argumente, acestea vor fi separate prin spațiu de celelalte. 
</p>

<p>
O expresie condiționată este de forma:
</p>
<pre class="code">if &lt;expr&gt; then &lt;expr&gt;; ... &lt;expr&gt;; else &lt;expr&gt;; ... &lt;expr&gt;; end;
if &lt;expr&gt; then &lt;expr&gt;; ... &lt;expr&gt;; end;</pre>

<p>
Pentru a construi și inițializa un nou obiect, se folosește <code>new</code>:
</p>
<pre class="code">Factorial f = new Factorial;</pre>

<p>
Operațiile aritmetice (&#039;+&#039;, &#039;-&#039;, &#039;*&#039;, &#039;/&#039;), de comparație (&#039;&lt;&#039;, &#039;⇐&#039;) și de egalitate (&#039;==&#039;) sunt expresii. Operatorul &#039;-&#039; funcționează și ca operator unar, pentru a obține un număr negativ.
</p>

<p>
Pentru a nega un întreg se folosește &#039;!&#039;. 
</p>

<p>
Pentru a grupa expresii se folosesc paranteze: &#039;(&#039; și &#039;)&#039;.
</p>

</div>
<!-- EDIT12 SECTION "Expresii" [11012-12225] -->
<h3 class="sectionedit13" id="structura_lexicala">Structura lexicală</h3>
<div class="level3">

<p>
LCPL conține următorii atomi lexicali:
</p>
<ul>
<li class="level1"><div class="li"> întregi - șiruri nevide de cifre 0-9 care sunt 0 sau nu incep cu 0</div>
</li>
<li class="level1"><div class="li"> identificatori - șiruri diferite de cuvintele cheie, conținând litere, cifre și &#039;_&#039;</div>
</li>
<li class="level1"><div class="li"> \n - linie nouă</div>
</li>
<li class="level1"><div class="li"> \r - carriage return</div>
</li>
<li class="level1"><div class="li"> \t - tab</div>
</li>
</ul>

<p>
Comentariile sunt doar pe o singură linie, încep cu <code>#</code> și se termină la finalul liniei.
</p>

<p>
Cunvinte cheie: <code>class, inherits, if, then, else, end, new, var</code>.
</p>

</div>
<!-- EDIT13 SECTION "Structura lexicală" [12226-12683] -->
<h1 class="sectionedit14" id="exercitii_de_laborator_13p">Exerciții de laborator (13p)</h1>
<div class="level1">

<p>
În rezolvarea laboratorului folosiți arhiva de sarcini <a href="../../../../_media/cpl/labs/lab03_mini_lcpl_parser.zip" class="media mediafile mf_zip" title="cpl:labs:lab03_mini_lcpl_parser.zip (146.1 KB)"> lab03_mini_lcpl_parser.zip </a>
</p>

</div>
<!-- EDIT14 SECTION "Exerciții de laborator (13p)" [12684-12859] -->
<h3 class="sectionedit15" id="continutul_mini-lcpl-parser">Conținutul mini-lcpl-parser</h3>
<div class="level3">

<p>
În directorul <code>mini-lcpl-parser</code> există două sub-directoare:
</p>
<ul>
<li class="level1"><div class="li"> <strong>lcpl-AST</strong> </div>
<ul>
<li class="level2"><div class="li"> conține structurile de date ale arborelui sintactic, precum și codul care serializează nodurile din arbore. Pe parcursul exercițiului veți construi noduri din arborele sintactic folosind aceste structuri.</div>
</li>
<li class="level2"><div class="li"> pentru a compila biblioteca <strong>lcpl-AST</strong> intrați in directorul lcpl-AST si executati urmatorii pasi:</div>
<ul>
<li class="level6"><div class="li"> mkdir build; cd build; cmake ..; make</div>
</li>
</ul>
</li>
<li class="level2"><div class="li"> în subdirectorul <strong>include/</strong> sunt definițiile claselor care compun AST-ul</div>
</li>
<li class="level2"><div class="li"> cui corespund aceste clase ? Gândiți-vă cum ați structurat gramatica în laboratorul trecut și de ce informații ați avea nevoie, informații pe care să le preluați în momentul executării unei acțiuni asociate unei reguli</div>
</li>
<li class="level2"><div class="li"> hint: cum ați ales neterminalii în momentul în care ați gandit logica gramaticii ? Urmând acest fir, cum ar trebui să fie “traduși” acești neterminali în AST: ar trebui să apară în AST sau nu ? </div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> <strong>lcpl-parser</strong> </div>
<ul>
<li class="level2"><div class="li"> conține un schelet al parserului</div>
</li>
<li class="level2"><div class="li"> pentru a compila parserul intrați in directorul lcpl-parser și dați comanda <code>make</code>. În urma compilării rezultă executabilul <code>lcpl-parser</code></div>
</li>
<li class="level2"><div class="li"> tot in acest director veți găsi două foldere, unul cu teste pentru fiecare exercițiu exemple, precum și rezultatul de referință. Pentru a genera fișierul .ast, rulați <code>./lcpl-parser path_fisier</code></div>
</li>
<li class="level2"><div class="li"> pentru ușurință puteți să folositi scriptul compare.sh, ce generează fișierul .ast și îl compară cu referința. (ex: ./compare.sh basic sau ./compare.sh all, pentru rularea tuturor testelor)</div>
</li>
<li class="level2"><div class="li"> pe măsură ce preluați câte un exercițiu pe care trebuie să îl rezolvați, gândiți-vă la următorii pași:</div>
<ul>
<li class="level3"><div class="li">  tokenii pe care trebuie să îi prelucrez sunt generați de analizorul lexical ?</div>
<ul>
<li class="level4"><div class="li"> dacă da, continuați</div>
</li>
<li class="level4"><div class="li"> dacă nu, modificați în consecință fișierul lcpl.l și/sau lcpl.y pentru a recunoaște noii tokeni <strong>și</strong> tipul lor</div>
</li>
</ul>
</li>
<li class="level3"><div class="li"> analizorul sintactic (gramatica) conține reguli conform cu ceea ce vreau să interpretez ? </div>
<ul>
<li class="level4"><div class="li"> dacă da, acțiunile asociate sunt cele pe care le urmăresc ? Sunt complete ?</div>
</li>
<li class="level4"><div class="li"> dacă nu, găsiți <strong>unde</strong> se potrivesc noile reguli în cadrul gramaticii, conform sintaxei LCPL descrise în documentația laboratorului</div>
</li>
<li class="level4"><div class="li"> puteți modifica regulile existente cum credeți de cuviință, sunt scrise pentru a vă ghida, dar nu toate sunt complete</div>
</li>
</ul>
</li>
<li class="level3"><div class="li"> în momentul scrierii acțiunii asociate unei reguli, luați în calcul următoarele:</div>
<ul>
<li class="level4"><div class="li"> ce reprezintă elementele regulii curente ? o expresie, o propoziție, o adunare, o grupare, o instanțiere ? după caz, conform limbajului de intrare</div>
</li>
<li class="level4"><div class="li"> care va fi rezultatul expresiei curente și cum o evaluez ? Tipul asociat este recunoscut in cadrul analizorului ? Unde trebuie definit acest tip ?</div>
</li>
<li class="level4"><div class="li"> cum arată un nod în cadrul AST-ului care va reprezenta regula/elementele regulii curente ? În cazul scheletului de laborator, căutați aceste clase in directorul lcpl-AST/include/, ele sunt deja implementate</div>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

<p>
Ierarhia de clase care reprezintă noduri ale AST-ului este formată dupa cum urmează (din lcpl-AST/include/):
</p>

<p>
<a href="../../../../_detail/cpl/labs/ierarhie_clase_lcpl.png%3Fid=cpl%253Alabs%253A03.html" class="media" title="cpl:labs:ierarhie_clase_lcpl.png"><img src="../../../../_media/cpl/labs/ierarhie_clase_lcpl.png%3Fw=450&amp;tok=66a61b" class="mediacenter" alt="" width="450" /></a>
</p>

<p>
Ulterior rulării ”./lcpl-parser simple.lcpl”, urmăriți cum a fost parsat conținutul fișierului simple.lcpl și AST-ul rezultat (pe acesta îl găsiți în simple.lcpl.ast). 
<p><div class="notetip">Observați legătura dintre clasele reprezentând nodurile AST-ului și elementele gramaticii definite în Bison.
</div></p>
</p>

</div>
<!-- EDIT15 SECTION "Conținutul mini-lcpl-parser" [12860-16483] -->
<h3 class="sectionedit16" id="analizorul_lexical">Analizorul lexical</h3>
<div class="level3">

<p>
Va trebui să completați analizorul lexical astfel încât să recunoască și să paseze către analizorul sintactic următorii atomi lexicali:
</p>
<ul>
<li class="level1"><div class="li"> cuvinte cheie: class, inherits, if, then, else, end, new, var</div>
</li>
<li class="level1"><div class="li"> identificatori</div>
</li>
<li class="level1"><div class="li"> constante întregi</div>
</li>
<li class="level1"><div class="li"> operatorul logic &lt;</div>
</li>
<li class="level1"><div class="li"> operatorii binari * și -</div>
</li>
<li class="level1"><div class="li"> operatorul de asignare =</div>
</li>
<li class="level1"><div class="li"> operatorul de atribuire al tipului de retur din funcție →</div>
</li>
</ul>

<p>
<p><div class="noteclassic">Luați în calcul implicațiile faptului că &#039;-&#039; este atât operator, cât și parte a sintaxei de definire a unei metode
</div></p>
<strong>Țineți cont de faptul că o parte dintre ei sunt deja implementați. Trebuie doar să îi căutați pe cei care lipsesc și să adăugați codul corespunzător.</strong>
</p>

</div>
<!-- EDIT16 SECTION "Analizorul lexical" [16484-17216] -->
<h3 class="sectionedit17" id="analizorul_sintactic">Analizorul sintactic</h3>
<div class="level3">

<p>
Pentru fiecare nod nou adaugat urmăriți modul de inițializare al acestora din folderul lcpl-AST/include.
</p>

</div>
<!-- EDIT17 SECTION "Analizorul sintactic" [17217-17357] -->
<h3 class="sectionedit18" id="exercitiul_1_3p">Exercițiul 1 (3p)</h3>
<div class="level3">

<p>
Pentru operatorii &#039;-&#039;, &#039;*&#039;, &#039;&lt;&#039; și metode cu valoare de retur va trebui să adaugați reguli de parsare și noi noduri, de tipul &#039;BinaryOperator&#039;, respectiv &#039;Method&#039;, în arbore. De asemenea, adaugați regula de parsare . Urmăriți exemplul pentru operatorul &#039;+&#039;, respectiv metoda fara valoare de retur, și indicațiile marcate cu “TODO 1”.
</p>

</div>
<!-- EDIT18 SECTION "Exercițiul 1 (3p)" [17358-17732] -->
<h3 class="sectionedit19" id="exercitiul_2_3p">Exercițiul 2 (3p)</h3>
<div class="level3">

<p>
Pentru statementul if va trebui să adaugați o nouă regulă de parsare și nodul aferent, de tipul &#039;IfStatement&#039;, în arbore. Pentru simplitate regula va trebui să evalueze doar structuri de forma: if &lt;cond&gt; then &lt;expr&gt; else &lt;expr&gt; end. De asemenea va trebui să definiți tipul intors de această regulă. Urmăriți indicațiile marcate cu “TODO 2”.
</p>

</div>
<!-- EDIT19 SECTION "Exercițiul 2 (3p)" [17733-18118] -->
<h3 class="sectionedit20" id="exercitiul_3_4p">Exercițiul 3 (4p)</h3>
<div class="level3">

<p>
Adaugați reguli de parsare și nodurile aferente pentru apelul de funcție (&#039;Dispatch&#039;) de forma : [id expr1 expr2 …], de asemenea va trebui să definiți tipul intors de aceste reguli. Urmăriți indicațiile marcate cu “TODO 3”.
</p>

</div>
<!-- EDIT20 SECTION "Exercițiul 3 (4p)" [18119-18383] -->
<h3 class="sectionedit21" id="exercitiul_bonus_4p">Exercițiul bonus (4p)</h3>
<div class="level3">

<p>
Extindeți exercițiul anterior, astfel încât gramatica sa accepte asignarea variabilelor și moștenirea unei clase. Urmăriți indicațiile marcate cu “TODO BONUS”.
</p>

</div>
<!-- EDIT21 SECTION "Exercițiul bonus (4p)" [18384-] --></div>
</body>
</html>
