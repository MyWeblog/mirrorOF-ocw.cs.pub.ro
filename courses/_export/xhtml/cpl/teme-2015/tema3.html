    
    

<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
  <meta charset="utf-8" />
  <title>cpl:teme-2015:tema3</title>
<meta name="generator" content="DokuWiki"/>
<meta name="robots" content="index,follow"/>
<meta name="date" content="2016-10-04T07:17:00+0300"/>
<meta name="keywords" content="cpl,teme-2015,tema3"/>
<link rel="search" type="application/opensearchdescription+xml" href="../../../../lib/exe/opensearch.php" title="CS Open CourseWare"/>
<link rel="start" href="../../../../../courses.1.html"/>
<link rel="alternate" type="application/rss+xml" title="Recent Changes" href="../../../../feed.php"/>
<link rel="alternate" type="application/rss+xml" title="Current Namespace" href="../../../../feed.php%3Fmode=list&amp;ns=cpl:teme-2015"/>
<link rel="alternate" type="text/html" title="Plain HTML" href="tema3.html"/>
<link rel="canonical" href="../../../../cpl/teme-2015/tema3.html"/>
<link rel="stylesheet" type="text/css" href="../../../../lib/exe/css.php%3Ft=arctic&amp;tseed=1479898000.css"/>
<script type="text/javascript">/*<![CDATA[*/var NS='cpl:teme-2015';var JSINFO = {"id":"cpl:teme-2015:tema3","namespace":"cpl:teme-2015","isadmin":0,"isauth":0};
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="../../../../lib/exe/js.php%3Ftseed=1479898000"></script>
<script type="text/x-mathjax-config">/*<![CDATA[*/MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ["$","$"], ["\\(","\\)"] ],
        displayMath: [ ["$$","$$"], ["\\[","\\]"] ],
        processEscapes: true
    }
});
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
<script type="text/javascript">/*<![CDATA[*/
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
		  
/*!]]>*/</script>
<script type="text/javascript">/*<![CDATA[*/
var pageTracker = _gat._getTracker("UA-38383934-1");
pageTracker._initData();
pageTracker._trackPageview();
		  
/*!]]>*/</script>
</head>
<body>
<div class="dokuwiki export">
<!-- TOC START -->
<div id="dw__toc">
<h3 class="toggle">Table of Contents</h3>
<div>

<ul class="toc">
<li class="level1"><div class="li"><a href="tema3.html#tema_de_casa_3_-_generarea_de_cod">Tema de casa 3 - Generarea de cod</a></div>
<ul class="toc">
<li class="level2"><div class="li"><a href="tema3.html#informatii_organizatorice">Informaţii organizatorice</a></div></li>
<li class="level2"><div class="li"><a href="tema3.html#enunt">Enunţ</a></div></li>
<li class="level2"><div class="li"><a href="tema3.html#generarea_de_cod">Generarea de cod</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="tema3.html#detalii_de_implementare">Detalii de implementare</a></div></li>
<li class="level3"><div class="li"><a href="tema3.html#suportul_de_executie_pentru_lcpl">Suportul de execuție pentru LCPL</a></div></li>
</ul>
</li>
<li class="level2"><div class="li"><a href="tema3.html#detalii_c_api_llvm">Detalii C++ API LLVM</a></div>
<ul class="toc">
<li class="clear">
<ul class="toc">
<li class="level4"><div class="li"><a href="tema3.html#generarea_de_constante">Generarea de constante</a></div></li>
<li class="level4"><div class="li"><a href="tema3.html#generarea_tipurilor_corespunzatoare_claselor_definite">Generarea tipurilor corespunzatoare claselor definite</a></div></li>
<li class="level4"><div class="li"><a href="tema3.html#generarea_prototipurilor_de_functii">Generarea prototipurilor de functii</a></div></li>
<li class="level4"><div class="li"><a href="tema3.html#generarea_corpului_unei_functii">Generarea corpului unei functii</a></div></li>
<li class="level4"><div class="li"><a href="tema3.html#definirea_unui_basic_block">Definirea unui basic block</a></div></li>
<li class="level4"><div class="li"><a href="tema3.html#instructiuni_llvm_de_care_ati_putea_avea_nevoie">Instructiuni LLVM de care ati putea avea nevoie</a></div></li>
</ul>
</li>
</ul>
</li>
<li class="level2"><div class="li"><a href="tema3.html#detalii_llvm_ir">Detalii LLVM IR</a></div></li>
<li class="level2"><div class="li"><a href="tema3.html#arhiva_de_pornire">Arhiva de pornire</a></div></li>
<li class="level2"><div class="li"><a href="tema3.html#testare">Testare</a></div></li>
<li class="level2"><div class="li"><a href="tema3.html#testare_automata">Testare automata</a></div></li>
<li class="level2"><div class="li"><a href="tema3.html#instructiuni_de_predare_a_temei">Instrucţiuni de predare a temei</a></div></li>
<li class="level2"><div class="li"><a href="tema3.html#resurse">Resurse</a></div></li>
<li class="level2"><div class="li"><a href="tema3.html#f_a_q">F A Q</a></div></li>
<li class="level2"><div class="li"><a href="tema3.html#change_log">Change Log</a></div></li>
</ul></li>
</ul>
</div>
</div>
<!-- TOC END -->

<h1 class="sectionedit1" id="tema_de_casa_3_-_generarea_de_cod">Tema de casa 3 - Generarea de cod</h1>
<div class="level1">

<p>
În cadrul acestei teme veti implementa generarea de cod pentru limbajul LCPL.
</p>

</div>
<!-- EDIT1 SECTION "Tema de casa 3 - Generarea de cod" [1-130] -->
<h2 class="sectionedit2" id="informatii_organizatorice">Informaţii organizatorice</h2>
<div class="level2">
<ul>
<li class="level1"><div class="li"> <strong>Deadline</strong>: Termenul limită până când se pot trimite temele fără depunctări de întârziere este <strong>sâmbătă, 9 ianuarie 2016, ora 23:59</strong>. Pentru mai multe detalii, consultaţi <a href="../../../../cpl/teme/general.html" class="wikilink1" title="cpl:teme:general">regulamentul</a> aferent temelor de casă.</div>
</li>
<li class="level1"><div class="li"> <strong>Colaborare</strong>: Tema va fi rezolvată <strong>individual</strong>.</div>
</li>
<li class="level1"><div class="li"> <strong>Punctare</strong>: </div>
<ul>
<li class="level2"><div class="li"> 100p pentru implementarea tuturor pasilor necesari</div>
</li>
<li class="level2"><div class="li"> 200p pentru generarea corectă de cod pentru toate testele publicate</div>
</li>
</ul>
</li>
</ul>

</div>
<!-- EDIT2 SECTION "Informaţii organizatorice" [131-634] -->
<h2 class="sectionedit3" id="enunt">Enunţ</h2>
<div class="level2">

<p>
Va trebui să realizaţi în limbajul C++, porţiunea responsabilă cu generarea cod LLVM IR, folosind LLVM C++ <abbr title="Application Programming Interface">API</abbr>. Programul vostru va trebui să primească la intrare output-ul temei 1 şi să genereze un fisier cu cod corect LLVM IR.
</p>

<p>
Documentaţia principală în cadrul acestei teme va fi LLVM C++ <abbr title="Application Programming Interface">API</abbr> și LLVM IR. Rezultatul programului realizat de voi poate folosi tool-urile LLVM pentru a genera cod pentru x86 si pentru a se executa.
</p>

</div>
<!-- EDIT3 SECTION "Enunţ" [635-1099] -->
<h2 class="sectionedit4" id="generarea_de_cod">Generarea de cod</h2>
<div class="level2">

<p>
Pentru generarea de cod veti folosi LLVM C++ <abbr title="Application Programming Interface">API</abbr>, similar cu ceea ce ați învățat în laboratorul 5. De asemenea, vă recomandăm să studiați și tutorialul de generare de cod de aici <a href="../../../../lib/exe/fetch.php%3Fhash=3c5b39&amp;media=http%253A%252F%252Fllvm.org%252Freleases%252F3.6.0%252Fdocs%252Ftutorial%252FLangImpl3.html" class="urlextern" title="http://llvm.org/releases/3.6.0/docs/tutorial/LangImpl3.html"  rel="nofollow">http://llvm.org/releases/3.6.0/docs/tutorial/LangImpl3.html</a>.
</p>

<p>
Arhiva de pornire conține codul generat pentru un nod de tip clasa si pentru metode vide. 
</p>

<p>
Tehnica folosită pentru implementarea generării de cod se bazează pe ASTVisitor. Voi trebuie sa implementați funcțiile <strong>visit</strong> pentru celelalte tipuri de noduri și să le completați pe cele deja puse ca exemplu, dacă este cazul. 
</p>

<p>
Nu sunteti obligați să folosiți abordarea sugerată în arhiva de pornire. Însă, codul generat trebuie sa fie cod LLVM IR valid și trebuie să producă rezultatele corecte. 
</p>

<p>
Vă recomandam să începeți cu înțelegerea documentației:
</p>
<ul>
<li class="level1"><div class="li"> Semantica și comportamentul programelor LCPL</div>
</li>
<li class="level1"><div class="li"> LLVM IR / C++ <abbr title="Application Programming Interface">API</abbr> pt generarea de LLVM IR</div>
</li>
<li class="level1"><div class="li"> Suportul pentru runtime </div>
</li>
</ul>

</div>
<!-- EDIT4 SECTION "Generarea de cod" [1100-2086] -->
<h3 class="sectionedit5" id="detalii_de_implementare">Detalii de implementare</h3>
<div class="level3">

<p>
Odată ce ați citit documentația puteți trece la implementarea generării de cod, parucrgând următorii pași:
</p>
<ul>
<li class="level1"><div class="li"> <strong>Emiterea constantelor globale.</strong> Şirurile de caractere din program sunt constante globale care trebuie alocate în memorie şi iniţializate de către generatorul de cod.</div>
</li>
</ul>
<ul>
<li class="level1"><div class="li"> <strong>Emiterea obiectelor de tip String care reprezinta numele claselor.</strong> Funcția typeName din runtime va returna unul dintre aceste obiecte.</div>
</li>
</ul>
<ul>
<li class="level1"><div class="li"> <strong>Emiterea informației de runtime (rtti - runtime type information).</strong> Fiecare clasă din programul de intrare va avea o informație de runtime. La crearea unui obiect nou se pasează informația de runtime a clasei către operatorul <em>new</em>.</div>
</li>
</ul>
<ul>
<li class="level1"><div class="li"> <strong>Emiterea tabelei cu adresele metodelor.</strong> In informația de runtime este inclusă si tabela de funcții virtuale. Această tabelă conține adresele tuturor metodelor dintr-o clasă, precum și pe cele ale clasei părinte.</div>
</li>
</ul>
<ul>
<li class="level1"><div class="li"> <strong>Emiterea codului pentru metodele de iniţializare ale claselor.</strong> LCPL permite execuţia unui cod de iniţializare pentru fiecare atribut al unei clase. Acest cod va deveni parte din metoda de iniţializare (constructor) care va fi apelată de operatorul new.</div>
</li>
</ul>
<ul>
<li class="level1"><div class="li"> <strong>Emiterea codului pentru fiecare metodă definită de utilizator.</strong></div>
</li>
</ul>
<ul>
<li class="level1"><div class="li"> <strong>Emiterea metodei <code>startup</code> care creează obiectul de tip Main si apelează metoda main.</strong></div>
</li>
</ul>

<p>
Puteţi organiza generatorul de cod în două etape: în prima se decide layout-ul obiectelor pentru fiecare clasă (deplasamentele atributelor şi ale metodelor), iar în a doua se generează cod pentru fiecare metodă (inclusiv metodele definite implicit pentru iniţializare).
</p>

</div>
<!-- EDIT5 SECTION "Detalii de implementare" [2087-3760] -->
<h3 class="sectionedit6" id="suportul_de_executie_pentru_lcpl">Suportul de execuție pentru LCPL</h3>
<div class="level3">

</div>

<h5 id="reprezentarea_datelor">Reprezentarea datelor</h5>
<div class="level5">

<p>
* Reprezentarea unui obiect în memorie arată astfel:
</p>
<div class="table sectionedit7"><table class="inline">
	<tr class="row0">
		<th class="col0"> Offset </th><th class="col1 centeralign">  Descriere                                     </th>
	</tr>
	<tr class="row1">
		<td class="col0 centeralign">   +0   </td><td class="col1 leftalign"> Pointer către rtti al clasei din care face parte obiectul           </td>
	</tr>
	<tr class="row2">
		<td class="col0 centeralign">   +4   </td><td class="col1"> Atributele obiectului - întregi pe 4 bytes sau referinţe către alte obiecte. </td>
	</tr>
</table></div>
<!-- EDIT7 TABLE [3891-4125] -->
<p>
Referinţa la un obiect este adresa din memorie a acelui obiect.
</p>

<p>
* Reprezentarea rtti in memorie arată astfel
</p>
<div class="table sectionedit8"><table class="inline">
	<tr class="row0">
		<th class="col0"> Offset </th><th class="col1 centeralign">  Descriere                                     </th>
	</tr>
	<tr class="row1">
		<td class="col0 centeralign">   +0   </td><td class="col1 leftalign"> Pointer către obiectul String care reprezintă numele clasei           </td>
	</tr>
	<tr class="row2">
		<td class="col0 centeralign">   +4   </td><td class="col1 leftalign"> Dimensiunea in bytes a obiectului, incluzând informația de runtime           </td>
	</tr>
	<tr class="row3">
		<td class="col0 centeralign">   +8   </td><td class="col1 leftalign"> Pointer către informația de runtime a clasei parinte, NULL pentru Object           </td>
	</tr>
	<tr class="row4">
		<td class="col0 centeralign">   +12   </td><td class="col1"> Tabela de metode </td>
	</tr>
</table></div>
<!-- EDIT8 TABLE [4240-4605] -->
<p>
Pe prima poziție din tabela de metode se va afla adresa constructorului clasei, urmând apoi adresele metodelor din clasa parinte și metodele clasei.
</p>

</div>

<h5 id="exemple_de_reprezentare">Exemple de reprezentare</h5>
<div class="level5">

<p>
Pentru:
</p>
<pre class="code">class Main inherits IO
 main : 
  [out &quot;Hello world!&quot;];
 end;
end;</pre>

<p>
se genereaza urmatoarele:
</p>

<p>
* Obiectul de tip String care reprezintă numele clasei
</p>
<pre class="code">@.str = constant [5 x i8] c&quot;Main\00&quot;
@NMain = global %struct.TString { %struct.__lcpl_rtti* @RString, i32 4, i8* getelementptr ([5 x i8]* @.str, i32 0, i32 0) }</pre>

<p>
* Informația de runtime pentru clasa Main
</p>
<pre class="code">%0 = type { %struct.TString*, i32, %struct.__lcpl_rtti*, [7 x i8*] }
@RMain = global %0 { %struct.TString* @NMain, i32 4, %struct.__lcpl_rtti* @RIO, 
[7 x i8*] [
	i8* bitcast (void (%struct.TMain*)* @Main_init to i8*), 
	i8* bitcast (void (%struct.TObject*)* @M6_Object_abort to i8*), 
	i8* bitcast (void (%struct.TObject*)* @M6_Object_typeName to i8*), 
	i8* bitcast (%struct.TIO* (%struct.TObject*)* @M6_Object_copy to i8*), 
	i8* bitcast (%struct.TString* (%struct.TIO*)* @M2_IO_in to i8*), 
	i8* bitcast (void (%struct.TIO*, %struct.TString*)* @M2_IO_out to i8*), 
	i8* bitcast (void (%struct.TMain*)* @M4_Main_main to i8*)
	]}</pre>

<p>
Clasa Main nu are atribute proprii, prin urmare dimensiunea ei este de 4 bytes, dimensiunea pointerului la rtti. Main este derivată din clasa IO, deci informația de parent va arata către rtti-ul clasei IO (@RIO). În tabela de funcții a clasei Main, pe prima poziție este adresa constructorului clasei Main_init, apoi urmează metodele clasei părinte IO și metoda main a clasei Main.
</p>

<p>
* Constructorul clasei
</p>
<pre class="code">define void @Main_init(%struct.TMain* %self) {
 %1 = alloca %struct.TMain*
 store %struct.TMain* %self, %struct.TMain** %1

 %2 = load %struct.TMain** %1
 %3 = bitcast %struct.TMain* %2 to %struct.TObject*
 call void @Object_init(%struct.TObject* %3)

 ret void
}</pre>

<p>
Din constructorul clasei Main se apelează constructorul clasei părinte, pentru a se inițializa atributele clasei părinte.
</p>

<p>
* Metodele clasei 
</p>
<pre class="code">define void @M4_Main_main(%struct.TMain* %self) {
 ; Prologue - save parameters
 %1 = alloca %struct.TMain*
 store %struct.TMain* %self, %struct.TMain** %1
 ...
}</pre>

</div>

<h5 id="conventia_de_apel">Convenţia de apel</h5>
<div class="level5">

<p>
Primul parametru pentru orice funcție generată va conține adresa obiectului de care aceasta aparține (<strong>self</strong>).
Variabilele LCPL pot fi pe stivă sau în registre. Structurile precum tabelele virtuale sau informațiile de runtime sunt variabile globale LLVM IR. 
</p>

</div>

<h5 id="conventia_de_nume">Convenţia de nume</h5>
<div class="level5">
<ul>
<li class="level1"><div class="li"> Obiectele de tip String care reprezintă numele claselor din programul de intrare vor avea forma <code>N&lt;NumeClasă&gt;</code>.  </div>
</li>
<li class="level1"><div class="li"> Structurile care definesc layoutul obiectelor in memorie vor avea forma <code>T&lt;NumeClasă&gt;</code></div>
</li>
<li class="level1"><div class="li"> Unordered List ItemInformația de runtime va avea forma <code>R&lt;NumeClasă&gt;</code></div>
</li>
<li class="level1"><div class="li"> Metodele de inițializare vor avea forma <code>&lt;NumeClasă&gt;_init</code></div>
</li>
<li class="level1"><div class="li"> Restul metodelor se vor genera pe principiul <code>M&lt;N&gt;_&lt;NumeClasă&gt;_&lt;NumeMetodă&gt;</code>, unde N este numărul de caractere al numelui clasei</div>
</li>
</ul>

</div>

<h5 id="functii_si_date_predefinite_pentru_lcpl">Funcţii şi date predefinite pentru LCPL</h5>
<div class="level5">

<p>
Biblioteca de runtime LCPL implementează funcţionalitatea claselor de bază aşa cum este descrisă în <a href="../../../../_media/cpl/teme/lcpl-manual.pdf" class="media mediafile mf_pdf" title="cpl:teme:lcpl-manual.pdf (123.1 KB)"> manualul limbajului LCPL</a>. În codul generat metodele din bibliotecă pot fi folosite respectând convenţia ca obiectul apelant să fie primul parametru al apelului. Este foarte recomandat să folosiţi această convenţie pentru toate clasele şi metodele, nu doar pentru clasele de bază.
</p>

</div>

<h5 id="secventa_de_initializare">Secvenţa de iniţializare</h5>
<div class="level5">

<p>
Punctul de intrare în program este funcția main din biblioteca de runtime. În ea este apelată funcția startup care:
</p>
<ul>
<li class="level1"><div class="li"> se creeaza un obiect de tip Main</div>
</li>
<li class="level1"><div class="li"> se apeleaza prin vtable metoda main a acestui obiect</div>
</li>
</ul>

<p>
Deoarece metoda main poate exista in clasa Main sau intr-o clasă din care este derivată clasa Main, nu se poate ști la runtime care este indexul metodei main in tabela de metode a clasei Main. Prin urmare, codul generat de voi va trebui sa conțina si funcția <code>startup</code> care apelează funcția main prin vtable, cu indexul corect, cunoscut la momentul generării codului.
</p>

</div>
<!-- EDIT6 SECTION "Suportul de execuție pentru LCPL" [3761-8772] -->
<h2 class="sectionedit9" id="detalii_c_api_llvm">Detalii C++ API LLVM</h2>
<div class="level2">

<p>
<abbr title="Application Programming Interface">API</abbr>-ul complet pentru generarea de cod LLVM il gasiti pe site-ul oficial llvm.org
</p>

</div>

<h4 id="generarea_de_constante">Generarea de constante</h4>
<div class="level4">
<ul>
<li class="level1"><div class="li"> intregi</div>
</li>
</ul>
<pre class="code">static ConstantInt * ConstantInt::get (LLVMContext &amp;Context, const APInt &amp;V);</pre>
<ul>
<li class="level1"><div class="li"> string:</div>
</li>
</ul>
<pre class="code">Constant * ConstantDataArray::getString	( LLVMContext &amp;Context,
                             StringRef 	Str,
                             bool 	AddNull = true 
                             )		[static]</pre>

</div>

<h4 id="generarea_tipurilor_corespunzatoare_claselor_definite">Generarea tipurilor corespunzatoare claselor definite</h4>
<div class="level4">
<pre class="code">///\ creare structura
static StructType * StructType::create (LLVMContext &amp;Context, StringRef Name)
///\ adaugare campuri
void 	setBody (ArrayRef&lt; Type * &gt; Elements, bool isPacked=false)</pre>

</div>

<h4 id="generarea_prototipurilor_de_functii">Generarea prototipurilor de functii</h4>
<div class="level4">
<ul>
<li class="level1"><div class="li"> tipul functiei</div>
</li>
</ul>
<pre class="code">static FunctionType * 	FunctionType::get (Type *Result, ArrayRef&lt; Type * &gt; Params, bool isVarArg);</pre>

<p>
exemplu pentru void func(int, int);
</p>
<pre class="code">///\ pregatire parametri
    std::vector&lt;llvm::Type*&gt; func_args;
    func_args.push_back(llvm::IntegerType::get(mod-&gt;getContext(), 32));
    func_args.push_back(llvm::IntegerType::get(mod-&gt;getContext(), 32));
    FunctionType* func_type = FunctionType::get(
                              llvm::Type::getVoidTy(mod-&gt;getContext()), // rezultat
                              func_args,                                // parametri
                              false);                                   // isVarArg
</pre>

<p>
Este recomandat sa creati si pointerul catre FunctionType
</p>
<pre class="code">PointerType* pointer_func_type = PointerType::get(func_type, 0);</pre>
<ul>
<li class="level1"><div class="li"> declararea functiei</div>
</li>
</ul>
<pre class="code">static Function * 	Create (FunctionType *Ty, // pt exemplul de mai sus //func_type//
                               LinkageTypes Linkage, 
                               const Twine &amp;N=&quot;&quot;, // numele functiei
                               Module *M=nullptr) // modulul din care face part</pre>
<ul>
<li class="level1"><div class="li"> calling convention</div>
</li>
</ul>
<pre class="code">void 	setCallingConv (CallingConv::ID CC) </pre>

<p>
In tema <em>setCallingConv</em> va primi parametru:
</p>
<pre class="code">CallingConv::C</pre>

</div>

<h4 id="generarea_corpului_unei_functii">Generarea corpului unei functii</h4>
<div class="level4">

</div>

<h4 id="definirea_unui_basic_block">Definirea unui basic block</h4>
<div class="level4">
<pre class="code">static BasicBlock * 	Create (LLVMContext &amp;Context, 
                              const Twine &amp;Name=&quot;&quot;, 
                              Function *Parent=0, 
                              BasicBlock *InsertBefore=0)</pre>

</div>

<h4 id="instructiuni_llvm_de_care_ati_putea_avea_nevoie">Instructiuni LLVM de care ati putea avea nevoie</h4>
<div class="level4">

<p>
Atentie: Prototipurile de mai jos sunt doar sugestii. Studiati LLVM <abbr title="Application Programming Interface">API</abbr> si alegeti varianta care considerati ca se potriveste cel mai bine cazului pentru care generati cod.
</p>
<pre class="code">// alocare spatiu pe stiva
AllocaInst (const Type *Ty, const Twine &amp;Name, BasicBlock *InsertAtEnd)
// salvare in memorie
StoreInst (Value *Val, Value *Ptr, bool isVolatile, BasicBlock *InsertAtEnd)
// incarca din memorie
LoadInst (Value *Ptr, const char *NameStr, bool isVolatile, BasicBlock *InsertAtEnd)
// incarca un camp dintr-o structura
static GetElementPtrInst * Create (Value *Ptr, 
                          Value *Idx, 
                          const Twine &amp;NameStr, 
                          BasicBlock *InsertAtEnd)

// operatii aritmetice binare
static BinaryOperator *  Create (BinaryOps Op, // Instruction::Add | Instruction::Sub ...
                                Value *S1, 
                                Value *S2, 
                                const Twine &amp;Name, 
                                BasicBlock *InsertAtEnd)
// operatiile unare in llvm sunt tot operatii binare cu un pseudo operand
static BinaryOperator * 	CreateNeg (Value *Op, const Twine &amp;Name, BasicBlock *InsertAtEnd)

// comparatii si branch
ICmpInst (BasicBlock &amp;InsertAtEnd, Predicate pred, Value *LHS, Value *RHS, const Twine &amp;NameStr=&quot;&quot;) 
static BranchInst * 	Create (BasicBlock *IfTrue, 
                           BasicBlock *IfFalse, 
                           Value *Cond, // rezultatul comparatiei (new ICmpInst)
                           BasicBlock *InsertAtEnd)</pre>

</div>
<!-- EDIT9 SECTION "Detalii C++ API LLVM" [8773-12806] -->
<h2 class="sectionedit10" id="detalii_llvm_ir">Detalii LLVM IR</h2>
<div class="level2">

<p>
Fisierul generat de voi este un modul scris în limbajul intermediar LLVM. Acest fişier va fi apoi transformat în asamblare pentru arhitectura target de catre llc, legat cu biblioteca de runtime şi apoi executat pe plaforma target. O descriere exhaustiva a limbajului se găseşte în <a href="http://llvm.org/docs/LangRef.html" class="urlextern" title="http://llvm.org/docs/LangRef.html"  rel="nofollow">documentaţia oficială</a>; mai jos sunt descrise pe scurt elementele de limbaj necesare pentru temă.
</p>

<p>
Un modul LLVM conţine definiţii de funcţii, de variabile globale şi declaraţii de simboluri externe modulului. Un obiect global (funcţie sau variabilă globală) este reprezentat prin adresa lui de memorie. Această adresă este un identificator care începe cu caracterul &#039;@&#039; şi poate conţine litere, cifre, caracterele &#039;.&#039; si &#039;$&#039; . 
</p>

<p>
Cateva exemple:
</p>
<pre class="code">; Un comentariu LLVM incepe cu caracterul ;

; Definiţia unei variabile globale - şir de caractere 
; Numele &quot;.str1&quot; este declarat &quot;internal&quot; pentru a nu intra in conflict cu alte nume 
; Variabila @.str1 este &quot;constant&quot; - nu îşi va schimba valoarea pe parcursul programului
@.str1 = internal constant [13 x i8] c&quot;Hello world!\00&quot;

; Definiţia unei funcţii
define i32 @addOne(i32 %arg)
{
  %1 = add i32 %arg, 1
  ret i32 %1
}

; Declaraţia unei funcţii externe (în cazul nostru, implementată în biblioteca runtime)
declare void @__lcpl_checkNull(i8*)</pre>

</div>

<h5 id="tipuri_si_initializari">Tipuri şi iniţializări</h5>
<div class="level5">

<p>
Tipurile de bază sunt valori care pot fi tinute în regiştri. In cazul LCPL, acestea sunt valori de tip întreg (i32), caracter (i8) sau adresă de memorie, care este pointer/referinţă la un alt tip (de exemplu i32*).
</p>

<p>
LLVM permite tipuri complexe: tablouri: [ 5 x i8 ], structuri: { i32, i8*, i8* }, pointeri la funcţii : i32 (i32,i32)*  . Constructia %nume=type <code>expresie tip</code> crează un alias <code>%nume</code>, ce va fi înlocuit cu <code>expresie tip</code> oriunde apare in program.
</p>
<pre class="code">; tipul care reprezintă informația de runtime pentru clasa String
%0 = type { %struct.TString*, i32, %struct.__lcpl_rtti*, [7 x i8*] }

; Obiectul RMain reprezintă informatia de runtime pentru clasa Main
; si este de tip %0, definit mai sus
@RMain = global %0 { %struct.TString* @NMain, i32 4, %struct.__lcpl_rtti* @RIO, 
...</pre>

<p>
O definiţie de variabilă globală trebuie iniţializată cu valori constante. In plus, variabilele globale de tip tablou de i8 pot fi initializate cu siruri de caractere. Urmatoarele caractere nu pot fi reprezentate direct si trebuie inlocuite cu valoarea lor hexazecimala:
</p>
<div class="table sectionedit11"><table class="inline">
	<tr class="row0">
		<td class="col0"> ” </td><td class="col1"> \22 </td>
	</tr>
	<tr class="row1">
		<td class="col0"> \ </td><td class="col1"> \5C </td>
	</tr>
	<tr class="row2">
		<td class="col0"> \n </td><td class="col1"> \0A </td>
	</tr>
	<tr class="row3">
		<td class="col0"> \r </td><td class="col1"> \0D </td>
	</tr>
	<tr class="row4">
		<td class="col0"> null </td><td class="col1"> \00 </td>
	</tr>
</table></div>
<!-- EDIT11 TABLE [15353-15417] -->
<p>
Inlocuirea se face astfel:
</p>
<pre class="code">1) Se fac modificarile scriind un buffer char *&lt;input_string&gt; (C)
2) sprint(&lt;output_string&gt;, &quot;%s&quot;, &lt;input_string&gt;) - pentru a ne asigura ca se trateaza celelalte caractere speciale (de exemplu \t)
3) llvm::Constant *const_str = ConstantDataArray::getString(module-&gt;getContext(), &lt;output_string&gt;, true);</pre>

<p>
<a href="http://llvm.org/docs/LangRef.html#constantexprs" class="urlextern" title="http://llvm.org/docs/LangRef.html#constantexprs"  rel="nofollow">Expresiile folosite la iniţializare</a> pot conţine conversii de pointeri, de exemplu:
</p>
<div class="table sectionedit12"><table class="inline">
	<tr class="row0">
		<td class="col0"> bitcast i32 (i32,i32)* @main.isEven to i8 * </td><td class="col1"> Converteşte adresa funcţiei main.isEven la un pointer la un sir de i8 </td>
	</tr>
	<tr class="row1">
		<td class="col0"> i8* getelementptr ([7 x i8]* @s62, i32 0, i32 2) </td><td class="col1"> Citeşte adresa celui de-al treilea element din şirul de 7 caractere s62 </td>
	</tr>
</table></div>
<!-- EDIT12 TABLE [15903-16153] -->
<p>
<p><div class="noteclassic"> La prima vedere, getelementptr are un index in plus (i32 0). Aceasta pentru ca s62 poate fi adresa de început a unui tablou de 7 caractere, dar poate fi si un pointer la începutul unui rând dintr-un tablou bidimensional cu 7 coloane. getelementptr întoarce astfel adresa elementului de pe rândul 0, coloana 2. Codul C echivalent este:
</p>
<pre class="code">char (*s62)[7];
&amp;(s62[0][2]);</pre>

<p>

</div></p>
</p>

</div>

<h5 id="functii">Funcţii</h5>
<div class="level5">

<p>
O funcţie în LLVM este alcătuită din mai multe basic blocuri. Un basic bloc începe cu un label şi se termină cu o instrucţiune de salt, condiţionat sau nu (de exemplu <code>br</code> sau <code>ret</code> ). Instrucţiunea de salt este obligatorie chiar dacă din basic blocul curent se trece direct în basic blocul urmator. Numele unui label este un identificator local funcţiei, ce începe cu %. De exemplu:
</p>
<div class="table sectionedit13"><table class="inline">
	<tr class="row0">
		<td class="col0"> Cod C<pre class="code"> int m(int c) {
   if (c&gt;20)
     f();
   return c; 
 }</pre>
</td><td class="col1"> Cod LLVM IR<pre class="code">define i32 @m(i32 %c) {
  %1 = icmp sgt i32 %c, 20
  br i1 %1, label %L2, label %L3
L2:
  call void @f()
  br label %L3
L3:
  ret i32 %c
}</pre>
</td>
	</tr>
</table></div>
<!-- EDIT13 TABLE [16964-17210] -->
<p>
Un simbol local unei funcţii începe cu caracterul %, urmat de un identificator sau de un număr. Numerele trebuie alocate consecutiv şi încep de la 1 pentru fiecare funcţie. Simbolurile locale sunt valori care pot fi tinute în regiştri. 
</p>

<p>
Fiecare simbol local poate fi scris o singură dată, într-o singură instrucţiune în funcţie. LLVM este o reprezentare în forma SSA (Single Static Assignment). Această restricţie poate cauza probleme in diverse cazuri; pentru LCPL de exemplu
* rezultatul unei expresii de tip <code>if</code> trebuie calculat pe fiecare ramură.
* o variabilă locală LCPL se află în partea stângă a unei atribuiri în mai multe locuri in program (de exemplu <code>x ← 1; x ← x + 1;</code> )
</p>

<p>
Pentru a rezolva această problemă, LLVM introduce instrucţiunea phi. Aceasta se poate găsi doar la începutul unui basic bloc, şi atribuie o valoare in funcție de ramura pe care programul a ajuns din basic blocul precedent. De exemplu:
</p>
<div class="table sectionedit14"><table class="inline">
	<tr class="row0">
		<td class="col0"> Cod C<pre class="code">int m(int c) {
  return c &gt; 20 ? f() : g() ;
}</pre>
</td><td class="col1"> Cod LLVM<pre class="code">define i32 @m(i32 %c) {
  %1 = icmp sgt i32 %c, 20
  br i1 %1, label %L2, label %L4
L2:
  %2 = call i32 @f()
  br label %L6
L4:
  %3 = call i32 @g()
  br label %L6
L6:
  %4 = phi i32 [ %2, %L2 ], [ %3, %L4 ]
  ret i32 %4
}</pre>
</td>
	</tr>
</table></div>
<!-- EDIT14 TABLE [18174-18480] -->
<p>
Acesta este singurul caz in care aveți nevoie de instrucțiunea phi. În rest se recomandă generarea de simboluri locale temporare care sa țină rezultatele intermediare din evaluarea expresiilor.
În ceea ce privește variabilele definite de utilizator, ele trebuie alocate pe stivă. LLVM pune la dispozitie instrucţiunea <code>alloca</code> , ce aloca spaţiu pe stivă pentru o variabilă şi întoarce un pointer la acea variabilă. Instrucţiunile <code>load</code> şi <code>store</code> transferă o valoare din memorie într-un registru şi înapoi. Un exemplu:
</p>
<div class="table sectionedit15"><table class="inline">
	<tr class="row0">
		<td class="col0"><pre class="code">int m() {
  int a=42;
  return a;
}</pre>
</td><td class="col1"><pre class="code">define i32 @m() {
  %a = alloca i32
  store i32 42, i32* %a
  %1 = load i32* %a
  ret i32 %1
}</pre>
</td>
	</tr>
</table></div>
<!-- EDIT15 TABLE [19031-19177] -->
<p>
De remarcat în exemplul de mai sus că %a este un registru, ce conţine un pointer către un int aflat pe stivă. %a nu conţine valoarea 42, ci adresa unei locaţii de memorie care conţine valoarea 42!
</p>

<p>
(Exemplele folosesc limbajul C, deoarece permite un cod LLVM mai simplu de înţeles decât codul LCPL echivalent.)
</p>

</div>
<!-- EDIT10 SECTION "Detalii LLVM IR" [12807-19503] -->
<h2 class="sectionedit16" id="arhiva_de_pornire">Arhiva de pornire</h2>
<div class="level2">
<ul>
<li class="level1"><div class="li"> Biblioteca de runtime LCPL. Aceasta implementează clasele si funcțiile predefinite din LCPL. Pentru a putea folosi această bibliotecă va trebui sa înţelegeţi şi să respectaţi reprezentarea internă a obiectelor LCPL.</div>
</li>
<li class="level1"><div class="li"> Un framework ce contine analiza semantică și partial generarea de cod.</div>
</li>
</ul>

</div>
<!-- EDIT16 SECTION "Arhiva de pornire" [19504-19843] -->
<h2 class="sectionedit17" id="testare">Testare</h2>
<div class="level2">

<p>
Tema poate fi testata local astfel:
- În urma build-ului veți obține un executabil <code>lcpl-codegen</code>:
</p>
<pre class="code">./lcpl-codegen &lt;input_file&gt; &lt;output_file&gt; 
llvm-as &lt;output_file&gt; -o &lt;output_file&gt;.bc
llvm-link &lt;output_file&gt;.bc runtime.bc -o &lt;output_file&gt;_run.bc 
lli  &lt;output_file&gt;_run</pre>

<p>
<code>output_file</code> - conține cod LLVM IR valid
</p>

</div>
<!-- EDIT17 SECTION "Testare" [19844-20200] -->
<h2 class="sectionedit18" id="testare_automata">Testare automata</h2>
<div class="level2">

<p>
Testarea temei de casă va folosi o serie de teste ce vor fi disponibile pe vmchecker. Modul în care este distribuit punctajul pentru această temă este următorul:
</p>
<ul>
<li class="level1"><div class="li"> <strong>Testele publice (80p)</strong></div>
<ul>
<li class="level2"><div class="li"> Testele <code>simple</code> (40p)</div>
</li>
<li class="level2"><div class="li"> Testele <code>advanced</code> (30p)</div>
</li>
<li class="level2"><div class="li"> Testele <code>complex</code> (10p) </div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> <strong>Calitatea implementării (20p)</strong></div>
<ul>
<li class="level2"><div class="li"> Organizarea codului sursă</div>
</li>
<li class="level2"><div class="li"> Comentariile din cod</div>
</li>
<li class="level2"><div class="li"> Explicațiile din README - acestea trebuie să conţină o prezentare extinsă a modului de implementare a temei şi a problemelor întâmpinate pe parcurs. </div>
</li>
</ul>
</li>
</ul>

</div>
<!-- EDIT18 SECTION "Testare automata" [20201-20788] -->
<h2 class="sectionedit19" id="instructiuni_de_predare_a_temei">Instrucţiuni de predare a temei</h2>
<div class="level2">

<p>
Arhiva trebuie sa aiba structura din arhiva de start:
</p>
<ul>
<li class="level1"><div class="li"> makefile in radacina</div>
</li>
<li class="level1"><div class="li"> sa produca un executabil <strong>lcpl-codegen</strong></div>
</li>
<li class="level1"><div class="li"> nu puneti in arhiva fisiere obiect/executabile.</div>
</li>
</ul>

</div>
<!-- EDIT19 SECTION "Instrucţiuni de predare a temei" [20789-21011] -->
<h2 class="sectionedit20" id="resurse">Resurse</h2>
<div class="level2">
<ul>
<li class="level1"><div class="li"> <a href="../../../../_media/cpl/teme/lcpl-manual.pdf" class="media mediafile mf_pdf" title="cpl:teme:lcpl-manual.pdf (123.1 KB)"> manualul limbajului LCPL</a></div>
</li>
<li class="level1"><div class="li"> <a href="../../../../lib/exe/fetch.php%3Fhash=3c5b39&amp;media=http%253A%252F%252Fllvm.org%252Freleases%252F3.6.0%252Fdocs%252Ftutorial%252FLangImpl3.html" class="media mediafile mf_html" title="http://llvm.org/releases/3.6.0/docs/tutorial/LangImpl3.html"> Tutorial generare de cod folosind LLVM C++ API </a></div>
</li>
<li class="level1"><div class="li"> <a href="../../../../_media/cpl/teme/runtime.zip" class="media mediafile mf_zip" title="cpl:teme:runtime.zip (2.6 KB)"> Suportul de runtime</a></div>
</li>
<li class="level1"><div class="li"> <a href="../../../../_media/cpl/teme/lcpl-codegen.zip" class="media mediafile mf_zip" title="cpl:teme:lcpl-codegen.zip (414.7 KB)"> Arhiva de start</a></div>
</li>
<li class="level1"><div class="li"> <a href="../../../../_media/cpl/teme/codegen_tests.zip" class="media mediafile mf_zip" title="cpl:teme:codegen_tests.zip (108.8 KB)"> Arhiva teste</a> (actualizată pe 06.01.2016)</div>
</li>
</ul>

</div>
<!-- EDIT20 SECTION "Resurse" [21012-21395] -->
<h2 class="sectionedit21" id="f_a_q">F A Q</h2>
<div class="level2">

</div>
<!-- EDIT21 SECTION "F A Q" [21396-21414] -->
<h2 class="sectionedit22" id="change_log">Change Log</h2>
<div class="level2">

</div>
<!-- EDIT22 SECTION "Change Log" [21415-] --></div>
</body>
</html>
