    
    

<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
  <meta charset="utf-8" />
  <title>cpl:labs-2015:11</title>
<meta name="generator" content="DokuWiki"/>
<meta name="robots" content="index,follow"/>
<meta name="date" content="2016-10-04T07:35:01+0300"/>
<meta name="keywords" content="cpl,labs-2015,11"/>
<link rel="search" type="application/opensearchdescription+xml" href="../../../../lib/exe/opensearch.php" title="CS Open CourseWare"/>
<link rel="start" href="../../../../../courses.1.html"/>
<link rel="alternate" type="application/rss+xml" title="Recent Changes" href="../../../../feed.php"/>
<link rel="alternate" type="application/rss+xml" title="Current Namespace" href="../../../../feed.php%3Fmode=list&amp;ns=cpl:labs-2015"/>
<link rel="alternate" type="text/html" title="Plain HTML" href="11.html"/>
<link rel="canonical" href="../../../../cpl/labs-2015/11.html"/>
<link rel="stylesheet" type="text/css" href="../../../../lib/exe/css.php%3Ft=arctic&amp;tseed=1479898000.css"/>
<script type="text/javascript">/*<![CDATA[*/var NS='cpl:labs-2015';var JSINFO = {"id":"cpl:labs-2015:11","namespace":"cpl:labs-2015","isadmin":0,"isauth":0};
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="../../../../lib/exe/js.php%3Ftseed=1479898000"></script>
<script type="text/x-mathjax-config">/*<![CDATA[*/MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ["$","$"], ["\\(","\\)"] ],
        displayMath: [ ["$$","$$"], ["\\[","\\]"] ],
        processEscapes: true
    }
});
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
<script type="text/javascript">/*<![CDATA[*/
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
		  
/*!]]>*/</script>
<script type="text/javascript">/*<![CDATA[*/
var pageTracker = _gat._getTracker("UA-38383934-1");
pageTracker._initData();
pageTracker._trackPageview();
		  
/*!]]>*/</script>
</head>
<body>
<div class="dokuwiki export">
<!-- TOC START -->
<div id="dw__toc">
<h3 class="toggle">Table of Contents</h3>
<div>

<ul class="toc">
<li class="level1"><div class="li"><a href="11.html#linkers_and_loaders">11. Linkers and Loaders</a></div>
<ul class="toc">
<li class="level2"><div class="li"><a href="11.html#nice_to_read">Nice to read</a></div></li>
<li class="level2"><div class="li"><a href="11.html#prezentare_teoretica">Prezentare teoretică</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="11.html#asambloare">Asambloare</a></div></li>
<li class="level3"><div class="li"><a href="11.html#de_ce_linkere">De ce linkere?</a></div></li>
<li class="level3"><div class="li"><a href="11.html#de_ce_loadere">De ce loadere?</a></div></li>
</ul>
</li>
<li class="level2"><div class="li"><a href="11.html#linkere_vs_loadere">Linkere vs. Loadere</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="11.html#relocarea">Relocarea</a></div></li>
<li class="level3"><div class="li"><a href="11.html#rezolvarea_simbolurilor">Rezolvarea simbolurilor</a></div></li>
<li class="level3"><div class="li"><a href="11.html#incarcarea">Încărcarea</a></div></li>
<li class="level3"><div class="li"><a href="11.html#linking_loaders">Linking loaders</a></div></li>
</ul>
</li>
<li class="level2"><div class="li"><a href="11.html#formatul_unix_elf">Formatul Unix ELF</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="11.html#fisiere_elf_relocabile_si_partajate">Fișiere ELF relocabile și partajate</a></div></li>
<li class="level3"><div class="li"><a href="11.html#fisiere_elf_executabile">Fișiere ELF executabile</a></div></li>
</ul>
</li>
<li class="level2"><div class="li"><a href="11.html#linker_command_language">Linker Command Language</a></div>
<ul class="toc">
<li class="clear">
<ul class="toc">
<li class="level4"><div class="li"><a href="11.html#sections">SECTIONS</a></div></li>
<li class="level4"><div class="li"><a href="11.html#entry">ENTRY</a></div></li>
<li class="level4"><div class="li"><a href="11.html#provide">PROVIDE</a></div></li>
<li class="level4"><div class="li"><a href="11.html#atribute_gcc">Atribute GCC</a></div></li>
</ul>
</li>
</ul>
</li>
<li class="level2"><div class="li"><a href="11.html#variabile_de_mediu_folosite_de_linker">Variabile de mediu folosite de linker</a></div></li>
</ul>
</li>
<li class="level1"><div class="li"><a href="11.html#exercitii_de_laborator_11p">Exerciții de laborator (11p)</a></div>
<ul class="toc">
<li class="level2"><div class="li"><a href="11.html#exercitiul_1_-_name_mangling_4p">Exercițiul 1 - name mangling (4p)</a></div>
<ul class="toc">
<li class="clear">
<ul class="toc">
<li class="level4"><div class="li"><a href="11.html#name_mangling_in_c_2p">Name mangling în C (2p)</a></div></li>
<li class="level4"><div class="li"><a href="11.html#name_mangling_in_c_2p1">Name mangling în C++ (2p)</a></div></li>
</ul>
</li>
</ul>
</li>
<li class="level2"><div class="li"><a href="11.html#exercitiul_2_-_rezolvarea_simbolurilor_2p">Exercițiul 2 - rezolvarea simbolurilor (2p)</a></div></li>
<li class="level2"><div class="li"><a href="11.html#exercitiul_3_-_instrumentarea_binarelor_3p">Exercițiul 3 - instrumentarea binarelor (3p)</a></div></li>
<li class="level2"><div class="li"><a href="11.html#exercitiul_4_-_linker_command_language_2p">Exercițiul 4 - Linker Command Language (2p)</a></div></li>
<li class="level2"><div class="li"><a href="11.html#bonus">BONUS</a></div>
<ul class="toc">
<li class="clear">
<ul class="toc">
<li class="level4"><div class="li"><a href="11.html#cpl_karma_-_ld_preload">1 cpl karma - LD_PRELOAD</a></div></li>
<li class="level4"><div class="li"><a href="11.html#cpl_karma_-_rpath">1 cpl karma - rpath</a></div></li>
</ul></li>
</ul></li>
</ul></li>
</ul>
</div>
</div>
<!-- TOC END -->

<h1 class="sectionedit1" id="linkers_and_loaders">11. Linkers and Loaders</h1>
<div class="level1">

</div>
<!-- EDIT1 SECTION "11. Linkers and Loaders" [2-40] -->
<h2 class="sectionedit2" id="nice_to_read">Nice to read</h2>
<div class="level2">
<ul>
<li class="level1"><div class="li"> <a href="http://www.iecc.com/linker/" class="urlextern" title="http://www.iecc.com/linker/"  rel="nofollow">Linkers and Loaders</a>,  John R. Levine</div>
</li>
</ul>

<p>
<p><div class="noteclassic">
Acest laborator va abunda de rom-engleză, în special de cuvintele <strong>linkăre</strong> și <strong>loadăre</strong>. :)

</div></p>
</p>

</div>
<!-- EDIT2 SECTION "Nice to read" [41-257] -->
<h2 class="sectionedit3" id="prezentare_teoretica">Prezentare teoretică</h2>
<div class="level2">

<p>
<strong>Linkerele</strong> unesc mai multe fișiere compilate (obiect) pentru a genera un singur fișier executabil.
</p>

<p>
<strong>Loaderele</strong> încarcă un program executabil la o anumită adresă în memorie.
</p>

<p>
Acestea permit construirea programelor din module, în locul unui program mare și monolitic. Astfel, una din principalele sarcini ale linkerelor și loaderelor este să lege numele abstracte folosite de programatori (ex: numele funcțiilor din biblioteci) și să le transforme în nume concrete (ex: locația deplasată cu 512 octeți de la începutul secvenței codului executabil din memorie sau o adresă numerică).
</p>

</div>
<!-- EDIT3 SECTION "Prezentare teoretică" [258-902] -->
<h3 class="sectionedit4" id="asambloare">Asambloare</h3>
<div class="level3">

<p>
La începuturile erei calculatoarelor, programarea se făcea în totalitate în cod mașină. Programatorii scriau programele simbolice pe hârtie și le transformau <em>de mână</em> în cod mașină. Dacă programatorul folosea nume simbolice (de exemplu un nume de procedură) acestea trebuiau transformate <em>de mână</em> în adrese și, dacă apoi se descoperea că o instrucțiune trebuie adăugată într-un anumit loc în program, acesta trebuia verificat pentru a fi modificate toate adresele afectate de acea instrucțiune.
</p>

<p>
Problema în aceasta abordare era că numele erau legate de o adresă fixă prea devreme în procesul de dezvoltare. Această problemă a fost rezolvată cu ajutorul asambloarelor ce permiteau folosirea de nume simbolice. Dacă programul trebuia schimbat, programatorul trebuia să îl reasambleze, dar această muncă de a atribui adresele fizice nu mai era făcută de el.
</p>

</div>
<!-- EDIT4 SECTION "Asambloare" [903-1829] -->
<h3 class="sectionedit5" id="de_ce_linkere">De ce linkere?</h3>
<div class="level3">

<p>
Bibliotecile complică această problemă (existau biblioteci de cod încă înaintea apariției asambloarelor). Aceste biblioteci ar trebui să fie încărcate în memorie și să poată fi accesate din programul care le apelează (eventual să fie încărcate în același loc cu celelalte metode ale programului). În general aceste biblioteci vin sub o formă binară (compilată) și ar trebui ca adresele lor sa poată fi atribuite în funcție de adresa efectivă la care sunt încărcate.
</p>

<p>
Pentru a rezolva această problemă a fost introdusă noțiunea de <strong>cod relocabil</strong>. Programatorii și asamblorul scriau module care începeau atribuirea adreselor relative de la 0 și amânau atribuirea adreselor absolute (adrese fizice) până în <strong>momentul linkeditării</strong>.
</p>

</div>
<!-- EDIT5 SECTION "De ce linkere?" [1830-2633] -->
<h3 class="sectionedit6" id="de_ce_loadere">De ce loadere?</h3>
<div class="level3">

<p>
Odată cu apariția sistemelor de operare, a devenit necesară o <strong>separare a linkerelor de loadere</strong>. Înainte programele puteau fi asamblate și link-ate cu adrese fixe pentru că programele aveau toată memoria la dispoziție, dar în contextul sistemelor de operare, în momentul în care modulele erau legate, programele nu știau la ce adresă vor fi încărcate.
</p>

<p>
Astfel linkerele făceau partea de agregare a modulelor și foloseau adrese relative, în timp ce loaderele le transformau în adrese absolute odată cu încărcarea programelor în memorie.
</p>

<p>
Această evoluție a continuat și a mai parcurs o serie de stagii marcate în principal de apariția blocurilor de date partajate de mai multe programe (linkerul trebuia să asigure suportul pentru accesul la aceste date), împărțirea programelor în secțiuni (linkerul trebuie să combine toate secțiunile de fiecare tip din fiecare modul), apariția bibliotecilor dinamice etc.
</p>

</div>
<!-- EDIT6 SECTION "De ce loadere?" [2634-3608] -->
<h2 class="sectionedit7" id="linkere_vs_loadere">Linkere vs. Loadere</h2>
<div class="level2">

<p>
Atât linkerele cât și loaderele lucrează (sau modifică) cod obiect și sunt cam singurele instrumente de largă răspândire care lucrează cu acest tip de cod (în afara debuggerelor).
</p>

<p>
Există trei mari acțiuni pe care le îndeplinesc:
</p>
<ul>
<li class="level1"><div class="li"> relocarea</div>
</li>
<li class="level1"><div class="li"> rezolvarea simbolurilor</div>
</li>
<li class="level1"><div class="li"> încărcarea</div>
</li>
</ul>

</div>
<!-- EDIT7 SECTION "Linkere vs. Loadere" [3609-3945] -->
<h3 class="sectionedit8" id="relocarea">Relocarea</h3>
<div class="level3">

<p>
Este o acțiune făcută și de <strong>linker</strong> și de <strong>loader</strong>.
</p>

<p>
Compilatoarele și asambloarele creează, în general, fișiere obiect cu adrese relative (pornind de la 0). Relocarea este procesul prin care se atribuie adrese de încărcare diferitelor părți din program, ajustând codul și datele în program pentru a reflecta adresele atribuite. Un program poate fi relocat de mai multe ori. De regulă, un linker creează un program mare cu adresele pornind de la zero din mai multe subprograme (fiecare fiind creat cu adrese pornind de la zero) care vor fi introduse în zone diferite în programul mare. La încărcare, loaderul va reloca executabilul produs de linker la o adresă efectivă în memorie.
</p>

</div>
<!-- EDIT8 SECTION "Relocarea" [3946-4679] -->
<h3 class="sectionedit9" id="rezolvarea_simbolurilor">Rezolvarea simbolurilor</h3>
<div class="level3">

<p>
Este o acțiune făcută de <strong>linker</strong>.
</p>

<p>
Într-un program compus din mai multe subprograme se pot face referințe între subprograme prin simboluri (de ex. proceduri sau variabile externe: un apel către sqrt() din biblioteca matematică). Rezolvarea unui simbol se face înlocuind toate utilizările simbolului cu adresa la care acesta este definit.
</p>

</div>
<!-- EDIT9 SECTION "Rezolvarea simbolurilor" [4680-5066] -->
<h3 class="sectionedit10" id="incarcarea">Încărcarea</h3>
<div class="level3">

<p>
Este o acțiune făcută de <strong>loader</strong>.
</p>

<p>
Încărcarea este procesul de aducere a unui program de pe un mediu de stocare secundar (hard-disk, SSD, flash etc.) în memoria principală astfel încât programul să fie gata de execuție. Această acțiune poate varia de la simpla copiere a datelor până la alocarea spațiului, setarea unor biți de protecție ai memoriei (de ex. paginile de cod sunt read-only) sau maparea unor zone de memorie virtuală pe spații de pe disk/flash/SSD/etc.
</p>

</div>
<!-- EDIT10 SECTION "Încărcarea" [5067-5582] -->
<h3 class="sectionedit11" id="linking_loaders">Linking loaders</h3>
<div class="level3">

<p>
Un singur program poate face toate cele trei funcții amintite mai sus. Limita dintre relocare și identificarea simbolurilor poate fi destul de confuză. Din moment ce linkerele pot rezolva referințe la simboluri, un mod de a trata relocarea este de a atribui un simbol adresei de start a fiecărei părți din program și apoi de a trata relocarea adreselor ca referințe la adresa simbolului de bază.
</p>

</div>
<!-- EDIT11 SECTION "Linking loaders" [5583-6017] -->
<h2 class="sectionedit12" id="formatul_unix_elf">Formatul Unix ELF</h2>
<div class="level2">

<p>
Fișierele ELF pot fi de trei tipuri (puțin diferite):
</p>
<ul>
<li class="level1"><div class="li"> <strong>relocabile</strong> - create de compilatoare sau asambloare, dar trebuie procesate de linker înainte de execuție</div>
</li>
<li class="level1"><div class="li"> <strong>executabile</strong> - gata relocate și cu toate simbolurile rezolvate exceptând, poate, simbolurile din bibliotecile partajate care vor fi rezolvate la runtime</div>
</li>
<li class="level1"><div class="li"> <strong>partajate</strong> - biblioteci comune ce conțin informații despre simboluri (folosite de linker) și cod executabil</div>
</li>
</ul>

<p>
Compilatoarele, asambloarele și linkerele tratează fișierele ELF ca un set de secțiuni logice descrise de un <em>section header table</em>. Loaderul tratează fișierele ELF ca un set de segmente descrise de un <em>program header table</em>, un segment fiind de obicei compus din mai multe secțiuni.
</p>

</div>
<!-- EDIT12 SECTION "Formatul Unix ELF" [6018-6795] -->
<h3 class="sectionedit13" id="fisiere_elf_relocabile_si_partajate">Fișiere ELF relocabile și partajate</h3>
<div class="level3">

<p>
Un fișier relocabil sau partajat este considerat o colecție de secțiuni definite în header. Fiecare secțiune conține un singur tip de informație (ex: codul programului, date read-only sau read-write, intrări relocabile, simboluri, etc.). Fiecare simbol definit este relativ la o secțiune (ex: punctul de intrare al unei proceduri va fi definit relativ la secțiunea care conține codul programului). 
</p>

<p>
Există două pseudo-secțiuni:
</p>
<ul>
<li class="level1"><div class="li"> SHN_ABS - conține simboluri ne-relocabile</div>
</li>
<li class="level1"><div class="li"> SHN_COMMON - conține blocuri de date neinițializate, moștenire din formatul a.out</div>
</li>
</ul>

<p>
Un executabil relocabil are în jur de 12 secțiuni. Numele secțiunilor au semnificație pentru linker, care caută anumite secțiuni pentru prelucrări specifice. Tipurile de secțiuni includ:
</p>
<ul>
<li class="level1"><div class="li"> PROGBITS - conținut al programului: cod, date, informații pentru debugger</div>
</li>
<li class="level1"><div class="li"> NOBITS - la fel ca și PROGBITS, dar nu alocă spațiu în fișierul propriu zis, ci folosește BSS pentru alocarea datelor la încărcarea programului</div>
</li>
<li class="level1"><div class="li"> SYMTAB - tabelă ce conține toate simbolurile</div>
</li>
<li class="level1"><div class="li"> DYNSYM - tabelă ce conține simbolurile folosite pentru linkarea dinamică</div>
</li>
<li class="level1"><div class="li"> STRTAB - tabelă de stringuri</div>
</li>
<li class="level1"><div class="li"> RELA - valorile de bază pentru relocare</div>
</li>
<li class="level1"><div class="li"> REL - valorile cu care se fac relocările (valorile sunt adăugate la valoarea de bază)</div>
</li>
<li class="level1"><div class="li"> DYNAMIC - informații pentru linkarea dinamică</div>
</li>
<li class="level1"><div class="li"> HASH - tabelă de simboluri folosite la runtime</div>
</li>
</ul>

<p>
Se pot defini și secțiuni proprii, însă vom enumera câteva dintre secțiunile tipice (standard):
</p>
<ul>
<li class="level1"><div class="li"> .text - de tip PROGBITS (cu modificatori ce permit execuția instrucțiunilor), este echivalentul segmentului text din a.out</div>
</li>
<li class="level1"><div class="li"> .data - de tip PROGBITS (cu modificatori ce permit scrierea datelor), este echivalentul segmentului de date din a.out</div>
</li>
<li class="level1"><div class="li"> .rodata - date read-only </div>
</li>
<li class="level1"><div class="li"> .bss - de tip NOBITS (cu modificatori ce permit scrierea); nu ocupă spațiu în fișier și este alocată la runtime</div>
</li>
<li class="level1"><div class="li"> .init și .fini - cod care este executat la inițializarea/finalizarea programului; spre exemplu, compilatoarele de C++ folosesc aceste secțiuni pentru a inițializa datele globale alocate static</div>
</li>
<li class="level1"><div class="li"> .symtab și .dynsym - tabele de simboluri</div>
</li>
<li class="level1"><div class="li"> .strtab și .dynstr - tabele de stringuri</div>
</li>
</ul>

</div>
<!-- EDIT13 SECTION "Fișiere ELF relocabile și partajate" [6796-9063] -->
<h3 class="sectionedit14" id="fisiere_elf_executabile">Fișiere ELF executabile</h3>
<div class="level3">

<p>
Fișierele executabile au același format, dar datele sunt aranjate astfel încât fișierul poate fi mapat direct în memorie și rulat. Conține un header de program care urmează headerului ELF din fișier și definește segmentele care trebuie mapate.
</p>

<p>
Un executabil are în general doar câteva segmente: unul read-only pentru cod și datele read-only și unul read-write pentru datele read-write. Toate secțiunile sunt împachetate în segmentele corespunzătoare astfel încât sistemul poate mapa simplu fișierul în memorie.
</p>

</div>
<!-- EDIT14 SECTION "Fișiere ELF executabile" [9064-9635] -->
<h2 class="sectionedit15" id="linker_command_language">Linker Command Language</h2>
<div class="level2">

<p>
Utilitarul <code>ld</code> poate fi configurat atât din linia de comandă, cât și printr-un limbaj specific: <em>Linker Command Language</em>. Fișierele de configurare au extensia <code>.lds</code> (ld script) și constituie o înșiruire de comenzi:
</p>
<ul>
<li class="level1"><div class="li"> cuvânt cheie [argumente]</div>
</li>
<li class="level1"><div class="li"> atribuiri unui simbol</div>
</li>
<li class="level1"><div class="li"> comentarii</div>
</li>
</ul>

</div>

<h4 id="sections">SECTIONS</h4>
<div class="level4">

<p>
Secțiuniile de cod sunt definite folosind comanda <code>SECTIONS</code>, urmată de diverse atribute. Exemplu:
</p>
<pre class="code">SECTIONS
{
       /* 
        * „.” (contorul de locație) este setat la 0x10000 
        * implicit, la începutul comenzii SECTIONS are valoarea 0
        * este incrementat automat la includerea unei secțiuni cu dimensiunea acesteia
        */
       . = 0x10000;
 
       /*
        * adună toate secțiunile .text din fișierele de intrare 
        * și pune-le în secțiunea .text în fișierul de ieșiere
        *
        * dacă nu există nici o secțiune .text în nici un fișier de intrare
        * nu se generează în fișierul de ieșire secțiunea .text
        */
       .text : { *(.text) }
 
       /* adresa de la care se scriu date este 0x8000000 */
       . = 0x8000000;
 
        /* similar text */
       .data : { *(.data) }
        /* similar text */
       .bss : { *(.bss) }
}</pre>

</div>

<h4 id="entry">ENTRY</h4>
<div class="level4">

<p>
Comanda <code>ENTRY</code> setează entry-pointul programului (prima instrucțiune de executat). Dacă comanda lipsește, atunci se va utiliza valoarea simbolului <code>.start</code> (dacă este definit), sau valoarea simbolului <code>.text</code> (dacă este definit), sau, dacă nu, valoarea 0.
</p>

</div>

<h4 id="provide">PROVIDE</h4>
<div class="level4">

<p>
Pentru a defini un simbol nou se poate folosi comanda <code>PROVIDE</code> în cadrul comenzii <code>SECTIONS</code>. Exemplu:
</p>
<pre class="code">SECTIONS
{
   .text : { *(.text) }
 
   PROVIDE(__data_start = .);
   .data : { *(.data) }
   PROVIDE(__data_stop =  .);
 
   PROVIDE(__bss_start = .);
   .bss : { *(.bss) }
   PROVIDE(__bss_stop =  .);
}</pre>

<p>
Pentru a folosi simbolurile definite în exemplul anterior se poate proceda ca în exemplul următor:
</p>
<pre class="code c"><span class="co2">#include &lt;stdio.h&gt;</span>
&nbsp;
<span class="kw2">extern</span> <span class="kw4">void</span> <span class="sy0">*</span> __data_start<span class="sy0">,</span> <span class="sy0">*</span> __data_stop<span class="sy0">,</span> <span class="sy0">*</span> __bss_start<span class="sy0">,</span> <span class="sy0">*</span> __bss_stop<span class="sy0">;</span>
&nbsp;
<span class="kw4">int</span> main<span class="br0">&#40;</span><span class="kw4">void</span><span class="br0">&#41;</span>
<span class="br0">&#123;</span>
	<a href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span class="kw3">printf</span></a><span class="br0">&#40;</span><span class="st0">&quot;.data starts at %p and ends at %p<span class="es1">\n</span>&quot;</span><span class="sy0">,</span>  <span class="sy0">&amp;</span>__data_start<span class="sy0">,</span> <span class="sy0">&amp;</span>__data_stop<span class="br0">&#41;</span><span class="sy0">;</span>
	<a href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span class="kw3">printf</span></a><span class="br0">&#40;</span><span class="st0">&quot;.bss starts at %p and ends at %p<span class="es1">\n</span>&quot;</span><span class="sy0">,</span>  <span class="sy0">&amp;</span>__bss_start<span class="sy0">,</span> <span class="sy0">&amp;</span>__bss_stop<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
	<span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">&#125;</span></pre>

</div>

<h4 id="atribute_gcc">Atribute GCC</h4>
<div class="level4">

<p>
În GCC se pot specifica pentru anumite tipuri de simboluri comportamente speciale. Sintaxa prin care se decorează un element cu un atribut este următoarea:
</p>
<pre class="code">type_of_element element_name __attribute__ ( attribute_goes_here );</pre>

<p>
Unul din atributele pe care GCC le suportă este specificarea secțiunii în care va fi inclus simbolul generat:
</p>
<pre class="code c"><span class="co1">// definim variabila x, o inițializăm cu 7 </span>
<span class="co1">// și specificăm compilatorului să o pună în secținea &quot;.cpl&quot;</span>
<span class="kw4">int</span> x __attribute__ <span class="br0">&#40;</span><span class="br0">&#40;</span>section <span class="br0">&#40;</span><span class="st0">&quot;.cpl&quot;</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="sy0">=</span> <span class="nu0">7</span><span class="sy0">;</span></pre>

</div>
<!-- EDIT15 SECTION "Linker Command Language" [9636-12513] -->
<h2 class="sectionedit16" id="variabile_de_mediu_folosite_de_linker">Variabile de mediu folosite de linker</h2>
<div class="level2">

<p>
<strong>LD_LIBRARY_PATH</strong> - o listă de directoare separate prin <code>:</code> ce specifică directoarele în care linkerul să caute biblioteci, înainte de a se uita în directoarele standard
</p>

<p>
<strong>LD_PRELOAD</strong> - calea către o bibliotecă dinamică ce va fi încărcată în locul unei alte biblioteci; spre exemplu astfel se poate înlocui biblioteca standard C
</p>

</div>
<!-- EDIT16 SECTION "Variabile de mediu folosite de linker" [12514-12913] -->
<h1 class="sectionedit17" id="exercitii_de_laborator_11p">Exerciții de laborator (11p)</h1>
<div class="level1">

<p>
În rezolvarea laboratorului folosiți arhiva de sarcini <a href="../../../../_media/cpl/labs/lab11-tasks.zip" class="media mediafile mf_zip" title="cpl:labs:lab11-tasks.zip (10.5 KB)">lab11-tasks.zip</a>.
</p>

<p>
Pe măsura ce rezolvați exercițiile, nu uitați că modificarea optiunilor compilării implică și recompilarea fișierelor sursă.
</p>

</div>
<!-- EDIT17 SECTION "Exerciții de laborator (11p)" [12914-13185] -->
<h2 class="sectionedit18" id="exercitiul_1_-_name_mangling_4p">Exercițiul 1 - name mangling (4p)</h2>
<div class="level2">

<p>
Linkerul este responsabil de rezolvarea numelor. Fiecare fișier obiect conține o tabelă de simboluri. În continuare vom analiza cum arată aceste tabele pentru diverse tipuri de funcții în C și în C++.
</p>

<p>
Pentru a vizualiza tabela de simboluri vom utiliza utilitarul <code>nm</code>.
</p>

<p>
<p><div class="notetip">
Denumirea simbolurilor nu este standard și este strâns dependentă de compilator și de platformă.

</div></p>
</p>

</div>

<h4 id="name_mangling_in_c_2p">Name mangling în C (2p)</h4>
<div class="level4">

<p>
Intrați în directorul <code>1-name/c</code>. Vom analiza pe rând fiecare din cele 3 fișiere.
</p>

<p>
Pentru a genera fișierele obiect, rulați comanda <code>make obj</code>. Vom avea nevoie de acestea pentru a vizualiza tabelele de simboluri. Tabela de simboluri poate fi vizualizată rulând comanda:
</p>
<pre class="code">nm -s $FIȘIER_OBIECT</pre>

<p>
Deschideți fișierul <code>main-only.c</code>. Programul apelează funcția <code>printf</code>, fără a include niciun header specific. Vizualizați tabela de simboluri. Ce observați? Ce înseamnă <code>T</code>? Dar <code>U</code>? Consultați pagina de manual a utilitarului <a href="http://linux.die.net/man/1/nm" class="urlextern" title="http://linux.die.net/man/1/nm"  rel="nofollow">nm</a>.
</p>

<p>
Deschideți fișierul <code>simple-functions.c</code>. Programul definește mai multe funcții având diverse tipuri de argumente. Vizualizați tabela de simboluri. Ce observați? În ce ordine sunt listate funcțiile?
</p>

<p>
Deschideți fișierul <code>static-function.c</code>. Programul definește o funcție statică și o apelează din funcția main. Vizualizați tabela de simboluri. Ce observați? Ce înseamnă <code>t</code>? Consultați pagina de manual a utilitarului <a href="http://linux.die.net/man/1/nm" class="urlextern" title="http://linux.die.net/man/1/nm"  rel="nofollow">nm</a>.
</p>

</div>

<h4 id="name_mangling_in_c_2p1">Name mangling în C++ (2p)</h4>
<div class="level4">

<p>
Intrați în directorul <code>1-name/cpp</code>. Vom analiza pe rând fiecare din cele 5 fișiere sursă.
</p>

<p>
Pentru a genera fișierele obiect, rulați comanda <code>make obj</code>. Vom avea nevoie de acestea pentru a vizualiza tabelele de simboluri. Tabela de simboluri poate fi vizualizată rulând comanda:
</p>
<pre class="code">nm -s $FIȘIER_OBIECT</pre>

<p>
Deschideți fișierul <code>main-only.cpp</code>. Programul include header-ul <code>iostream</code> și importă în cadrul namespace-ului curent streamul <code>cout</code>. Vizualizați tabela de simboluri. Ce observați? Folosiți parametrul <code>C</code> al utilitarului <code>nm</code> pentru a înțelege mai bine simbolistica outputului. Consultați pagina de manual a utilitarului <a href="http://linux.die.net/man/1/nm" class="urlextern" title="http://linux.die.net/man/1/nm"  rel="nofollow">nm</a>.
</p>

<p>
Deschideți fișierul <code>simple-functions.cpp</code>. Programul definește mai multe funcții având diverse tipuri de argumente. Vizualizați tabela de simboluri.
</p>

<p>
Deschideți fișierul <code>static-function.cpp</code>. Programul definește o funcție statică și o apelează din funcția main. Vizualizați tabela de simboluri.
</p>

<p>
Deschideți fișierele <code>myClass.hpp</code> și <code>myClass.cpp</code>. Cele două definesc clasa <code>myClass</code>. Vizualizați tabela de simboluri. De ce sunt două simboluri diferite pentru constructorul fără argumente? Citiți explicația de <a href="http://stackoverflow.com/questions/6921295/dual-emission-of-constructor-symbols/6921467#6921467" class="urlextern" title="http://stackoverflow.com/questions/6921295/dual-emission-of-constructor-symbols/6921467#6921467"  rel="nofollow">aici</a>.
</p>

<p>
Deschideți fișierul <code>useClass.cpp</code>. Programul folosește clasa definită anterior. Vizualizați tabela de simboluri.
</p>

</div>
<!-- EDIT18 SECTION "Exercițiul 1 - name mangling (4p)" [13186-16283] -->
<h2 class="sectionedit19" id="exercitiul_2_-_rezolvarea_simbolurilor_2p">Exercițiul 2 - rezolvarea simbolurilor (2p)</h2>
<div class="level2">

<p>
Rezolvarea simbolurilor de către linker se face în următoarea ordine:
</p>
<ul>
<li class="level1"><div class="li"> simbolul este căutat în fișierul obiect în care este folosit prima oară</div>
</li>
<li class="level1"><div class="li"> simbolul este căutat în oricare din fișierele obiect sau bibliotecile statice cu care este compilat (în ordinea în care acestea apar ca argumente ale linkerului)</div>
</li>
<li class="level1"><div class="li"> simbolul este căutat în bibliotecile partajate (în ordinea în care acestea apar în linia de comandă)</div>
</li>
</ul>

<p>
Intrați în directorul <code>2-symbols</code>. Vizualizați conținutul fișierelor sursă c. O să găsiți trei implementări diferite ale funcției <code>function</code>.
</p>

<p>
Rulați comanda <code>make</code> pentru a genera:
</p>
<ul>
<li class="level1"><div class="li"> fișierele obiect corespunzătoare fiecărui fișier sursă</div>
</li>
<li class="level1"><div class="li"> biblioteca dinamică <code>libA.so</code> ce implementează funcția <code>function</code> în fișierul <code>a.c</code></div>
</li>
<li class="level1"><div class="li"> biblioteca dinamică <code>libB.so</code> ce implementează funcția <code>function</code> în fișierul <code>b.c</code></div>
</li>
<li class="level1"><div class="li"> executabilul <code>exe12</code> compilat astfel <code>gcc main.o -lA -lB -L. -o exe12</code></div>
</li>
<li class="level1"><div class="li"> executabilul <code>exe21</code> compilat astfel <code>gcc main.o -lB -lA -L. -o exe21</code></div>
</li>
<li class="level1"><div class="li"> executabilul <code>exe-static</code> compilat astfel <code>gcc main.o c.o -lA -lB -L. -o exe-static</code></div>
</li>
</ul>

<p>
Setați variabila de mediu <a href="../../../../cpl/labs/12%3F&amp;.html#variabile_de_mediu_folosite_de_linker" class="urlextern" title="http://ocw.cs.pub.ro/courses/cpl/labs/12?&amp;#variabile_de_mediu_folosite_de_linker"  rel="nofollow">LD_LIBRARY_PATH</a> corespunzător, pentru ca linkerul să găsească bibliotecile generate în directorul curent.
</p>

<p>
Executabilul <code>exe12</code> a fost generat linkând 2 biblioteci dinamice ce implementează funcția <code>function</code>. Care este ordinea bibliotecilor dinamice în linia de comandă? Rulați binarul pentru a observa outputul produs.
</p>

<p>
Executabilul <code>exe21</code> a fost generat linkând 2 biblioteci dinamice ce implementează funcția <code>function</code>. Care este ordinea bibliotecilor dinamice în linia de comandă? Rulați binarul pentru a observa outputul produs.
</p>

<p>
Executabilul <code>exe-static</code> a fost generat linkând 2 biblioteci dinamice și un fișier obiect ce implementează funcția <code>function</code>. În ce ordine au fost specificate în linia de comandă? Rulați binarul pentru a observa outputul produs.
</p>

</div>
<!-- EDIT19 SECTION "Exercițiul 2 - rezolvarea simbolurilor (2p)" [16284-18412] -->
<h2 class="sectionedit20" id="exercitiul_3_-_instrumentarea_binarelor_3p">Exercițiul 3 - instrumentarea binarelor (3p)</h2>
<div class="level2">

<p>
Presupunem că avem un set de binare ale unei aplicații/biblioteci ale cărei surse nu le mai avem (de ex. am cumpărat licența pentru o bibliotecă proprietară și compania care producea acea bibliotecă s-a închis). Dorim să modificăm aplicația/biblioteca, fără a modifica acele binare. :)
</p>

<p>
Neavând acces la surse putem spune linkerului să routeze toate apelurile către un anumit simbol către o funcție specială aflată sub controlul nostru. Dacă se trimite argumentul <code>–wrap=symbol</code> linkerului acesta:
</p>
<ul>
<li class="level1"><div class="li"> va înlocui toate referințele către simbolul <code>symbol</code> cu referințe către <code>__wrap_symbol</code></div>
</li>
<li class="level1"><div class="li"> va genera un simbol <code>__real_symbol</code> care va trimite către varianta originală a lui <code>symbol</code></div>
</li>
</ul>

<p>
Intrați în directorul <code>3-wrap</code>. Vizualizați fișierul <code>main.c</code>. Programul încearcă să scrie un mesaj în fișierul <code>/bad/path</code> și eșuează din lipsa permisiunilor și a existenței directoarelor superioare. Pentru a compila fișierul, rulați comanda <code>make default</code> și rulați executabilul <code>exe_default</code>.
</p>

<p>
<strong>Fără a modifica fișierul <code>main.c</code></strong>, veți suprascrie funcția <code>open</code> așa cum am descris mai sus, astfel încât să obțineți un file descriptor valid. Implementarea o veți realiza în cadrul fișierului <code>wrap.c</code>. Pentru a compila, rulați comanda <code>make wrapped</code>, apoi rulați executabilul <code>exe_wrapped</code>.
</p>

<p>
<p><div class="notetip"> <strong>Hint</strong>: man ld, apoi căutați –wrap 
</div></p>
</p>

</div>
<!-- EDIT20 SECTION "Exercițiul 3 - instrumentarea binarelor (3p)" [18413-19916] -->
<h2 class="sectionedit21" id="exercitiul_4_-_linker_command_language_2p">Exercițiul 4 - Linker Command Language (2p)</h2>
<div class="level2">

<p>
<p><div class="noteclassic">
Dacă lucrați pe calculatoarele proprii și acestea sunt pe 64 de biți, instalați gcc-multilib pentru a putea compila cross-platform:
<strong>sudo apt-get install gcc-multilib</strong>

</div></p>
</p>

<p>
Consultați secțiunea <a href="../../../../cpl/labs/11%3F&amp;.html#linker_command_language" class="urlextern" title="http://ocw.cs.pub.ro/courses/cpl/labs/11?&amp;#linker_command_language"  rel="nofollow">Linker Command Language</a> din laborator.
</p>

<p>
Intrați în directorul <code>4-lcl</code>. Aveți definit în cadrul fișierului <code>def.h</code> un macro care primește numele unei funcții și generează un pointer la funcție și-l pune în secținuea <code>.cpl</code>:
</p>
<pre class="code c"><span class="co1">// def.h</span>
<span class="co2">#define MODULE_INIT(X) \
  static void * __ptr_init_cpl_##X __attribute__ ((section (&quot;.cpl&quot;))) = &amp;X;</span></pre>

<p>
De asemenea, în director veți găsi un set de fișiere cu funcții de inițializare pentru care s-a apelat macro-ul de mai sus.
</p>

<p>
Practic, în secțiunea <code>.cpl</code> se vor adăuga pointeri către toate funcțiile.
</p>

<p>
Modificați scriptul de linker din cadrul directorului pentru a introduce o secțiune de date specială <code>.cpl</code> care să adune secțiunile <code>.cpl</code> din fiecare fișier obiect de intrare, conform <strong>TODO-ului</strong> din script (revedeți secțiunea <a href="../../../../cpl/labs/11.html#provide" class="urlextern" title="http://ocw.cs.pub.ro/courses/cpl/labs/11#provide"  rel="nofollow">PROVIDE</a>). Apoi, în cadrul fișierului <code>main.c</code>, exportați două simboluri pentru începutul și sfârșitul acestei secțiuni și iterați prin toți pointerii, apelând pe rând funcția către care aceștia trimit (puteți pasa orice întreg ca parametru).
</p>

</div>
<!-- EDIT21 SECTION "Exercițiul 4 - Linker Command Language (2p)" [19917-21402] -->
<h2 class="sectionedit22" id="bonus">BONUS</h2>
<div class="level2">

</div>

<h4 id="cpl_karma_-_ld_preload">1 cpl karma - LD_PRELOAD</h4>
<div class="level4">

<p>
Scopul acestui exercițiu este de a suprascrie o funcție de bibliotecă (similar ca la exercițiul 3).
</p>

<p>
Implementați acest lucru folosindu-vă de variabila de mediu <code>LD_PRELOAD</code>.
</p>

</div>

<h4 id="cpl_karma_-_rpath">1 cpl karma - rpath</h4>
<div class="level4">

<p>
Refaceți exercițiul 2 fără a folosi variabila de mediu <code>LD_LIBRARY_PATH</code>. 
</p>

<p>
Folosiți-vă de <a href="https://en.wikipedia.org/wiki/Rpath" class="urlextern" title="https://en.wikipedia.org/wiki/Rpath"  rel="nofollow">run-time search path</a>.
Citiți secțiunea <code>GNU ld.so</code> pentru a înțelege algoritmul aplicat de linker pentru a căuta biblioteci dinamice.
</p>

</div>
<!-- EDIT22 SECTION "BONUS" [21403-] --></div>
</body>
</html>
