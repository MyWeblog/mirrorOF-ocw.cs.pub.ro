    
    

<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
  <meta charset="utf-8" />
  <title>cpl:labs-2015:06</title>
<meta name="generator" content="DokuWiki"/>
<meta name="robots" content="index,follow"/>
<meta name="date" content="2016-10-04T07:32:54+0300"/>
<meta name="keywords" content="cpl,labs-2015,06"/>
<link rel="search" type="application/opensearchdescription+xml" href="../../../../lib/exe/opensearch.php" title="CS Open CourseWare"/>
<link rel="start" href="../../../../../courses.1.html"/>
<link rel="alternate" type="application/rss+xml" title="Recent Changes" href="../../../../feed.php"/>
<link rel="alternate" type="application/rss+xml" title="Current Namespace" href="../../../../feed.php%3Fmode=list&amp;ns=cpl:labs-2015"/>
<link rel="alternate" type="text/html" title="Plain HTML" href="06.html"/>
<link rel="canonical" href="../../../../cpl/labs-2015/06.html"/>
<link rel="stylesheet" type="text/css" href="../../../../lib/exe/css.php%3Ft=arctic&amp;tseed=1479898000.css"/>
<script type="text/javascript">/*<![CDATA[*/var NS='cpl:labs-2015';var JSINFO = {"id":"cpl:labs-2015:06","namespace":"cpl:labs-2015","isadmin":0,"isauth":0};
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="../../../../lib/exe/js.php%3Ftseed=1479898000"></script>
<script type="text/x-mathjax-config">/*<![CDATA[*/MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ["$","$"], ["\\(","\\)"] ],
        displayMath: [ ["$$","$$"], ["\\[","\\]"] ],
        processEscapes: true
    }
});
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
<script type="text/javascript">/*<![CDATA[*/
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
		  
/*!]]>*/</script>
<script type="text/javascript">/*<![CDATA[*/
var pageTracker = _gat._getTracker("UA-38383934-1");
pageTracker._initData();
pageTracker._trackPageview();
		  
/*!]]>*/</script>
</head>
<body>
<div class="dokuwiki export">
<!-- TOC START -->
<div id="dw__toc">
<h3 class="toggle">Table of Contents</h3>
<div>

<ul class="toc">
<li class="level1"><div class="li"><a href="06.html#reprezentarea_datelor">06. Reprezentarea datelor</a></div>
<ul class="toc">
<li class="level2"><div class="li"><a href="06.html#tipuri_de_sectiuni">Tipuri de secțiuni</a></div></li>
<li class="level2"><div class="li"><a href="06.html#tipuri_de_date">Tipuri de date</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="06.html#integer">integer</a></div></li>
<li class="level3"><div class="li"><a href="06.html#char">char</a></div></li>
<li class="level3"><div class="li"><a href="06.html#float">float</a></div></li>
<li class="level3"><div class="li"><a href="06.html#enum">enum</a></div></li>
<li class="level3"><div class="li"><a href="06.html#array">array</a></div></li>
<li class="level3"><div class="li"><a href="06.html#struct">struct</a></div></li>
<li class="level3"><div class="li"><a href="06.html#pointer">pointer</a></div></li>
<li class="level3"><div class="li"><a href="06.html#string">string</a></div></li>
<li class="level3"><div class="li"><a href="06.html#set">set</a></div></li>
<li class="level3"><div class="li"><a href="06.html#union">union</a></div></li>
<li class="level3"><div class="li"><a href="06.html#bitfield">bitfield</a></div></li>
<li class="level3"><div class="li"><a href="06.html#class">class</a></div></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><div class="li"><a href="06.html#inferenta_de_tipuri">Inferența de tipuri</a></div>
<ul class="toc">
<li class="level2"><div class="li"><a href="06.html#conversiile_de_tipuri">Conversiile de tipuri</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="06.html#conversii_numerice_explicite">conversii numerice explicite</a></div>
<ul class="toc">
<li class="level4"><div class="li"><a href="06.html#conversii_numerice_implicite">conversii numerice implicite</a></div></li>
</ul>
</li>
<li class="level3"><div class="li"><a href="06.html#conversii_de_pointeri_explicite">conversii de pointeri explicite</a></div></li>
<li class="level3"><div class="li"><a href="06.html#conversii_de_pointeri_implicite">conversii de pointeri implicite</a></div></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><div class="li"><a href="06.html#apelul_de_functii">Apelul de funcţii</a></div>
<ul class="toc">
<li class="level2"><div class="li"><a href="06.html#transmiterea_parametrilor">Transmiterea parametrilor</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="06.html#apelul_prin_valoare">Apelul prin valoare</a></div></li>
<li class="level3"><div class="li"><a href="06.html#apelul_prin_rezultat">Apelul prin rezultat</a></div></li>
<li class="level3"><div class="li"><a href="06.html#apelul_prin_valoare-rezultat">Apelul prin valoare-rezultat</a></div></li>
<li class="level3"><div class="li"><a href="06.html#apelul_prin_referinta">Apelul prin referinta</a></div></li>
<li class="level3"><div class="li"><a href="06.html#apelul_prin_nume">Apelul prin nume</a></div></li>
</ul>
</li>
<li class="level2"><div class="li"><a href="06.html#conventii_de_apel">Convenții de apel</a></div></li>
<li class="level2"><div class="li"><a href="06.html#prototipuri_de_functii">Prototipuri de funcții</a></div></li>
<li class="level2"><div class="li"><a href="06.html#cadre_de_stiva_stack_frames">Cadre de stiva (stack frames)</a></div></li>
</ul>
</li>
<li class="level1"><div class="li"><a href="06.html#exercitii">Exerciții</a></div></li>
</ul>
</div>
</div>
<!-- TOC END -->

<h1 class="sectionedit1" id="reprezentarea_datelor">06. Reprezentarea datelor</h1>
<div class="level1">

<p>
În urma compilării și linkării unui program rezultă un fişier binar care, indiferent de formatul lui, este reprezentarea programului în memoria procesorului pentru care a fost compilat. Aceasta reprezentare conține în mod uzual mai multe secțiuni implicite, secțiuni care în funcție de format au diverse denumiri, dar scopul lor este asemănător.
</p>

</div>
<!-- EDIT1 SECTION "06. Reprezentarea datelor" [1-403] -->
<h2 class="sectionedit2" id="tipuri_de_sectiuni">Tipuri de secțiuni</h2>
<div class="level2">
<ul>
<li class="level1"><div class="li"> <code>secțiunea de cod</code> (<code>.code</code> sau <code>.text</code>) este secțiunea în care se păstrează, codificate binar, instrucțiunile pe care le va executa procesorul.</div>
</li>
<li class="level1"><div class="li"> <code>secțiunea de date</code> (<code>.data</code>) este secțiunea în care se aloca variabilele globale.</div>
</li>
<li class="level1"><div class="li"> <code>secțiunea de constante</code> (<code>.const</code> sau <code>.rodata</code>) este secțiunea în care se păstrează datele constante dintr-un program.</div>
</li>
<li class="level1"><div class="li"> <code>secțiunea de heap</code> (<code>.heap</code>) este secțiunea în care programatorul poate aloca dinamic memorie cu apeluri de tipul malloc sau new.</div>
</li>
<li class="level1"><div class="li"> <code>secțiunea de stiva</code> (<code>.stack</code>) este secțiunea folosita pentru pastrarea contextului specific fiecărei funcții (parametrii funcției, variabilele locale și alte date care nu sunt neapărat vizibile la nivelul programatorului).</div>
</li>
</ul>

<p>
Dimensiunea secțiunilor, poziționarea lor în memorie, precum și alte aspecte legate de modalitățile de accesare a lor sunt specifice fiecărei arhitecturi. Din motive de securitate, unele procesoare pot restricţiona accesul la scriere in sectiunea de constante, sau pot permite executia doar din secţiunea de cod.
</p>

<p>
Din punct de vedere a reprezentării datelor, aceste secțiuni găzduiesc diferite tipuri de date din punct de vedere a vizibilității lor în program:
</p>
<ul>
<li class="level1"><div class="li"> variabilele globale se vor regăsi în secțiunea de date</div>
</li>
<li class="level1"><div class="li"> constantele se vor regăsi în secțiunea de constante. Majoritatea compilatoarelor încadrează la aceasta secțiune și şirurile de caractere explicite.</div>
</li>
<li class="level1"><div class="li"> variabilele locale se vor regăsi fie într-un registru, fie pe stiva în contextul specific funcției de care aparțin. </div>
</li>
</ul>

<p>
În figura de mai jos este o <code>posibilă</code> distribuție a acestor secțiuni în memorie:
</p>
<pre class="code">.stack
 ...
.heap
.data
.const
.code</pre>

<p>
În afară de aceste secţiuni implicite, programatorul poate defini secţiuni noi, eventual plasate în zone de memorie specificate explicit.
</p>

</div>
<!-- EDIT2 SECTION "Tipuri de secțiuni" [404-2317] -->
<h2 class="sectionedit3" id="tipuri_de_date">Tipuri de date</h2>
<div class="level2">

<p>
Pentru a translata un program scris într-un limbaj de nivel înalt trebuie să oferim mecanisme de reprezentare a structurilor de date ale limbajului, care sunt în general mult mai complexe decât cele suportate nativ de procesorul pentru care se face translatarea. 
</p>

<p>
În continuare vom prezenta pe scurt câteva reprezentări posibile pentru cele mai folosite tipuri de date:
</p>

</div>
<!-- EDIT3 SECTION "Tipuri de date" [2318-2725] -->
<h3 class="sectionedit4" id="integer">integer</h3>
<div class="level3">

<p>
Ne aşteptăm în general ca arhitectura să ofere un suport substanțial pentru lucrul cu numere întregi. Operațiile pe întregi mai lungi sunt implementate prin mai multe load-uri, store-uri și operații de tip addc (add with carry), subb (substract with borrow). Operațiile pe numere întregi mai scurte (byte, short) sunt implementate prin load-uri urmate de operații de extindere a semnului.
</p>

</div>
<!-- EDIT4 SECTION "integer" [2726-3147] -->
<h3 class="sectionedit5" id="char">char</h3>
<div class="level3">

<p>
În general, caracterele se reprezintă pe un octet, de exemplu codificarea <abbr title="American Standard Code for Information Interchange">ASCII</abbr>. În C, tipul de date <code>char</code> nu este nici cu semn, nici fără semn (conform standardului). În situația în care programatorul folosește acest tip de date pentru a reprezenta numere pe 8 biți, atunci el va trebui să precizeze explicit dacă tipul de date este <code>signed</code> sau <code>unsigned</code>. Mai nou compilatoarele oferă suport și pentru caractere pe 2 octeți (de ex. Unicode) - aceste reprezentări cuprind și alte stiluri de scriere în afară de cel latin (Katakana, Hiragana, Chinese etc.). Codificările multibyte (de exemplu UTF-8: 8-bit Unicode) permit reprezentarea a mai mult de 256 de caractere păstrând compatibilitatea cu codificarea <abbr title="American Standard Code for Information Interchange">ASCII</abbr>.
</p>

</div>
<!-- EDIT5 SECTION "char" [3148-3909] -->
<h3 class="sectionedit6" id="float">float</h3>
<div class="level3">

<p>
Tipurile floating point au în general două sau trei formate - single, double și (ceva mai puțin frecvent) extended și ocupă până la 80 biți. Hardware-ul suporta tipul float în simplă precizie și de multe ori și dublă precizie. O excepție notabila este arhitectura Intel386 care nu suporta decât tipul extins pe 80 biți.
</p>

<p>
Pentru majoritatea arhitecturilor, e nevoie de suport software pentru operațiile în virgulă mobilă, de exemplu pentru tratarea cazurilor de overflow, underflow sau operaţii invalide. În unele cazuri - de exemplu pentru majoritatea microcontroller-urilor sau DSP-urilor - operațiile în virgula mobila sunt emulate în întregime de software, fiind implementate ca apeluri de funcții de bibliotecă.
</p>

</div>
<!-- EDIT6 SECTION "float" [3910-4672] -->
<h3 class="sectionedit7" id="enum">enum</h3>
<div class="level3">

<p>
Valorile din enum-uri sunt, în general, reprezentate ca numere întregi naturale consecutive, fără semn; de obicei tipul enum se mapează pe int.
</p>

</div>
<!-- EDIT7 SECTION "enum" [4673-4838] -->
<h3 class="sectionedit8" id="array">array</h3>
<div class="level3">

<p>
În general, array-urile pot avea mai mult de o dimensiune și, în funcție de limbaj, pot avea elemente doar de un tip fundamental (tip predefinit în limbaj) sau pot avea elemente de orice tip (definit de utilizator). În ambele cazuri, pot fi văzute ca blocuri n-dimensionale, cu fiecare dimensiune corespunzând unui indice. Ele sunt liniarizate fiind împărțite în &#039;felii&#039;, pe rânduri (sau în cazul Fortran-ului - pe coloane) și alocând spațiu de stocare pentru fiecare element în funcție de poziția lui în cadrul feliei. De exemplu, un vector declarat în Pascal:
</p>
<pre class="code pascal"> <span class="kw1">var</span> a<span class="sy1">:</span> <span class="kw4">array</span><span class="br0">&#91;</span><span class="nu0">1</span><span class="sy1">..</span><span class="nu0">10</span><span class="sy1">,</span> <span class="nu0">0</span><span class="sy1">..</span><span class="nu0">5</span><span class="br0">&#93;</span> <span class="kw1">of</span> <span class="kw4">integer</span><span class="sy1">;</span> </pre>

<p>
ocupă (10-1+1)*(5-0+1) = 60 de elemente.
a[1, 0] va fi elementul nr. 0
a[2, 0] va fi elementul nr. 6 etc.
În general, pentru un array Pascal:
</p>
<pre class="code pascal"> <span class="kw1">var</span> vect<span class="sy1">:</span> <span class="kw4">array</span><span class="br0">&#91;</span>lo1<span class="sy1">..</span><span class="me1">hi1</span><span class="sy1">,</span> lo2<span class="sy1">..</span><span class="me1">hi2</span><span class="sy1">,</span> <span class="sy1">...,</span> loN<span class="sy1">..</span><span class="me1">hiN</span><span class="br0">&#93;</span> <span class="kw1">of</span> <span class="kw1">type</span><span class="sy1">;</span> </pre>

<p>
adresa elementului vect[e1, e2, …., en] este:
&lt;latex&gt; base(vect) + size(type) * \sum_{i=1}^N (e_{i} - lo_{i})\prod_{j=1}^i (hi_{j}-lo_{j}+1) &lt;/latex&gt;
</p>

<p>
unde base(vect) e adresa primului element și size(type) e numărul de octeți ocupat de fiecare element. Uneori, pentru a spori eficienta, compilatorul rotunjește numărul de octeți ocupat de un element pana la o dimensiune care poate fi încărcată eficient din memorie.
</p>

</div>
<!-- EDIT8 SECTION "array" [4839-6154] -->
<h3 class="sectionedit9" id="struct">struct</h3>
<div class="level3">

<p>
Compilatoarele aleg să reprezinte aceste structuri:
</p>
<ul>
<li class="level1"><div class="li"> împachetat - cu elementele consecutive puse unul după altul în memorie, sau</div>
</li>
<li class="level1"><div class="li"> neîmpachetat - adică cu elementele aliniate</div>
</li>
</ul>

<p>
O greşeala foarte comuna este să se presupună ca elementele unui struct sunt întotdeauna poziționate unul după altul, de exemplu să recepționeze un șir de octeți dintr-un socket direct într-un struct, aşteptându-se să nu existe spații goale între membrii structurii. De observat că, deși nu se poate “prezice” cu siguranță spațiul care va fi inserat între membrii unei structuri, <a href="http://www.open-std.org/JTC1/SC22/WG14/" class="urlextern" title="http://www.open-std.org/JTC1/SC22/WG14/"  rel="nofollow"> standardul</a> C nu permite inversarea ordinii membrilor structurii și nici prezență de spații goale înainte de primul membru (vezi secțiunea 6.7.2.1 din <a href="http://www.open-std.org/JTC1/SC22/WG14/www/C99RationaleV5.10.pdf" class="urlextern" title="http://www.open-std.org/JTC1/SC22/WG14/www/C99RationaleV5.10.pdf"  rel="nofollow"> rationale</a>).
</p>

</div>
<!-- EDIT9 SECTION "struct" [6155-7046] -->
<h3 class="sectionedit10" id="pointer">pointer</h3>
<div class="level3">

<p>
Pointerii sunt nişte variabile ce conțin o adresă din memorie. Aspecte care poate nu sunt evidente pentru toată lumea:
</p>
<ul>
<li class="level1"><div class="li"> Dimensiunea unui pointer este dimensiunea unui cuvant din arhitectura pentru care s-a compilat (tipul de date <code>long</code> în C). Din punct de vedere al standardului C, nu este corect sa se presupuna ca un un pointer are aceeași dimensiune cu un număr <code>long</code>.</div>
</li>
<li class="level1"><div class="li"> “Tip *a” <strong>NU</strong> este echivalent cu “Tip a[ ]”. Majoritatea cred că a[5] este echivalent cu *(a+5) și crede că a declara o variabilă ca “pointer” este echivalent cu a o declara “array”. După cum s-a explicat mai sus - array-ul e un șir continuu de elemente de tipul “Tip”, pe când pointer-ul e o adresa la un element de tipul “Tip”. Rezultatul operatorului <code>sizeof</code> diferă.</div>
</li>
</ul>

<p>
În general translatoarele fac <code>cast</code> automat între pointer și array și de aceea diferența poate fi uneori greu de conştientizat.
Un exemplu care arata diferenta:
</p>
<pre class="code c"><span class="co1">// in f1.cpp:</span>
<span class="kw2">extern</span> <span class="kw4">int</span><span class="sy0">*</span> v<span class="sy0">;</span>
<span class="co1">// in f2.cpp:</span>
<span class="kw4">int</span> v<span class="br0">&#91;</span><span class="nu0">10</span><span class="br0">&#93;</span><span class="sy0">;</span>
&nbsp;
La compilare<span class="sy0">:</span>
Error <span class="nu0">1</span> error C2372<span class="sy0">:</span> <span class="st0">'v'</span> <span class="sy0">:</span> redefinition<span class="sy0">;</span> different types of indirection</pre>

<p>
Un exemplu și pentru reprezentarea și plasarea în memorie a array-urilor și pointerilor, inclusiv din punct de vedere al secțiunilor în care ajung aceste date este următorul:
</p>
<pre class="code c"><span class="kw4">char</span> st1<span class="br0">&#91;</span><span class="nu0">6</span><span class="br0">&#93;</span><span class="sy0">;</span>
<span class="kw4">char</span> st2<span class="br0">&#91;</span><span class="br0">&#93;</span> <span class="sy0">=</span> “ABCD”<span class="sy0">;</span>
<span class="kw4">const</span> <span class="kw4">char</span> <span class="sy0">*</span>st3 <span class="sy0">=</span> “<span class="nu0">1234</span>”<span class="sy0">;</span></pre>

<p>
<a href="../../../../_detail/cpl/labs/laborator-05-reprezentare-date.png%3Fid=cpl%253Alabs-2015%253A06.html" class="media" title="cpl:labs:laborator-05-reprezentare-date.png"><img src="../../../../_media/cpl/labs/laborator-05-reprezentare-date.png%3Fw=480&amp;tok=de0792" class="mediacenter" alt="" width="480" /></a>
</p>

<p>
În acest caz:
</p>
<ul>
<li class="level1"><div class="li"> st1 este un array neinitializat, care va fi păstrat în secțiunea de date;</div>
</li>
<li class="level1"><div class="li"> st2 este un array initializat care va fi păstrat în secțiunea de date, dar valoarea sa de initializare va fi păstrată în secțiunea de constante și va fi copiată în secvența de startup corespunzătoare execuției programului;</div>
</li>
<li class="level1"><div class="li"> st3 este un pointer către un șir de caractere, șir de caractere care va fi păstrat în secțiunea de constante.</div>
</li>
</ul>

<p>
Operatia *st = 0 este permisă atât pentru st1 cât și pentru st2, având ca rezultat modificarea primei valori din cele 2 array-uri, în schimb ce *st3 = 0 nu este permis pentru ca ar presupune modificări în secțiunea de constante (operație ilegală).
</p>

</div>
<!-- EDIT10 SECTION "pointer" [7047-9210] -->
<h3 class="sectionedit11" id="string">string</h3>
<div class="level3">

<p>
Probabil cele mai cunoscute reprezentări:
</p>
<ul>
<li class="level1"><div class="li"> cea din Pascal - pe primul octet se ține dimensiunea șirului,</div>
</li>
<li class="level1"><div class="li"> cea din C - șirul de caractere este terminat cu caracterul NULL.</div>
</li>
</ul>

</div>
<!-- EDIT11 SECTION "string" [9211-9409] -->
<h3 class="sectionedit12" id="set">set</h3>
<div class="level3">

<p>
Șiruri de biți, un bit e 1 dacă elementul este în mulțime și 0 altfel. Dacă știm că un set este rar (adică are mult mai multe elemente posibile decât elemente efective) o reprezentare mai bună e un vector sortat de elemente sau un arbore binar de căutare.
</p>

</div>
<!-- EDIT12 SECTION "set" [9410-9693] -->
<h3 class="sectionedit13" id="union">union</h3>
<div class="level3">

<p>
O uniune este similara ca declarație cu o structură cu mențiunea că toți membrii unei uniuni sunt toți poziționați de la aceeași adresă în memorie; spațiul alocat în memorie pentru o uniune corespunde cu dimensiunea celui mai mare membru. Principala utilitate a uniunilor este aceea a conservării spațiului, deoarece permite posibilitatea de a stoca mai multe tipuri în același spațiu de memorie – uniunile sunt o formă incipientă de polimorfism. Tocmai datorita faptului ca toți membrii unei uniuni coexistă în același spațiu de memorie, este aproape imposibil pentru un compilator să facă o verificare ca tipul scris într-o uniune este și tipul citit din acea uniune; Verificarea faptul ca sunt folosiți corect membrii dintr-o uniune revine în totalitate programatorului.
</p>

</div>
<!-- EDIT13 SECTION "union" [9694-10517] -->
<h3 class="sectionedit14" id="bitfield">bitfield</h3>
<div class="level3">

<p>
Un bitfield este în general păstrat într-un cuvânt maşină, iar fiecare din biți este adresat nu prin poziția sa, ci prin numele asociat acestuia (sau acestora), exact ca atunci când se accesează un membru al unei structuri. Deși din punct de vedere a limbajului de programare folosirea de bitfield-uri rezolva probleme legate de manipularea de secvențe de biți și de împachetare a datelor care ocupă mai putin decât dimensiunea unui octet (sau cuvânt), din punct de vedere al codului generat (și implicit a compilatorului), bitfield-urile pot ridica foarte multe probleme: 
* codul de acces pentru fiecare bit al bitfield-ului poate fi foarte ineficient deoarece în general arhitecturile nu permit accese de memorie pe biți, ci pe cuvinte de memorie;
* trebuie avut grijă și la suprapunerile de acces la memorie ce pot aparea în cazul execuției în paralel a acceselor la biții dintr-un bitfield. 
</p>

<p>
<strong>ATENȚIE</strong>: ordinea biților într-un bitfield nu este garantată, compilatorul putând rearanja biții – de aceea, biții trebuie întotdeauna accesați prin membrul corespunzător din structura și niciodată prin poziția sa!
</p>

</div>
<!-- EDIT14 SECTION "bitfield" [10518-11695] -->
<h3 class="sectionedit15" id="class">class</h3>
<div class="level3">

<p>
Într-un limbaj orientat obiect, reprezentarea unei clase este legată de cea a unei structuri, în care se adaugă membri suplimentari. Pentru a implementa moştenirea și polimorfismul, reprezentarea unui obiect derivat conține subobiecte corespunzătoare claselor de baza. Din acest motiv, un pointer la obiectul derivat se poate converti către un pointer la obiectul de bază, ca în exemplul următor. De remarcat că, în cazul în care există mai multe clase de bază sau interfețe implementate, obiectul de bază se poate găsi la o altă adresă decât obiectul derivat.
</p>
<pre class="code c">class B <span class="br0">&#123;</span> 
  <span class="kw4">int</span> a<span class="sy0">,</span> b<span class="sy0">;</span> 
  virtual <span class="kw4">void</span> f<span class="br0">&#40;</span><span class="kw4">void</span><span class="br0">&#41;</span><span class="sy0">;</span>
<span class="br0">&#125;</span><span class="sy0">;</span>
&nbsp;
class B1 <span class="br0">&#123;</span>
  <span class="kw4">int</span> x<span class="sy0">,</span> y<span class="sy0">;</span>
  virtual <span class="kw4">void</span> z<span class="br0">&#40;</span><span class="kw4">void</span><span class="br0">&#41;</span><span class="sy0">;</span>
<span class="br0">&#125;</span><span class="sy0">;</span>
&nbsp;
class D<span class="sy0">:</span> B<span class="sy0">,</span> B1 <span class="br0">&#123;</span> 
  <span class="kw4">int</span> c<span class="sy0">,</span> d<span class="sy0">;</span>
  <span class="kw4">void</span> f<span class="br0">&#40;</span><span class="kw4">void</span><span class="br0">&#41;</span><span class="sy0">;</span>
  <span class="kw4">void</span> z<span class="br0">&#40;</span><span class="kw4">void</span><span class="br0">&#41;</span><span class="sy0">;</span> 
<span class="br0">&#125;</span><span class="sy0">;</span>
&nbsp;
D objD<span class="sy0">;</span> B1 <span class="sy0">*</span> ptrB1<span class="sy0">;</span>
PtrB1 <span class="sy0">=</span> <span class="sy0">&amp;</span>objD<span class="sy0">;</span>
ptrB1<span class="sy0">-&gt;</span>f<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>
<a href="../../../../_detail/cpl/labs/laborator-05-reprezentare-obiecte.png%3Fid=cpl%253Alabs-2015%253A06.html" class="media" title="cpl:labs:laborator-05-reprezentare-obiecte.png"><img src="../../../../_media/cpl/labs/laborator-05-reprezentare-obiecte.png%3Fw=480&amp;tok=69ca31" class="mediacenter" alt="" width="480" /></a>
</p>

<p>
Reprezentarea unei clase poate conține un membru ascuns, un pointer către tabela funcțiilor virtuale (vtable). Există o tabelă asociată fiecărei clase, iar tabela clasei derivate are sub-tabele corespunzând claselor de bază. Un apel către o funcție virtuală implică două citiri din memorie – prima pentru a afla tabela corectă, a doua pentru a afla adresa funcției. Prin acest mecanism, pornind de la un pointer către o instanță a unei clasă de bază se poate apela o metodă a clasei derivate.
De remarcat:
</p>
<ul>
<li class="level1"><div class="li"> in C++, toate metodele sunt automat finale. Urmatorul exemplu arata o functie finala, una virtuala, si, respectiv, una pur virtuala:</div>
</li>
<li class="level1"><div class="li"> <pre class="code c">class foo
<span class="br0">&#123;</span>
<span class="kw4">int</span> bar1<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span> <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span> <span class="br0">&#125;</span><span class="sy0">;</span>
virtual <span class="kw4">int</span> bar2<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span> <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span> <span class="br0">&#125;</span><span class="sy0">;</span>
virtual <span class="kw4">int</span> bar3<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">&#125;</span></pre>
</div>
</li>
<li class="level1"><div class="li"> in Java, toate metodele sunt automat virtuale. Urmatorul exemplu arata o functie finala, una virtuala, si, respectiv, una pur virtuala:</div>
</li>
<li class="level1"><div class="li"> <pre class="code c">abstract class foo
<span class="br0">&#123;</span>
final <span class="kw4">int</span> bar1<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span> <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span> <span class="br0">&#125;</span> 
<span class="kw4">int</span> bar2<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span> <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span> <span class="br0">&#125;</span>
abstract <span class="kw4">int</span> bar3<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
<span class="br0">&#125;</span></pre>
</div>
</li>
</ul>

<p>
Vom vorbi mai mult despre generarea de cod pentru clase in laboratorul urmator.
</p>

</div>
<!-- EDIT15 SECTION "class" [11696-13720] -->
<h1 class="sectionedit16" id="inferenta_de_tipuri">Inferența de tipuri</h1>
<div class="level1">

<p>
Inferența de tipuri reprezintă posibilitatea de deducere automată, parțială sau integrală, a tipului valorii derivate dintr-o eventuală evaluare a unei expresii. Din moment ce acest proces are loc în timpul compilării, compilatorul este de obicei capabil sa „infere” tipul unei variabile sau semnătura de tip a unei funcții, fără adnotări explicite de tip. În multe cazuri este posibilă omiterea completă a adnotărilor de tipuri dintr-un program dacă sistemul de inferență de tipuri este suficient de robust, sau dacă programul sau limbajul de programare este suficient de simplu. 
De exemplu, pentru o functie simplă în C
</p>
<pre class="code c"><span class="kw4">int</span> increment<span class="br0">&#40;</span><span class="kw4">int</span> x<span class="br0">&#41;</span>
<span class="br0">&#123;</span>
    <span class="kw1">return</span> x <span class="sy0">+</span> <span class="nu0">1</span><span class="sy0">;</span>
<span class="br0">&#125;</span></pre>

<p>
Într-un limbaj fără declarația explicită a tipurilor, precum Python, sau Visual Basic, ea se poate scrie
</p>
<pre class="code python">increment<span class="br0">&#40;</span>x<span class="br0">&#41;</span>
<span class="br0">&#123;</span>
    <span class="kw1">return</span> x + <span class="nu0">1</span><span class="sy0">;</span>
<span class="br0">&#125;</span></pre>

<p>
Din faptul ca 1 este număr întreg și din faptul că adunarea este permisă doar între numere de același fel și că rezultatul adunării este tot număr de același fel cu ceilalți operanzi, se poate „infera” ca funcția de incrementare întoarce un număr întreg și, de asemenea, că primește o valoare întreagă.
</p>

<p>
Și in C# se pot defini variabile fără a specifica tipul, si acestea trebuie inițializate la definire. Exemplu:
</p>
<pre class="code c"> var lista <span class="sy0">=</span> new List<span class="sy0">&lt;</span>Int64<span class="sy0">&gt;</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span> </pre>

<p>
Pentru a obține informații corecte pentru inferența tipului unei expresii care nu are o adnotare de tip explicită, compilatorul poate fie să adune informații de tip din adnotările specifice sub-expresiilor ce formează expresia neadnotată, fie prin înțelegerea implicită a valorilor diferiților atomi ce formează expresia. 
</p>

<p>
De cele mai multe ori compilatoarele care fac inferență de tipuri folosesc o combinație complexă a acestor două metode.
</p>

<p>
Este posibil să existe cazuri care nu pot fi complet rezolvate de inferența de tipuri, de exemplu în cazul polimorfismului. Oricât de performantă ar fi inferența de tipuri, de multe ori, pentru dezambiguizări (atât pentru programator cât și pentru compilator), este bine să se folosească adnotări de tipuri.
</p>

<p>
Deşi inferența de tipuri este foarte des întâlnită în limbajele funcționale, exista și limbaje de programare clasice care prezintă anumite forme de inferență de tipuri. În cele ce urmează se vor face referiri la forme de inferență în limbajul C.
</p>

<p>
În limbajul C, inferența de tipuri este necesară în momentul în care într-o expresie, operanzii au tipuri diferite, iar operațiile asociate expresiei sunt valide pentru mai multe din tipurile implicate în expresie. În astfel de cazuri, se aplică intern conversii între tipurile operanzilor la alte tipuri care să permită corectitudinea operațiilor, pe operanzi omogeni (din punct de vedere al tipurilor). Astfel de conversii se numesc conversii implicite, iar omogenitatea tipurilor operanzilor este dictată de standardele limbajului de programare (de exemplu pentru C, standardul ANSI).
</p>

<p>
Un caz foarte interesant de inferență de tip este cel din COOL, și în limbajele funcționale, în care o expresie returnează mereu o valoare, chiar și in cazul instrucțiunilor de bază – if, while, case. În mod evident, o astfel de expresie, cu mai multe ramuri, va returna tipul de date din care sunt derivate toate tipurile rezultatelor ramurilor. În COOL, de exemplu, a fost introdus SELF_TYPE, care este mereu evaluat la tipul clasei în care se află. Dacă o metodă virtuală a clasei de bază întoarce SELF_TYPE, ea va intoarce:
* când este apelată printr-o instanță a clasei de bază → tipul clasei de bază
* când este apelată printr-o instanță a unei clase derivate → tipul clasei derivate.
</p>

</div>
<!-- EDIT16 SECTION "Inferența de tipuri" [13721-17508] -->
<h2 class="sectionedit17" id="conversiile_de_tipuri">Conversiile de tipuri</h2>
<div class="level2">

<p>
Conversiile de tipuri se pot clasifica după mai multe criterii; cele mai reprezentative sunt:
* implicit sau explicit
* numerice sau de pointeri
</p>

<p>
Din combinația celor 2 criterii se pot obține 4 categorii de conversii destul de uzuale:
</p>

</div>
<!-- EDIT17 SECTION "Conversiile de tipuri" [17509-17780] -->
<h3 class="sectionedit18" id="conversii_numerice_explicite">conversii numerice explicite</h3>
<div class="level3">
<pre class="code c"> <span class="kw4">int</span> x <span class="sy0">=</span> <span class="br0">&#40;</span><span class="kw4">int</span><span class="br0">&#41;</span> <span class="nu16">3.3</span><span class="sy0">;</span> </pre>

<p>
O astfel de conversie, presupune extragerea părții întregi a unui număr în virgulă mobilă; deși din punct de vedere al programatorului o astfel de operațiune pare trivială, din punct de vedere al compilatorului nu este atât de simplu și presupune calcule destul de complexe (în funcție și de suportul de virgulă mobilă specific arhitecturii pentru care se compilează); de foarte multe ori, astfel de conversii presupun apeluri de funcții de bibliotecă care emulează funcționarea procesorului în virgulă mobilă. 
</p>

</div>

<h4 id="conversii_numerice_implicite">conversii numerice implicite</h4>
<div class="level4">

<p>
Aceste conversii presupun promovări ale anumitor operanzi dintr-o expresie la tipuri superioare (mai cuprinzătoare) tipului lor, acest lucru permițând efectuarea de operații pe tipuri care la prima vedere sunt neomogene ordinea promovării tipurilor numerice este următoarea:
</p>
<pre class="code">                      char -&gt; unsigned char -&gt;
                      short int -&gt; unsigned short int -&gt;
                      int -&gt; unsigned int -&gt;
                      long -&gt; unsigned long -&gt;
                      long long -&gt; unsigned long long -&gt;
                      float -&gt; double -&gt; long double</pre>

<p>
<strong>NOTĂ</strong> Operațiile în virgulă mobilă se fac întotdeauna la precizie maximă (double sau long double, în funcție de arhitectură), iar rezultatul este apoi convertit la tipul și precizia corespunzatoare
</p>
<pre class="code c"><span class="kw4">int</span> a <span class="sy0">=</span> <span class="nu0">7</span><span class="sy0">,</span> b <span class="sy0">=</span> <span class="nu0">2</span><span class="sy0">;</span>
<span class="kw4">double</span> x<span class="sy0">;</span>
x <span class="sy0">=</span> a <span class="sy0">*</span> <span class="nu0">1</span>. <span class="sy0">/</span> b<span class="sy0">;</span>
x <span class="sy0">=</span> a <span class="sy0">/</span> b <span class="sy0">*</span> <span class="nu0">1</span>.<span class="sy0">;</span>
x <span class="sy0">=</span> <span class="nu0">1</span>. <span class="sy0">*</span> a <span class="sy0">+</span> a <span class="sy0">/</span> b<span class="sy0">;</span></pre>

<p>
O prima expresie: „a * 1. / b”. Toate operațiile se fac pe double, datorita promovării treptate a fiecărui operand.
</p>
<ul>
<li class="level1"><div class="li"> „a * 1.” înmulțire între întreg și float – fiind operație floating point se va face cu dublă precizie –</div>
</li>
<li class="level1"><div class="li"> a va fi promovat la double, la fel ca și constanta „1.”</div>
</li>
<li class="level1"><div class="li"> rezultatul double al expresiei anterioare se va impărți la valoarea întreagă b, care va fi convertită și ea la double. </div>
</li>
<li class="level1"><div class="li"> rezultatul obținut este un double – variabila căreia îi este atribuit rezultatul este tot double, deci nu mai este nevoie și de alta conversie – dacă variabila era de alt tip, o alta conversie ar fi fost necesară.</div>
</li>
</ul>

<p>
a doua expresie este „a / b * 1.”
</p>
<ul>
<li class="level1"><div class="li"> „a / b” este o operație între numere întregi. rezultatul împărțirii va fi un număr întreg (adica 3).</div>
</li>
<li class="level1"><div class="li"> întregul obținut la operația anterioară se va inmulți cu „1.”, rezultând o înmulțire de numere double, precedată de conversia lui 3 în virgulă mobilă.</div>
</li>
</ul>

<p>
a treia expresie este „1. * a + a / b”
</p>
<ul>
<li class="level1"><div class="li"> „1. * a” este o operație în virgulă mobilă datorita precedentei operatorilor, </div>
</li>
<li class="level1"><div class="li"> „a / b” este o impărțire de întregi, cu rezultat întreg</div>
</li>
<li class="level1"><div class="li"> cea de-a treia operație este +, efectuata pe numere în virgulă mobilă (precedată de conversiile implicite de rigoare)</div>
</li>
</ul>

</div>
<!-- EDIT18 SECTION "conversii numerice explicite" [17781-20667] -->
<h3 class="sectionedit19" id="conversii_de_pointeri_explicite">conversii de pointeri explicite</h3>
<div class="level3">

<p>
Conversiile explicite de pointeri, spre deosebire de conversiile numerice, nu produc schimbări în date, ci doar în modalitatea de folosire a adresei la care se referă pointerul
</p>
<pre class="code c"><span class="kw4">int</span> x <span class="sy0">=</span> <span class="nu0">12345</span><span class="sy0">;</span>
<span class="kw4">float</span> <span class="sy0">*</span>p<span class="sy0">;</span>
p <span class="sy0">=</span> <span class="br0">&#40;</span><span class="kw4">float</span> <span class="sy0">*</span><span class="br0">&#41;</span> <span class="sy0">&amp;</span>x<span class="sy0">;</span></pre>

<p>
În acest caz, *p va fi o valoare în virgulă mobilă care are ca reprezentare binară valoarea din x.
</p>

</div>
<!-- EDIT19 SECTION "conversii de pointeri explicite" [20668-21055] -->
<h3 class="sectionedit20" id="conversii_de_pointeri_implicite">conversii de pointeri implicite</h3>
<div class="level3">

<p>
Conversiile implicite de pointeri se fac doar către pointeri de tip void * - orice altă conversie de pointeri, atât între diferite tipuri de pointeri, cât și de la tipul void * la orice alt tip, trebuie făcute explicit:
</p>
<pre class="code c"><span class="kw4">void</span> <span class="sy0">*</span>p<span class="sy0">;</span>
<span class="kw4">int</span> x<span class="sy0">;</span>
<span class="kw4">int</span> <span class="sy0">*</span>q<span class="sy0">;</span>
p <span class="sy0">=</span> <span class="sy0">&amp;</span>x<span class="sy0">;</span>
q <span class="sy0">=</span> <span class="br0">&#40;</span><span class="kw4">int</span> <span class="sy0">*</span><span class="br0">&#41;</span> p<span class="sy0">;</span></pre>

</div>
<!-- EDIT20 SECTION "conversii de pointeri implicite" [21056-21390] -->
<h1 class="sectionedit21" id="apelul_de_functii">Apelul de funcţii</h1>
<div class="level1">

</div>
<!-- EDIT21 SECTION "Apelul de funcţii" [21391-21423] -->
<h2 class="sectionedit22" id="transmiterea_parametrilor">Transmiterea parametrilor</h2>
<div class="level2">

<p>
În limbajele de nivel înalt, exista câteva modalități de transmitere a parametrilor și de întoarcere a rezultatelor, dintre care amintim: 
<strong>NOTĂ</strong> - Folosim termenul de argument sau argument actual pentru a ne referi la valoarea sau variabila care se pasează unei rutine și termenul de parametru sau parametru formal pentru a referi variabila căreia îi este asociată în rutina apelată
</p>
<ul>
<li class="level1"><div class="li"> apelul prin valoare</div>
</li>
<li class="level1"><div class="li"> apelul prin rezultat</div>
</li>
<li class="level1"><div class="li"> apelul prin valoare-rezultat</div>
</li>
<li class="level1"><div class="li"> apelul prin referinta </div>
</li>
<li class="level1"><div class="li"> apelul prin nume.</div>
</li>
</ul>

</div>
<!-- EDIT22 SECTION "Transmiterea parametrilor" [21424-21993] -->
<h3 class="sectionedit23" id="apelul_prin_valoare">Apelul prin valoare</h3>
<div class="level3">

<p>
Trimite un argument punând la dispoziția procedurii apelate valoarea lui care se asociază parametrului formal corespunzător. În timpul execuției procedurii apelate, nu există nici o interacțiune cu variabilele apelantului. Excepția apare desigur în cazul în care argumentul este un pointer și procedura apelata ar putea folosi valoarea pointerului pentru a modifica valorile către care indică. Apelul prin valoare se implementează de obicei prin copierea valorii fiecărui argument în parametrul corespunzător la intrarea în procedura apelată. Aceasta modalitate poate fi foarte eficientă în cazul argumentelor care pot fi ținute în regiștri, dar foarte ineficientă pentru vectori deoarece presupune schimb de date intens cu memoria.
</p>

<p>
Un exemplu de limbaj în care se folosește apelul prin valoare este C, în care de fapt, acesta este singurul mecanism de pasare a parametrilor. Dar un parametru poate fi și adresa unui obiect și se obține efectul apelului prin referință.
În limbaje precum Java, argumentele de tipuri primare sunt trimise astfel. De asemenea, pe obiecte de tip Integer, Float, etc, se realizează unboxing înainte de trimitere, deci efectul va fi același.
</p>

</div>
<!-- EDIT23 SECTION "Apelul prin valoare" [21994-23233] -->
<h3 class="sectionedit24" id="apelul_prin_rezultat">Apelul prin rezultat</h3>
<div class="level3">

<p>
Este similar celui prin valoare, cu deosebirea că aici se întorc valorile de la apelat la apelant. La intrarea în procedura apelată nu se întamplă nimic, iar la întoarcere valoarea unui parametru apelat prin rezultat este pusă la dispoziția apelantului prin copierea valorii lui în argumentul asociat. Acest tip de apel apare în cazul parametrilor de tip out din Ada.
Exemplu in C#:
</p>
<pre class="code c""><span class="kw4">void</span> a<span class="br0">&#40;</span>out <span class="kw4">int</span> result<span class="br0">&#41;</span>
<span class="br0">&#123;</span> result <span class="sy0">=</span> <span class="nu0">7</span><span class="sy0">;</span> <span class="coMULTI">/* daca lipseste atribuirea in result, da eroare de compilare */</span> <span class="br0">&#125;</span> 
<span class="br0">&#91;</span>...<span class="br0">&#93;</span>
<span class="co1">// exemplu de folosire:</span>
<span class="kw4">int</span> rez<span class="sy0">;</span>
a<span class="br0">&#40;</span>out rez<span class="br0">&#41;</span><span class="sy0">;</span> <span class="co1">// acum rez a primit valoarea din a.</span></pre>

</div>
<!-- EDIT24 SECTION "Apelul prin rezultat" [23234-23870] -->
<h3 class="sectionedit25" id="apelul_prin_valoare-rezultat">Apelul prin valoare-rezultat</h3>
<div class="level3">

<p>
Este caracterizat de reuniunea proprietăților celor două tipuri de apel: prin valoare și prin rezultat. La intrarea în procedura apelată valoarea argumentului se copiază în parametru, iar la ieșire valoarea parametrului se copiază înapoi în argument. Este implementat în Ada pentru parametri de tip inout.
</p>

</div>
<!-- EDIT25 SECTION "Apelul prin valoare-rezultat" [23871-24229] -->
<h3 class="sectionedit26" id="apelul_prin_referinta">Apelul prin referinta</h3>
<div class="level3">

<p>
Realizează o asociere între argumentul actual și parametrul corespunzator. La intrarea în procedura apelată se determină adresa argumentului și aceasta se pune la dispoziția procedurii ca mijloc de accesare a argumentului. Procedura apelată va avea acces total la argument pe toată perioada execuției sale, putând să schimbe parametrul actual și să îl transmită altor rutine pe care le apelează. Acest mecanism este foarte eficient când vectori sunt tramsmiși ca parametri, dar poate fi ineficient în cazul parametrilor de mărime mică care ar putea fi transmiși prin regiștri. Pot apărea probleme în cazul în care o constantă este transmisă prin acest mecanism.
</p>

<p>
Dacă compilatorul implementează o constantă ca pe o locație partajată de memorie în care se stochează valoarea constantei și care se accesează la fiecare folosire a constantei într-o procedură și dacă constanta se transmite altei proceduri prin referință, procedura apelata ar putea modifica conținutul locației alterând astfel valoarea constantei, necesară continuării execuției procedurii apelante după revenirea din cealaltă procedură. Soluția uzuală este copierea constantelor în noi locații de memorie și transmiterea acestor adrese când se face apelul prin referință. Aceasta modalitate de apel prin referința este implementată în Fortran, dar după cum am spus, acest efect se poate realiza și în C și C++ prin transmiterea adresei ca valoare.
</p>

<p>
<p><div class="noteclassic">
În Java, parametrii sunt transmiși prin valoare (la fel ca și în C). Acest lucru este valabil atât pentru primitive cât și pentru obiecte.
</p>

<p>
Afirmația <strong>obiectele se transmit prin referință</strong> este greșită. Obiectele sunt transmise tot prin valoare, însă acestea reprezintă o referință către zona de memorie în care sunt stocate datele. Corect este <strong>referința obiectelor este transmisă prin valoare</strong>.

</div></p>
</p>

</div>
<!-- EDIT26 SECTION "Apelul prin referinta" [24230-26181] -->
<h3 class="sectionedit27" id="apelul_prin_nume">Apelul prin nume</h3>
<div class="level3">

<p>
Este cel mai complex mecanism de pasare a argumentelor, atât din punct de vedere conceptual, cât și în ceea ce privește implementarea și îl amintim doar din motive istorice deoarece ALGOL 60 este singurul limbaj care oferă acest tip de mecanism. Se poate spune că este similar cu apelul prin referință deoarece permite accesul procedurii apelate la argumentul transmis. Diferența vine din faptul că adresa argumentului este calculată la fiecare acces la acesta și nu doar o singură dată la intrarea în procedură. Astfel, dacă argumentul este a[i], și valoarea lui i se schimbă între două folosiri ale argumentului, la cele două folosiri se vor accesa de fapt două elemente diferite ale vectorului.
</p>
<pre class="code pascal"><span class="kw1">begin</span>
  <span class="kw4">integer</span> <span class="kw4">array</span> a<span class="br0">&#91;</span><span class="nu0">1</span><span class="sy1">..</span><span class="nu0">2</span><span class="br0">&#93;</span><span class="sy1">;</span> <span class="kw4">integer</span> i<span class="sy1">;</span>
&nbsp;
  <span class="kw1">procedure</span> f<span class="br0">&#40;</span>x<span class="sy1">,</span> j<span class="br0">&#41;</span><span class="sy1">;</span>
    <span class="kw4">integer</span> x<span class="sy1">,</span> j<span class="sy1">;</span>
    <span class="kw1">begin</span>
      <span class="kw4">integer</span> k<span class="sy1">;</span>
      k <span class="sy1">:</span><span class="sy3">=</span> x<span class="sy1">;</span>
      j <span class="sy1">:</span><span class="sy3">=</span> j<span class="sy3">+</span><span class="nu0">1</span><span class="sy1">;</span>
      x <span class="sy1">:</span><span class="sy3">=</span> j<span class="sy1">;</span>
      f <span class="sy1">:</span><span class="sy3">=</span> k<span class="sy1">;</span>
    <span class="kw1">end</span><span class="sy1">;</span>
&nbsp;
  i <span class="sy1">:</span><span class="sy3">=</span> <span class="nu0">1</span><span class="sy1">;</span>
  a<span class="br0">&#91;</span><span class="nu0">1</span><span class="br0">&#93;</span> <span class="sy1">:</span><span class="sy3">=</span> <span class="nu0">5</span><span class="sy1">;</span>
  a<span class="br0">&#91;</span><span class="nu0">2</span><span class="br0">&#93;</span> <span class="sy1">:</span><span class="sy3">=</span> <span class="nu0">8</span><span class="sy1">;</span>	
  outinteger<span class="br0">&#40;</span>a<span class="br0">&#91;</span><span class="nu0">1</span><span class="br0">&#93;</span><span class="sy1">,</span> f<span class="br0">&#40;</span>a<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="sy1">,</span>i<span class="br0">&#41;</span><span class="sy1">,</span> a<span class="br0">&#91;</span><span class="nu0">2</span><span class="br0">&#93;</span><span class="br0">&#41;</span><span class="sy1">;</span>
<span class="kw1">end</span></pre>

<p>
În exemplul de mai sus în care i și a[i] sunt transmiși de către programul principal procedurii f, prima folosire a parametrului x aduce valoarea lui a[1], pe cand cea de-a doua folosire seteaza valoarea a[2]. Apelul outinteger() va avea ca rezultat afișarea valorilor „5 5 2”. Dacă s-ar fi folosit apelul prin referința, atunci s-ar fi afișat „5 5 8”.
</p>

</div>
<!-- EDIT27 SECTION "Apelul prin nume" [26182-27581] -->
<h2 class="sectionedit28" id="conventii_de_apel">Convenții de apel</h2>
<div class="level2">

<p>
Apelarea unei proceduri dintr-o altă procedură presupune existența unui &#039;protocol&#039; prin care se trece controlul de la apelant la apelat, prin care parametrii sunt pasați în aceeași direcție iar valoarea rezultatului este pasata de la apelat la apelant. În cazul unui model simplu de runtime, execuția unei proceduri constă în cinci faze, fiecare dintre acestea având mai multe subfaze:
</p>
<ul>
<li class="level1"><div class="li"> Asamblarea argumentelor ce trebuie transferate procedurii și pasarea controlului.</div>
<ul>
<li class="level2"><div class="li"> Fiecare argument este evaluat și pus în registrul sau locația de pe stivă corespunzatoare; evaluare poate înseamna calcularea adresei lui (pentru cei pasați prin referință), valoarea lui (pentru cei pasați prin valoare), etc.</div>
</li>
<li class="level2"><div class="li"> Se stabilește adresa codului procedurii (pentru cele mai multe limbaje însă, a fost stabilită la compilare sau linkare)</div>
</li>
<li class="level2"><div class="li"> Regiștrii care au fost folosiți și vor mai fi și după întoarcerea din procedura apelată, se stochează în memorie dacă protocolul specifică că este datoria apelantului sa facă acest lucru</div>
</li>
<li class="level2"><div class="li"> Se salvează adresa de întoarcere și se execută un salt la adresa codului procedurii (de obicei o instrucțiune <code>call</code> face aceste lucruri)</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Prologul procedurii, executat la întrarea în procedură, stabilește mediul necesar adresării și poate salva regiștrii folosiți de procedură în scopuri proprii</div>
</li>
<li class="level1"><div class="li"> Se executa procedura, care la rândul ei poate apela alte proceduri</div>
</li>
<li class="level1"><div class="li"> Epilogul procedurii restaurează valorile regiștrilor și mediul de adresare al apelantului, asamblează valoarea pe care trebuie să o întoarcă și îi redă controlul apelantului</div>
<ul>
<li class="level2"><div class="li"> Regiștrii salvați de procedura apelată sunt restaurați din memorie</div>
</li>
<li class="level2"><div class="li"> Valoarea care trebuie întoarsă se pune în locul corespunzator (dacă procedura întoarce o valoare)</div>
</li>
<li class="level2"><div class="li"> Se incarcă adresa de revenire și se executa un salt la această adresă (de obicei, o instrucțiune <code>ret</code> face acest lucru)</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Codul din procedura apelantă care se afla după apel își termină restaurarea mediului sau de execuție și primește valoarea intoarsă</div>
<ul>
<li class="level2"><div class="li"> Regiștrii salvați de către procedura apelantă sunt restaurați din memorie</div>
</li>
<li class="level2"><div class="li"> Se folosește valoarea întoarsă de procedura apelată.</div>
</li>
</ul>
</li>
</ul>

</div>
<!-- EDIT28 SECTION "Convenții de apel" [27582-29870] -->
<h2 class="sectionedit29" id="prototipuri_de_functii">Prototipuri de funcții</h2>
<div class="level2">

<p>
Un prototip de funcție reprezintă o declarare a funcției care omite corpul funcției, dar specifică numele, tipul parametrilor și tipul întors. În timp ce definiția unei funcții specifică ce face o funcție, prototipul funcției poate fi descris ca fiind interfața funcției. Acest lucru este pus în evidență în IDE-urile care au opțiuni diferite “Go to declaration” și “Go to definition”.
</p>

<p>
Prototipurile sunt foarte importante, pentru că ele sunt folosite de compilator pentru a determina caracteristicile unei funcții ce urmează a fi apelata pentru a i se putea transmite parametrii sau a se putea primi valoarea întoarsă de funcție. De asemenea, prototipul funcției este folosit și în funcția apelată pentru primirea parametrilor de la funcția apelantă, precum și pentru transmiterea valorii întoarse de funcție.
</p>

<p>
Dacă prototipul funcției vizibil în locul sau locurile în care funcția este apelata diferă de prototipul functiei din locul în care funcția este definita, atunci se pot ajunge la apeluri de funcție eronate, datorate incompatibilității între numărul și tipul parametrilor din locul apelării funcției și din funcția propriu-zisă.
</p>

<p>
Din punct de vedere al compilatorului, dacă o funcție nu este declarată, ea va avea automat atribuit prototipul implicit al funcțiilor:
</p>
<pre class="code c"><span class="co1">// pentru apeluri de tipul</span>
func<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span> x <span class="sy0">=</span> func<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
<span class="co1">// semnătura implicită este</span>
<span class="kw4">int</span> func<span class="br0">&#40;</span><span class="kw4">void</span><span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>
Pentru funcții care sunt apelate cu argumente semnătura implicită este 
</p>
<pre class="code c">func<span class="br0">&#40;</span>x<span class="sy0">,</span> y<span class="sy0">,</span> z<span class="br0">&#41;</span><span class="sy0">;</span>
<span class="co1">//</span>
<span class="kw4">int</span> func<span class="br0">&#40;</span>typeof_x<span class="sy0">,</span> typeof_y<span class="sy0">,</span> typeof_z<span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>
<strong>ATENȚIE</strong>: dacă tipurile argumentelor sunt mai mici decât un <code>int</code>, compilatorul de C va face upcast parametrului la int și apoi va chema funcția. Dacă implementarea funcției se aștepta să îi fi fost trimiși mai puțini bytes se poate corupe memoria. Exemplu:
</p>
<pre class="code c"><span class="kw4">char</span> c <span class="sy0">=</span> <span class="st0">'a'</span><span class="sy0">;</span>
<span class="kw4">short</span> s <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span>
f<span class="br0">&#40;</span>c<span class="sy0">,</span> s<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
<span class="co1">// semnătură implicită generată: </span>
<span class="kw4">int</span> f<span class="br0">&#40;</span><span class="kw4">int</span><span class="sy0">,</span> <span class="kw4">int</span><span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>
Presupunând că parametrii sunt trimiși pe o stivă adresabilă la nivel de octet și că <code>sizeof(char) = 1</code>, <code>sizeof(short) = 2</code> și <code>sizeof(int) = 4</code> avem următoarea diferență între ce așteptă funcția <code>f</code> să primească ca parametri și ce argumente au fost pasate pe stivă.
</p>
<div class="table sectionedit30"><table class="inline">
	<tr class="row0">
		<td class="col0"> parametri trimiși la apel </td><td class="col1"> c0 </td><td class="col2"> c1 </td><td class="col3"> c2 </td><td class="col4"> c3 </td><td class="col5"> s0 </td><td class="col6"> s1 </td><td class="col7"> s2 </td><td class="col8"> s3 </td>
	</tr>
	<tr class="row1">
		<td class="col0"> parametri așteptați de implementare </td><td class="col1"> c1 </td><td class="col2"> s0 </td><td class="col3"> s1 </td><td class="col4"></td><td class="col5"></td><td class="col6"></td><td class="col7"></td><td class="col8"></td>
	</tr>
</table></div>
<!-- EDIT30 TABLE [32195-32322] -->
<p>
în general compilatoarele fac verificări de compatibilitate între prototipurile unei aceleiași funcții, dar există cazuri cand aceste verificări nu sunt posibile (de exemplu când se folosesc funcții din biblioteci).
</p>

<p>
Un exemplu de functionare eronată a unui apel de funcție din motive de incompatibilitate între prototipurile unei funcții:
</p>
<pre class="code c"><span class="co1">//        fisier1.c</span>
<span class="coMULTI">/* func() nedeclarata                   prototip implicit
                                        int func(void) */</span>
<span class="kw4">int</span> main<span class="br0">&#40;</span><span class="br0">&#41;</span>
<span class="br0">&#123;</span>
    <span class="coMULTI">/* ... */</span>
    value <span class="sy0">+=</span> func<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
    <span class="coMULTI">/* ... */</span>
<span class="br0">&#125;</span></pre>
<pre class="code c"><span class="co1">// fisier2.c</span>
<span class="coMULTI">/* prototip int func(int, int) */</span>
<span class="kw4">long</span> <span class="kw4">long</span> func<span class="br0">&#40;</span><span class="kw4">int</span> param1<span class="sy0">,</span> <span class="kw4">int</span> param2<span class="br0">&#41;</span>
<span class="br0">&#123;</span>
    <span class="kw1">return</span> <span class="br0">&#40;</span><span class="kw4">long</span> <span class="kw4">long</span><span class="br0">&#41;</span> param1 <span class="sy0">+</span> param2<span class="sy0">;</span>
<span class="br0">&#125;</span></pre>

<p>
În acest caz, în locul de unde se face apelul (din funcția main) se foloseşte prototipul implicit, care împreună cu un apel greşit de funcție, duce la cod eronat:
</p>
<ul>
<li class="level1"><div class="li"> în locul de unde se face apelul, nu se transmite niciun parametru, și se aşteaptă să se întoarcă o valoare de tip int,</div>
</li>
<li class="level1"><div class="li"> în funcția apelată, se așteapta 2 parametri care vor fi citiți eronat din locațiile corespunzătoare, iar valoarea întoarsă va fi un long long. </div>
</li>
</ul>

<p>
Cea mai frecventă eroare din punct de vedere al incompatibilității între prototipuri este aceea a nedeclarării prototipurilor în cazul unor funcții de bibliotecă, fapt ce duce la folosirea prototipului implicit și la imposibilitatea verificării compatibilității între prototipuri.
</p>

<p>
Este important de observat, totuși, ca majoritatea limbajelor moderne (inclusiv C++, versus C) nu acceptă tipuri si prototipuri implicite.
</p>

</div>
<!-- EDIT29 SECTION "Prototipuri de funcții" [29871-33938] -->
<h2 class="sectionedit31" id="cadre_de_stiva_stack_frames">Cadre de stiva (stack frames)</h2>
<div class="level2">

<p>
Deși ar fi ideal ca toți operanzii să fie ținuți în regiștri, majoritatea procedurilor necesită spatiu de memorie pentru:
</p>
<ul>
<li class="level1"><div class="li"> variabilele care fie nu au primit regiștri, fie nu pot fi ținute în regiștri pentru că le sunt încărcate adresele (explicit sau implicit, ca in cazul parametrilor transferati prin referință) sau pentru că trebuie să fie indexabile</div>
</li>
<li class="level1"><div class="li"> a oferi un loc “standard” pentru a salva valorile din regiștri atunci când se execută un apel de procedură</div>
</li>
<li class="level1"><div class="li"> a oferi unui debugger o modalitate de a cunoaște lanțul de proceduri active la un moment dat (call stack)</div>
</li>
</ul>

<p>
Deoarece aceste spații de memorie devin necesare la intrarea într-o procedură și devin inutile la ieșirea din aceasta, ele sunt grupate în cadre de stivă(activation records sau stack frames), care la randul lor sunt organizate sub formă de stiva. Un cadru de stivă poate conține:
</p>
<ul>
<li class="level1"><div class="li"> valorile parametrilor trimiși rutinei curente care nu încap în regiștrii destinați acestui scop, </div>
</li>
<li class="level1"><div class="li"> toate sau o parte din variabilele locale, </div>
</li>
<li class="level1"><div class="li"> o zona de salvare a regiștrilor temporari alocați de compilator,</div>
</li>
<li class="level1"><div class="li"> adresa de întoarcere din procedura etc.</div>
</li>
</ul>

<p>
Pentru a putea accesa locatiile din cadrul de stivă curent în timpul execuției, acestora li se asociază distante în unitati de memorie relative la un pointer stocat într-un registru. Pointerul poate fi frame pointer-ul <code>fp</code> care indică prima locație a cadrului curent, sau stack pointer-ul <code>sp</code> care indică vârful stivei, adica imediat dupa ultima locație a cadrului curent. Numeroase compilatoare aranjează în memorie cadrele de stivă astfel încat începutul acestora se află la adrese mai mari de memorie decât sfârșitul acestora. Această alegere face ca deplasamentul față de sp-ul curent în cadrul curent să fie pozitiv, așa cum se vede în figura de mai jos.
</p>

<p>
<a href="../../../../_detail/cpl/labs/laborator-05-stack-sp.png%3Fid=cpl%253Alabs-2015%253A06.html" class="media" title="cpl:labs:laborator-05-stack-sp.png"><img src="../../../../_media/cpl/labs/laborator-05-stack-sp.png%3Fw=480&amp;tok=892431" class="mediacenter" alt="" width="480" /></a>
</p>

<p>
Unele compilatoare folosesc amândoi pointerii, <code>sp</code> și fp, având variabile relative la amândoi regiștrii.
</p>

<p>
<a href="../../../../_detail/cpl/labs/laborator-05-stack-fp.png%3Fid=cpl%253Alabs-2015%253A06.html" class="media" title="cpl:labs:laborator-05-stack-fp.png"><img src="../../../../_media/cpl/labs/laborator-05-stack-fp.png%3Fw=480&amp;tok=1a0678" class="mediacenter" alt="" width="480" /></a>
</p>

<p>
Caracteristicile limbajului și cele ale hardware-lui determină alegerea unuia dintre acești registri sau chiar folosirea ambilor pentru accesarea locațiilor de pe stivă. Problemele sunt urmatoarele:
</p>
<ul>
<li class="level1"><div class="li"> folosirea a doi regiștri pentru accesul la stivă înseamnă a consuma un registru care ar putea folosi altor scopuri;</div>
</li>
<li class="level1"><div class="li"> dacă deplasamentul scurt față de un singur registru oferit de instrucțiunile load (încărcare din memorie) și store (salvare în memorie) este suficient pentru a acoperi spatiul de memorie al majorității înregistrărilor de activare (ceea ce se întâmplă pentru cele mai multe  arhitecturi).</div>
</li>
<li class="level1"><div class="li"> dacă dimensiunea cadrului de stivă este sau nu cunoscută la momentul compilării, și dacă se modifică pe parcursul execuției procedurii.</div>
</li>
</ul>

<p>
Dimensiunea unui cadru de stivă nu este cunoscută, de exemplu, dacă trebuie să fie suportate funcții de alocare a memoriei de tipul <code>alloca()</code> din biblioteca C prin care se alocă spațiu în mod dinamic în cadrul de stivă curent, și se întoarce un pointer la acel spațiu.
</p>

<p>
Prin urmare, este suficient și de preferat să se folosească doar sp-ul, în cazul în care nu trebuie să se ofere suport pentru funcții de tipul <code>alloca()</code>.
</p>

<p>
Efectul unui apel <code>alloca()</code> este să extindă cadrul de stivă făcând sp-ul să indice la o locație nouă. Prin urmare, deplasamentele relative la sp vor pointa către alte locații. Deoarece în C se poate calcula adresa unei variabile locale și apoi folosi, se impune ca acele cantități accesate relativ la sp să nu poată fi direct adresabile de catre utilizator și se preferă ca acestea să fie valori necesare la apelul unei alte proceduri. 
</p>

<p>
Astfel, în momentul când există fp, adresarea relativa la sp se foloseste pentru:
</p>
<ul>
<li class="level1"><div class="li"> transmiterea argumentelor unei alte proceduri, </div>
</li>
<li class="level1"><div class="li"> salvarea regiștrilor peste un apel de procedură</div>
</li>
<li class="level1"><div class="li"> întoarcerea rezultatelor dintr-o altă procedură. </div>
</li>
</ul>

<p>
Pentru a oferi suport pentru <code>alloca()</code> avem nevoie atât de un registru sp cât și de unul fp. Chiar dacă aceasta necesita înca un registru în plus, exista avantajul execuției rapide în cazul apelurilor de proceduri. Astfel, la intrarea în procedură:
</p>
<ul>
<li class="level1"><div class="li"> se salvează vechiul fp pe stivă, în cadrul noului cadru,</div>
</li>
<li class="level1"><div class="li"> se setează valoarea noului fp la valoarea vechiului sp și</div>
</li>
<li class="level1"><div class="li"> adaugă lungimea cadrului curent la vechiul sp pentru a obține noua valoare a lui sp.</div>
</li>
</ul>

<p>
La întoarcerea din procedură, procesul invers este:
</p>
<ul>
<li class="level1"><div class="li"> se setează valoarea noului sp la valoarea vechiului fp</div>
</li>
<li class="level1"><div class="li"> se încarcă noul fp de pe stivă</div>
</li>
</ul>

<p>
<a href="../../../../_detail/cpl/labs/laborator-05-stack-full.png%3Fid=cpl%253Alabs-2015%253A06.html" class="media" title="cpl:labs:laborator-05-stack-full.png"><img src="../../../../_media/cpl/labs/laborator-05-stack-full.png%3Fw=480&amp;tok=585cfb" class="mediacenter" alt="" width="480" /></a>
</p>

</div>
<!-- EDIT31 SECTION "Cadre de stiva (stack frames)" [33939-38681] -->
<h1 class="sectionedit32" id="exercitii">Exerciții</h1>
<div class="level1">

<p>
<a href="../../../../_media/cpl/labs/laborator-05-arhiva.zip" class="media mediafile mf_zip" title="cpl:labs:laborator-05-arhiva.zip (4.1 KB)">Arhiva</a> laboratorului.
</p>
<ol>
<li class="level1"><div class="li"> Scrieți un program <code>C</code> care să determine sensul stivei (este mărită sau micșorată valoarea adresei vârfului stivei la operații de <code>push</code>?).</div>
</li>
<li class="level1"><div class="li"> De ce nu există diferențe pentru definițiile lui v între următoarele semnături de funcții? <pre class="code c"> <span class="kw4">void</span> f<span class="br0">&#40;</span><span class="kw4">int</span> <span class="sy0">*</span> v<span class="br0">&#41;</span><span class="sy0">;</span> </pre>

<p>
  și 
</p>
<pre class="code c"> <span class="kw4">void</span> g<span class="br0">&#40;</span><span class="kw4">int</span> v<span class="br0">&#91;</span><span class="br0">&#93;</span><span class="br0">&#41;</span><span class="sy0">;</span> </pre>
</div>
</li>
<li class="level1"><div class="li"> În directorul <code>return_struct</code> din arhiva laboratorului aveți implementate două funcții: una care întoarce o structură și alta care primește o structură ca parametru. Rulați <code>make asm</code> pentru a genera un fișier ”.s” și explicați:</div>
<ul>
<li class="level2"><div class="li"> modul în care se trimite un argument de tip structură,</div>
</li>
<li class="level2"><div class="li"> modul în care se întoarce o structură.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Modificați <code>doar</code> funcția <strong>ask</strong> din programul <strong>ovr</strong> pentru a afișa nota corectă.</div>
</li>
<li class="level1"><div class="li"> Determinați (inspectând codul asm) cum sunt implementați <a href="http://gcc.gnu.org/onlinedocs/gcc/Variable-Length.html" class="urlextern" title="http://gcc.gnu.org/onlinedocs/gcc/Variable-Length.html"  rel="nofollow"> vectorii automatici de lungime variabilă</a>. Pentru vectori automatici de lungime constantă <code>sizeof(v)</code> reprezintă toată memoria alocată (în bytes) pentru acel vector - o constantă cunoscută la momentul compilării. Cum este implementat operatorul <code>sizeof</code> pentru vectori de lungime variabilă? Folosiți codul din directorul <code>alloca</code> din arhiva laboratorului.</div>
</li>
<li class="level1"><div class="li"> Scrieți o funcție <code>fast_multiply_3</code> în asm care să înmulțească trei numere întregi primite ca argumente. Declarați funcția ca fiind de tip <code>fastcall</code> (Pe arhitecturi Intel x86, folosirea conveției de apel fastcall, presupune că:</div>
<ul>
<li class="level2"><div class="li"> primul argument se află în <code>%ecx</code></div>
</li>
<li class="level2"><div class="li"> al doilea argument se află în <code>%edx</code></div>
</li>
<li class="level2"><div class="li"> toți ceilalți parametri se află pe stivă ca la convenția de apel</div>
</li>
<li class="level2"><div class="li"> Următoarea linie declară o funcție specificându-i convenție de apel de tip <code>fastcall</code></div>
</li>
<li class="level2"><div class="li"> <pre class="code c"> __attribute__<span class="br0">&#40;</span><span class="br0">&#40;</span>fastcall<span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="kw4">int</span> fast_multiply_3<span class="br0">&#40;</span><span class="kw4">int</span> a<span class="sy0">,</span> <span class="kw4">int</span> b<span class="sy0">,</span> <span class="kw4">int</span> c<span class="br0">&#41;</span><span class="sy0">;</span> </pre>
</div>
</li>
<li class="level2"><div class="li"> Apelați funcția definită la pasul anterior dintr-un fișier <code>C</code>. Observați și explicați ce se întâmplă dacă în cadrul fișierului <code>C</code> nu apare declarația funcției <code>fast_multiply_3</code> sau dacă acestei declarații îi lipsește decoratorul <code>fastcall</code>.</div>
</li>
<li class="level2"><div class="li"> Pentru operația de înmulțire folosiți instrucțiunea</div>
</li>
<li class="level2"><div class="li"> <pre class="code asm"> imull <span class="sy1">%</span><span class="kw4">eax</span><span class="sy1">,</span> <span class="sy1">%</span><span class="kw4">ecx</span> # echivalent cu <span class="sy1">%</span><span class="kw4">ecx</span> <span class="sy1">:</span>= <span class="sy1">%</span><span class="kw4">ecx</span> <span class="sy1">*</span> <span class="sy1">%</span><span class="kw4">eax</span> </pre>
</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Scrieți un program care să determine ordinea secțiunilor în memorie.</div>
<ul>
<li class="level2"><div class="li"> <code>Hint</code>: Declarați obiecte în fiecare secțiune și verificați adresa.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Modificați programul următor pentru a afișa <strong>structurile sunt identice</strong>:</div>
</li>
</ol>
<dl class="file">
<dt><a href="../../../code/cpl/labs-2015/06%3Fcodeblock=25" title="Download Snippet" class="mediafile mf_c">ex8.c</a></dt>
<dd><pre class="code file c"><span class="co2">#include &lt;string.h&gt; //memcmp</span>
<span class="co2">#include &lt;stdio.h&gt;</span>
&nbsp;
<span class="kw4">struct</span> comp_ex <span class="br0">&#123;</span>
    <span class="kw4">char</span> c<span class="sy0">;</span>
    <span class="kw4">int</span> i<span class="sy0">;</span>
    <span class="kw4">short</span> s<span class="sy0">;</span>
<span class="br0">&#125;</span><span class="sy0">;</span>
&nbsp;
<span class="kw4">int</span> main<span class="br0">&#40;</span><span class="br0">&#41;</span>
<span class="br0">&#123;</span>
     <span class="kw4">struct</span> comp_ex sa<span class="sy0">,</span> sb<span class="sy0">;</span>
&nbsp;
     <span class="co1">// toate câmpurile din a și b sunt inițializate </span>
     sa.<span class="me1">c</span> <span class="sy0">=</span> sb.<span class="me1">c</span> <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span>
     sa.<span class="me1">i</span> <span class="sy0">=</span> sb.<span class="me1">i</span> <span class="sy0">=</span> <span class="nu0">2</span><span class="sy0">;</span>
     sa.<span class="me1">s</span> <span class="sy0">=</span> sb.<span class="me1">s</span> <span class="sy0">=</span> <span class="nu0">3</span><span class="sy0">;</span>
&nbsp;
     <span class="kw1">if</span> <span class="br0">&#40;</span><span class="nu0">0</span> <span class="sy0">==</span> <a href="http://www.opengroup.org/onlinepubs/009695399/functions/memcmp.html"><span class="kw3">memcmp</span></a><span class="br0">&#40;</span><span class="sy0">&amp;</span>sa<span class="sy0">,</span> <span class="sy0">&amp;</span>sb<span class="sy0">,</span> <span class="kw4">sizeof</span><span class="br0">&#40;</span><span class="kw4">struct</span> comp_ex<span class="br0">&#41;</span><span class="br0">&#41;</span><span class="br0">&#41;</span>
         <a href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span class="kw3">printf</span></a><span class="br0">&#40;</span><span class="st0">&quot;structurile sunt identice<span class="es1">\n</span>&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
     <span class="kw1">else</span>
         <a href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span class="kw3">printf</span></a><span class="br0">&#40;</span><span class="st0">&quot;structurile sunt diferite<span class="es1">\n</span>&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
     <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">&#125;</span></pre>
</dd></dl>

</div>
<!-- EDIT32 SECTION "Exerciții" [38682-] --></div>
</body>
</html>
