    
    

<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
  <meta charset="utf-8" />
  <title>pdm:laboratoare:02</title>
<meta name="generator" content="DokuWiki"/>
<meta name="robots" content="index,follow"/>
<meta name="date" content="2016-03-20T23:54:26+0200"/>
<meta name="keywords" content="pdm,laboratoare,02"/>
<link rel="search" type="application/opensearchdescription+xml" href="../../../../lib/exe/opensearch.php" title="CS Open CourseWare"/>
<link rel="start" href="../../../../../courses.1.html"/>
<link rel="alternate" type="application/rss+xml" title="Recent Changes" href="../../../../feed.php"/>
<link rel="alternate" type="application/rss+xml" title="Current Namespace" href="../../../../feed.php%3Fmode=list&amp;ns=pdm:laboratoare"/>
<link rel="alternate" type="text/html" title="Plain HTML" href="02.html"/>
<link rel="canonical" href="../../../../pdm/laboratoare/02.html"/>
<link rel="stylesheet" type="text/css" href="../../../../lib/exe/css.php%3Ft=arctic&amp;tseed=1479898000.css"/>
<script type="text/javascript">/*<![CDATA[*/var NS='pdm:laboratoare';var JSINFO = {"id":"pdm:laboratoare:02","namespace":"pdm:laboratoare","isadmin":0,"isauth":0};
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="../../../../lib/exe/js.php%3Ftseed=1479898000"></script>
<script type="text/x-mathjax-config">/*<![CDATA[*/MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ["$","$"], ["\\(","\\)"] ],
        displayMath: [ ["$$","$$"], ["\\[","\\]"] ],
        processEscapes: true
    }
});
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
<script type="text/javascript">/*<![CDATA[*/
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
		  
/*!]]>*/</script>
<script type="text/javascript">/*<![CDATA[*/
var pageTracker = _gat._getTracker("UA-38383934-1");
pageTracker._initData();
pageTracker._trackPageview();
		  
/*!]]>*/</script>
</head>
<body>
<div class="dokuwiki export">
<!-- TOC START -->
<div id="dw__toc">
<h3 class="toggle">Table of Contents</h3>
<div>

<ul class="toc">
<li class="level1"><div class="li"><a href="02.html#laborator_2_-_structura_android_-_depanare">Laborator 2 - Structura Android - Depanare</a></div>
<ul class="toc">
<li class="level2"><div class="li"><a href="02.html#instalarea_software-urilor_necesare">Instalarea software-urilor necesare</a></div></li>
<li class="level2"><div class="li"><a href="02.html#creare_unei_aplicatii_android">Creare unei aplicatii Android</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="02.html#structura">Structura</a></div></li>
</ul>
</li>
<li class="level2"><div class="li"><a href="02.html#depanare">Depanare</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="02.html#ddms">DDMS</a></div>
<ul class="toc">
<li class="level4"><div class="li"><a href="02.html#utilizare">Utilizare</a></div></li>
<li class="level4"><div class="li"><a href="02.html#dispozitive">Dispozitive</a></div></li>
<li class="level4"><div class="li"><a href="02.html#loguri">Loguri</a></div></li>
<li class="level4"><div class="li"><a href="02.html#controlul_simulatorului">Controlul Simulatorului</a></div></li>
<li class="level4"><div class="li"><a href="02.html#threads">Threads</a></div></li>
</ul>
</li>
<li class="level3"><div class="li"><a href="02.html#hierachy_viewer">Hierachy Viewer</a></div>
<ul class="toc">
<li class="level4"><div class="li"><a href="02.html#vizualizarea_ierarhiei_de_view-uri">Vizualizarea ierarhiei de View-uri</a></div></li>
</ul>
</li>
<li class="level3"><div class="li"><a href="02.html#evenimentele_activitatilor">Evenimentele Activitatilor</a></div></li>
<li class="level3"><div class="li"><a href="02.html#exercitii">Exercitii</a></div></li>
</ul></li>
</ul></li>
</ul>
</div>
</div>
<!-- TOC END -->

<h1 class="sectionedit1" id="laborator_2_-_structura_android_-_depanare">Laborator 2 - Structura Android - Depanare</h1>
<div class="level1">

</div>
<!-- EDIT1 SECTION "Laborator 2 - Structura Android - Depanare" [1-58] -->
<h2 class="sectionedit2" id="instalarea_software-urilor_necesare">Instalarea software-urilor necesare</h2>
<div class="level2">

<p>
Pentru a realiza aplicații pentru Android, trebuie instalat Android SDK. Acesta este compus din trei componente:
</p>
<ul>
<li class="level1"><div class="li"> Editorul Eclipse</div>
</li>
<li class="level1"><div class="li"> Plugin-ul Android pentru Eclipse</div>
</li>
<li class="level1"><div class="li"> Programale de compilare a aplicațiilor</div>
</li>
</ul>

<p>
Pentru a face instalarea mai ușoară, Google oferă un pachet cu toate cele trei componente configurate. Acesta se numește ADT Bundle și se poate descărca de la adresa <a href="http://developer.android.com/sdk/index.html" class="urlextern" title="http://developer.android.com/sdk/index.html"  rel="nofollow">acesta</a>. Fișierul este o arhivă zip, care conține două directoare: eclipse și sdk. În primul director se află editorul, iar în al doilea se află compilatorul, biblioteciile și simulatoarele de Android. În continuare, vom denumi SDK_ROOT directorul în care am dezarhivat ADT Bundle. Vom porni editorul Eclipse din SDK_ROOT/Eclipse/eclipse. În Windows, acesta se numește eclipse.exe. Odată pornit, va trebui să verificăm că avem instalate toate pachetele necesare. Pentru acesta, vom merge în eclipse, la meniul Window/Android SDK Manager. 
<a href="http://ocw.cs.pub.ro/courses/_detail/pdm/laboratoare/figura_2.png?id=pdm%3Alaboratoare%3A02" class="media wikilink2" title="pdm:laboratoare:figura_2.png"><img src="http://ocw.cs.pub.ro/courses/_media/pdm/laboratoare/figura_2.png" class="mediacenter" title=" Android SDK Manager" alt=" Android SDK Manager" /></a>
Verificăm să fie instalate următoarele:
</p>
<ul>
<li class="level1"><div class="li"> Android SDK Tools</div>
</li>
<li class="level1"><div class="li"> Android SDK Platform-tools</div>
</li>
<li class="level1"><div class="li"> SDK Platform pentru versiunea de Android dorită (la data scrierii acestui articol, cea mai recentă versiune este Android 4.2.2, numită și <abbr title="Application Programming Interface">API</abbr> Level 17)</div>
</li>
<li class="level1"><div class="li"> ARM EABI v7a System Image sau similar, depinde de versiunea de Android.</div>
</li>
</ul>

<p>
Pe lângă aceste pachete, vom selecta pentru instalare următoatele:
</p>
<ul>
<li class="level1"><div class="li"> Documentation for Android SDK pentru versiunea de Android dorită (la data scrierii acestui articol, cea mai recentă versiune este Android 4.2.2, numită și <abbr title="Application Programming Interface">API</abbr> Level 17)</div>
</li>
<li class="level1"><div class="li"> Google <abbr title="Application Programming Interface">API</abbr></div>
</li>
<li class="level1"><div class="li"> Intel x86 Atom System Image</div>
</li>
<li class="level1"><div class="li"> Google USB Driver</div>
</li>
<li class="level1"><div class="li"> Intel x86 Emulation Accelerator (HAXM)</div>
</li>
</ul>

<p>
Intel porteaza Android pentru platforma x86, aceeasi platforma folosita si pentru calculatoare. Din acest motiv, simulatorul pentru Android poate rula fara a fi nevoie sa simuleze platofrma hardware, insa are nevoie de imaginea Intel x86 Atom System Image si Intel x86 Emulation Accelerator(HAXM). Rularea programelor Android se poate face în două moduri: pe simulator, pe un telefon sau tabletă cu Android. Simulatorul pus la dispoziție de către Google este QEMU [2], care încarcă o imagine de Android. Pachetul de dezvoltare Android permite realizarea mai multor simulatoare. <a href="http://ocw.cs.pub.ro/courses/_detail/laboratoare/figura_3.png?id=pdm%3Alaboratoare%3A02" class="media wikilink2" title="laboratoare:figura_3.png"><img src="http://ocw.cs.pub.ro/courses/_media/laboratoare/figura_3.png" class="mediacenter" title=" Android Virtual Device Manager" alt=" Android Virtual Device Manager" /></a> Pentru a le configura, vom merge in eclipse la meniul Window/Android Virtual Device Manager. Figura arată fereastra cu lista de simulatoare, aceasta fiind goală inițial. Vom apăsa butonul New… pentru a configura un nou simulator. <a href="http://ocw.cs.pub.ro/courses/_detail/laboratoare/figura_4.png?id=pdm%3Alaboratoare%3A02" class="media wikilink2" title="laboratoare:figura_4.png"><img src="http://ocw.cs.pub.ro/courses/_media/laboratoare/figura_4.png" class="mediacenter" title=" Virtual Device" alt=" Virtual Device" /></a> În figura se pot vedea setările simulatorului. Setările sunt:
</p>
<ul>
<li class="level1"><div class="li"> AVD Name – numele simulatorului; putem pune orice text care conține litere, cifre, punct și _.</div>
</li>
<li class="level1"><div class="li"> Device – acesta este, de fapt, o listă cu dispozitive reale ce pot fi simulate – practic aici se setează dimensiunile ecranului și rezoluția.</div>
</li>
<li class="level1"><div class="li"> Target – selectăm versiunea de Android pe care dorim s-o simulăm.</div>
</li>
<li class="level1"><div class="li"> CPU/ABI – selectăm platforma de Android pe care o dorim (ARM – este platforma existentă pe majoritatea telefoanelor, Intel – mai puțin răspândită, însă funcționează mai rapid pe simulator).</div>
</li>
<li class="level1"><div class="li"> Keyboard – putem să selectăm dacă dorim tastatură fizică.</div>
</li>
<li class="level1"><div class="li"> Skin – putem selecta dacă dorim butoane fizice.</div>
</li>
<li class="level1"><div class="li"> Front Camera – simularea camerei video din fața telefonului.</div>
</li>
<li class="level1"><div class="li"> Back Camera – simularea camerei video din spatele telefonului și cum să fie aceasta legată (la webcam, simulate etc.).</div>
</li>
<li class="level1"><div class="li"> Memory Options – RAM: spațiul de memorie alocat simulatorului. Este indicat ca pe Windows acesta să nu depășească 768 <abbr title="Megabyte">MB</abbr>, altfel există posibilitatea ca simulatorul să nu pornească.</div>
</li>
<li class="level1"><div class="li"> Internal Storage – spațiul de stocare al hard discului intern al telefonului.</div>
</li>
<li class="level1"><div class="li"> SD Card – dimensiunea cardului de memorie. Aceasta poate fi specificată în <abbr title="Megabyte">MB</abbr> sau poate fi ales un fișier cu o imagine de card.</div>
</li>
<li class="level1"><div class="li"> Emulation Options – pentru o performanță mai bună, este indicat să selectăm Use Host GPU pentru a folosi procesorul grafic al calculatorului.</div>
</li>
</ul>

<p>
Pentru a rula pe telefon sau tabletă, este necesară activarea modului de dezvoltare pe acestea. În general, activarea se face de la Setări/Dezvoltare/Depanare USB. În Windows trebuie instalate și driver-ele telefonului sau tabletei. Acestea se pot obține de la producător.
</p>

</div>
<!-- EDIT2 SECTION "Instalarea software-urilor necesare" [59-4569] -->
<h2 class="sectionedit3" id="creare_unei_aplicatii_android">Creare unei aplicatii Android</h2>
<div class="level2">

<p>
Pentru a crea o aplicatie Android vom deschide Eclipse si vom selecta , dupa care vom selecta .
</p>

<p>
<a href="http://ocw.cs.pub.ro/courses/_detail/laboratoare/new_project_new.png?id=pdm%3Alaboratoare%3A02" class="media wikilink2" title="laboratoare:new_project_new.png"><img src="http://ocw.cs.pub.ro/courses/_media/laboratoare/new_project_new.png" class="mediacenter" alt="" /></a>
</p>

<p>
<a href="http://ocw.cs.pub.ro/courses/_detail/laboratoare/figura_5.png?id=pdm%3Alaboratoare%3A02" class="media wikilink2" title="laboratoare:figura_5.png"><img src="http://ocw.cs.pub.ro/courses/_media/laboratoare/figura_5.png" class="mediacenter" alt="" /></a>
</p>

<p>
In urma acestor actiuni, va aparea fereastra urmatoare:
</p>

<p>
In campurile  si  se va introduce numele aplicatiei, iar in campul  se va introduce numele pachetului care va contine aplicatia noastra. Este de preferat sa se introduca un text de forma .
</p>

<note tip>

<p>
Este de preferat sa se scrie site-ul in ordine inversa. Exemplu:ro.rosedu.android.Proiect1
</p>

</note>

<p>
In campul  se va selecta versiunea de Android pentru care se creeaza proiectul, iar in campul  se va selecta cea mai veche versiune de Android pe care poate rula aplicatia creata.
</p>

</div>
<!-- EDIT3 SECTION "Creare unei aplicatii Android" [4570-5353] -->
<h3 class="sectionedit4" id="structura">Structura</h3>
<div class="level3">

<p>
Structura unei aplicatii se poate observa din fereastra . <a href="http://ocw.cs.pub.ro/courses/_detail/laboratoare/figura_6.png?id=pdm%3Alaboratoare%3A02" class="media wikilink2" title="laboratoare:figura_6.png"><img src="http://ocw.cs.pub.ro/courses/_media/laboratoare/figura_6.png" class="mediacenter" alt="" /></a>
</p>
<ul>
<li class="level1"><div class="li"> In directorul  se gaseste intregul cod sursa.</div>
</li>
<li class="level1"><div class="li"> In directorul  se afla un fisier Java cu ID-uri catre resurse.</div>
</li>
<li class="level1"><div class="li"> In  vom gasi programul compilat.</div>
</li>
<li class="level1"><div class="li"> Directorul  contine mai multe directoare . In acestea se salveaza imaginile folosite in aplicatie.</div>
</li>
<li class="level1"><div class="li"> In  gasim fisierul . Acesta reprezinta interfata grafica, separata de codul programului.</div>
</li>
<li class="level1"><div class="li"> Pe langa aceste directoare, se mai observa fisierul . Aici vom scrie detalii despre aplicatie, cum ar fi permisiunile si versiunea aplicatiei.</div>
</li>
</ul>

<p>
Pentru prima aplicatie vom utiliza un buton la a carui apasare va aparea un mesaj. Pentru a pune buton pe fereastra vom deschide fisierul . Fisierul este structura pe tag-uri, fiecare element reprezentand un tag. Pentru a adauga butonul, vom scrie urmatoarea bucata de cod: 
</p>
<pre class="code xml"><span class="sc3"><span class="re1">&lt;Button</span></span>
<span class="sc3">     	 <span class="re0">android:id</span>=<span class="st0">&quot;@+id/buton&quot;</span> </span>
<span class="sc3">	 <span class="re0">android:layout_width</span>=<span class="st0">&quot;wrap_content&quot;</span></span>
<span class="sc3">	 <span class="re0">android:layout_height</span>=<span class="st0">&quot;wrap_content&quot;</span></span>
<span class="sc3">	 <span class="re0">android:text</span>=<span class="st0">&quot;Apasa&quot;</span>    <span class="re2">/&gt;</span></span></pre>

<p>
Pentru a adauga o actiune butonului, deschidem fisierul din directorul .
</p>

<p>
<a href="http://ocw.cs.pub.ro/courses/_detail/laboratoare/activity_view1.png?id=pdm%3Alaboratoare%3A02" class="media wikilink2" title="laboratoare:activity_view1.png"><img src="http://ocw.cs.pub.ro/courses/_media/laboratoare/activity_view1.png?w=1000&amp;tok=53f65b" class="mediacenter" alt="" width="1000" /></a>
</p>

<p>
Vom crea o noua functie ce va fi apelata la apasarea butonului. 
</p>
<pre class="code java"><span class="kw1">public</span> <span class="kw4">void</span> apasa<span class="br0">&#40;</span><a href="http://www.google.com/search?hl=en&amp;q=allinurl%3Adocs.oracle.com+javase+docs+api+view"><span class="kw3">View</span></a> v<span class="br0">&#41;</span>
    <span class="br0">&#123;</span>
    	Toast.<span class="me1">makeText</span><span class="br0">&#40;</span><span class="kw1">this</span>, <span class="st0">&quot;Hello!&quot;</span>, Toast.<span class="me1">LENGTH_SHORT</span><span class="br0">&#41;</span>.<span class="me1">show</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
    <span class="br0">&#125;</span></pre>

<p>
Pentru ca functia sa fie apelata la apasarea butonului, va trebui sa facem legatura intre buton si functie. Acest lucru se poate face in doua moduri: din codul programului sau din fisierul . Alegem cea de-a doua varianta, in care vom adauga urmatoarea linie in tag-ul butonului: 
</p>
<pre class="code">android:onClick=&quot;apasa&quot;</pre>

<p>
Pentru a rula aplicatia, este necesar un simulator. Vom crea unul astfel: in Eclipse vom selecta 
</p>

<p>
<a href="http://ocw.cs.pub.ro/courses/_detail/laboratoare/figura_3.png?id=pdm%3Alaboratoare%3A02" class="media wikilink2" title="laboratoare:figura_3.png"><img src="http://ocw.cs.pub.ro/courses/_media/laboratoare/figura_3.png" class="mediacenter" alt="" /></a>
</p>

<p>
Apasam butonul New, introducem numele si versiunea de Android pe care o dorim, dupa care putem rula aplicatia.
</p>

</div>
<!-- EDIT4 SECTION "Structura" [5354-7276] -->
<h2 class="sectionedit5" id="depanare">Depanare</h2>
<div class="level2">

<p>
Depanarea este foarte importanta in procesul de realizare a aplicatiilor pentru dispozitive mobile. Acest proces este insa putin diferit fata de depanarea programelor clasice pentru calculator, in primul rand pentru ca ruleaza pe alt dispozitiv. Tocmai din acest motiv, avem nevoie de programe spcializate pentru a realiza depanarea. De asemenea, fiind vorba de dispozitive mobile, apar si anumite evenimente specifice, cum ar fi apeluri telefonice, descarcarea bateriei etc., evenimente ce trebuie tratate intr-un fel sau altul. In laboratorul de astazi vom prezenta programele de depanare existente si modul lor de functionare. De asemenea, ne vom ocupa putin de studierea evenimentelor ferestrelor.
</p>

</div>
<!-- EDIT5 SECTION "Depanare" [7277-8001] -->
<h3 class="sectionedit6" id="ddms">DDMS</h3>
<div class="level3">

<p>
Utilitarul pentru depanarea aplicatiilor pentru Android se numeste DDMS (Dalvik Debug Monitor System). Acesta foloseste de fapt un alt utilitar, numit ADB (Android Debug Bridge), pentru a se conecta la simulatoare sau dispozitive fizice. Cu ajutorul DDMS putem vizualiza parametrii dispozitivului si a programelor ce ruleaza pe acesta. DDMS poate fi accesat sub forma unei perspective in Eclipse.
</p>

<p>
Activarea se face din meniul: 
</p>
<pre class="code">Window -&gt; Open Perspective -&gt; DDMS</pre>

</div>

<h4 id="utilizare">Utilizare</h4>
<div class="level4">

<p>
Cele mai importrante functii pe care DDMS le poate indeplini sunt:
</p>
<ul>
<li class="level1"><div class="li"> Afisarea log-urilor dispozitivelor</div>
</li>
<li class="level1"><div class="li"> Afisarea informatiilor despre procesele curente</div>
</li>
<li class="level1"><div class="li"> Controlul simulatoarelor</div>
</li>
</ul>

</div>

<h4 id="dispozitive">Dispozitive</h4>
<div class="level4">

<p>
DDMS poate afisa informatii de depanare atat de la simulatoarele pornite cat si de la dispozitivele conectate la calculator. Alegerea dispozitivului curent se face prin selectarea lui din panoul Devices.
</p>

</div>

<h4 id="loguri">Loguri</h4>
<div class="level4">

<p>
Logurile sistemului sunt cele mai importante informatii pe care le poate oferi DDMS. Aici sunt descrise toate actiunile indeplinite de catre dispozitiv, exceptiile aparute si informatii necesare depanaraii. Log-urile vor aparea in panoul denumit LogCat (a nu se confunda cu Console! - acestea sunt mesajele afisate de catre Eclipse). Fiecare mesaj din aceasta lista este insotit de urmatoarele date (fiecare pe cate o coloana):
</p>
<ul>
<li class="level1"><div class="li"> Tipul mesajului</div>
<ul>
<li class="level2"><div class="li">       *         * I** - //Information// - mesaj informativ</div>
</li>
<li class="level2"><div class="li">       *         * D** - //Debug// - mesaj utile la depanare</div>
</li>
<li class="level2"><div class="li">       *         * W** - //Warning// - mesaj de avertizare (exceptiile ce nu sunt foarte importante si nu au un impact important asupra componentei apar sub forma de astfel de mesaje)</div>
</li>
<li class="level2"><div class="li">       *         * E** - //Error// - mesaj de eroare (exceptiile ce intrerup o componenta apar sub forma de astfel de mesaje)</div>
</li>
<li class="level2"><div class="li">       *         * V** - //Verbose// - informatii suplimentare afisate de programe (in general la cerere, se folosesc la depistarea problemelor de functionare rezultate in general din cauza configurarii gresite a programelor)</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> //Time// - data si ora la care a fost scris mesajul</div>
</li>
<li class="level1"><div class="li"> //PID// - ID-ul procesului ce a generat mesajul</div>
</li>
<li class="level1"><div class="li"> //Tag// - Eticheta sau categoria mesajului (este util pentru filtre)</div>
</li>
<li class="level1"><div class="li"> //Message// - mesajul propriu-zis (text)</div>
</li>
</ul>

<p>
Este de remarcat ca fiecare mesaj reprezinta cate o linie de text. Spre exemplu, exceptiile sunt in general afisate pe mai multe linii, acestea continand foarte multa informatie. Astfel, fiecare exceptie este reprezentata de mai multe mesaje de log.
</p>

<p>
Ceea ce ne intereseaza in continuare este cum putem genera astfel de mesaje de log. SDK-ul ne pune la dispozitie doua metode:
</p>
<ul>
<li class="level1"><div class="li"> functiile statice ale clasei <a href="http://developer.android.com/reference/android/util/Log.html" class="urlextern" title="http://developer.android.com/reference/android/util/Log.html"  rel="nofollow">Log</a></div>
</li>
<li class="level1"><div class="li"> //System.out.println// mesajele catre consola standard (stdout)</div>
</li>
</ul>

<p>
Exemplu pentru clasa //Log//: <code>Log.println</code> <code>(Log.DEBUG,</code> <code>&quot;exemplu</code> <code>log&quot;,</code> <code>&quot;aceasta</code> <code>este</code> <code>un</code> <code>mesaj</code> <code>de</code> <code>log</code> <code>cu</code> <code>eticheta</code> <code>&#039;exemplu</code> <code>log&#039;&quot;);</code> Exemplu pentru utilizarea System.out.println. De remarcat este ca mesajele de log trimise sub aceasta forma vor avea eticheta “System.out” si vor fi de tipul Information. <code>System.out.println</code> <code>(&quot;aceasta</code> <code>este</code> <code>un</code> <code>mesaj</code> <code>catre</code> <code>consola</code> <code>standard&quot;);</code> Un alta functie importanta ce trebuie discutata este posibilitatea de filtrare a mesajelor de log. Deoarece LogCat agrega toate mesajele de log din sistem, urmarirea unor anumite mesaje poate fi dificila. Pentru a usura aceasta sarcina, se pot genera filtre dupa:
</p>
<ul>
<li class="level1"><div class="li"> PID</div>
</li>
<li class="level1"><div class="li"> Tag</div>
</li>
<li class="level1"><div class="li"> Tip</div>
</li>
</ul>

<p>
Un filtru se creaza prin apasarea butonului plus verde din bara panoului Log (respectiv LogCat in Eclipse). 
</p>

</div>

<h4 id="controlul_simulatorului">Controlul Simulatorului</h4>
<div class="level4">

<p>
Desi destul de exact, simulatorul Android nu poate totusi simula functiile unui telefon real. Pentru a putea totusi testa comportamentul aplicatiilor cat mai bine, DDMS ne pune la dispozitie un panou de control (Emulator Control). Astfel putem sa simulam:
</p>
<ul>
<li class="level1"><div class="li"> starea conexiunii de voce</div>
</li>
<li class="level1"><div class="li"> primirea unui apel telefonic</div>
</li>
<li class="level1"><div class="li"> primirea unui SMS</div>
</li>
<li class="level1"><div class="li"> date primite de la GPS</div>
</li>
</ul>

<p>
Evident, acest panou nou are nici un efect asupra dispozitivelor reale.
</p>

</div>

<h4 id="threads">Threads</h4>
<div class="level4">

<p>
In panoul Threads sunt afisate informatiile despre fiecare fir de executie al fiecarui proces. Deoarece aceste informatii sunt culese prin intermediul unei legaturi de retea, overhead-ul este destul de mare. Pentru nu a incetini semnificativ functionarea dispozitivului (care este mereu nevoit sa trimita aceste date), vizualizarea trebuie activata. Astfel, se selecteaza procesul dorit (din panoul Devices) si se apasa butonul Update Threads. Dupa ce s-au cules informatiile dorite, monitorizarea se poate opri prin inca o apasare a butonului. 
</p>

</div>
<!-- EDIT6 SECTION "DDMS" [8002-12955] -->
<h3 class="sectionedit7" id="hierachy_viewer">Hierachy Viewer</h3>
<div class="level3">

<p>
Un alt program foarte util pentru depanare este hierachyviewer. Acesta permite vizualizarea arborescenta a compozitiei fereastrelor. De asemenea afiseaza parametrii fiecarui View si timpul de incarcare al acestuia. O alta functie importanta este posibilitatea capturarii unei imagini a View-ului.
</p>

<p>
Trebuie mentionat ca putem analiza cu acest program orice aplicatie (componenta) ce ruleaza pe un dispozitiv. Ne putem astfel inspira asupra modului in care este construita interfata grafica.
</p>

<p>
Activarea se face din meniul:
</p>

<p>
<code>Window</code> <code>-&gt;</code> <code>Open</code> <code>Perspective</code> <code>-&gt;</code> <code>Hierarchy</code> <code>Viewer</code>
</p>

</div>

<h4 id="vizualizarea_ierarhiei_de_view-uri">Vizualizarea ierarhiei de View-uri</h4>
<div class="level4">

<p>
La fel ca DDMS, hierachyviewer functioneaza atat cu simulatoare cat si cu dispozitive reale. La pornire, este afisata lista dispozitivelor conectate. Se alege un dispozitiv (stanga) si o componenta ce ruleaza pe acel dispozitiv (dreapta) si se apasa butonul Load View Hierarchy. Daca nu s-a ales nici o componenta, programul va afisa componenta ce este in capatul Task-ului curent. 
</p>

<p>
Afisarea ierarhiei de View-uri se face sub forma unui arbore avand alaturate fie propietatiile, fie imaginea fiecarui View. Selectarea intre cele doua moduri se face folosind butoanele de la baza ferestrei programului. 
</p>

<p>
Vizualizarea ierarhiei impreuna cu imaginea ferestrei joaca un rol important in realizarea design-ului. Peste imaginea reala se poate suprapune o fotografie cu design-ul dorit. Fotografia suprapusa este semitransparenta, astfel permitand dezvoltatorilor sa faca corecturi asupra interfetei grafice, pana ce acesta se potriveste perfect cu design-ul. 
</p>

</div>
<!-- EDIT7 SECTION "Hierachy Viewer" [12956-14609] -->
<h3 class="sectionedit8" id="evenimentele_activitatilor">Evenimentele Activitatilor</h3>
<div class="level3">

<p>
Scopul acestui laborator este studierea evenimetelor ferestrelor utilizand programele de depanare descrise mai sus. Am discutat la curs despre evenimentele pe care le primesc ferestrele. Schema urmatoare le ilustreaza mai bine. Apelurile de functie sunt reprezentate in dreptunghiurile gri. 
</p>

<p>
In continuare aveti ilustrat un exemplu de fereastra ce suprascrie toate functiile pentru evenimentele ce controleaza ciclul de viata. De remarcat este faptul ca fiecare dintre aceste functii face un apel catre functia parintelui (functie originala). Acest lucru este obligatoriu. 
</p>
<pre class="code java"><span class="kw1">public</span> <span class="kw1">class</span> Evenimente <span class="kw1">extends</span> Activity 
<span class="br0">&#123;</span>
    @Override
    <span class="kw1">public</span> <span class="kw4">void</span> onCreate<span class="br0">&#40;</span>Bundle savedInstanceState<span class="br0">&#41;</span> 
    <span class="br0">&#123;</span>
        <span class="kw1">super</span>.<span class="me1">onCreate</span><span class="br0">&#40;</span>savedInstanceState<span class="br0">&#41;</span><span class="sy0">;</span>
    <span class="br0">&#125;</span>
&nbsp;
    @Override
    <span class="kw1">public</span> <span class="kw4">void</span> onStart <span class="br0">&#40;</span><span class="br0">&#41;</span>
    <span class="br0">&#123;</span>
    	<span class="kw1">super</span>.<span class="me1">onStart</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
    <span class="br0">&#125;</span>
&nbsp;
    @Override
    <span class="kw1">public</span> <span class="kw4">void</span> onRestart <span class="br0">&#40;</span><span class="br0">&#41;</span>
    <span class="br0">&#123;</span>
    	<span class="kw1">super</span>.<span class="me1">onRestart</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
    <span class="br0">&#125;</span>
&nbsp;
    @Override
    <span class="kw1">public</span> <span class="kw4">void</span> onResume <span class="br0">&#40;</span><span class="br0">&#41;</span>
    <span class="br0">&#123;</span>
    	<span class="kw1">super</span>.<span class="me1">onResume</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
    <span class="br0">&#125;</span>
&nbsp;
    @Override
    <span class="kw1">public</span> <span class="kw4">void</span> onPause <span class="br0">&#40;</span><span class="br0">&#41;</span>
    <span class="br0">&#123;</span>
    	<span class="kw1">super</span>.<span class="me1">onPause</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
    <span class="br0">&#125;</span>
&nbsp;
    @Override
    <span class="kw1">public</span> <span class="kw4">void</span> onStop <span class="br0">&#40;</span><span class="br0">&#41;</span>
    <span class="br0">&#123;</span>
    	<span class="kw1">super</span>.<span class="me1">onStop</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
    <span class="br0">&#125;</span>
&nbsp;
    @Override
    <span class="kw1">public</span> <span class="kw4">void</span> onDestroy <span class="br0">&#40;</span><span class="br0">&#41;</span>
    <span class="br0">&#123;</span>
    	<span class="kw1">super</span>.<span class="me1">onDestroy</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
    <span class="br0">&#125;</span>
&nbsp;
    <span class="co1">// functii folosite pentru salvarea si restaurarea starii    </span>
&nbsp;
    @Override
    <span class="kw1">public</span> <span class="kw4">void</span> onSaveInstanceState <span class="br0">&#40;</span>Bundle outState<span class="br0">&#41;</span>
    <span class="br0">&#123;</span>
        <span class="co1">// apelarea functiei din activitatea parinte este recomandata, dar nu obligatorie</span>
    	<span class="kw1">super</span>.<span class="me1">onSaveInstanceState</span><span class="br0">&#40;</span>outState<span class="br0">&#41;</span><span class="sy0">;</span>
    <span class="br0">&#125;</span>
&nbsp;
    @Override
    <span class="kw1">public</span> <span class="kw4">void</span> onRestoreInstanceState <span class="br0">&#40;</span>Bundle inState<span class="br0">&#41;</span>
    <span class="br0">&#123;</span>
        <span class="co1">// apelarea functiei din activitatea parinte este recomandata, dar nu obligatorie</span>
    	<span class="kw1">super</span>.<span class="me1">onRestoreInstanceState</span><span class="br0">&#40;</span>inState<span class="br0">&#41;</span><span class="sy0">;</span>
    <span class="br0">&#125;</span>
<span class="br0">&#125;</span></pre>

<p>
Puteti observa in exemplul de mai sus ca trei dintre functii primesc ca parametru un obiect de tip <a href="http://developer.android.com/reference/android/os/Bundle.html" class="urlextern" title="http://developer.android.com/reference/android/os/Bundle.html"  rel="nofollow">Bundle</a>. Acesta este folosit pentru memorarea starii in cazul in care activitatea trebuie inchisa din lipsa de memorie. Astfel, functiile sunt apelate in felul urmator:
</p>
<ul>
<li class="level1"><div class="li"> //onCreate// - este apelata la crearea ferestrei (atentie: crearea este diferita de afisare). Parametrul savedInstance este fie null, daca fereastra este noua, sau este o instanta a unui obiect de tip Bundle in care a fost salvata starea anterioara (in functia onSaveInstanceState).</div>
</li>
<li class="level1"><div class="li"> //onRestoreInstanceState// - este apelata doar daca in prealabil a fost salvata starea ferestrei in onSaveInstanceState.</div>
</li>
<li class="level1"><div class="li"> //onSaveInstanceState// - este apelata cand fereastra urmeaza sa fie ascunsa si exista posibilitatea ca procesul acesteia sa fie terminat din lipsa de memorie.</div>
</li>
</ul>

<p>
Din obiectul de tip <a href="http://developer.android.com/reference/android/os/Bundle.html" class="urlextern" title="http://developer.android.com/reference/android/os/Bundle.html"  rel="nofollow">Bundle</a> ne intereseaza cel mai mult functiile care incep cu put si functiile care incep cu get. Pentru anumite widget-uri(EditText, CheckBox) starea lor este salvata automat in //onSaveInstanceState//. Astfel, daca aplicatia este oprita(//onDestroy//), la repornire, un EditText va contine textul care a fost introdus anterior. Pentru a dezactiva aceasta optiune, putem introduce in fisierul xml, in tag-ul widget-ului dorit urmatoarea linie de cod: <code>android:saveEnabled=&quot;false&quot;</code> de asemea trebuie sa ii alocam un id widget-ului: <code>android:id=&quot;@+id/idWidget&quot;</code>
</p>

<note>

<p>
Dezactiviarea se poate face si din cod folosind functia //setSaveEnabled(boolean).//
</p>

</note>

</div>
<!-- EDIT8 SECTION "Evenimentele Activitatilor" [14610-18130] -->
<h3 class="sectionedit9" id="exercitii">Exercitii</h3>
<div class="level3">
<ol>
<li class="level1"><div class="li"> Realizati o activitate careia ii suprascrieti urmatoarele functii de eveniment. Afisati cate un mesaj de log cu Tag-ul evenimente din fiecare dintre aceste functii. Textul mesajului de log trebuie sa contina numele evenimentului. De exemplu, in onCreate() puteti afisa un mesaj cu textul s-a apelat onCreate(). Pentru a putea citi mai usor mesajele de log afisate de catre programul vostru, o sa creati un filtru de log dupa tag-ul eveniment.</div>
</li>
</ol>
<ul>
<li class="level1"><div class="li">     * onCreate</div>
<ul>
<li class="level2"><div class="li"> onRestart</div>
</li>
<li class="level2"><div class="li"> onStart</div>
</li>
<li class="level2"><div class="li"> onResume</div>
</li>
<li class="level2"><div class="li"> onPause</div>
</li>
<li class="level2"><div class="li"> onStop</div>
</li>
<li class="level2"><div class="li"> onDestroy</div>
</li>
</ul>
</li>
</ul>
<ol>
<li class="level1"><div class="li"> Suprascrieti si evenimentele urmatoare. Modificati mesajul de log din functia onCreate astfel incat sa va afiseze daca fereastra este noua sau are o stare ce trebuie reprodusa.</div>
</li>
<li class="level1"><div class="li"> Observati ce se intampla cu evenimentele ferestrelor cand:</div>
</li>
</ol>
<ul>
<li class="level1"><div class="li">     * Primiti un apel telefonic (Hint: utilizati Emulator Control din DDMS)</div>
<ul>
<li class="level2"><div class="li"> Se apasa butonul Home</div>
</li>
<li class="level2"><div class="li"> Se tine mult apasat butonul Home</div>
</li>
<li class="level2"><div class="li"> Se apasa butonul de raspundere la convorbire</div>
</li>
<li class="level2"><div class="li"> Se apasa butonul de inchidere al ecranului (este butonul de inchidere a convorbrii)</div>
</li>
</ul>
</li>
</ul>
<ol>
<li class="level1"><div class="li"> Adaugati pe fereastra un EditText si un CheckBox. Observati ce se intampla in cazurile de mai sus.</div>
</li>
<li class="level1"><div class="li"> Dezactivati optiunea de salvare a starii, dupa care repetati pasii din exercitiul anterior.</div>
</li>
<li class="level1"><div class="li"> Salvati starea EditBox-ului si a CheckBox-ului in functia de salvare a starii (hint: utilizati putString si putBoolean), fara a modifica functia onCreate si/sau onRestoreInstanceState, observati ce se intampla in cazurile de mai sus.</div>
</li>
<li class="level1"><div class="li"> Completati functia onCreate si/sau onRestoreInstanceState astfel incat sa restaurati starea ferestrelor. Inchideti fortat procesul (hint: apasati butonul Home pe dispozitiv, in timp ce functioneaza aplicatia, in DDMS, la Devices, selectati procesul, este numele pachetului, si apsati butonul Stop). Reporniti aplicatia. Verificati daca starea s-a restaurat.</div>
</li>
<li class="level1"><div class="li"> Utilizati hierachyviewer pentru a vizualiza arborele de View-uri ale ambelor ferestre.</div>
</li>
</ol>

</div>
<!-- EDIT9 SECTION "Exercitii" [18131-] --></div>
</body>
</html>
