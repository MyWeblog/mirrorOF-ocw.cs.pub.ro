    
    

<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
  <meta charset="utf-8" />
  <title>pdm:laboratoare:03</title>
<meta name="generator" content="DokuWiki"/>
<meta name="robots" content="index,follow"/>
<meta name="date" content="2016-03-20T23:45:40+0200"/>
<meta name="keywords" content="pdm,laboratoare,03"/>
<link rel="search" type="application/opensearchdescription+xml" href="../../../../lib/exe/opensearch.php" title="CS Open CourseWare"/>
<link rel="start" href="../../../../../courses.1.html"/>
<link rel="alternate" type="application/rss+xml" title="Recent Changes" href="../../../../feed.php"/>
<link rel="alternate" type="application/rss+xml" title="Current Namespace" href="../../../../feed.php%3Fmode=list&amp;ns=pdm:laboratoare"/>
<link rel="alternate" type="text/html" title="Plain HTML" href="03.html"/>
<link rel="canonical" href="../../../../pdm/laboratoare/03.html"/>
<link rel="stylesheet" type="text/css" href="../../../../lib/exe/css.php%3Ft=arctic&amp;tseed=1479898000.css"/>
<script type="text/javascript">/*<![CDATA[*/var NS='pdm:laboratoare';var JSINFO = {"id":"pdm:laboratoare:03","namespace":"pdm:laboratoare","isadmin":0,"isauth":0};
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="../../../../lib/exe/js.php%3Ftseed=1479898000"></script>
<script type="text/x-mathjax-config">/*<![CDATA[*/MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ["$","$"], ["\\(","\\)"] ],
        displayMath: [ ["$$","$$"], ["\\[","\\]"] ],
        processEscapes: true
    }
});
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
<script type="text/javascript">/*<![CDATA[*/
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
		  
/*!]]>*/</script>
<script type="text/javascript">/*<![CDATA[*/
var pageTracker = _gat._getTracker("UA-38383934-1");
pageTracker._initData();
pageTracker._trackPageview();
		  
/*!]]>*/</script>
</head>
<body>
<div class="dokuwiki export">
<!-- TOC START -->
<div id="dw__toc">
<h3 class="toggle">Table of Contents</h3>
<div>

<ul class="toc">
<li class="level1"><div class="li"><a href="03.html#laborator_3_-_interfete_grafice_-_activitati">Laborator 3 - Interfețe grafice - Activități</a></div>
<ul class="toc">
<li class="level2"><div class="li"><a href="03.html#ferestre">Ferestre</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="03.html#oncreate">onCreate</a></div></li>
<li class="level3"><div class="li"><a href="03.html#onpause">onPause</a></div></li>
</ul>
</li>
<li class="level2"><div class="li"><a href="03.html#interfata_grafica-xml">Interfata grafica-XML</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="03.html#layout">Layout</a></div>
<ul class="toc">
<li class="level4"><div class="li"><a href="03.html#linear_layout">Linear Layout</a></div></li>
<li class="level4"><div class="li"><a href="03.html#absolute_layout">Absolute Layout</a></div></li>
</ul>
</li>
<li class="level3"><div class="li"><a href="03.html#setarea_evenimentelor_pe_elementele_grafice">Setarea evenimentelor pe elementele grafice</a></div></li>
</ul>
</li>
<li class="level2"><div class="li"><a href="03.html#accesarea_elementelor_grafice_din_java">Accesarea elementelor grafice din Java</a></div></li>
<li class="level2"><div class="li"><a href="03.html#intent-uri">Intent-uri</a></div></li>
<li class="level2"><div class="li"><a href="03.html#utilizarea_resurselor">Utilizarea resurselor</a></div></li>
<li class="level2"><div class="li"><a href="03.html#exercitii">Exercitii</a></div></li>
<li class="level2"><div class="li"><a href="03.html#bonus">Bonus</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="03.html#help">Help</a></div></li>
</ul></li>
</ul></li>
</ul>
</div>
</div>
<!-- TOC END -->

<h1 class="sectionedit1" id="laborator_3_-_interfete_grafice_-_activitati">Laborator 3 - Interfețe grafice - Activități</h1>
<div class="level1">

</div>
<!-- EDIT1 SECTION "Laborator 3 - Interfețe grafice - Activități" [1-63] -->
<h2 class="sectionedit2" id="ferestre">Ferestre</h2>
<div class="level2">

<p>
In sistemul Android ferestrele se numesc activitati. Din punct de vedere al programarii, acestea sunt clase care extind clasa Activity. Spre deosebire de alte sisteme in care un program contine mai multe ferestre afisate simultan, in Android, ecranul este mereu ocupat de o singura fereastra. Mai mult, ferestrele sunt conectate prin simplul fapt ca o fereastra da nastere mai multor ferestre. Fereastra care apare pe ecran in momentul in care aplicatia este pornita este considerata fereastra principala, din ea pornind toate celelalte. Pentru a crea o activitate, vom crea o clasa ce extinde clasa Activity. La pornire, programul o va genera, iar noi putem interactiona cu fereastra prin evenimente. Unele dintre cele mai importante evenimente sunt:  si . <code java>public class MainActivity extends Activity {
</p>

<p>
<code>   @Override</code><br/>

<code>   public void onCreate(Bundle savedInstanceState)</code><br/>

<code>   {</code><br/>

<code>       super.onCreate(savedInstanceState);</code><br/>

<code>       setContentView(R.layout.activity_main);        </code><br/>

<code>   }</code><br/>

<code>   @Override</code><br/>

<code>   protected void onPause() </code><br/>

<code>   {</code><br/>

<code>       // TODO Auto-generated method stub</code><br/>

<code>       super.onPause();</code><br/>

<code>   }</code>
</p>

<p>
}</code>
</p>

<note warning>

<p>
Nu uitati sa apelati functia parintelui (in exemplul nostru Activity) in interiorul evenimentelor!
</p>

</note>

</div>
<!-- EDIT2 SECTION "Ferestre" [64-1568] -->
<h3 class="sectionedit3" id="oncreate">onCreate</h3>
<div class="level3">

<p>
Evenimentul este apelat in momentul in care se creaza activitate. Aici vom initializa compentele ferestrei. Pentru a face elementele de pe fereastra vizibile, este necesar sa apelam functia . Exista cazuri in care la pornirea eplicatiei, aceasta trebuie sa revina la o stare anterioara (ex: dupa o oprire fortata). Astfel, este recomandat ca in acest aveniment sa se verifice daca fereastra este una noua sau nu, adica daca variabila de tip  pasata ca parametru este nula sau nu. <code>if</code> <code>(savedInstanceState!=null)</code> <code>{</code> <code>//fereastra</code> <code>nu</code> <code>e</code> <code>noua</code> <code>si</code> <code>trebuie</code> <code>incarcate</code> <code>anumite</code> <code>date</code> <code>ramase</code> <code>}</code> <code>else</code> <code>{</code> <code>//fereastra</code> <code>e</code> <code>noua</code> <code>}</code>
</p>

</div>
<!-- EDIT3 SECTION "onCreate" [1569-2354] -->
<h3 class="sectionedit4" id="onpause">onPause</h3>
<div class="level3">

<p>
Cand acest eveniment este apelat, fereastra se pregateste pentru oprire. De aceea este important sa salvam toate schimbarile de care avem nevoie. Aici vom opri procesele care nu mai sunt necesare cand aplicatia nu ruleaza, cum ar fi elementele video sau audio.
</p>

</div>
<!-- EDIT4 SECTION "onPause" [2355-2635] -->
<h2 class="sectionedit5" id="interfata_grafica-xml">Interfata grafica-XML</h2>
<div class="level2">

<p>
Unul dintre cele mai importante elemente ale unei aplicatii il reprezinta interfata grafica. Pentru a putea diferentia interfata grafica de scrierea codului aplicatiei, cele doua se afla in fisiere diferite. De asemenea, design-ul interfetei este facut intr-un alt limbaj, unul descriptiv. Acesta seamana cu limbajul <abbr title="HyperText Markup Language">HTML</abbr>, fiind alcatuit din marcaje. <code xml><RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent" >
</p>

<p>
<code>   </code><TextView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_centerHorizontal="true"
        android:layout_centerVertical="true"
        android:text="@string/hello_world"
        tools:context=".MainActivity" />
</p>

<p>
</RelativeLayout> </code> Pentru fiecare element de pe fereastra exista un marcaj. Numele marcajului este acelasi cu numele clasei din partea de cod. Elementele au anumite caracteristici: pozitionarea, dimensiunile, culoarea, textul de pe ele. Pentru setarea fiecarei proprietati se scrie un parametru in acest mod: <code>android:proprietate=&quot;valoare&quot;</code> Un buton rosu cu textul “Buton nou” pe el, va fi declarat astfel: <Button 
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:background="#FF0000"
        android:text="Buton nou"
        /> Observam ca proprietatile  si  au valoarea . Luand aceasta valoarea, butonul va avea cele mai mici dimensiuni posibile. Putem inlocui  cu  si vom observa ca butonul va acoperi toata fereastra. Dimensiunile pot, de asemenea, sa fie absolute, in pixeli. Culoarea butonului poate fi scrisa in format RGB sau aRGB (a reprezinta transparenta).
</p>

</div>
<!-- EDIT5 SECTION "Interfata grafica-XML" [2636-4535] -->
<h3 class="sectionedit6" id="layout">Layout</h3>
<div class="level3">

<p>
Mai adaugati un buton pe fereastra creata anterior si observati ce se intampla. Pentru ca pe o fereastra putem avea un singur view, exista view-uri speciale care au rolul de a aranja continutul. Aceste view-uri se numesc layout-uri si se comporta ca niste containere care aranjeaza elementele din interiorul lor dupa o anumita regula. Exista mai multe tipuri de layout-uri:
</p>
<ul>
<li class="level1"><div class="li"> <a href="http://developer.android.com/guide/topics/ui/layout/linear.html" class="urlextern" title="http://developer.android.com/guide/topics/ui/layout/linear.html"  rel="nofollow">Linear Layout</a></div>
</li>
<li class="level1"><div class="li"> <a href="http://developer.android.com/reference/android/widget/AbsoluteLayout.html" class="urlextern" title="http://developer.android.com/reference/android/widget/AbsoluteLayout.html"  rel="nofollow">Absolute Layout</a></div>
</li>
<li class="level1"><div class="li"> <a href="http://developer.android.com/guide/topics/ui/layout/listview.html" class="urlextern" title="http://developer.android.com/guide/topics/ui/layout/listview.html"  rel="nofollow">List View</a></div>
</li>
<li class="level1"><div class="li"> <a href="http://developer.android.com/guide/topics/ui/layout/gridview.html" class="urlextern" title="http://developer.android.com/guide/topics/ui/layout/gridview.html"  rel="nofollow">Grid View</a></div>
</li>
</ul>

</div>

<h4 id="linear_layout">Linear Layout</h4>
<div class="level4">

<p>
LinearLayout este un container care aliniaza toate elementele pe care le contine fie vertical, fie orizontal.
</p>

<p>
<a href="http://ocw.cs.pub.ro/courses/_detail/laboratoare/layout.png?id=pdm%3Alaboratoare%3A03" class="media wikilink2" title="laboratoare:layout.png"><img src="http://ocw.cs.pub.ro/courses/_media/laboratoare/layout.png?w=300&amp;tok=e8b45e" class="mediacenter" alt="" width="300" /></a>
</p>

<p>
Selectarea orientarii se face prin atributul . Pentru a face ca cele doua butoane create anterior sa nu se suprapuna putem folosi un layout linear. <code xml><LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="fill_parent"
    android:layout_height="fill_parent" 
    android:orientation="vertical">
</p>

<p>
<code>   </code><Button 
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:background="#FF0000"
        android:text="Buton nou"
        /><br/>

<code>    </code><Button 
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:background="#FF0000"
        android:text="Buton "
        />
</p>

<p>
</LinearLayout> </code>
</p>

</div>

<h4 id="absolute_layout">Absolute Layout</h4>
<div class="level4">

<p>
Acest container permite pozitionarea componentelor sale in functie de coordonatele x si y. <code xml><AbsoluteLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="fill_parent"
    android:layout_height="fill_parent" >
</p>

<p>
<code>   </code><Button 
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_x="20px"
        android:layout_y="30px"
        android:background="#FF0000"
        android:text="Buton nou"
        /><br/>

<code>    </code><Button 
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:background="#FF0000"
        android:layout_x="60px"
        android:layout_y="150px"
        android:text="Buton "
        />
</p>

<p>
</AbsoluteLayout> </code>
</p>

</div>
<!-- EDIT6 SECTION "Layout" [4536-7271] -->
<h3 class="sectionedit7" id="setarea_evenimentelor_pe_elementele_grafice">Setarea evenimentelor pe elementele grafice</h3>
<div class="level3">

<p>
Pana acum am editat fereastra aplicatiei, dar aceasta nu este functionala. Pentru a putea utiliza butoanele create, trebuie sa le legam de actiunea pe care dorim sa o execute. Acest lucru se realizeaza prin intermediul unei alte proprietati: <code>android:onClick=&quot;metodaExecutata&quot;</code> Daca dorim sa executam o actiune la un alt eveniment si nu la apasarea butonului, vom selecta o alta variabila in loc de .
</p>

</div>
<!-- EDIT7 SECTION "Setarea evenimentelor pe elementele grafice" [7272-7734] -->
<h2 class="sectionedit8" id="accesarea_elementelor_grafice_din_java">Accesarea elementelor grafice din Java</h2>
<div class="level2">

<p>
Widget-urile pot fi modificate si din codul Java, nu doar fisierul XML, deoarece apropate toate proprietatile din XML au o functie echivalenta in JAVA. Apelam la aceasta optiune cand dorim ca la apelarea unui anumit eveniment, un element al ferestrei sa se modifice. Pentru a realiza acest lucru, trebuie sa cream o legatura intre elementul din XML si partea de cod. In primul rand, pe langa propietatile deja setate, ale elementului, vom mai adauga una:id. <code>android:id=&quot;@+id/idElement&quot;</code> Dupa ce elementul poate fi identificat prin id, il putem lega de codul Java. <code>Button</code> <code>buton=findViewById(R.id.buton1);</code>
</p>

</div>
<!-- EDIT8 SECTION "Accesarea elementelor grafice din Java" [7735-8414] -->
<h2 class="sectionedit9" id="intent-uri">Intent-uri</h2>
<div class="level2">

<p>
Intent-ul este evenimentul prin care doua activitati comunica. Deoarece pe ecran este afisata o singura activitate odata, avem nevoie de o activitate principala care sa genereze alte activitati. Acest lucru se realizeaza prin crearea unui intent: <code>Intent</code> <code>intent</code> <code>=</code> <code>new</code> <code>Intent(this,</code> <code>NewActivity.class);</code> <code>startActivity(intent);</code> Fiecare activitate nou creata trebuie declarata in fisierul . Declararea se face astfel: <code xml> <activity
            android:name=".ActivitateNoua"
            android:label="ctivitate_noua" >
</p>

<p>
<code>          </code></activity></code>
</p>

<p>
In multe situatii, activitatea noua are nevoie de niste parametrii provenind din prima activitate. Acesti parametrii sunt pasati cu ajutorul metodei . Valoarea pasata poate sa fie de aproape orice tip. Activitatea nou creata, va prelua datele transmise cu ajutorul metodei , aceasta existand in mai multe variante in functie de tipul pe care dorim sa il obtinem.
</p>

</div>
<!-- EDIT9 SECTION "Intent-uri" [8415-9467] -->
<h2 class="sectionedit10" id="utilizarea_resurselor">Utilizarea resurselor</h2>
<div class="level2">

<p>
In aplicatiile noastre vom dori sa folosim diferite resurse, cum ar fi imaginile. Toate aceste elemente pe care dorim sa le adaugam in aplicatie trebuie salvate in directorul . Ele pot fi adaugate din codul XML sau din cadoul Java. In XML exista anumite elemente care suporta aceste resurse, cum ar fi . Acestea se pun pe view folosind urmatoarea atribuire: <code>android:src=&quot;@drawable/nume_poza&quot;</code> Din codul Java, ele se adauga astfel: <code java>ImageView i=(ImageView) findViewById(R.id.img);
</p>

<p>
<code>       i.setImageResource(R.drawable.image);</code></code>
</p>

</div>
<!-- EDIT10 SECTION "Utilizarea resurselor" [9468-10094] -->
<h2 class="sectionedit11" id="exercitii">Exercitii</h2>
<div class="level2">
<ol>
<li class="level1"><div class="li"> Creati o fereastra care sa arate ca in imagine:<a href="http://ocw.cs.pub.ro/courses/_detail/laboratoare/butoane2.png?id=pdm%3Alaboratoare%3A03" class="media wikilink2" title="laboratoare:butoane2.png"><img src="http://ocw.cs.pub.ro/courses/_media/laboratoare/butoane2.png?w=300&amp;tok=973d19" class="mediacenter" alt="" width="300" /></a></div>
</li>
<li class="level1"><div class="li"> Inserati spatii intre butoane.</div>
</li>
<li class="level1"><div class="li"> Mariti dimensiunile butoanelor, dand o valoare exacta, si faceti astfel incat textul sa ramana centrat.</div>
</li>
<li class="level1"><div class="li"> Adaugati un eveniment pe primul buton astfel incat la apasare, acesta sa primeasca o alta culoare.</div>
</li>
<li class="level1"><div class="li"> Modificati evenimentul astfel incat de data aceasta, butonul sa dispara.</div>
</li>
<li class="level1"><div class="li"> Faceti ca la apasarea oricarui buton, sa se afiseze pe ecran textul de pe butonul apasat.</div>
</li>
<li class="level1"><div class="li"> Creati inca o fereastra pe care adaugati o imagine. La apasarea butonului //Fereastra Noua// va aparea noua fereastra.</div>
</li>
<li class="level1"><div class="li"> Adaugati ferestrei crete anterior un buton de back.</div>
</li>
<li class="level1"><div class="li"> Faceti ca fereastra cu imaginea sa apara si la apasarea butonului //Inserati Fereastra// si afisati, sub poza, care a fost butonul care a creat fereastra.</div>
</li>
<li class="level1"><div class="li"> Adaugati celei de-a doua ferestre un buton prin intermediul caruia sa se schimbe imaginea existenta cu o alta.</div>
</li>
</ol>

</div>
<!-- EDIT11 SECTION "Exercitii" [10095-11092] -->
<h2 class="sectionedit12" id="bonus">Bonus</h2>
<div class="level2">
<ol>
<li class="level1"><div class="li"> Invatam sa desenam</div>
</li>
</ol>

<p>
Scopul urmatorului exercitiu este sa realizati un program de desen care va permite utilizatorului sa deseneze liber cu degetul pe ecran.
</p>

</div>
<!-- EDIT12 SECTION "Bonus" [11093-11273] -->
<h3 class="sectionedit13" id="help">Help</h3>
<div class="level3">

<p>
1.Desenare Pentru desenare vom folosi un obiect de tipul SurfaceView. Scopul acestuia este de a oferi o suprafata de desen, pe care o vom edita prin intermediul unui SurfaceHolder. Pentru a obtine acest obiect vom apela pe SurfaceView-ul nostru functia “getHolder()” .
</p>

<p>
Dupa ce obtinem SurfaceHolder-ul trebuie sa editam Canvas-ul desenat pe el.
</p>

<p>
Dupa deschiderea activitatii este posibil ca SurfaceHolder-ul sa se incarce mai greu, de aceea nu este recomandat sa desenam in cadrul functiei onCreate. In schimb vom adauga un CallBack pe holder si vom desena in cadrul functiei “surfaceCreated(SurfaceHolder holder)”. In continuare este un exemplu de cod:
</p>

<p>
<code java> holder.addCallback(new Callback() {
</p>

<p>
<code>       public void surfaceDestroyed(SurfaceHolder holder) {</code><br/>

<code>           // TODO Auto-generated method stub</code><br/>

<code>           </code><br/>

<code>       }</code><br/>

<code>       </code><br/>

<code>       public void surfaceCreated(SurfaceHolder holder) {</code><br/>

<code>           // aici obtinem canvasul, il editam si il postam inapoi</code><br/>

<code>           </code><br/>

<code>       }</code><br/>

<code>       </code><br/>

<code>       public void surfaceChanged(SurfaceHolder holder, int format, int width,</code><br/>

<code>               int height) {</code><br/>

<code>           // TODO Auto-generated method stub</code><br/>

<code>           </code><br/>

<code>       }</code><br/>

<code>   });</code>
</p>

<p>
</code>
</p>

<p>
Pentru a obtine Canvasul vom apela pe holder functia “lockCanvas()”, care returneaza canvasul desenat la momentul respectiv pe holder si il blocheaza pentru a nu putea fi editat din alt thread in acelasi timp.
</p>

<p>
Pe canvas vom putea desena diferite forme folosind functii ca drawCircle(CentuX, CentruY, Raza, paint);
</p>

<p>
Al patrulea parametru este de tipul Paint. El contine informatii referitoare la culoare, transparenta, grosimea liniei si alte aspecte legate de stil.
</p>

<p>
Dupa ce terminam de editat Canvasul il putem desena pe holder folosin functia “unlockCanvasAndPost(canvas)”.
</p>

<p>
2.Interpretarea touch-urilor Pentru a putea primi coordonatele unui touch in cadrul unui obiect trebuie sa adaugam pe acesta un OnTouchListener. Exemplu:
</p>

<p>
<code java> unObiect.setOnTouchListener(new OnTouchListener() {
</p>

<p>
<code>           public boolean onTouch(View v, MotionEvent event) {</code><br/>

<code>                           </code><br/>

<code>               // TODO Auto-generated method stub</code><br/>

<code>               return true;</code><br/>

<code>           }</code><br/>

<code>       });</code>
</p>

<p>
</code>
</p>

<p>
Atunci cand vom atinge ecranul functia onTouch va fi apelata si vom putea citi din event coordonatele touch-ului exprimate in pixeli, in functie de coltul din stanga sus al obiectului pe care am setat listener-ul.
</p>

<p>
Pentru a obtine numarul de degete care ating ecranul vom folosi //event.getPointerCount()//
</p>

<p>
Pentru un singur deget putem obtine coodronatele cu event.getX(); si event.getY();
</p>

<p>
Un exemplu de a obtine coordonatele pentru multitouch este //event.getX(event.getPointerId(0))// pentru a obtine abscisa primului deget
</p>

<p>
Pentru a obtine tipul actiunii, de exemplu daca a fost pus degetul, sau a fost miscat, sau a fost ridicat folosim //event.getActionMasked()//
</p>

<p>
2.Folosirea fragmentelor
</p>
<ol>
<li class="level1"><div class="li"> Creati o activitate cu un buton la apasarea caruia sa adaugati in mod dinamic un fragment cu functionalitatile de la exercitiul anterior.</div>
</li>
<li class="level1"><div class="li"> Creati o activitate cu doua fragmente identice, ce implementeaza functionalitatile de la exercitiul anterior. In plus atunci cand desenam pe unul din fragmente modificarile trebuie sa fie vizibile si pe celalalt.</div>
</li>
</ol>

</div>
<!-- EDIT13 SECTION "Help" [11274-] --></div>
</body>
</html>
