    
    

<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
  <meta charset="utf-8" />
  <title>sasc:laboratoare:03</title>
<meta name="generator" content="DokuWiki"/>
<meta name="robots" content="index,follow"/>
<meta name="date" content="2016-04-25T13:10:42+0300"/>
<meta name="keywords" content="sasc,laboratoare,03"/>
<link rel="search" type="application/opensearchdescription+xml" href="../../../../lib/exe/opensearch.php" title="CS Open CourseWare"/>
<link rel="start" href="../../../../../courses.1.html"/>
<link rel="alternate" type="application/rss+xml" title="Recent Changes" href="../../../../feed.php"/>
<link rel="alternate" type="application/rss+xml" title="Current Namespace" href="../../../../feed.php%3Fmode=list&amp;ns=sasc:laboratoare"/>
<link rel="alternate" type="text/html" title="Plain HTML" href="03.html"/>
<link rel="canonical" href="../../../../sasc/laboratoare/03.html"/>
<link rel="stylesheet" type="text/css" href="../../../../lib/exe/css.php%3Ft=arctic&amp;tseed=1476798676.css"/>
<script type="text/javascript">/*<![CDATA[*/var NS='sasc:laboratoare';var JSINFO = {"id":"sasc:laboratoare:03","namespace":"sasc:laboratoare","isadmin":0,"isauth":0};
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="../../../../lib/exe/js.php%3Ftseed=1476798676"></script>
<script type="text/x-mathjax-config">/*<![CDATA[*/MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ["$","$"], ["\\(","\\)"] ],
        displayMath: [ ["$$","$$"], ["\\[","\\]"] ],
        processEscapes: true
    }
});
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
<script type="text/javascript">/*<![CDATA[*/
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
		  
/*!]]>*/</script>
<script type="text/javascript">/*<![CDATA[*/
var pageTracker = _gat._getTracker("UA-38383934-1");
pageTracker._initData();
pageTracker._trackPageview();
		  
/*!]]>*/</script>
</head>
<body>
<div class="dokuwiki export">
<!-- TOC START -->
<div id="dw__toc">
<h3 class="toggle">Table of Contents</h3>
<div>

<ul class="toc">
<li class="level2"><div class="li"><a href="03.html#lab_03_-_prgs">Lab 03 - PRGs</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="03.html#exercise_1_4p">Exercise 1 (4p)</a></div></li>
<li class="level3"><div class="li"><a href="03.html#exercise_2_4p">Exercise 2 (4p)</a></div></li>
<li class="level3"><div class="li"><a href="03.html#exercise_3_-_lfsr_2p">Exercise 3 - LFSR (2p)</a></div></li>
</ul></li>
</ul>
</div>
</div>
<!-- TOC END -->

<h2 class="sectionedit1" id="lab_03_-_prgs">Lab 03 - PRGs</h2>
<div class="level2">

</div>
<!-- EDIT1 SECTION "Lab 03 - PRGs" [1-28] -->
<h3 class="sectionedit2" id="exercise_1_4p">Exercise 1 (4p)</h3>
<div class="level3">

<p>
Advantage. The purpose of this problem is to clarify the concept of advantage. Consider the following two experiments $\mathsf{EXP}(0)$ and $\mathsf{EXP}(1)$:
</p>
<ul>
<li class="level1"><div class="li"> In $\mathsf{EXP}(0)$ the challenger flips a fair coin (probability $1/2$ for HEADS and $1/2$ for TAILS) and sends the result to the adversary $\mathsf{A}$.</div>
</li>
<li class="level1"><div class="li"> In $\mathsf{EXP}(1)$ the challenger always sends TAILS to the adversary.</div>
</li>
</ul>

<p>
Let r = 0 for HEADS and r = 1 for TAILS. Then we have the experiment as shown below:
<a href="../../../../_detail/sasc/laboratoare/adversar_prg.png%3Fid=sasc%253Alaboratoare%253A03.html" class="media" title="sasc:laboratoare:adversar_prg.png"><img src="../../../../_media/sasc/laboratoare/adversar_prg.png%3Fw=400&amp;tok=d01585" class="media" alt="" width="400" /></a>
</p>

<p>
The adversary’s goal is to distinguish these two experiments: at the end of each experiment the adversary outputs a bit $0$ or $1$ for its guess for which experiment it is in. For $b = 0,1$ let $W_{b}$ be the event that in experiment $b$ the adversary output $1$. The adversary tries to maximize its distinguishing advantage, namely the quantity
$\mathsf{Adv} = \left| \mathsf{Pr}\left[W_{0}\right] − \mathsf{Pr}\left[W_{1}\right] \right| \in \left[0, 1\right]$ .
</p>

<p>
The advantage $\mathsf{Adv}$ captures the adversary’s ability to distinguish the two experiments. If the advantage is $0$ then the adversary behaves exactly the same in both experiments and therefore does not distinguish between them. If the advantage is $1$ then the adversary can tell perfectly what experiment it is in. If the advantage is negligible for all efficient adversaries (as defined in class) then we say that the two experiments are indistinguishable.
</p>

<p>
a. Calculate the advantage of each of the following adversaries:
</p>
<ul>
<li class="level1"><div class="li"> A1: Always output $1$.</div>
</li>
<li class="level1"><div class="li"> A2: Ignore the result reported by the challenger, and randomly output $0$ or $1$ with even probability.</div>
</li>
<li class="level1"><div class="li"> A3: Output $1$ if HEADS was received from the challenger, else output $0$.</div>
</li>
<li class="level1"><div class="li"> A4: Output $0$ if HEADS was received from the challenger, else output $1$.</div>
</li>
<li class="level1"><div class="li"> A5: If HEADS was received, output $1$. If TAILS was received, randomly output $0$ or $1$ with even probability.</div>
</li>
</ul>

<p>
b. What is the maximum advantage possible in distinguishing these two experiments? Explain why.
</p>

</div>
<!-- EDIT2 SECTION "Exercise 1 (4p)" [29-2092] -->
<h3 class="sectionedit3" id="exercise_2_4p">Exercise 2 (4p)</h3>
<div class="level3">

<p>
Let&#039;s use the experiment defined earlier as a pseudorandom generator ($\mathsf{PRG}$) as follows:
</p>
<ol>
<li class="level1"><div class="li"> Set a desired output length $n$</div>
</li>
<li class="level1"><div class="li"> Obtain a random sequence $R$ of bits of length $n$ (say flipping a coin, using a Linear-congruential generator, or any other method)</div>
</li>
<li class="level1"><div class="li"> For each bit $r$ in the random sequence $R$ generated in the previous step, output a bit $b$ as follows:</div>
</li>
</ol>
<ul>
<li class="level1"><div class="li"> if the bit $r$ is $0$, then output a random bit $b$ (e.g. flip a coin and output either $0$ or $1$ depending on its result)</div>
</li>
<li class="level1"><div class="li"> if the bit $r$ is $1$, then output $1$</div>
</li>
</ul>

<p>
a. Implement the frequency (monobit) test from <a href="http://csrc.nist.gov/publications/nistpubs/800-22-rev1a/SP800-22rev1a.pdf" class="urlextern" title="http://csrc.nist.gov/publications/nistpubs/800-22-rev1a/SP800-22rev1a.pdf"  rel="nofollow"> NIST (see section 2.1)</a> and check if a sequence generated by the above $\mathsf{PRG}$ (say $n=100$) seems random or not.
</p>

<p>
b. Run the test on a random bitstring (e.g. a string such as R used by the above $\mathsf{PRG}$), and compare the result of the test.
</p>

<p>
If the two results are different across many iterations, this test already gives you an attacker that breaks the $\mathsf{PRG}$.
</p>

<p>
<p><div class="notetip">You may use a function like this to generate a random bitstring
</div></p>
</p>
<pre class="code python"><span class="kw1">import</span> <span class="kw3">random</span>
&nbsp;
<span class="kw1">def</span> get_random_string<span class="br0">&#40;</span>n<span class="br0">&#41;</span>: <span class="co1">#generate random bit string</span>
  bstr <span class="sy0">=</span> bin<span class="br0">&#40;</span><span class="kw3">random</span>.<span class="me1">getrandbits</span><span class="br0">&#40;</span>n<span class="br0">&#41;</span><span class="br0">&#41;</span>.<span class="me1">lstrip</span><span class="br0">&#40;</span><span class="st0">'0b'</span><span class="br0">&#41;</span>.<span class="me1">zfill</span><span class="br0">&#40;</span>n<span class="br0">&#41;</span>
  <span class="kw1">return</span> bstr</pre>

<p>
<p><div class="notetip">Also, in Python you may find the functions sqrt, fabs and erfc from the module math useful
</div></p>
</p>

</div>
<!-- EDIT3 SECTION "Exercise 2 (4p)" [2093-3539] -->
<h3 class="sectionedit4" id="exercise_3_-_lfsr_2p">Exercise 3 - LFSR (2p)</h3>
<div class="level3">

<p>
In this exercise we&#039;ll build a simple Linear Feedback Shift Register (LFSR). LFSRs produce random bit strings with good statistical properties, but are very easy to predict.
</p>

<p>
The register is a sequence of $n$ bits; a LFSR is defined by:
</p>
<ul>
<li class="level1"><div class="li"> an initial state (the initial bit contents of the register)</div>
</li>
<li class="level1"><div class="li"> a polynomial that describes how bit shifts should be performed</div>
</li>
</ul>

<p>
For example, given an $18$ bit LFSRm the polynomial $X^{18} + X^{11} + 1$ and the initial state:
</p>
<pre class="code">  state = &#039;001001001001001001&#039;
                     *      *</pre>

<p>
we generate a new bit $b$ by $\mathsf{xor}$-ing bits $11$ ($0$) and $18$ ($1$), thus obtaining $b = 1$. We then shift the whole register to the right (thus dropping the right-most bit, which is the bit we add to the generated random sequence) and insert $b$ to the left. Thus, the new state is:
</p>
<pre class="code">  state = &#039;100100100100100100&#039;</pre>

<p>
The process is repeated until the desired number of bits have been generated.
</p>

<p>
Using the above starting state and polynomial, generate $100$ random bits and run the monobit statistical test from the previous exercise to see if their frequency seems random.
</p>

</div>
<!-- EDIT4 SECTION "Exercise 3 - LFSR (2p)" [3540-] --></div>
</body>
</html>
