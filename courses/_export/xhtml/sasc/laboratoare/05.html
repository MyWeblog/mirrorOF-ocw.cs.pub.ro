    
    

<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
  <meta charset="utf-8" />
  <title>sasc:laboratoare:05</title>
<meta name="generator" content="DokuWiki"/>
<meta name="robots" content="index,follow"/>
<meta name="date" content="2016-04-25T13:09:56+0300"/>
<meta name="keywords" content="sasc,laboratoare,05"/>
<link rel="search" type="application/opensearchdescription+xml" href="../../../../lib/exe/opensearch.php" title="CS Open CourseWare"/>
<link rel="start" href="../../../../../courses.1.html"/>
<link rel="alternate" type="application/rss+xml" title="Recent Changes" href="../../../../feed.php"/>
<link rel="alternate" type="application/rss+xml" title="Current Namespace" href="../../../../feed.php%3Fmode=list&amp;ns=sasc:laboratoare"/>
<link rel="alternate" type="text/html" title="Plain HTML" href="05.html"/>
<link rel="canonical" href="../../../../sasc/laboratoare/05.html"/>
<link rel="stylesheet" type="text/css" href="../../../../lib/exe/css.php%3Ft=arctic&amp;tseed=1476798676.css"/>
<script type="text/javascript">/*<![CDATA[*/var NS='sasc:laboratoare';var JSINFO = {"id":"sasc:laboratoare:05","namespace":"sasc:laboratoare","isadmin":0,"isauth":0};
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="../../../../lib/exe/js.php%3Ftseed=1476798676"></script>
<script type="text/x-mathjax-config">/*<![CDATA[*/MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ["$","$"], ["\\(","\\)"] ],
        displayMath: [ ["$$","$$"], ["\\[","\\]"] ],
        processEscapes: true
    }
});
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
<script type="text/javascript">/*<![CDATA[*/
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
		  
/*!]]>*/</script>
<script type="text/javascript">/*<![CDATA[*/
var pageTracker = _gat._getTracker("UA-38383934-1");
pageTracker._initData();
pageTracker._trackPageview();
		  
/*!]]>*/</script>
</head>
<body>
<div class="dokuwiki export">
<!-- TOC START -->
<div id="dw__toc">
<h3 class="toggle">Table of Contents</h3>
<div>

<ul class="toc">
<li class="level2"><div class="li"><a href="05.html#lab_05_-_des">Lab 05 - DES</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="05.html#exercise_1">Exercise 1</a></div></li>
<li class="level3"><div class="li"><a href="05.html#exercise_2">Exercise 2</a></div></li>
<li class="level3"><div class="li"><a href="05.html#exercise_3">Exercise 3</a></div></li>
</ul></li>
</ul>
</div>
</div>
<!-- TOC END -->

<h2 class="sectionedit1" id="lab_05_-_des">Lab 05 - DES</h2>
<div class="level2">

<p>
In this lab we&#039;ll do some exercises with DES and some of its variants, as we discussed in the last lecture:
<a href="http://cs.curs.pub.ro/2014/pluginfile.php/13095/mod_resource/content/2/sasc_curs4_5.pdf" class="urlextern" title="http://cs.curs.pub.ro/2014/pluginfile.php/13095/mod_resource/content/2/sasc_curs4_5.pdf"  rel="nofollow">http://cs.curs.pub.ro/2014/pluginfile.php/13095/mod_resource/content/2/sasc_curs4_5.pdf</a>
</p>

</div>
<!-- EDIT1 SECTION "Lab 05 - DES" [1-224] -->
<h3 class="sectionedit2" id="exercise_1">Exercise 1</h3>
<div class="level3">

<p>
Remember DESX defined as the operation DESX( (k1,k2,k3), m) = k1 ⊕ DES(k2, m ⊕ k3).
Show an attack on DESX that runs in time 2<sup>120</sup>.
</p>

</div>
<!-- EDIT2 SECTION "Exercise 1" [225-393] -->
<h3 class="sectionedit3" id="exercise_2">Exercise 2</h3>
<div class="level3">

<p>
Show why the following schemes do not bring any real advantage compared to DES:
</p>
<ul>
<li class="level1"><div class="li"> a) c = k1 ⊕ DES(k2, m)</div>
</li>
<li class="level1"><div class="li"> b) c = DES(k2, m ⊕ k1)</div>
</li>
</ul>

</div>
<!-- EDIT3 SECTION "Exercise 2" [394-555] -->
<h3 class="sectionedit4" id="exercise_3">Exercise 3</h3>
<div class="level3">

<p>
The goal of this exercise is to implement the meet-in-the-middle attack on double DES.
For this, you are given a starter code (see below), implemented using the Pycrypto library:
<a href="https://pypi.python.org/pypi/pycrypto" class="urlextern" title="https://pypi.python.org/pypi/pycrypto"  rel="nofollow">https://pypi.python.org/pypi/pycrypto</a>
</p>

<p>
Perform the following tasks:
</p>
<ul>
<li class="level1"><div class="li"> a) Install the pycrypto library</div>
</li>
<li class="level1"><div class="li"> b) Starting from the starter code (see below), write methods to encrypt and decrypt using double-DES (2DES), defined as follows:</div>
</li>
</ul>

<p>
&lt;quote&gt; 2DES( (k1,k2), m) = DES(k1, DES(k2, m))&lt;/quote&gt;
</p>
<ul>
<li class="level1"><div class="li"> c) You are given the ciphertexts</div>
</li>
</ul>

<p>
c1 = &#039;cda98e4b247612e5b088a803b4277710f106beccf3d020ffcc577ddd889e2f32&#039;
</p>

<p>
c2 = &#039;54826ea0937a2c34d47f4595f3844445520c0995331e5d492f55abcf9d8dfadf&#039;
</p>

<p>
as hex strings (i.e. you need to decode them to get the actual byte strings to use with DES, e.g. c1.decode(&#039;hex&#039;))
</p>

<p>
Decrypt them using the following keys:
</p>

<p>
k1 = &#039;Smerenie&#039;
</p>

<p>
k2 = &#039;Dragoste&#039;
</p>

<p>
The plaintext corresponding to c1 is m1=&#039;Fericiti cei saraci cu duhul, ca&#039;. Find the plaintext m2 corresponding to c2.
</p>

<p>
<p><div class="notetip">
With the Pycrypto library, DES is given a key in 8 bytes (64 bits) rather than 7 (56 bits). However, the last bit in each byte is considered as a parity bit, but in fact ignored in this library, leaving the actual key in 56 bits. For this and the following exercises, we assume the entire key as 64 bits, given for example as 8 characters, as above.
</p>

<p>
Note also that for this exercises, we shall be using the default values when initialising the DES cipher (i.e. ECB mode and no IV).

</div></p>
</p>
<ul>
<li class="level1"><div class="li"> d) Decrypt the entire ciphertext (c1 || c2) with k1 and k2 using 2DES and check it matches the messages m1||m2 above.</div>
</li>
<li class="level1"><div class="li"> e) You are given the following ciphertext/plaintext pairs:</div>
</li>
</ul>

<p>
m1 = &#039;Pocainta&#039; (in byte string, i.e. can be used directly with Pycrypto DES)
</p>

<p>
c1 = &#039;9f98dbd6fe5f785d&#039; (in hex string, you need to hex-decode)
</p>

<p>
m2 = &#039;Iertarea&#039;
</p>

<p>
c2 = &#039;6e266642ef3069c2&#039;
</p>

<p>
Due to a problem with the PRG, you also know the last 6-bytes of each key (note we now have a different key than for the previous exercises):
k1 (last 6 bytes) = &#039;oIkvH5&#039;
k2 (last 6 bytes) = &#039;GK4EoU&#039;
</p>

<p>
To build a table, I recommend using a list of tuples, where you add new (key,enc) pairs as follows:
</p>
<pre class="code">tb = []
tb.append((&#039;keyval&#039;, &#039;encva&#039;))</pre>

<p>
To sort the table, you can do this:
</p>
<pre class="code">tbs = sorted(tb, key=itemgetter(1))</pre>

<p>
To search with binary search, first select just the second column (to search the encryptions):
</p>
<pre class="code">tenc = [value for _,value in tbs]</pre>

<p>
then use the bisect library (e.g. bisect.bisect_left)
<a href="https://docs.python.org/2/library/bisect.html" class="urlextern" title="https://docs.python.org/2/library/bisect.html"  rel="nofollow">https://docs.python.org/2/library/bisect.html</a>
</p>

<p>
The starter code is this:
</p>
<pre class="code">import sys
import random
import string
from operator import itemgetter
import time
import bisect
from Crypto.Cipher import DES

def strxor(a, b): # xor two strings (trims the longer input)
  return &quot;&quot;.join([chr(ord(x) ^ ord(y)) for (x, y) in zip(a, b)])

def hexxor(a, b): # xor two hex strings (trims the longer input)
  ha = a.decode(&#039;hex&#039;)
  hb = b.decode(&#039;hex&#039;)
  return &quot;&quot;.join([chr(ord(x) ^ ord(y)).encode(&#039;hex&#039;) for (x, y) in zip(ha, hb)])

def bitxor(a, b): # xor two bit strings (trims the longer input)
  return &quot;&quot;.join([str(int(x)^int(y)) for (x, y) in zip(a, b)])

def str2bin(ss):
  &quot;&quot;&quot;
    Transform a string (e.g. &#039;Hello&#039;) into a string of bits
  &quot;&quot;&quot;
  bs = &#039;&#039;
  for c in ss:
    bs = bs + bin(ord(c))[2:].zfill(8)
  return bs

def str2int(ss):
  &quot;&quot;&quot;
    Transform a string (e.g. &#039;Hello&#039;) into a (long) integer by converting
    first to a bistream
  &quot;&quot;&quot;
  bs = str2bin(ss)
  li = int(bs, 2)
  return li

def hex2bin(hs):
  &quot;&quot;&quot;
    Transform a hex string (e.g. &#039;a2&#039;) into a string of bits (e.g.10100010)
  &quot;&quot;&quot;
  bs = &#039;&#039;
  for c in hs:
    bs = bs + bin(int(c,16))[2:].zfill(4)
  return bs

def bin2hex(bs):
  &quot;&quot;&quot;
    Transform a bit string into a hex string
  &quot;&quot;&quot;
  bv = int(bs,2)
  return int2hexstring(bv)

def byte2bin(bval):
  &quot;&quot;&quot;
    Transform a byte (8-bit) value into a bitstring
  &quot;&quot;&quot;
  return bin(bval)[2:].zfill(8)

def int2hexstring(bval):
  &quot;&quot;&quot;
    Transform an int value into a hexstring (even number of characters)
  &quot;&quot;&quot;
  hs = hex(bval)[2:]
  lh = len(hs)
  return hs.zfill(lh + lh%2)

def get_index(a, x):
  &#039;Locate the leftmost value exactly equal to x in list a&#039;
  i = bisect.bisect_left(a, x)
  if i != len(a) and a[i] == x:
    return i
  else:
    return -1

def des_enc(k, m):
  &quot;&quot;&quot;
  Encrypt a message m with a key k using DES as follows:
  c = DES(k, m)

  Args:
    m should be a bytestring (i.e. a sequence of characters such as &#039;Hello&#039; or &#039;\x02\x04&#039;)
    k should be a bytestring of length exactly 8 bytes.

  Note that for DES the key is given as 8 bytes, where the last bit of
  each byte is just a parity bit, giving the actual key of 56 bits, as expected for DES.
  The parity bits are ignored.

  Return:
    The bytestring ciphertext c
  &quot;&quot;&quot;
  d = DES.new(k)
  c = d.encrypt(m)

  return c

def des_dec(k, c):
  &quot;&quot;&quot;
  Decrypt a message c with a key k using DES as follows:
  m = DES(k, c)

  Args:
    c should be a bytestring (i.e. a sequence of characters such as &#039;Hello&#039; or &#039;\x02\x04&#039;)
    k should be a bytestring of length exactly 8 bytes.

  Note that for DES the key is given as 8 bytes, where the last bit of
  each byte is just a parity bit, giving the actual key of 56 bits, as expected for DES.
  The parity bits are ignored.

  Return:
    The bytestring plaintext m
  &quot;&quot;&quot;
  d = DES.new(k)
  m = d.decrypt(c)

  return m
  
def main():

  # Exercitiu pentru test des2_enc
  key1 = &#039;Smerenie&#039;
  key2 = &#039;Dragoste&#039;
  m1_given = &#039;Fericiti cei saraci cu duhul, ca&#039;
  c1 = &#039;cda98e4b247612e5b088a803b4277710f106beccf3d020ffcc577ddd889e2f32&#039;
  # TODO: implement des2_enc and des2_dec
  m1 = des2_dec(key1, key2, c1.decode(&#039;hex&#039;))

  print &#039;ciphertext: &#039; + c1
  print &#039;plaintext: &#039; + m1
  print &#039;plaintext in hexa: &#039; + m1.encode(&#039;hex&#039;)

  # TODO: run meet-in-the-middle attack for the following plaintext/ciphertext
  m1 = &#039;Pocainta&#039;
  c1 = &#039;9f98dbd6fe5f785d&#039; # in hex string
  m2 = &#039;Iertarea&#039;
  c2 = &#039;6e266642ef3069c2&#039;
  
  # Note: you only need to search for the first 2 bytes of the each key:
  k1 = &#039;??oIkvH5&#039;
  k2 = &#039;??GK4EoU&#039;



if __name__ == &quot;__main__&quot;:
  main()</pre>

</div>
<!-- EDIT4 SECTION "Exercise 3" [556-] --></div>
</body>
</html>
