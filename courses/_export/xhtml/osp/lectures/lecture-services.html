    
    

<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
  <meta charset="utf-8" />
  <title>osp:lectures:lecture-services</title>
<meta name="generator" content="DokuWiki"/>
<meta name="robots" content="index,follow"/>
<meta name="date" content="2016-11-06T18:55:37+0200"/>
<meta name="keywords" content="osp,lectures,lecture-services"/>
<link rel="search" type="application/opensearchdescription+xml" href="../../../../lib/exe/opensearch.php" title="CS Open CourseWare"/>
<link rel="start" href="../../../../../courses.1.html"/>
<link rel="alternate" type="application/rss+xml" title="Recent Changes" href="../../../../feed.php"/>
<link rel="alternate" type="application/rss+xml" title="Current Namespace" href="../../../../feed.php%3Fmode=list&amp;ns=osp:lectures"/>
<link rel="alternate" type="text/html" title="Plain HTML" href="lecture-services.html"/>
<link rel="canonical" href="../../../../osp/lectures/lecture-services.html"/>
<link rel="stylesheet" type="text/css" href="../../../../lib/exe/css.php%3Ft=arctic&amp;tseed=1476798676.css"/>
<script type="text/javascript">/*<![CDATA[*/var NS='osp:lectures';var JSINFO = {"id":"osp:lectures:lecture-services","namespace":"osp:lectures","isadmin":0,"isauth":0};
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="../../../../lib/exe/js.php%3Ftseed=1476798676"></script>
<script type="text/x-mathjax-config">/*<![CDATA[*/MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ["$","$"], ["\\(","\\)"] ],
        displayMath: [ ["$$","$$"], ["\\[","\\]"] ],
        processEscapes: true
    }
});
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
<script type="text/javascript">/*<![CDATA[*/
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
		  
/*!]]>*/</script>
<script type="text/javascript">/*<![CDATA[*/
var pageTracker = _gat._getTracker("UA-38383934-1");
pageTracker._initData();
pageTracker._trackPageview();
		  
/*!]]>*/</script>
</head>
<body>
<div class="dokuwiki export">
<!-- TOC START -->
<div id="dw__toc">
<h3 class="toggle">Table of Contents</h3>
<div>

<ul class="toc">
<li class="level2"><div class="li"><a href="lecture-services.html#android_services">04 - Android Services</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="lecture-services.html#lecture">Lecture</a></div></li>
<li class="level3"><div class="li"><a href="lecture-services.html#practical">Practical</a></div>
<ul class="toc">
<li class="level4"><div class="li"><a href="lecture-services.html#resources">Resources</a></div></li>
<li class="level4"><div class="li"><a href="lecture-services.html#files">Files</a></div></li>
<li class="level4"><div class="li"><a href="lecture-services.html#task_1_-_creating_a_started_service_3p">Task 1 - Creating a started service (3p)</a></div></li>
<li class="level4"><div class="li"><a href="lecture-services.html#task_2_-_running_a_foreground_service_3p">Task 2 - Running a foreground service (3p)</a></div></li>
<li class="level4"><div class="li"><a href="lecture-services.html#task_3_-_moving_from_started_service_to_bounded_service_4p">Task 3 - Moving from started service to bounded service (4p)</a></div></li>
<li class="level4"><div class="li"><a href="lecture-services.html#bonustask_4_-_connecting_to_a_bounded_service_from_another_application_4p">Bonus: Task 4 - Connecting to a bounded service from another application (4p)</a></div></li>
</ul></li>
</ul></li>
</ul>
</div>
</div>
<!-- TOC END -->

<h2 class="sectionedit1" id="android_services">04 - Android Services</h2>
<div class="level2">
<ul>
<li class="level1"><div class="li"> Description: Android Services, Started Services, Bound Services, Messenger, AIDL, Foreground Services</div>
</li>
<li class="level1"><div class="li"> Practical part: </div>
</li>
</ul>

</div>
<!-- EDIT1 SECTION "04 - Android Services" [1-164] -->
<h3 class="sectionedit2" id="lecture">Lecture</h3>
<div class="level3">
<ul>
<li class="level1"><div class="li"><a href="../../../../_media/osp/lectures/lecture-services.pdf" class="media mediafile mf_pdf" title="osp:lectures:lecture-services.pdf (836.7 KB)"> Lecture Slides</a></div>
</li>
<li class="level1"><div class="li"><a href="../../../../_media/osp/lectures/4.services_notes.pdf" class="media mediafile mf_pdf" title="osp:lectures:4.services_notes.pdf (67.8 KB)"> Lecture Notes</a></div>
</li>
</ul>

<p>
<iframe title="" src="../../../../_media/osp/lectures/lecture-services.pdf" style="width:98%; height:400px"></iframe>
</p>

</div>
<!-- EDIT2 SECTION "Lecture" [165-382] -->
<h3 class="sectionedit3" id="practical">Practical</h3>
<div class="level3">

</div>

<h4 id="resources">Resources</h4>
<div class="level4">

</div>

<h4 id="files">Files</h4>
<div class="level4">
<ul>
<li class="level1"><div class="li"> <a href="../../../../_media/osp/media/lab3.zip" class="media mediafile mf_zip" title="osp:media:lab3.zip (658 B)">lab3.zip</a></div>
</li>
</ul>

</div>

<h4 id="task_1_-_creating_a_started_service_3p">Task 1 - Creating a started service (3p)</h4>
<div class="level4">

<p>
Create a new project with a blank main Activity. Add an EditText, a Button and a TextView to the Activity&#039;s layout. From the lab files, add the <code>PiComputer.java</code> class to your project. This class computes the number <code>PI</code> with variable precisions using the <a href="https://en.wikipedia.org/wiki/Vi%C3%A8te%27s_formula" class="urlextern" title="https://en.wikipedia.org/wiki/Vi%C3%A8te%27s_formula"  rel="nofollow">Viete series</a>. Your first task is to create a started service that will receive a value for the precision, will create an instance of the <code>PiComputer</code> class giving it the received precision value and call the <code>compute()</code> method, retrieving the result. 
</p>

<p>
Use the EditText to allow the user to input the precision and, when the user clicks the Button call <code>startService(Intent)</code> putting the precision value as an Extra in the Intent.
</p>

<p>
Create a new class in your project that will extend the <code>Service</code> Android class. Add the new service to the <code>AndroidManifest.xml</code> file. Within the service, override the <code>onStartCommand()</code> method and, if the received intent has the precision value extra, trigger the computing mechanism. We will consider that computing the value of <code>PI</code> is a computationally intensive operation. Therefore, the <code>compute</code> method should be called from a separate thread (Hint: <a href="http://developer.android.com/reference/android/os/AsyncTask.html" class="urlextern" title="http://developer.android.com/reference/android/os/AsyncTask.html"  rel="nofollow">AsyncTask</a>).
</p>
<pre class="code">  AsyncTask&lt;Integer, Void, Double&gt; task = new AsyncTask&lt;Integer, Void, Double&gt;() {
            @Override
            protected Double doInBackground(Integer... params) {
               // Here you will have to compute the PI number
            }


            @Override
            protected void onPostExecute(Double aDouble) {
               // Here a broadcast will be launched to notify the computed result to the MainActivity
            }
        };</pre>

<p>
In order for the service to send the answer back to the Activity, create a <code>BroadcastReceiver</code> instance and, within it&#039;s <code>onReceive()</code> method, update the TextView within the Activity using the value in the <code>Intent</code> parameter. Then, create a new <code>IntentFilter</code> with a custom action and register the receiver with the newly created <code>IntentFilter</code>:
</p>
<pre class="code">BroadcastReceiver mReceiver = new BroadcastReceiver() {
  @Override
  public void onReceive(Context context, Intent intent){
    // get the value for PI from the intent
    // and set it as the TextView&#039;s text
  }
};

IntentFilter filter = new IntentFilter();
filter.addAction(customActionString);

registerReceiver(mReceiver, filter);</pre>

<p>
Since we don&#039;t want to have the receiver registered after the Activity has been destroyed, override the <code>onDestroy()</code> method and unregister the receiver:
</p>
<pre class="code">public class MainActivity extends Activity {
  ...
  @Override
  public void onDestroy() {
    super.onDestroy();
    
    unregisterReceiver(mReceiver);
  }
}</pre>

<p>
From the service, after the thread has finished computing the value for <code>PI</code> create a new <code>Intent</code>, put the value as an extra and call <code>sendBroadcast()</code>:
</p>
<pre class="code">Intent i = new Intent();
// set the action of the intent to the one you previously used in the Activity
i.setAction(customActionString);
//put the computed value of PI as an extra
i.putExtra(&quot;pi_value_extra&quot;, String.valueOf(computedPi));

sendBroadcast(i);</pre>

</div>

<h4 id="task_2_-_running_a_foreground_service_3p">Task 2 - Running a foreground service (3p)</h4>
<div class="level4">

<p>
We want to have a new service notifying the user that our application is online, providing with a always-present notification which can be used to access the app at any time.
</p>

<p>
For this, create a new class that also extends <code>Service</code> and add it to the <code>AndroidManifest.xml</code> accordingly. Override the <code>onStartCommand()</code> method of the newly created service. If the intent action is “start_foreground” then show the notification and if the intent action is “stop_foreground” hide the notification.
</p>

<p>
The first step in creating a <code>Notification</code> is to construct an Intent which will be used to direct the user to the main Activity:
</p>
<pre class="code">Intent i = new Intent(this, MainActivity.class);</pre>

<p>
Next, you need to create a <code>PendingIntent</code> using the <code>PendingIntent.getActivity()</code> method to which you will provide the previously created <code>Intent</code>:
</p>
<pre class="code">PendingIntent pending = PendingIntent.getActivity(this, 0, i, 0);</pre>

<p>
Finally, you can construct the <code>Notification</code> instance using the <code>Notification.Builder</code> factory:
</p>
<pre class="code">Notification.Builder notifBuilder = new Notification.Builder(this);</pre>

<p>
Set the icon and the content text on the notification appropriately (the icon should usually be your app&#039;s icon and the text can be any String that you find is informative of the running state of the app). Afterwards, set the content intent on the notification so that, when the user clicks it, the pending intent you created earlier is called:
</p>
<pre class="code">notifBuilder.setContentIntent(pending);</pre>

<p>
Having set all required elements for the notification you can call the builder&#039;s <code>build()</code> method and get the notification:
</p>
<pre class="code">Notification notification = notifBuilder.build();</pre>

<p>
Now, depending on the action of the intent sent as a parameter to the <code>onStartCommand()</code> method call <code>startForeground()</code> or <code>stopForeground</code>:
</p>

<p>
In the main Activity, add two more buttons, one used to show the notification and the other one to hide it. On each Button click create an intent, set the appropriate action and call <code>startService(intent)</code>.
</p>

</div>

<h4 id="task_3_-_moving_from_started_service_to_bounded_service_4p">Task 3 - Moving from started service to bounded service (4p)</h4>
<div class="level4">

<p>
We now want to compute the value of <code>PI</code> using a bounded service instead of a started one. Therefore, create a third service and add it to the <code>AndroidManifest.xml</code>. Within this service&#039;s class declare an inner class that extends <code>Binder</code>. Add a method to the class that returns the current instance of the service class:
</p>
<pre class="code">public class BoundService extends Service {
  ...
  public class MyBinder extends Binder {
    BoundService getService() {
      return BoundService.this;
    }
  }
}</pre>

<p>
Since the <code>Binder</code> class returns the service instance, create a method for computing <code>PI</code> within the service:
</p>
<pre class="code">public void computePi(int precision, final Handler callback) {
  ...
}</pre>

<p>
Within this method compute the value of <code>PI</code> on a separate thread using the given precision. When the thread has finished and you have obtained the computed value, use the <code>Handler</code> object to obtain a <code>Message</code>, create a new <code>Bundle</code> object, add the value to it and send the <code>Message</code>:
</p>
<pre class="code">// after the value of PI has been computed
Message msg = callback.obtainMessage();

Bundle args = new Bundle();
args.putDouble(&quot;pi_value&quot;, value);
msg.setData(args);

msg.sendToTarget();</pre>

<p>
Add a new service member variable to the Activity class and also a <code>ServiceConnection</code> member variable, which you must also implement:
</p>
<pre class="code">public class MainActivity extends Activity {
  private BoundService mService;
  ...
  ServiceConnection mConnection = new ServiceConnection() {
    @Override
    public void onServiceConnected(ComponentName component, IBinder service) {
      MyBinder mBinder = (MyBinder)service;
      mService = mBinder.getService();
    }
    ...
  };
}</pre>

<p>
In the Activity&#039;s <code>onCreate()</code> method you need to bind to the service using the <code>ServiceConnection</code> member variable:
</p>
<pre class="code">Intent i = new Intent(this, BoundService.class);
bindService(i, mConnection, Context.BIND_AUTO_CREATE);</pre>

<p>
Since the service&#039;s compute method requires a <code>Handler</code> in order to send the result of the computation, create the Handler instance as well:
</p>
<pre class="code">Handler mHandler = new Handler() {
  @Override
  public void handleMessage(Message msg) {
    Bundle data = msg.getData();
    // if the data has the &quot;pi_value&quot; key, retrieve it
    // and set it as the text of the TextView element
  }
};</pre>

<p>
Add a <code>Button</code> to the Activity, which on click will check if the service member variable is not null and call the <code>BoundService.computePi()</code> method:
</p>
<pre class="code">if (mService != null) {
  mService.computePi(precision, mHandler);
}</pre>

<p>
Since we won&#039;t need the service after the Activity has been destroyed, call <code>unbindService()</code> in the <code>onDestroy()</code> method:
</p>
<pre class="code">@Override
public void onDestroy() {
  ...
  unbindService(mConnection);
}</pre>

</div>

<h4 id="bonustask_4_-_connecting_to_a_bounded_service_from_another_application_4p">Bonus: Task 4 - Connecting to a bounded service from another application (4p)</h4>
<div class="level4">

<p>
We now want to make a fourth service that will expose the <code>PiComputer</code> mechanism to external applications. Create a <code>IExtService.aidl</code> file in the <code>src/</code> folder of your application, within the same package as all other services. Within the <code>.aidl</code> file we will declare an interface which will be used by the system to allow external applications access to our internal service&#039;s functionality:
</p>
<pre class="code">package ndk.lab4.picomputer; // this is just an example, use the package name you have within your app

interface IExtService {
  double computePi(int precision);
}</pre>

<p>
Now, create a fourth service(you can call it <code>ExtService</code> for consistency) in your app and add it to the <code>AndroidManifest.xml</code>. When declaring the service add an <code>android:exported</code> field in the XML element. Also, add an <code>&lt;intent-filter&gt;</code> child element:
</p>
<pre class="code">&lt;service
    android:name=&quot;.ExtService&quot;
    android:exported=&quot;true&quot;&gt;
    &lt;intent-filter&gt;
        &lt;action android:name=&quot;ndk.lab4.picompute&quot;/&gt;
    &lt;/intent-filter&gt;
&lt;/service&gt;</pre>

<p>
Within the service implement the <code>IExtService.Stub</code> interface as a member variable and return the instance from the service&#039;s <code>onBind()</code> method.
</p>

<p>
Create a new Android application that will act as a client for the service exposed by the first application. In this new application&#039;s main Activity layout put an EditText, a Button and a TextView. The EditText will be used to allow the user to input the desired precision, the TextView will display the result and the Button&#039;s click will trigger the call to the remote service.
</p>

<p>
Copy the <code>.aidl</code> file from the first application to the new one&#039;s <code>src/</code> folder. Do not change the package name in the <code>.aidl</code> file, but instead create a package name in the second app that corresponds to the one in the app providing the service.
</p>

<p>
In the MainActivity retain a member variable to the <code>IExtService</code> and create a local <code>ServiceConnection</code>. When implementing the <code>ServiceConnection.onServiceConnected()</code> method, get a reference to the remote <code>IExtService</code> using the <code>IExtService.Stub.asInterface(IBinder)</code> construct.
</p>

<p>
To connect to the remote service create an <code>Intent</code> variable, set the package to be the one of your original app and the action to be the one declared in that app&#039;s <code>AndroidManifest.xml</code>:
</p>
<pre class="code">Intent i = new Intent();
i.setPackage(origAppPackageName);
i.setAction(remoteServiceAction);</pre>

<p>
Afterwards, you can call <code>bindService()</code> using the intent and the previously declared <code>ServiceConnection</code> instance. Now, when you want to compute the value of <code>PI</code> in the second application, call the <code>mRemoteService.compute()</code> method.
</p>

</div>
<!-- EDIT3 SECTION "Practical" [383-] --></div>
</body>
</html>
