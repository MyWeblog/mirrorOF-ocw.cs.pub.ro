    
    

<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
  <meta charset="utf-8" />
  <title>iocla:laboratoare:laborator-05</title>
<meta name="generator" content="DokuWiki"/>
<meta name="robots" content="index,follow"/>
<meta name="date" content="2016-11-06T12:22:27+0200"/>
<meta name="keywords" content="iocla,laboratoare,laborator-05"/>
<link rel="search" type="application/opensearchdescription+xml" href="../../../../lib/exe/opensearch.php" title="CS Open CourseWare"/>
<link rel="start" href="../../../../../courses.1.html"/>
<link rel="alternate" type="application/rss+xml" title="Recent Changes" href="../../../../feed.php"/>
<link rel="alternate" type="application/rss+xml" title="Current Namespace" href="../../../../feed.php%3Fmode=list&amp;ns=iocla:laboratoare"/>
<link rel="alternate" type="text/html" title="Plain HTML" href="laborator-05.html"/>
<link rel="canonical" href="../../../../iocla/laboratoare/laborator-05.html"/>
<link rel="stylesheet" type="text/css" href="../../../../lib/exe/css.php%3Ft=arctic&amp;tseed=1476798676.css"/>
<script type="text/javascript">/*<![CDATA[*/var NS='iocla:laboratoare';var JSINFO = {"id":"iocla:laboratoare:laborator-05","namespace":"iocla:laboratoare","isadmin":0,"isauth":0};
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="../../../../lib/exe/js.php%3Ftseed=1476798676"></script>
<script type="text/x-mathjax-config">/*<![CDATA[*/MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ["$","$"], ["\\(","\\)"] ],
        displayMath: [ ["$$","$$"], ["\\[","\\]"] ],
        processEscapes: true
    }
});
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
<script type="text/javascript">/*<![CDATA[*/
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
		  
/*!]]>*/</script>
<script type="text/javascript">/*<![CDATA[*/
var pageTracker = _gat._getTracker("UA-38383934-1");
pageTracker._initData();
pageTracker._trackPageview();
		  
/*!]]>*/</script>
</head>
<body>
<div class="dokuwiki export">
<!-- TOC START -->
<div id="dw__toc">
<h3 class="toggle">Table of Contents</h3>
<div>

<ul class="toc">
<li class="level1"><div class="li"><a href="laborator-05.html#laborator_05structuri_vectori_explorarea_memoriei">Laborator 05: Structuri, vectori, explorarea memoriei</a></div>
<ul class="toc">
<li class="level2"><div class="li"><a href="laborator-05.html#structuri">Structuri</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="laborator-05.html#declararea_unei_structuri">Declararea unei structuri</a></div></li>
<li class="level3"><div class="li"><a href="laborator-05.html#instantierea_unei_structuri">Instanțierea unei structuri</a></div></li>
<li class="level3"><div class="li"><a href="laborator-05.html#alocarea_dinamica_a_unei_structuri">Alocarea dinamică a unei structuri</a></div></li>
<li class="level3"><div class="li"><a href="laborator-05.html#accesarea_valorilor_dintr-o_structura">Accesarea valorilor dintr-o structură</a></div></li>
</ul>
</li>
<li class="level2"><div class="li"><a href="laborator-05.html#vectori">Vectori</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="laborator-05.html#declararea_unui_vector">Declararea unui vector</a></div></li>
<li class="level3"><div class="li"><a href="laborator-05.html#instructiuni_de_operare_pe_siruri">Instrucțiuni de operare pe șiruri</a></div>
<ul class="toc">
<li class="level4"><div class="li"><a href="laborator-05.html#movs_move_data_from_string_to_string">MOVS (Move data from string to string)</a></div></li>
<li class="level4"><div class="li"><a href="laborator-05.html#cmps_compare_strings">CMPS (Compare strings)</a></div></li>
<li class="level4"><div class="li"><a href="laborator-05.html#scas_scan_string">SCAS (Scan string)</a></div></li>
<li class="level4"><div class="li"><a href="laborator-05.html#lods_load_from_string">LODS (Load from string)</a></div></li>
<li class="level4"><div class="li"><a href="laborator-05.html#stos_store_to_string">STOS (Store to string)</a></div></li>
</ul>
</li>
</ul>
</li>
<li class="level2"><div class="li"><a href="laborator-05.html#vectori_de_structuri">Vectori de structuri</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="laborator-05.html#declararea_unui_vector_de_structuri">Declararea unui vector de structuri</a></div></li>
<li class="level3"><div class="li"><a href="laborator-05.html#parcurgerea_unui_vector_de_structuri">Parcurgerea unui vector de structuri</a></div></li>
</ul>
</li>
<li class="level2"><div class="li"><a href="laborator-05.html#explorarea_memoriei">Explorarea memoriei</a></div></li>
<li class="level2"><div class="li"><a href="laborator-05.html#tutoriale_si_exercitii">Tutoriale și exerciții</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="laborator-05.html#p_1_tutorialafisare_a_continutului_unei_structuri">[1p] 1. Tutorial: Afișare a conținutului unei structuri</a></div></li>
<li class="level3"><div class="li"><a href="laborator-05.html#p_2_modificare_a_unei_structuri">[1.5p] 2. Modificare a unei structuri</a></div></li>
<li class="level3"><div class="li"><a href="laborator-05.html#p_3_tutorialalocare_a_unei_structuri_pe_stiva">[1p] 3. Tutorial: Alocare a unei structuri pe stivă</a></div></li>
<li class="level3"><div class="li"><a href="laborator-05.html#p_4_alocare_a_campurilor_unei_structuri_pe_stiva">[1.5p] 4. Alocare a câmpurilor unei structuri pe stivă</a></div></li>
<li class="level3"><div class="li"><a href="laborator-05.html#p_5_tutorialprelucrare_a_unei_structuri">[0.5p] 5. Tutorial: Prelucrare a unei structuri</a></div></li>
<li class="level3"><div class="li"><a href="laborator-05.html#p_6_prelucrare_a_unei_structuri">[2p] 6. Prelucrare a unei structuri</a></div></li>
<li class="level3"><div class="li"><a href="laborator-05.html#p_7_tutorialpopulare_a_unui_vector_de_structuri">[1p] 7. Tutorial: Populare a unui vector de structuri</a></div></li>
<li class="level3"><div class="li"><a href="laborator-05.html#p_8_alocare_si_populare_unui_vector_de_structuri">[1.5p] 8. Alocare și populare unui vector de structuri</a></div></li>
<li class="level3"><div class="li"><a href="laborator-05.html#p_9_bonusalocare_pe_stiva">[1.5p] 9. Bonus: Alocare pe stivă</a></div></li>
<li class="level3"><div class="li"><a href="laborator-05.html#p_10_bonuscautarea_unui_subsir_intr-un_sir">[1.5p] 10. Bonus: Căutarea unui subșir într-un șir</a></div></li>
<li class="level3"><div class="li"><a href="laborator-05.html#p_11_bonuslista_simplu_inlantuita">[1p] 11. Bonus: Listă simplu înlănțuită</a></div></li>
</ul></li>
</ul></li>
</ul>
</div>
</div>
<!-- TOC END -->

<h1 class="sectionedit1" id="laborator_05structuri_vectori_explorarea_memoriei">Laborator 05: Structuri, vectori, explorarea memoriei</h1>
<div class="level1">

<p>
În acest laborator vom introduce noțiunea de structură din limbajul assembly, vom lucra cu operații specializate pe șiruri și vom vedea câteva avantaje – legate de securitate și debugging – a explorării memoriei.
</p>

</div>
<!-- EDIT1 SECTION "Laborator 05: Structuri, vectori, explorarea memoriei" [1-294] -->
<h2 class="sectionedit2" id="structuri">Structuri</h2>
<div class="level2">

<p>
Structurile sunt folosite pentru a grupa date care au tipuri diferite, dar care pot fi folosite împreună pentru a crea un tip compus.
</p>

<p>
În continuare vom trece prin pașii necesari pentru a folosi o structură: declararea, instanțierea și accesarea câmpurilor unei structuri.
</p>

</div>
<!-- EDIT2 SECTION "Structuri" [295-599] -->
<h3 class="sectionedit3" id="declararea_unei_structuri">Declararea unei structuri</h3>
<div class="level3">

<p>
În NASM, o structură se declară folosind construcția <code>struc &lt;nume structura&gt;</code>, urmată de o listă de câmpuri și încheiată cu <code>endstruc</code>.
</p>

<p>
Fiecare câmp al structurii este definit prin următoarele: o etichetă (folosită pentru a putea accesa membrii), specificatorul de tip și numărul de elemente.
</p>

<p>
Exemplu:
</p>
<pre class="code asm"><span class="kw5">struc</span> mystruct
    a<span class="sy1">:</span>    <span class="kw5">resw</span> <span class="nu0">1</span>    <span class="co1">; a va referi un singur element de dimensiune un cuvânt</span>
    b<span class="sy1">:</span>    <span class="kw5">resd</span> <span class="nu0">1</span>    <span class="co1">; b va referi un singur element de dimensiune un dublu cuvânt</span>
    c<span class="sy1">:</span>    <span class="kw5">resb</span> <span class="nu0">1</span>    <span class="co1">; c va referi un singur element de dimensiune un octet</span>
    d<span class="sy1">:</span>    <span class="kw5">resd</span> <span class="nu0">1</span>    <span class="co1">; d va referi un singur element de dimensiune un dublu cuvânt</span>
    e<span class="sy1">:</span>    <span class="kw5">resb</span> <span class="nu0">6</span>    <span class="co1">; e va referi 6 elemente de dimensiune un octet</span>
<span class="kw5">endstruc</span></pre>

<p>
<p><div class="noteclassic">
Aici sunt folosite pseudo-instrucțiunile NASM din familia <code>res</code> pentru a defini tipul de date și numărul de elemente pentru fiecare dintre câmpurile structurii. Pentru mai multe detalii despre sintaxa <code>res</code> urmați acest link: 
<a href="http://www.nasm.us/doc/nasmdoc3.html#section-3.2.2" class="urlextern" title="http://www.nasm.us/doc/nasmdoc3.html#section-3.2.2"  rel="nofollow">http://www.nasm.us/doc/nasmdoc3.html#section-3.2.2</a>

</div></p>
</p>

<p>
Fiecare etichetă ce definește un câmp reprezintă offset-ul câmpului în cadrul structurii. De exemplu, <code>b</code> va avea valoarea 2, deoarece sunt 2 octeți de la începutul structurii până la câmpul <code>b</code> (primii 2 octeți sunt ocupați de cuvântul <code>a</code>).
</p>

<p>
<p><div class="notewarning">
Dacă doriți să folosiți același nume de câmp în două structuri diferite, trebuie să prefixați numele etichetei cu <code>.</code> (dot) astfel:
</p>
<pre class="code asm"><span class="kw5">struc</span> mystruct1
    <span class="sy1">.</span>a<span class="sy1">:</span>    <span class="kw5">resw</span>	<span class="nu0">1</span>
    <span class="sy1">.</span>b<span class="sy1">:</span>    <span class="kw5">resd</span>	<span class="nu0">1</span>
<span class="kw5">endstruc</span>
&nbsp;
<span class="kw5">struc</span> mystruct2
    <span class="sy1">.</span>a<span class="sy1">:</span>    <span class="kw5">resd</span>	<span class="nu0">16</span>
    <span class="sy1">.</span>b<span class="sy1">:</span>    <span class="kw5">resw</span>	<span class="nu0">1</span>
<span class="kw5">endstruc</span></pre>

<p>
Folosiți contrucția <code>mystruct2.b</code> pentru aflarea valorii offset-ului lui &#039;b&#039; din cadrul structurii mystruct2.

</div></p>
</p>

</div>
<!-- EDIT3 SECTION "Declararea unei structuri" [600-2383] -->
<h3 class="sectionedit4" id="instantierea_unei_structuri">Instanțierea unei structuri</h3>
<div class="level3">

<p>
O primă variantă pentru a avea o structură în memorie este de a declara-o static în secțiunea <code>.data</code>. Sintaxa folosește macro-urile NASM <code>istruc</code> și <code>iend</code> și keyword-ul <code>at</code>.
</p>

<p>
În exemplul următor este prezentată instanțierea statică a structurii declarate mai sus, unde <code>struct_var</code> este adresa din memorie de unde încep datele.
</p>
<pre class="code asm">struct_var<span class="sy1">:</span>
    <span class="kw5">istruc</span> mystruct
        <span class="kw5">at</span> a<span class="sy1">,</span> <span class="kw5">dw</span>        <span class="sy1">-</span><span class="nu0">1</span>
        <span class="kw5">at</span> b<span class="sy1">,</span> <span class="kw5">dd</span>        <span class="nu0">0x12345678</span>
        <span class="kw5">at</span> c<span class="sy1">,</span> <span class="kw5">db</span>        <span class="st0">' '</span>
        <span class="kw5">at</span> d<span class="sy1">,</span> <span class="kw5">dd</span>        <span class="nu0">23</span>
        <span class="kw5">at</span> e<span class="sy1">,</span> <span class="kw5">db</span>        <span class="st0">'Gary'</span><span class="sy1">,</span> <span class="nu0">0</span>
    <span class="kw5">iend</span></pre>

<p>
<p><div class="notewarning">
Pentru a nu inițializa valorile membrilor greșit, va trebui să aveți grijă ca pentru fiecare câmp, tipul de date din instanțiere să corespundă tipului din declarare.

</div></p>
</p>

</div>
<!-- EDIT4 SECTION "Instanțierea unei structuri" [2384-3191] -->
<h3 class="sectionedit5" id="alocarea_dinamica_a_unei_structuri">Alocarea dinamică a unei structuri</h3>
<div class="level3">

<p>
Pentru a aloca dinamic o structură vom folosi un apel al funcției <code>malloc</code>. Va trebui să cunoaștem dinainte dimensiunea structurii. În cazul exemplului nostru, o instanțiere a structurii are 17 octeți.
</p>

<p>
În primul rând vom avea în secțiunea <code>.data</code> dimensiunea structurii și pointer-ul care va fi setat la valoarea pe care o va întoarce <code>malloc</code>.
</p>
<pre class="code asm"><span class="kw5">section</span> <span class="kw5">.data</span>
    struct_size<span class="sy1">:</span>   <span class="kw5">dd</span> <span class="nu0">17</span>
    struct_ptr<span class="sy1">:</span>    <span class="kw5">dd</span> <span class="nu0">0</span></pre>

<p>
La un moment dat, în secțiunea <code>.text</code> vom avea apelul <code>malloc(17)</code> care va aloca memorie de pe heap și va întoarce adresa de început a zonei alocate.
</p>
<pre class="code asm">    <span class="kw1">mov</span> <span class="kw4">eax</span><span class="sy1">,</span> <span class="br0">&#91;</span>struct_size<span class="br0">&#93;</span>       <span class="co1">; pregătim apelul funcției malloc</span>
    <span class="kw1">push</span> <span class="kw4">eax</span>
    <span class="kw1">call</span> malloc
    <span class="kw1">mov</span> <span class="kw6">dword</span> <span class="br0">&#91;</span>struct_ptr<span class="br0">&#93;</span><span class="sy1">,</span> <span class="kw4">eax</span>  <span class="co1">; salvăm adresa întoarsă de malloc</span>
    <span class="kw1">add</span> <span class="kw4">esp</span><span class="sy1">,</span> <span class="nu0">4</span></pre>

</div>
<!-- EDIT5 SECTION "Alocarea dinamică a unei structuri" [3192-4052] -->
<h3 class="sectionedit6" id="accesarea_valorilor_dintr-o_structura">Accesarea valorilor dintr-o structură</h3>
<div class="level3">

<p>
Pentru a accesa și/sau modifica un anumit membru al structurii instanțiate trebuie să îi cunoaștem adresa. Această adresă se poate obține calculând suma dintre adresa de început a structurii și offset-ul din cadrul structurii al membrului dorit .
</p>

<p>
Următoarea secvență de cod prezintă punerea unei valori în câmpul <code>b</code> al structurii și, ulterior, afișarea valorii acestui câmp.
</p>
<pre class="code asm">    <span class="kw1">mov</span> <span class="kw4">eax</span><span class="sy1">,</span> <span class="nu0">12345</span>
    <span class="kw1">mov</span> <span class="kw6">dword</span> <span class="br0">&#91;</span>struct <span class="sy1">+</span> b<span class="br0">&#93;</span><span class="sy1">,</span> <span class="kw4">eax</span> <span class="co1">; adresa câmpului b este adresa de bază a structurii instanțiate static + offset-ul câmpului (dat de eticheta 'b')</span>
&nbsp;
    <span class="kw1">mov</span> <span class="kw4">ebx</span><span class="sy1">,</span> <span class="kw6">dword</span> <span class="br0">&#91;</span>struct <span class="sy1">+</span> b<span class="br0">&#93;</span> <span class="co1">; punerea valorii din câmpul b în registrul ebx pentru afișare</span>
    PRINT_DEC <span class="nu0">4</span><span class="sy1">,</span> <span class="kw4">ebx</span>
    NEWLINE</pre>

</div>
<!-- EDIT6 SECTION "Accesarea valorilor dintr-o structură" [4053-4824] -->
<h2 class="sectionedit7" id="vectori">Vectori</h2>
<div class="level2">

<p>
Putem considera un vector ca o înșiruire de elemente de același tip, plasate contiguu în memorie. Ați observat ceva similar în laboratoarele trecute când declaram static șiruri de caractere în secțiunea <code>.data</code>.
</p>

</div>
<!-- EDIT7 SECTION "Vectori" [4825-5070] -->
<h3 class="sectionedit8" id="declararea_unui_vector">Declararea unui vector</h3>
<div class="level3">

<p>
În general, datele statice declarate pot fi inițializate sau neinițializate. Diferențierea se face atât prin faptul că la datele inițializate oferim o valoare inițială, dar și prin sintaxa NASM folosită.
</p>

<p>
De exemplu, pentru a declara un vector de 100 de cuvinte inițializate cu valoarea 42, vom folosi construcția:
</p>
<pre class="code asm"><span class="kw5">section</span> <span class="kw5">.data</span>
    myVect<span class="sy1">:</span>    <span class="kw5">times</span> <span class="nu0">100</span>    <span class="kw5">dw</span> <span class="nu0">42</span></pre>

<p>
Pe de altă parte, dacă dorim declararea unui vector de 20 de elemente dublu cuvinte neinițializate, folosim instrucțiuni din familia <code>res</code> astfel:
</p>
<pre class="code asm"><span class="kw5">section</span> <span class="kw5">.bss</span>
    myVect<span class="sy1">:</span>    <span class="kw5">resd</span> <span class="nu0">20</span></pre>

</div>
<!-- EDIT8 SECTION "Declararea unui vector" [5071-5711] -->
<h3 class="sectionedit9" id="instructiuni_de_operare_pe_siruri">Instrucțiuni de operare pe șiruri</h3>
<div class="level3">

<p>
Deoarece operațiile pe vectori sunt des întâlnite în programe, au fost implementate instrucțiuni speciale care facilitează: transferul de date între doi vectori, compararea a doi vectori, găsirea unui element într-un vector, parcurgerea unui vector etc.
</p>

<p>
O instrucțiune pe vectori poate avea un operand sursă, unul destinație, sau pe amândoi. Convențional, șirul sursă se află poziționat în segmentul DS, iar șirul destinație în ES. Mai mult, registrul SI este utilizat ca offset pentru adresa elementului curent din șirul sursă, iar DI este offset pentru șirul destinație.
</p>

<p>
Deși fiecare dintre aceste instrucțiuni care vor fi prezentate în continuare pot fi folosite independent, există o construcție specială pentru a crea bucle, prin prefixarea instrucțiunii de operare pe șiruri cu una dintre următoarele mnemonici:
</p>
<ul>
<li class="level1"><div class="li"> <code>rep</code> - repetă cât timp ECX != 0</div>
</li>
<li class="level1"><div class="li"> <code>repe</code>/<code>repz</code> - repeat while »equal« (ex: repetă până găsim un element diferit în vector)</div>
</li>
<li class="level1"><div class="li"> <code>repne</code>/<code>repnz</code> - repeat while »not equal« (ex: repetă până găsim un element comun în vector)</div>
</li>
</ul>

<p>
Utilizarea unuia dintre aceste prefixe are ca efect repetarea instrucțiunii prin hardware, fapt care duce la o îmbunătățire a performanței (și chiar a memoriei, datorită eliminării surplusului de instrucțiuni ca <code>jmp</code> și <code>cmp</code>). Aceste bucle se numesc și <strong>bucle hardware</strong>.
</p>

<p>
Pe lângă registrele ESI și EDI, instrucțiunile din familia <code>rep</code> mai folosesc următoarele resurse:
</p>
<ul>
<li class="level1"><div class="li"> registrul ECX</div>
</li>
<li class="level2"><div class="li"> flag-ul Zero (ZF) - prin care se verifică condiția de egalitate/inegalitate, în cazul instrucțiunilor <code>repz</code> și <code>repnz</code></div>
</li>
<li class="level2"><div class="li"> flag-ul Direction (DF) - prin care se specifică dacă registrele ESI și EDI se incrementează (DF = 0) sau de decrementează (DF = 1) după fiecare instrucțiune de operare pe șiruri.</div>
</li>
</ul>

<p>
În continuare vor fi prezentate în detaliu instrucțiunile folosite pentru lucrul cu vectori.
</p>

</div>

<h4 id="movs_move_data_from_string_to_string">MOVS (Move data from string to string)</h4>
<div class="level4">

<p>
Se transferă un element (octet/cuvânt/dublu cuvânt) de la sursă (DS:SI) la destinație (ES:DI) și se actualizează ESI și EDI pentru a face referire la următorul element din șir.
</p>

<p>
Utilizată împreună cu prefixul <code>rep</code>, realizează un transfer de bloc memorie-memorie.
</p>

<p>
Dacă instructiunea conține numele operanzilor, asamblorul poate infera tipul șirului; dacă nu, trebuie specificat în mod explicit tipul operației: pe byte, word sau double word.
Astfel, prototipurile posibile pentru această instrucțiune sunt:
</p>
<pre class="code asm">    <span class="kw1">movs</span> &lt;sir_dest&gt;<span class="sy1">,</span> &lt;sir_src&gt;
    <span class="kw1">movsb</span><span class="sy1">,</span> <span class="kw1">movsw</span><span class="sy1">,</span> <span class="kw3">movsd</span></pre>

</div>

<h4 id="cmps_compare_strings">CMPS (Compare strings)</h4>
<div class="level4">

<p>
Instrucțiunea realizează comparația dintre valoarea aflată la EDI și cea aflată la ESI (în această ordine, deci invers față de un CMP normal), și actualizează în mod corespunzător registrul de indicatori.
</p>

<p>
Împreună cu prefixul <code>repe</code>/<code>repz</code>, instrucțiunea determină prima pereche de elemente diferite din cele doua șiruri.
</p>

<p>
Formele in care poate apărea această instrucțiune sunt similare cu instrucțiunea <code>movs</code>:
</p>
<pre class="code asm">    <span class="kw1">cmps</span> &lt;sir_dest&gt;<span class="sy1">,</span> &lt;sir_src&gt;
    <span class="kw1">cmpsb</span><span class="sy1">,</span> <span class="kw1">cmpsw</span><span class="sy1">,</span> <span class="kw3">cmpsd</span></pre>

</div>

<h4 id="scas_scan_string">SCAS (Scan string)</h4>
<div class="level4">

<p>
Această instrucțiune realizează o comparație între elementul curent al sirului destinație (ES:DI) și acumulator (AL/AX/EAX), și actualizează flag-urile. Ce de obicei, sunt actualizate registrele SI și DI.
</p>

<p>
Mnemonici posibile:
</p>
<pre class="code asm">    <span class="kw1">scas</span> &lt;sir_dest&gt;
    <span class="kw1">scasb</span><span class="sy1">,</span> <span class="kw1">scasw</span><span class="sy1">,</span> <span class="kw1">scasd</span></pre>

</div>

<h4 id="lods_load_from_string">LODS (Load from string)</h4>
<div class="level4">

<p>
Instrucțiunea transferă elementul situat la adresa DS:SI în acumulator (AL/AX/EAX), și actualizează SI.
</p>

<p>
Nu are sens ca această instructiune să fie însoțită de prefixul de repetare, deoarece în acumulator ar rămâne numai ultimul element transferat. Din acest motiv, instrucțiunea se folosește numai în bucle soft.
</p>
<pre class="code asm">    <span class="kw1">lods</span> &lt;sir_src&gt;
    <span class="kw1">lodsb</span><span class="sy1">,</span> <span class="kw1">lodsw</span><span class="sy1">,</span> <span class="kw1">lodsd</span></pre>

</div>

<h4 id="stos_store_to_string">STOS (Store to string)</h4>
<div class="level4">

<p>
Instrucțiunea transferă un element din acumulator (AL/AX/EAX) în șirul destinație (adresat de ES:DI), actualizând DI pentru a indica la urmatorul element. Dacă e folosit împreună cu prefixul de repetare, putem inițializa un șir cu o constantă.
</p>
<pre class="code asm">    <span class="kw1">stos</span> &lt;sir_dest&gt;
    <span class="kw1">stosb</span><span class="sy1">,</span> <span class="kw1">stosw</span><span class="sy1">,</span> <span class="kw1">stosd</span></pre>

</div>
<!-- EDIT9 SECTION "Instrucțiuni de operare pe șiruri" [5712-10031] -->
<h2 class="sectionedit10" id="vectori_de_structuri">Vectori de structuri</h2>
<div class="level2">

<p>
Adesea vom avea nevoie de vectori care să conțină elemente de dimensiuni mai mari decât cea a unui cuvânt dublu. Pentru a obține acest lucru vom combina cele două concepte prezentate anterior și vom folosi vectori de structuri. Bineînțeles, instrucțiunile de operare pe șiruri nu vor funcționa, deci vom fi nevoiți să ne întoarcem la metoda clasică de accesare a elementelor: cea prin adresarea explicită a memoriei.
</p>

<p>
Pentru exemplul din această secțiune, creăm o structură ce reprezintă un punct într-un spațiu 2D.
</p>
<pre class="code asm"><span class="kw5">struc</span> point
    <span class="sy1">.</span>x<span class="sy1">:</span>    <span class="kw5">resd</span> <span class="nu0">1</span>
    <span class="sy1">.</span>y<span class="sy1">:</span>    <span class="kw5">resd</span> <span class="nu0">1</span>
<span class="kw5">endstruc</span></pre>

</div>
<!-- EDIT10 SECTION "Vectori de structuri" [10032-10684] -->
<h3 class="sectionedit11" id="declararea_unui_vector_de_structuri">Declararea unui vector de structuri</h3>
<div class="level3">

<p>
Deoarece NASM nu suportă niciun mecanism pentru a declara explicit un vector de structuri, va trebui să declarăm efectiv o zonă de date în care să încapă vectorul nostru.
</p>

<p>
Considerând că ne dorim un vector zeroizat de 100 de elemente de tipul structurii <code>point</code> (care este de dimensiune 8 octeți), trebuie să alocăm 100 * 8 (= 800) octeți.
</p>

<p>
Obținem:
</p>
<pre class="code asm"><span class="kw5">section</span> <span class="kw5">.data</span>
    pointArray<span class="sy1">:</span>    <span class="kw5">times</span> <span class="nu0">800</span>    <span class="kw5">db</span> <span class="nu0">0</span></pre>

<p>
În plus, NASM oferă o alternativă la calculul “de mână” al dimensiunii unei structuri, generând automat macro-ul <code>&lt;nume structura&gt;_size</code>. Astfel, exemplul anterior poate deveni:
</p>
<pre class="code asm"><span class="kw5">section</span> <span class="kw5">.data</span>
    pointArray<span class="sy1">:</span>    <span class="kw5">times</span> point_size <span class="sy1">*</span> <span class="nu0">100</span>    <span class="kw5">db</span> <span class="nu0">0</span></pre>

</div>
<!-- EDIT11 SECTION "Declararea unui vector de structuri" [10685-11440] -->
<h3 class="sectionedit12" id="parcurgerea_unui_vector_de_structuri">Parcurgerea unui vector de structuri</h3>
<div class="level3">

<p>
Cum am mai spus, pentru accesarea câmpului unui element dintr-un vector trebuie să folosim adresarea normală (în particular adresarea “based-indexed with scale”). Formula pentru aflarea adresei elementului este <code>baza_vector + i * dimensiune_struct</code>.
</p>

<p>
Presupunând că avem în registrul <code>ebx</code> adresa de început a vectorului și în <code>eax</code> indicele elementului pe care dorim să îl accesăm, exemplul următor prezintă afișarea valorii câmpului <code>y</code> a acestui element.
</p>
<pre class="code asm">    <span class="kw1">mov</span> <span class="kw4">ebx</span><span class="sy1">,</span> pointArray                         <span class="co1">; mutăm în ebx adresa de început a șirului</span>
    <span class="kw1">mov</span> <span class="kw4">eax</span><span class="sy1">,</span> <span class="nu0">13</span>                                 <span class="co1">; să zicem că vrem al 13-lea element</span>
    <span class="kw1">mov</span> <span class="kw4">edx</span><span class="sy1">,</span> <span class="br0">&#91;</span><span class="kw4">ebx</span> <span class="sy1">+</span> point_size <span class="sy1">*</span> <span class="kw4">eax</span> <span class="sy1">+</span> point<span class="sy1">.</span>y<span class="br0">&#93;</span> <span class="co1">; calcularea adresei câmpului dorit</span>
&nbsp;
    PRINT_UDEC <span class="nu0">4</span><span class="sy1">,</span> <span class="kw4">edx</span>
    NEWLINE</pre>

<p>
Parcurgem vectorul, având la fiecare iterație indicele curent în registrul eax. Putem să afișăm valorile din ambele câmpuri ale fiecărui element din vector cu următorul program:
</p>
<pre class="code asm"><span class="kw5">%include</span> <span class="st0">&quot;io.inc&quot;</span>
&nbsp;
<span class="kw5">struc</span>   point
	<span class="sy1">.</span>x<span class="sy1">:</span> <span class="kw5">resd</span> <span class="nu0">1</span>
	<span class="sy1">.</span>y<span class="sy1">:</span> <span class="kw5">resd</span> <span class="nu0">1</span>
<span class="kw5">endstruc</span>
&nbsp;
<span class="kw5">section</span> <span class="kw5">.data</span>
    pointArray<span class="sy1">:</span> <span class="kw5">times</span> point_size <span class="sy1">*</span> <span class="nu0">100</span> <span class="kw5">db</span> <span class="nu0">0</span>
&nbsp;
<span class="kw5">section</span> <span class="kw5">.text</span>
    <span class="kw5">global</span> CMAIN
&nbsp;
CMAIN<span class="sy1">:</span>                                 
    <span class="kw1">push</span> <span class="kw4">ebp</span>
    <span class="kw1">mov</span> <span class="kw4">ebp</span><span class="sy1">,</span> <span class="kw4">esp</span>
&nbsp;
    <span class="kw1">xor</span> <span class="kw4">edx</span><span class="sy1">,</span> <span class="kw4">edx</span>
    <span class="kw1">xor</span> <span class="kw4">eax</span><span class="sy1">,</span> <span class="kw4">eax</span>
label<span class="sy1">:</span>
    <span class="kw1">mov</span> <span class="kw4">edx</span><span class="sy1">,</span> <span class="br0">&#91;</span>pointArray <span class="sy1">+</span> point_size <span class="sy1">*</span> <span class="kw4">eax</span> <span class="sy1">+</span> point<span class="sy1">.</span>x<span class="br0">&#93;</span> <span class="co1">; accesăm membrul x</span>
    PRINT_UDEC <span class="nu0">4</span><span class="sy1">,</span> <span class="kw4">edx</span>
    PRINT_CHAR <span class="st0">','</span>
&nbsp;
    <span class="kw1">mov</span> <span class="kw4">edx</span><span class="sy1">,</span> <span class="br0">&#91;</span>pointArray <span class="sy1">+</span> point_size <span class="sy1">*</span> <span class="kw4">eax</span> <span class="sy1">+</span> point<span class="sy1">.</span>y<span class="br0">&#93;</span> <span class="co1">; accesăm membrul y</span>
    PRINT_UDEC <span class="nu0">4</span><span class="sy1">,</span> <span class="kw4">edx</span>
    NEWLINE
&nbsp;
    <span class="kw1">inc</span> <span class="kw4">eax</span> <span class="co1">; incrementarea indicelui de iterare  </span>
    <span class="kw1">cmp</span> <span class="kw4">eax</span><span class="sy1">,</span> <span class="nu0">100</span>
    <span class="kw1">jl</span> label
&nbsp;
    <span class="kw1">leave</span>
    <span class="kw1">ret</span></pre>

</div>
<!-- EDIT12 SECTION "Parcurgerea unui vector de structuri" [11441-13111] -->
<h2 class="sectionedit13" id="explorarea_memoriei">Explorarea memoriei</h2>
<div class="level2">

<p>
Explorarea memoriei poate fi necesară în mai multe cazuri, printre care:
</p>
<ul>
<li class="level1"><div class="li"> inspectarea memoriei unui program după un crash al acestuia pentru a determina cauzele crash-ului</div>
</li>
<li class="level2"><div class="li"> inspectarea memoriei pentru a găsi vulnerabilități în program</div>
</li>
<li class="level2"><div class="li"> descoperirea de <em>memory leak</em>-uri</div>
</li>
<li class="level2"><div class="li"> căutarea după o anumită valoare</div>
</li>
</ul>

<p>
Majoritatea utilitarelor de debugging și analiză dinamică (gdb, IDA, radare2) suportă, într-un fel sau altul, explorarea memoriei.
</p>

<p>
Unul dintre scopurile explorării memoriei este să afișăm toate valorile din memorie care încep de la o anumită adresă (și, opțional, se termină la o altă adresă). Un caz practic ar fi să afișăm <em>stack frame</em>-ul curent, adică ce se află între esp și ebp (după alocarea variabilelor locale).
</p>
<pre class="code asm"><span class="kw5">%include</span> <span class="st0">&quot;io.inc&quot;</span>
&nbsp;
<span class="kw5">section</span> <span class="kw5">.text</span>
    <span class="kw5">global</span> CMAIN
CMAIN<span class="sy1">:</span>
    <span class="kw1">push</span> <span class="kw4">ebp</span>
    <span class="kw1">mov</span> <span class="kw4">ebp</span><span class="sy1">,</span> <span class="kw4">esp</span>
&nbsp;
    <span class="kw1">sub</span> <span class="kw4">esp</span><span class="sy1">,</span> <span class="nu0">128</span>    <span class="co1">; (simulare de) alocare de memorie</span>
&nbsp;
    <span class="kw1">xor</span> <span class="kw4">eax</span><span class="sy1">,</span> <span class="kw4">eax</span>
    <span class="kw1">mov</span> <span class="kw4">ebx</span><span class="sy1">,</span> <span class="kw4">esp</span>    <span class="co1">; ebx este interatorul prin memorie</span>
&nbsp;
label<span class="sy1">:</span>
    <span class="kw1">mov</span> <span class="kw4">eax</span><span class="sy1">,</span> <span class="br0">&#91;</span><span class="kw4">ebx</span><span class="br0">&#93;</span>
&nbsp;
    <span class="co1">; afișarea a 4 octeți din memorie</span>
    PRINT_HEX <span class="nu0">4</span><span class="sy1">,</span> <span class="kw4">eax</span>
    NEWLINE
&nbsp;
    <span class="kw1">add</span> <span class="kw4">ebx</span><span class="sy1">,</span> <span class="nu0">4</span>      <span class="co1">; incrementarea adresei pentru a referi la următorii 4 octeți</span>
    <span class="kw1">cmp</span> <span class="kw4">ebx</span><span class="sy1">,</span> <span class="kw4">ebp</span>    <span class="co1">; condiția de terminare</span>
    <span class="kw1">jl</span> label
&nbsp;
    <span class="kw1">leave</span>
    <span class="kw1">ret</span></pre>

<p>
Un alt exemplu relevant este căutarea unei anumite valori într-o zonă de memorie. Pentru a implementa asta putem folosi una dintre instrucțiunile de operare pe șiruri <code>scas</code>, într-o buclă hardware. În următorul exemplu căutarea se face tot în <em>stack-frame</em>-ul curent (între esp și ebp).
</p>
<pre class="code asm"><span class="kw5">%include</span> <span class="st0">&quot;io.inc&quot;</span>
&nbsp;
<span class="kw5">section</span> <span class="kw5">.text</span>
<span class="kw5">global</span> CMAIN
CMAIN<span class="sy1">:</span>
    <span class="kw1">push</span> <span class="kw4">ebp</span>
    <span class="kw1">mov</span> <span class="kw4">ebp</span><span class="sy1">,</span> <span class="kw4">esp</span>
&nbsp;
    <span class="kw1">sub</span> <span class="kw4">esp</span><span class="sy1">,</span> <span class="nu0">16</span>         <span class="co1">; alocare de variabile locale</span>
&nbsp;
    <span class="kw1">mov</span> <span class="kw4">ecx</span><span class="sy1">,</span> <span class="nu0">4</span>          <span class="co1">; numărul de dublu cuvinte dintre esp și ebp (16 / 4 == 4) </span>
    <span class="kw1">mov</span> <span class="kw4">eax</span><span class="sy1">,</span> <span class="nu0">0x12345678</span> <span class="co1">; valoarea căutată</span>
    <span class="kw1">mov</span> <span class="kw4">edi</span><span class="sy1">,</span> <span class="kw4">esp</span>        <span class="co1">; esp este adresa de început a &quot;șirului&quot;</span>
    <span class="kw1">cld</span>                 <span class="co1">; resetarea bit-ului de direcție pentru a avea incrementarea lui DI (DF = 0)</span>
    <span class="kw1">repne</span> <span class="kw1">scasd</span>
    <span class="kw1">jne</span> finish          <span class="co1">; dacă nu a găsit în ecx pași</span>
&nbsp;
    PRINT_STRING <span class="st0">&quot;Found&quot;</span>
finish<span class="sy1">:</span>
    <span class="kw1">leave</span>
    <span class="kw1">ret</span></pre>

<p>
Pe de altă parte, dacă dorim să ignorăm o anumită valoare (spre exemplu 0) putem folosi
</p>
<pre class="code asm">    <span class="kw1">mov</span> <span class="kw4">al</span><span class="sy1">,</span> <span class="nu0">0</span>
    <span class="kw1">repe</span> <span class="kw1">scasb</span>       <span class="co1">; ignoră zero-uri; edi va referi la următoarea adresă după primul element diferit de 0</span>
    <span class="kw1">dec</span> <span class="kw4">edi</span>
    PRINT_HEX <span class="nu0">4</span><span class="sy1">,</span> <span class="kw4">edi</span> <span class="co1">; afișează primul număr diferit de zero</span></pre>

</div>
<!-- EDIT13 SECTION "Explorarea memoriei" [13112-15646] -->
<h2 class="sectionedit14" id="tutoriale_si_exercitii">Tutoriale și exerciții</h2>
<div class="level2">

<p>
În cadrul exercițiilor vom folosi <a href="http://elf.cs.pub.ro/asm/res/laboratoare/lab-05-tasks.zip" class="urlextern" title="http://elf.cs.pub.ro/asm/res/laboratoare/lab-05-tasks.zip"  rel="nofollow">arhiva de laborator</a>.
</p>

<p>
Descărcați arhiva, decomprimați-o și accesați directorul aferent.
</p>

</div>
<!-- EDIT14 SECTION "Tutoriale și exerciții" [15647-15876] -->
<h3 class="sectionedit15" id="p_1_tutorialafisare_a_continutului_unei_structuri">[1p] 1. Tutorial: Afișare a conținutului unei structuri</h3>
<div class="level3">

<p>
În programul <code>print_structure.asm</code> sunt afișate câmpurile unei structuri.
</p>

<p>
Urmăriți codul, observați construcțiile și modurile de adresare a memoriei. Rulați codul.
</p>

<p>
<p><div class="noteimportant">
Treceți la următorul pas doar după ce ați înțeles foarte bine ce face codul. Vă va fi greu să faceți următorul exercițiu dacă aveți dificultăți în înțelegerea exercițiului curent.

</div></p>
</p>

</div>
<!-- EDIT15 SECTION "[1p] 1. Tutorial: Afișare a conținutului unei structuri" [15877-16346] -->
<h3 class="sectionedit16" id="p_2_modificare_a_unei_structuri">[1.5p] 2. Modificare a unei structuri</h3>
<div class="level3">

<p>
Scrieți cod în cadrul funcției <code>main</code> astfel încât să modificați câmpurile structurii <code>sample_student</code> pentru ca
</p>
<ul>
<li class="level1"><div class="li"> anul nașterii să fie <code>1993</code></div>
</li>
<li class="level1"><div class="li"> vârsta să fie <code>22</code></div>
</li>
<li class="level1"><div class="li"> grupa să fie <code>323CA</code></div>
</li>
</ul>

<p>
<p><div class="notewarning">
Nu modificați ce se afișează, modificați codul structurii. Nu vă atingeți de codul de afișare, acel cod trebuie să rămână același. Trebuie să adăugați la începutul funcției main, în locul marcat cu <code>TODO</code> codul pentru modificarea structurii.

</div></p>
</p>

<p>
<p><div class="notewarning">
Trebuie să modificați conținutul structurii din cod, adică trebuie să scrieți în zona de memorie aferentă câmpului din structură. Nu modificați structura din secțiunea <code>.data</code>, este vorba să folosiți cod pentru a modifca structura.

</div></p>
</p>

<p>
<p><div class="notetip">
Pentru modificarea grupei, va trebui să schimbați al treilea octet/caracter al câmpului <code>group</code> (adică octetul/caracterul cu indexul <code>2</code>).

</div></p>
</p>

</div>
<!-- EDIT16 SECTION "[1.5p] 2. Modificare a unei structuri" [16347-17337] -->
<h3 class="sectionedit17" id="p_3_tutorialalocare_a_unei_structuri_pe_stiva">[1p] 3. Tutorial: Alocare a unei structuri pe stivă</h3>
<div class="level3">

<p>
În programul <code>on_stack_structure.asm</code> se alocă o structură ca o variabilă locală funcției <code>main</code>: se face loc pe stivă folosind <code>sub esp, 100</code> și apoi se inițializează câmpuri din structură și se afișează. Urmăriți codul, observați construcțiile și modul de adresare a memoriei.
</p>

</div>
<!-- EDIT17 SECTION "[1p] 3. Tutorial: Alocare a unei structuri pe stivă" [17338-17707] -->
<h3 class="sectionedit18" id="p_4_alocare_a_campurilor_unei_structuri_pe_stiva">[1.5p] 4. Alocare a câmpurilor unei structuri pe stivă</h3>
<div class="level3">

<p>
Actualizați programul de mai sus pentru a completa și celelalte câmpuri așa cum este indicat în comentariul marcat cu <code>TODO</code>.
</p>

<p>
<p><div class="notetip">
Folosiți construcția <code>rep movsb</code> pentru a completa câmpurile de tip string (array de bytes), adică <code>name</code> și <code>surname</code>. Lungimea șirului (plasată în registrul <code>ecx</code>) trebuie să includă și terminatorul de șir (<code>NUL</code>-terminatorul: valoarea <code>0</code>, sau caracterul <code>&#039;\0&#039;</code>).
</p>

<p>
Pentru celelalte câmpuri (<code>age</code>, <code>birth_year</code>, <code>gender</code>) folosiți valori întregi.

</div></p>
</p>

<p>
<p><div class="noteimportant">
Pentru câmpul <code>gender</code> folosiți valoarea <code>1</code> sau <code>2</code> (octet).

</div></p>
</p>

</div>
<!-- EDIT18 SECTION "[1.5p] 4. Alocare a câmpurilor unei structuri pe stivă" [17708-18415] -->
<h3 class="sectionedit19" id="p_5_tutorialprelucrare_a_unei_structuri">[0.5p] 5. Tutorial: Prelucrare a unei structuri</h3>
<div class="level3">

<p>
În programul <code>process_structure.asm</code> câmpul <code>id</code> al variabilei <code>sample_student</code> (de tip structură <code>stud_struct</code>) este populat cu inițialele de la prenumele și numele studentului. Urmăriți codul, observați construcțiile și modul de adresare a memoriei.
</p>

</div>
<!-- EDIT19 SECTION "[0.5p] 5. Tutorial: Prelucrare a unei structuri" [18416-18745] -->
<h3 class="sectionedit20" id="p_6_prelucrare_a_unei_structuri">[2p] 6. Prelucrare a unei structuri</h3>
<div class="level3">

<p>
Actualizați programul anterior astfel încât câmpul <code>id</code> să fie inițializat la primele 3 litere din prenume, urmate de primele trei litere din nume, urmate de semnul <code>-</code> (<em>minus</em>) și urmate de numele grupei. Adică pentru intrarea definită în fișier, afișarea va însemna mesajul <em>AndVoi-323CA</em>.
</p>

<p>
<p><div class="notetip">
Folosiți construcția <code>rep movsb</code> pentru a completa câmpul <code>id</code> cu secvențele de subșiruri din prenume, nume și grupă.

</div></p>
</p>

<p>
<p><div class="notetip">
Șirul referit de câmpul <code>id</code> trebuie să fie <code>NUL</code>-terminat. Pentru aceasta va trebui să scrieți <code>NUL</code>-terminatorul (adică <code>0</code> sau caracterul <code>&#039;\0&#039;</code> pe ultima poziție a șirului.
</p>

<p>
Pentru a scrie un caracter pe o poziție a șirului (de exemplu caracterul <code>-</code> sau <code>NUL</code>-terminatorul) folosiți o construcție de forma
</p>
<pre class="code">    mov byte [sample_student + id + &lt;index&gt;], &lt;character&gt;</pre>

<p>
unde <code>&lt;index&gt;</code> este index-ul unde vrem să scriem în cadrul șirului, iar <code>&lt;character&gt;</code> este caracterul pe ca vrem să îl scriem.

</div></p>
</p>

</div>
<!-- EDIT20 SECTION "[2p] 6. Prelucrare a unei structuri" [18746-19825] -->
<h3 class="sectionedit21" id="p_7_tutorialpopulare_a_unui_vector_de_structuri">[1p] 7. Tutorial: Populare a unui vector de structuri</h3>
<div class="level3">

<p>
În programul <code>structure_array.asm</code> este definită o variabilă <code>students</code> similară unui vector de structuri. În cadrul programului se face inițializarea și afișarea acestui vector de structuri, folosindu-se șirul vid (primul caracter este <code>0</code>) în cadrul câmpurilor de tip șir. Urmăriți codul, observați construcțiile și modul de adresare a memoriei Rulați codul.
</p>

</div>
<!-- EDIT21 SECTION "[1p] 7. Tutorial: Populare a unui vector de structuri" [19826-20276] -->
<h3 class="sectionedit22" id="p_8_alocare_si_populare_unui_vector_de_structuri">[1.5p] 8. Alocare și populare unui vector de structuri</h3>
<div class="level3">

<p>
Actualizați programul de mai sus astfel încât vectorul de structuri să nu mai fie o variabilă globală neinițilizată (în <code>.bss</code>) ci să fie alocat pe stivă.
</p>

<p>
<p><div class="notetip">
Construcția legată de <code>.bss</code> e recomandat să o ștergeți complet ca să nu vă încurce.

</div></p>
</p>

<p>
<p><div class="notetip">
Ca să alocați vectorul de structuri pe stivă, folosiți o construcție de forma:
</p>
<pre class="code">    sub esp, &lt;size&gt;</pre>

<p>
unde <code>&lt;size&gt;</code> este dimensiunea spațiului pe care trebuie să îl faceți pe stivă. Folosiți valoarea <code>2000</code> pentru dimensiunea spațiului (exact rezultatul <code>STRUCT_STUDENTS*NUM_STUDENTS</code>).
</p>

<p>
Pentru a referi începutul spațiului alocat folosiți expresia <code>ebp - 2000</code>. De la adresa indicată de <code>ebp - 2000</code> începe vectorul de structuri.
</p>

<p>
Folosiți variabila <code>ebx</code> pentru a referi începutul spațiului alocat (adresa acelui spațiu). Folosiți o construcție de forma
</p>
<pre class="code">    lea ebx, [ebp-2000]</pre>

<p>
Va trebui să folosiți construcția de mai sus pe parcursul programului în locul vechii construcții
</p>
<pre class="code">    mov ebx, students</pre>

<p>

</div></p>
</p>

</div>
<!-- EDIT22 SECTION "[1.5p] 8. Alocare și populare unui vector de structuri" [20277-21433] -->
<h3 class="sectionedit23" id="p_9_bonusalocare_pe_stiva">[1.5p] 9. Bonus: Alocare pe stivă</h3>
<div class="level3">

<p>
Realizați o alocare <strong>pe stivă</strong> a unui șir/array de bytes de o dimensiune dată (să spunem 128 de octeți) și apoi inițializați acel șir cu octetul/caracterul <code>&#039;a&#039;</code>.
</p>

<p>
<p><div class="notetip">
Pentru alocare pe stivă folosiți o construcție de forma
</p>
<pre class="code">sub esp, 128</pre>

<p>

</div></p>
</p>

<p>
<p><div class="notetip">
Pentru inițializare folosiți <code>rep stosb</code>.

</div></p>
</p>

<p>
<p><div class="notetip">
Pentru afișare folosiți funcția <code>puts</code>. Adică folosiți o construcție de forma:
</p>
<pre class="code">    push &lt;address&gt;
    call puts
    add esp, 4</pre>

<p>
unde <code>&lt;address&gt;</code> este adresa șirului pe care doriți să-l afișați.

</div></p>
</p>

</div>
<!-- EDIT23 SECTION "[1.5p] 9. Bonus: Alocare pe stivă" [21434-22080] -->
<h3 class="sectionedit24" id="p_10_bonuscautarea_unui_subsir_intr-un_sir">[1.5p] 10. Bonus: Căutarea unui subșir într-un șir</h3>
<div class="level3">

<p>
Găsiți toate aparițiile subșirului <code>substring</code> în șirul <code>source_text</code> din fișierul <code>find_substring.asm</code>. Ca pas intermediar, determinați și afișați lungimea șirului <code>source_text</code>.
</p>

<p>
<p><div class="notetip"> Pentru determinarea lungimii șirului, folosiți instrucțiunea <code>scas</code>. 
</div></p>
<p><div class="notetip"> Compararea a două șiruri se face cel mai ușor cu instrucțiunea <code>cmps</code>.
</div></p>
</p>

</div>
<!-- EDIT24 SECTION "[1.5p] 10. Bonus: Căutarea unui subșir într-un șir" [22081-22536] -->
<h3 class="sectionedit25" id="p_11_bonuslista_simplu_inlantuita">[1p] 11. Bonus: Listă simplu înlănțuită</h3>
<div class="level3">

<p>
În fișierul <code>linked_list.asm</code> este definită structura <code>list_elem</code>, reprezentând un element dintr-o listă simplu înlănțuită. Câmpul <code>value</code> trebuie să conțină valoarea din listă, iar câmpul <code>next</code>, adresa următorului element. Pornind de la scheletul de cod, creați și afișați o listă care să conțină elementele vectorului <code>source_array</code>.
</p>

<p>
<p><div class="notetip">Folosiți exemplul de alocare dinamică din schelet. Adresa întoarsă de <code>maloc</code> se va afla in <code>eax</code>. Dacă folosiți regiștrii <code>eax</code>, <code>ecx</code> și <code>edx</code>, va fi nevoie să îi salvați pe stivă, deoarece valorile acestora se pot schimba în urma apelului de funcție. De exemplu, pentru a-l salva pe <code>edx</code>:
</p>
<pre class="code">    push edx                    ; stocăm edx pe stivă
    mov eax, list_elem_size
    push eax
    call _malloc
    add esp, 4
    pop edx                     ; restaurăm valoarea lui edx</pre>

<p>

</div></p>
</p>

</div>
<!-- EDIT25 SECTION "[1p] 11. Bonus: Listă simplu înlănțuită" [22537-] --></div>
</body>
</html>
