    
    

<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
  <meta charset="utf-8" />
  <title>iocla:laboratoare:laborator-03</title>
<meta name="generator" content="DokuWiki"/>
<meta name="robots" content="index,follow"/>
<meta name="date" content="2016-11-06T12:56:31+0200"/>
<meta name="keywords" content="iocla,laboratoare,laborator-03"/>
<link rel="search" type="application/opensearchdescription+xml" href="../../../../lib/exe/opensearch.php" title="CS Open CourseWare"/>
<link rel="start" href="../../../../../courses.1.html"/>
<link rel="alternate" type="application/rss+xml" title="Recent Changes" href="../../../../feed.php"/>
<link rel="alternate" type="application/rss+xml" title="Current Namespace" href="../../../../feed.php%3Fmode=list&amp;ns=iocla:laboratoare"/>
<link rel="alternate" type="text/html" title="Plain HTML" href="laborator-03.html"/>
<link rel="canonical" href="../../../../iocla/laboratoare/laborator-03.html"/>
<link rel="stylesheet" type="text/css" href="../../../../lib/exe/css.php%3Ft=arctic&amp;tseed=1476798676.css"/>
<script type="text/javascript">/*<![CDATA[*/var NS='iocla:laboratoare';var JSINFO = {"id":"iocla:laboratoare:laborator-03","namespace":"iocla:laboratoare","isadmin":0,"isauth":0};
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="../../../../lib/exe/js.php%3Ftseed=1476798676"></script>
<script type="text/x-mathjax-config">/*<![CDATA[*/MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ["$","$"], ["\\(","\\)"] ],
        displayMath: [ ["$$","$$"], ["\\[","\\]"] ],
        processEscapes: true
    }
});
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
<script type="text/javascript">/*<![CDATA[*/
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
		  
/*!]]>*/</script>
<script type="text/javascript">/*<![CDATA[*/
var pageTracker = _gat._getTracker("UA-38383934-1");
pageTracker._initData();
pageTracker._trackPageview();
		  
/*!]]>*/</script>
</head>
<body>
<div class="dokuwiki export">
<!-- TOC START -->
<div id="dw__toc">
<h3 class="toggle">Table of Contents</h3>
<div>

<ul class="toc">
<li class="level1"><div class="li"><a href="laborator-03.html#laborator_03first_baby_steps">Laborator 03: First baby steps</a></div>
<ul class="toc">
<li class="level2"><div class="li"><a href="laborator-03.html#introducere">Introducere</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="laborator-03.html#ce_este_un_limbaj_de_asamblare">Ce este un limbaj de asamblare?</a></div></li>
<li class="level3"><div class="li"><a href="laborator-03.html#de_ce_sa_invat_limbaj_de_asamblare">De ce să învăț limbaj de asamblare?</a></div>
<ul class="toc">
<li class="level4"><div class="li"><a href="laborator-03.html#debugging">Debugging</a></div></li>
<li class="level4"><div class="li"><a href="laborator-03.html#optimizare_de_cod">Optimizare de cod</a></div></li>
<li class="level4"><div class="li"><a href="laborator-03.html#reverse_engineering">Reverse engineering</a></div></li>
<li class="level4"><div class="li"><a href="laborator-03.html#embedded_si_altele">Embedded și altele</a></div></li>
<li class="level4"><div class="li"><a href="laborator-03.html#fun">Fun</a></div></li>
</ul>
</li>
</ul>
</li>
<li class="level2"><div class="li"><a href="laborator-03.html#familia_x86">Familia x86</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="laborator-03.html#registre">Registre</a></div></li>
<li class="level3"><div class="li"><a href="laborator-03.html#clase_de_instructiuni">Clase de instrucțiuni</a></div>
<ul class="toc">
<li class="level4"><div class="li"><a href="laborator-03.html#instructiuni_de_transfer_de_date">Instrucțiuni de transfer de date</a></div></li>
<li class="level4"><div class="li"><a href="laborator-03.html#instructiuni_aritmetice_si_logice">Instrucțiuni aritmetice și logice</a></div></li>
<li class="level4"><div class="li"><a href="laborator-03.html#instructiuni_de_control">Instrucțiuni de control</a></div></li>
</ul>
</li>
</ul>
</li>
<li class="level2"><div class="li"><a href="laborator-03.html#exemple">Exemple</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="laborator-03.html#hello_world">Hello, World!</a></div></li>
<li class="level3"><div class="li"><a href="laborator-03.html#jmp_si_jmp-if-condition">JMP și JMP-if-condition</a></div></li>
</ul>
</li>
<li class="level2"><div class="li"><a href="laborator-03.html#exercitii">Exerciții</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="laborator-03.html#p_1_conditional_jumps">[1p] 1. Conditional jumps</a></div></li>
<li class="level3"><div class="li"><a href="laborator-03.html#p_2_more_hellos">[3p] 2. More hellos</a></div></li>
<li class="level3"><div class="li"><a href="laborator-03.html#p_3_grumpy_jumps">[2p] 3. Grumpy jumps</a></div></li>
<li class="level3"><div class="li"><a href="laborator-03.html#p_4_sets">[3p] 4. Sets</a></div></li>
<li class="level3"><div class="li"><a href="laborator-03.html#p_5_min">[1p] 5. Min</a></div></li>
<li class="level3"><div class="li"><a href="laborator-03.html#p_6_bonusfibonacci">[1p] 6. BONUS: Fibonacci</a></div></li>
</ul>
</li>
<li class="level2"><div class="li"><a href="laborator-03.html#resurse_utile">Resurse utile</a></div></li>
</ul></li>
</ul>
</div>
</div>
<!-- TOC END -->

<h1 class="sectionedit1" id="laborator_03first_baby_steps">Laborator 03: First baby steps</h1>
<div class="level1">

<p>
În acest laborator, vom prezenta o parte din instrucțiunile x86, precum și o suită de exemple introductive.
</p>

</div>
<!-- EDIT1 SECTION "Laborator 03: First baby steps" [1-159] -->
<h2 class="sectionedit2" id="introducere">Introducere</h2>
<div class="level2">

<p>
Înainte de a începe efectiv să învățăm să citim cod scris în limbaj de asamblare, iar apoi să scriem primele noastre programe, trebuie să răspundem la câteva întrebări.
</p>

</div>
<!-- EDIT2 SECTION "Introducere" [160-369] -->
<h3 class="sectionedit3" id="ce_este_un_limbaj_de_asamblare">Ce este un limbaj de asamblare?</h3>
<div class="level3">

<p>
După cum probabil știți, rolul de bază al unui calculator - în speță, al procesorului - este de a citi, interpreta și executa instrucțiuni. Aceste instrucțiuni sunt codificate în cod mașină.
</p>

<p>
Un exemplu ar fi:
</p>
<pre class="code">1011000000001100011001100011000111011111111111100100</pre>

<p>
Această secvență de biți nu ne spune nimic în mod deosebit. Putem să facem o conversie în baza 16 pentru a o comprima și grupa mai bine.
</p>
<pre class="code">\xB0\x0C\x66\x31\xD2\xFF\xE4</pre>

<p>
În continuare, pentru mulți dintre noi nu spune nimic această secvență.
De aici vine necesitatea unui limbaj mai ușor de înțeles și utilizat.
</p>

<p>
Limbajul de asamblare ne permite să scriem programe text care mai departe vor fi traduse, prin intermediul unui utilitar numit <strong>asamblor</strong>, specific fiecărei arhitecturi, în cod mașină.
Majoritatea limbajelor de asamblare asigură o corespondență directă între instrucțiuni. De exemplu:
</p>
<pre class="code asm"><span class="kw1">mov</span> <span class="kw4">al</span><span class="sy1">,</span> <span class="nu0">12</span> &lt;<span class="sy1">-</span>&gt; <span class="st0">'\xB0\x0C'</span>
<span class="kw1">xor</span> <span class="kw4">dx</span><span class="sy1">,</span> <span class="kw4">dx</span> &lt;<span class="sy1">-</span>&gt; <span class="st0">'\x66\x31\xD2'</span>
<span class="kw1">jmp</span> <span class="kw4">esp</span>    &lt;<span class="sy1">-</span>&gt; <span class="st0">'\xFF\xE4'</span></pre>

<p>
<p><div class="noteclassic">
Deoarece limbajul de asamblare depinde de arhitectură, în general nu este portabil. De aceea, producătorii de procesoare au încercat să păstreze neschimbate instrucțiunile de la o generație la alta, adăugându-le pe cele noi, pentru a păstra măcar compatibilitatea în cadrul aceleiași familii de procesoare (de exemplu, procesoarele Intel 80286, 80386, 80486 etc. fac parte din genericul Intel x86).

</div></p>
</p>

</div>
<!-- EDIT3 SECTION "Ce este un limbaj de asamblare?" [370-1878] -->
<h3 class="sectionedit4" id="de_ce_sa_invat_limbaj_de_asamblare">De ce să învăț limbaj de asamblare?</h3>
<div class="level3">

<p>
Pe lângă valoarea didactică foarte mare, în care înțelegeți în ce constă “stack overflow”, reprezentarea datelor și ce e specific procesorului cu care lucrați, există câteva aplicații în care cunoașterea limbajului de asamblare și, implicit, a arhitecturii sunt necesare sau chiar critice.
</p>

</div>

<h4 id="debugging">Debugging</h4>
<div class="level4">

<p>
Este destul de probabil ca cel puțin unul din programele pe care le-ați scris în trecut să genereze următorul rezultat:
</p>
<pre class="code">Segmentation fault</pre>

<p>
Uneori, veți fi întâmpinați de o serie de date similare cu cele de mai jos:
</p>
<pre class="code">Page Fault cr2=10000000 at eip e75; flags=6
eax=00000030 ebx=00000000 ecx=0000000c edx=00000000
esi=0001a44a edi=00000000 ebp=00000000 esp=00002672
cs=18 ds=38 es=af fs=0 gs=0 ss=20 error=0002</pre>

<p>
Pentru cineva care cunoaște limbaj de asamblare, e relativ ușor să se apuce să depaneze problema folosind un debugger precum <a href="http://www.gnu.org/software/gdb/" class="urlextern" title="http://www.gnu.org/software/gdb/"  rel="nofollow">gdb</a> sau <a href="http://www.ollydbg.de/" class="urlextern" title="http://www.ollydbg.de/"  rel="nofollow">OllyDbg</a>, deoarece mesajul îi furnizează aproape toate informațiile de care are nevoie.
</p>

</div>

<h4 id="optimizare_de_cod">Optimizare de cod</h4>
<div class="level4">

<p>
Gândiți-vă cum ați scrie un program C care să realizeze criptare și decriptare <a href="http://csrc.nist.gov/publications/fips/fips197/fips-197.pdf" class="urlextern" title="http://csrc.nist.gov/publications/fips/fips197/fips-197.pdf"  rel="nofollow">AES</a>. Apoi, indicați compilatorului faptul că doriți să vă optimizeze codul. Evaluați performanța codului respectiv (dimensiune, timp de execuție, număr de instrucțiuni de salt etc.).
Deși compilatoarele sunt deseori trecute la categoria “magie neagră”, există situații în care pur și simplu știți <a href="https://software.intel.com/sites/default/files/article/165683/aes-wp-2012-09-22-v01.pdf" class="urlextern" title="https://software.intel.com/sites/default/files/article/165683/aes-wp-2012-09-22-v01.pdf"  rel="nofollow">ceva</a> despre procesorul pe care lucrați mai bine ca acestea.
</p>

<p>
Mai mult, e suficient să înțelegeți cod asamblare pentru a putea evalua un cod și optimiza secțiunile critice ale acestuia. Chiar dacă nu veți programa în limbaj de asamblare, veți fi conștienți de codul ce va fi generat de pe urma instrucțiunilor C pe care le folosiți.
</p>

</div>

<h4 id="reverse_engineering">Reverse engineering</h4>
<div class="level4">

<p>
O mare parte din aplicațiile uzuale sunt closed-source. Tot ce aveți când vine vorba de aceste aplicații este un fișier deja compilat, binar. Există posibilitatea ca unele dintre acestea să conțină cod malițios, caz în care trebuie analizate într-un mediu controlat (malware analysis/research).
</p>

</div>

<h4 id="embedded_si_altele">Embedded și altele</h4>
<div class="level4">

<p>
Există cazuri în care se impun constrângeri asupra dimensiunii codului și/sau datelor, cum este cazul device-urilor specializate pentru un singur task, având puțină memorie. Din această categorie fac parte și driverele pentru dispozitive.
</p>

</div>

<h4 id="fun">Fun</h4>
<div class="level4">

<p>
Pentru mai multe detalii, discutați asistentul vostru de laborator pentru a vă împărtăși experiența lui personală în materie de limbaj de asamblare și cazurile practice de utilizare folosite.
</p>

</div>
<!-- EDIT4 SECTION "De ce să învăț limbaj de asamblare?" [1879-4761] -->
<h2 class="sectionedit5" id="familia_x86">Familia x86</h2>
<div class="level2">

<p>
Aproape toate procesoarele importante de la Intel împart un ISA (instruction set architecture) comun. Aceste procesoare sunt puternic backwards compatible, având mare parte din instrucțiuni neschimbate de-a lungul generațiilor, ci doar adăugate sau extinse.
</p>

<p>
<p><div class="noteclassic">
Un ISA definește instrucțiunile pe care le suportă un procesor, dimensiunea registrelor, moduri de adresare, tipurile de date, formatul instrucțiunilor, întreruperile și organizarea memoriei.

</div></p>
</p>

<p>
Procesoarele din această familie intră în categoria largă de CISC (Complex Instruction Set Computers). Filozofia din spatele lor este de a avea un număr mare de instrucțiuni, cu lungime variabilă, capabile să efectueze operații complexe, în mai mulți cicli de ceas.
</p>

</div>
<!-- EDIT5 SECTION "Familia x86" [4762-5542] -->
<h3 class="sectionedit6" id="registre">Registre</h3>
<div class="level3">

<p>
Unitățile de lucru de bază pentru procesoarele x86 sunt registrele. Acestea sunt o suită de locații în cadrul procesorului prin intermediul cărora acesta interacționează cu memoria, I/O etc.
</p>

<p>
Procesoarele x86 au 8 astfel de registre de 32 de biți. Deși oricare dintre acestea poate fi folosit în cadrul operațiilor, din motive istorice, fiecare registru are un rol anume.
</p>
<div class="table sectionedit7"><table class="inline">
	<tr class="row0">
		<th class="col0"> Nume </th><th class="col1"> Rol </th>
	</tr>
	<tr class="row1">
		<td class="col0"> EAX </td><td class="col1 leftalign"> acumulator; apeluri de sistem, I/O, aritmetică                                            </td>
	</tr>
	<tr class="row2">
		<td class="col0"> EBX </td><td class="col1 leftalign"> registru de bază; folosit pentru adresarea bazată a memoriei                              </td>
	</tr>
	<tr class="row3">
		<td class="col0"> ECX </td><td class="col1 leftalign"> contor în cadrul instrucțiunilor de buclare                                               </td>
	</tr>
	<tr class="row4">
		<td class="col0"> EDX </td><td class="col1"> registru de date; I/O, aritmetică, valori de întrerupere; poate extinde EAX la 64 de biți </td>
	</tr>
	<tr class="row5">
		<td class="col0"> ESI </td><td class="col1 leftalign"> sursă în cadrul operațiilor pe stringuri                                                  </td>
	</tr>
	<tr class="row6">
		<td class="col0"> EDI </td><td class="col1 leftalign"> destinație în cadrul operațiilor pe stringuri                                             </td>
	</tr>
	<tr class="row7">
		<td class="col0"> EBP </td><td class="col1 leftalign"> base sau frame pointer; indică spre cadrul curent al stivei                               </td>
	</tr>
	<tr class="row8">
		<td class="col0"> ESP </td><td class="col1 leftalign"> stack pointer; indică spre vârful stivei                                                  </td>
	</tr>
</table></div>
<!-- EDIT7 TABLE [5949-6780] -->
<p>
Pe lângă acestea, mai există câteva registre speciale care nu pot fi accesate direct de către programator, cum ar fi EFLAGS și EIP (instruction pointer).
</p>

<p>
EIP este un registru în care se găsește adresa instrucțiunii curente, care urmează să fie executată. El nu poate fi modificat direct, programatic, ci indirect prin instrucțiuni de <em>jump</em>, <em>call</em> și <em>ret</em>.
</p>

<p>
Registrul EFLAGS conține 32 de biți folosiți pe post de indicatori de stare sau variabile de condiție. Spunem că un indicator/flag este setat dacă valoarea lui este 1. Cei folosiți de către programatori în mod uzual sunt următorii:
</p>
<div class="table sectionedit8"><table class="inline">
	<tr class="row0">
		<th class="col0"> Nume </th><th class="col1 leftalign"> Nume extins        </th><th class="col2"> Descriere </th>
	</tr>
	<tr class="row1">
		<td class="col0"> CF </td><td class="col1 leftalign"> Carry Flag           </td><td class="col2"> Acest flag este setat dacă rezultatul instrucțiunii precedente a generat carry sau borrow </td>
	</tr>
	<tr class="row2">
		<td class="col0"> PF </td><td class="col1 leftalign"> Parity Flag          </td><td class="col2 leftalign"> Setat dacă byte-ul low al rezultatului conține un număr par de biți de 1                  </td>
	</tr>
	<tr class="row3">
		<td class="col0"> AF </td><td class="col1"> Auxiliary Carry Flag </td><td class="col2 leftalign"> Folosit în aritmetică BCD; setat dacă bitul 3 generează carry sau borrow                  </td>
	</tr>
	<tr class="row4">
		<td class="col0"> ZF </td><td class="col1 leftalign"> Zero Flag            </td><td class="col2 leftalign"> Setat dacă rezultatul instrucțiunii precedente este 0                                     </td>
	</tr>
	<tr class="row5">
		<td class="col0"> SF </td><td class="col1 leftalign"> Sign Flag            </td><td class="col2 leftalign"> Are aceeași valoare cu a bitului de semn din cadrul rezultatului (1 negativ, 0 pozitiv)   </td>
	</tr>
	<tr class="row6">
		<td class="col0"> OF </td><td class="col1 leftalign"> Overflow Flag        </td><td class="col2 leftalign"> Setat dacă rezultatul depășește valoarea întreagă maximă (sau minimă) reprezentabilă      </td>
	</tr>
</table></div>
<!-- EDIT8 TABLE [7407-8202] -->
<p>
<p><div class="noteclassic">
Dacă urmăriți evoluția registrelor de la 8086, veți vedea că inițial se numeau AX, BX, CX etc. și aveau dimensiunea de 16 biți. De la 80386, Intel a extins aceste registre la 32 biți (i.e. “extended” AX → EAX).

</div></p>
</p>

</div>
<!-- EDIT6 SECTION "Registre" [5543-8441] -->
<h3 class="sectionedit9" id="clase_de_instructiuni">Clase de instrucțiuni</h3>
<div class="level3">

<p>
Deși setul curent de instrucțiuni pentru procesoarele Intel are proporții <a href="http://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-instruction-set-reference-manual-325383.pdf" class="urlextern" title="http://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-instruction-set-reference-manual-325383.pdf"  rel="nofollow">biblice</a>, noi ne vom ocupa de un <a href="http://css.csail.mit.edu/6.858/2015/readings/i386.pdf" class="urlextern" title="http://css.csail.mit.edu/6.858/2015/readings/i386.pdf"  rel="nofollow">subset</a> din acestea, și anume, o parte dintre instrucțiunile 80386.
</p>

<p>
Toate instrucțiunile procesoarelor x86 se pot încadra în 3 categorii: transfer de date, aritmetice/logice și de control. Vom enumera doar câteva instrucțiuni reprezentative, deoarece multe dintre ele se aseamănă.
</p>

</div>

<h4 id="instructiuni_de_transfer_de_date">Instrucțiuni de transfer de date</h4>
<div class="level4">
<div class="table sectionedit10"><table class="inline">
	<tr class="row0">
		<th class="col0"> Nume </th><th class="col1"> Operanzi </th><th class="col2"> Descriere </th>
	</tr>
	<tr class="row1">
		<td class="col0 leftalign"> mov  </td><td class="col1"> dst, src </td><td class="col2 leftalign"> Mută valoarea din sursă peste destinație       </td>
	</tr>
	<tr class="row2">
		<td class="col0"> push </td><td class="col1 leftalign"> src      </td><td class="col2 leftalign"> Mută valoarea din sursă în vârful stivei       </td>
	</tr>
	<tr class="row3">
		<td class="col0 leftalign"> pop  </td><td class="col1 leftalign"> dst      </td><td class="col2 leftalign"> Mută valoarea din vârful stivei în destinație  </td>
	</tr>
	<tr class="row4">
		<td class="col0 leftalign"> lea  </td><td class="col1"> dst, src </td><td class="col2"> Încarcă adresa efectivă a sursei în destinație </td>
	</tr>
	<tr class="row5">
		<td class="col0"> xchg </td><td class="col1"> dst, src </td><td class="col2 leftalign"> Interschimbă valorile din sursă și destinație  </td>
	</tr>
</table></div>
<!-- EDIT10 TABLE [9136-9532] -->
</div>

<h4 id="instructiuni_aritmetice_si_logice">Instrucțiuni aritmetice și logice</h4>
<div class="level4">
<div class="table sectionedit11"><table class="inline">
	<tr class="row0">
		<th class="col0"> Nume </th><th class="col1"> Operanzi </th><th class="col2"> Descriere </th>
	</tr>
	<tr class="row1">
		<td class="col0"> add </td><td class="col1 leftalign"> dst, src     </td><td class="col2 leftalign"> Adună sursa cu destinația; rezultatul se scrie la destinație                    </td>
	</tr>
	<tr class="row2">
		<td class="col0"> sub </td><td class="col1 leftalign"> dst, src     </td><td class="col2 leftalign"> Se scade din sursă destinația și se reține în destinație                        </td>
	</tr>
	<tr class="row3">
		<td class="col0"> and </td><td class="col1 leftalign"> dst, src     </td><td class="col2 leftalign"> Se efectuează operația de ȘI logic între sursă și destinație                    </td>
	</tr>
	<tr class="row4">
		<td class="col0"> shl </td><td class="col1"> dst, &lt;const&gt; </td><td class="col2"> Se face shiftare logică la stânga a destinației cu un număr constant de poziții </td>
	</tr>
</table></div>
<!-- EDIT11 TABLE [9579-10051] -->
</div>

<h4 id="instructiuni_de_control">Instrucțiuni de control</h4>
<div class="level4">
<div class="table sectionedit12"><table class="inline">
	<tr class="row0">
		<th class="col0 leftalign"> Nume          </th><th class="col1"> Operanzi </th><th class="col2"> Descriere </th>
	</tr>
	<tr class="row1">
		<td class="col0 leftalign"> jmp           </td><td class="col1"> &lt;adresă&gt; </td><td class="col2"> Efectuează salt necondiționat la adresa indicată (direct, prin registru, prin etichete) </td>
	</tr>
	<tr class="row2">
		<td class="col0 leftalign"> cmp           </td><td class="col1"> dst, src </td><td class="col2 leftalign"> Compară sursa cu destinația (detalii mai jos)             </td>
	</tr>
	<tr class="row3">
		<td class="col0"> j<em>condiție</em> </td><td class="col1"> &lt;adresă&gt; </td><td class="col2 leftalign"> Efectuează salt condiționat, în funcție de valoarea flagului/variabilei de condiție     </td>
	</tr>
	<tr class="row4">
		<td class="col0 leftalign"> call          </td><td class="col1"> &lt;adresă&gt; </td><td class="col2 leftalign"> Face apel la subrutina care se găsește la adresa indicată                               </td>
	</tr>
</table></div>
<!-- EDIT12 TABLE [10087-10590] -->
<p>
<p><div class="noteimportant">
<a href="http://x86.renejeschke.de/html/file_module_x86_id_35.html" class="urlextern" title="http://x86.renejeschke.de/html/file_module_x86_id_35.html"  rel="nofollow">Instrucțiunea &#039;&#039;cmp dest, src&#039;&#039;</a> realizează în spate operația <code>dest - src</code> (adică scade din destinație sursa); este vorba de o scădere cu semn. Fără a reține rezultatul. Astfel, în cazul codului
</p>
<pre class="code">    cmp eax, 0
    jl negative</pre>

<p>
se va face saltul la eticheta <code>negative</code> dacă eax este mai mic decât <code>0</code>. Se face operația <code>eax - 0</code> și dacă rezultatul este negativ (adică dacă eax este negativ) se face saltul.
</p>

<p>
Alte detalii <a href="https://en.wikibooks.org/wiki/X86_Assembly/Control_Flow#Comparison_Instructions" class="urlextern" title="https://en.wikibooks.org/wiki/X86_Assembly/Control_Flow#Comparison_Instructions"  rel="nofollow">aici</a>.

</div></p>
</p>

</div>
<!-- EDIT9 SECTION "Clase de instrucțiuni" [8442-11227] -->
<h2 class="sectionedit13" id="exemple">Exemple</h2>
<div class="level2">

<p>
<p><div class="noteclassic">
Limbajul de asamblare x86 are două sintaxe oficiale: Intel și AT&amp;T. Există o serie de <a href="https://en.wikipedia.org/wiki/X86_assembly_language#Syntax" class="urlextern" title="https://en.wikipedia.org/wiki/X86_assembly_language#Syntax"  rel="nofollow">diferențe</a> între cele două. Sintaxa Intel este sprijinită de majoritatea asambloarelor. Din considerente de platformă și răspândire (și pentru că programatorii scriu a = 1, nu 1 = a), noi vom folosi sintaxa Intel în cadrul laboratorului.

</div></p>
</p>

</div>
<!-- EDIT13 SECTION "Exemple" [11228-11662] -->
<h3 class="sectionedit14" id="hello_world">Hello, World!</h3>
<div class="level3">

<p>
Putem vedea un exemplu de program în limbaj de asamblare mai jos. Acesta va afișa, la consolă, string-ul <code>Hello, World!</code>.
</p>
<pre class="code asm"><span class="kw5">%include</span> <span class="st0">&quot;io.inc&quot;</span>
<span class="kw5">extern</span> puts
&nbsp;
<span class="kw5">section</span> <span class="kw5">.data</span>
    myString<span class="sy1">:</span> <span class="kw5">db</span> <span class="st0">'Hello, World!'</span><span class="sy1">,</span><span class="nu0">0</span>
&nbsp;
<span class="kw5">section</span> <span class="kw5">.text</span>
<span class="kw5">global</span> CMAIN
CMAIN<span class="sy1">:</span>
    <span class="kw1">mov</span> <span class="kw4">ebp</span><span class="sy1">,</span> <span class="kw4">esp</span>        <span class="co1">; Initialize frame pointer</span>
    <span class="kw1">lea</span> <span class="kw4">eax</span><span class="sy1">,</span> <span class="br0">&#91;</span>myString<span class="br0">&#93;</span> <span class="co1">; Load the effective address of our string into the eax register</span>
    <span class="kw1">push</span> <span class="kw4">eax</span>            <span class="co1">; Push the address unto the stack in order to pass it to 'puts'</span>
    <span class="kw1">call</span> puts           <span class="co1">; Call the puts routine</span>
    <span class="kw1">pop</span> <span class="kw4">eax</span>             <span class="co1">; Retrieve eax from the stack</span>
    <span class="kw1">ret</span>                 <span class="co1">; Return from the main routine</span></pre>

</div>
<!-- EDIT14 SECTION "Hello, World!" [11663-12338] -->
<h3 class="sectionedit15" id="jmp_si_jmp-if-condition">JMP și JMP-if-condition</h3>
<div class="level3">

<p>
Fluxul programelor în limbaj de asamblare este controlat prin instrucțiuni de tip <strong>jump</strong>, un analog al lui <strong>goto</strong> din limbajul C.
</p>

<p>
Instrucțiunea <strong>jmp</strong> va dirija fluxul programului spre adresa primită ca argument, fie direct, fie printr-un registru.
</p>

<p>
Spre exemplu:
</p>
<pre class="code asm"><span class="kw5">%include</span> <span class="st0">&quot;io.inc&quot;</span>
<span class="kw5">extern</span> puts
&nbsp;
<span class="kw5">section</span> <span class="kw5">.data</span>
    string1<span class="sy1">:</span> <span class="kw5">db</span> <span class="st0">&quot;You'll never get here!&quot;</span><span class="sy1">,</span><span class="nu0">0</span>
    string2<span class="sy1">:</span> <span class="kw5">db</span> <span class="st0">&quot;Nothing to see here.&quot;</span><span class="sy1">,</span><span class="nu0">0</span>
&nbsp;
<span class="kw5">section</span> <span class="kw5">.text</span>
<span class="kw5">global</span> CMAIN
CMAIN<span class="sy1">:</span>
    <span class="kw1">mov</span> <span class="kw4">ebp</span><span class="sy1">,</span> <span class="kw4">esp</span>
    <span class="kw1">lea</span> <span class="kw4">eax</span><span class="sy1">,</span> <span class="br0">&#91;</span>string2<span class="br0">&#93;</span>
    <span class="kw1">push</span> <span class="kw4">eax</span>
    <span class="kw1">call</span> puts
    <span class="kw1">pop</span> <span class="kw4">eax</span>
    <span class="kw1">jmp</span> exit           <span class="co1">; Unconditional jump to the 'exit' label</span>
    <span class="kw1">lea</span> <span class="kw4">eax</span><span class="sy1">,</span> <span class="br0">&#91;</span>string1<span class="br0">&#93;</span> <span class="co1">; Code unreachable beyond this point</span>
    <span class="kw1">push</span> <span class="kw4">eax</span>
    <span class="kw1">call</span> puts
    <span class="kw1">pop</span> <span class="kw4">eax</span>
exit<span class="sy1">:</span>
    <span class="kw1">ret</span></pre>

<p>
Așa cum am precizat, instrucțiunile de tip <strong>jmp</strong> pot primi ca argument un registru care să conțină adresa la care se va face salt, sau un offset relativ față de poziția curentă în program (sau, mai bine spus, față de registrul <strong>eip</strong>).
</p>

<p>
Puteți urmări aceste două aspecte în exemplul de mai jos.
</p>
<pre class="code asm"><span class="kw5">%include</span> <span class="st0">&quot;io.inc&quot;</span>
<span class="kw5">extern</span> puts
&nbsp;
<span class="kw5">section</span> <span class="kw5">.data</span>
    string1<span class="sy1">:</span> <span class="kw5">db</span> <span class="st0">&quot;This looks convoluted&quot;</span><span class="sy1">,</span><span class="nu0">0</span>
    string2<span class="sy1">:</span> <span class="kw5">db</span> <span class="st0">&quot;Where are we going?&quot;</span><span class="sy1">,</span><span class="nu0">0</span>
&nbsp;
<span class="kw5">section</span> <span class="kw5">.text</span>
<span class="kw5">global</span> CMAIN
CMAIN<span class="sy1">:</span>
    <span class="kw1">mov</span> <span class="kw4">ebp</span><span class="sy1">,</span> <span class="kw4">esp</span>
    <span class="kw1">mov</span> <span class="kw4">eax</span><span class="sy1">,</span> zone2
    <span class="kw1">jmp</span> <span class="kw4">eax</span>       <span class="co1">; jmp to whatever eax contains</span>
zone1<span class="sy1">:</span>
    <span class="kw1">lea</span> <span class="kw4">eax</span><span class="sy1">,</span> <span class="br0">&#91;</span>string2<span class="br0">&#93;</span>
    <span class="kw1">push</span> <span class="kw4">eax</span>
    <span class="kw1">call</span> puts
    <span class="kw1">pop</span> <span class="kw4">eax</span>
    <span class="kw1">jmp</span> exit
zone2<span class="sy1">:</span>
    <span class="kw1">lea</span> <span class="kw4">eax</span><span class="sy1">,</span> <span class="br0">&#91;</span>string1<span class="br0">&#93;</span>
    <span class="kw1">push</span> <span class="kw4">eax</span>
    <span class="kw1">call</span> puts
    <span class="kw1">pop</span> <span class="kw4">eax</span>
    <span class="kw1">jmp</span> <span class="sy2">$</span><span class="sy1">-</span><span class="nu0">0x1c</span>    <span class="co1">; relative offset jump</span>
exit<span class="sy1">:</span>
    <span class="kw1">ret</span></pre>

<p>
<p><div class="noteimportant">Ce reprezintă <strong>$</strong> în exemplul de mai sus? Dar valoarea <strong>0x1c</strong>?
</div></p>
</p>

<p>
Instrucțiunile de tipul <strong>jump-if-condition</strong> se aseamănă cu <strong>if</strong> din C. Aceste instrucțiuni folosesc drept condiții indicatorii de stare din registrul <code>EFLAGS</code>. E foarte important de ținut minte faptul că acest registru indică contextul de execuție al instrucțiunii curente și se modifică după fiecare instrucțiune.
</p>

<p>
Pentru a exemplifica acest lucru, fie următorul program:
</p>
<pre class="code asm"><span class="kw5">%include</span> <span class="st0">&quot;io.inc&quot;</span>
<span class="kw5">extern</span> puts
&nbsp;
<span class="kw5">section</span> <span class="kw5">.data</span>
    myString<span class="sy1">:</span> <span class="kw5">db</span> <span class="st0">&quot;Hello, World!&quot;</span><span class="sy1">,</span><span class="nu0">0</span>
&nbsp;
<span class="kw5">section</span> <span class="kw5">.text</span>
<span class="kw5">global</span> CMAIN
CMAIN<span class="sy1">:</span>
    <span class="kw1">mov</span> <span class="kw4">ebp</span><span class="sy1">,</span> <span class="kw4">esp</span>
    <span class="kw1">mov</span> <span class="kw4">eax</span><span class="sy1">,</span> <span class="nu0">1</span>
    <span class="kw1">mov</span> <span class="kw4">ebx</span><span class="sy1">,</span> <span class="nu0">1</span>
    <span class="kw1">cmp</span> <span class="kw4">eax</span><span class="sy1">,</span> <span class="kw4">ebx</span>
    <span class="kw1">add</span> <span class="kw4">ecx</span><span class="sy1">,</span> <span class="nu0">1</span>   <span class="co1">; Delete this line</span>
    <span class="kw1">je</span> print
    <span class="kw1">ret</span>
print<span class="sy1">:</span>
    <span class="kw1">lea</span> <span class="kw4">eax</span><span class="sy1">,</span> <span class="br0">&#91;</span>myString<span class="br0">&#93;</span>
    <span class="kw1">push</span> <span class="kw4">eax</span>
    <span class="kw1">call</span> puts
    <span class="kw1">pop</span> <span class="kw4">eax</span>
    <span class="kw1">ret</span></pre>

<p>
Observați ce se întâmplă atunci când ștergeți instrucțiunea indicată. Instrucțiunea <strong>je print</strong> va face jump doar dacă ZF este setat. Instrucțiunea <strong>cmp</strong> face diferența dintre cei doi operanzi; dacă diferența este 0, atunci ZF va fi setat. În schimb, instrucțiunea <strong>add ecx, 1</strong> modifică valoarea lui ZF. De aceea, se recomandă ca instrucțiunile de tipul j<em>condiție</em> să fie plasate imediat după instrucțiunile ce verifică condiția respectivă.
</p>

</div>
<!-- EDIT15 SECTION "JMP și JMP-if-condition" [12339-15177] -->
<h2 class="sectionedit16" id="exercitii">Exerciții</h2>
<div class="level2">

<p>
În cadrul exercițiilor vom folosi <a href="http://elf.cs.pub.ro/asm/res/laboratoare/lab-03-tasks.zip" class="urlextern" title="http://elf.cs.pub.ro/asm/res/laboratoare/lab-03-tasks.zip"  rel="nofollow">arhiva de laborator</a>.
</p>

<p>
Descărcați arhiva, decomprimați-o și accesați directorul aferent.
</p>

<p>
<p><div class="notetip">
Pentru a afișa valorile din registre vom folosi biblioteca <code>io.inc</code> din NASM până veți învăța cum se efectuează apelurile de funcții. Aceasta permite afișarea de valori în diverse formate și de șiruri de caractere. Pentru mai multe detalii urmăriți descrierea de <a href="http://dman95.github.io/SASM/english.html" class="urlextern" title="http://dman95.github.io/SASM/english.html"  rel="nofollow">aici</a>.

</div></p>
</p>

</div>
<!-- EDIT16 SECTION "Exerciții" [15178-15744] -->
<h3 class="sectionedit17" id="p_1_conditional_jumps">[1p] 1. Conditional jumps</h3>
<div class="level3">

<p>
Accesați directorul <code>1-2-hello-world</code> din arhiva laboratorului ce conține exemplul anterior. Modificați programul astfel încât afișarea mesajului să se facă numai dacă conținutul registrului <strong>eax</strong> este mai mare decât cel din <strong>ebx</strong>. Modificați și valoarea registrelor pentru a face în continuare afișarea mesajului <code>&quot;Hello, World!&quot;</code>.
</p>

</div>
<!-- EDIT17 SECTION "[1p] 1. Conditional jumps" [15745-16142] -->
<h3 class="sectionedit18" id="p_2_more_hellos">[3p] 2. More hellos</h3>
<div class="level3">
<ol>
<li class="level1"><div class="li"> <strong>[0.5p]</strong> Folosind programul ce afișează &#039;Hello, World!&#039; de mai sus, încărcați adresa șirului în alt registru și puneți-l pe stivă. S-a schimbat ceva? De ce da/nu?</div>
</li>
<li class="level1"><div class="li"> <strong>[0.5p]</strong> Modificați programul astfel încât să mai afișeze încă un mesaj (&#039;Goodbye, World!&#039;)</div>
</li>
<li class="level1"><div class="li"> <strong>[2p]</strong> Folosind instrucțiuni de tip jump, modificați programul astfel încât să afișeze de 3 ori &#039;Hello, World!&#039;. Evitați ciclarea la infinit.</div>
</li>
</ol>

</div>
<!-- EDIT18 SECTION "[3p] 2. More hellos" [16143-16612] -->
<h3 class="sectionedit19" id="p_3_grumpy_jumps">[2p] 3. Grumpy jumps</h3>
<div class="level3">

<p>
Accesați directorul <code>3-grumpy-jumps</code>. Treceți prin codul sursă din grumpy-jumps.asm.
</p>
<ol>
<li class="level1"><div class="li"> <strong>[1p]</strong> Modificați-l astfel încât la rularea lui să se afișeze mesajul <code>Well done!</code>. Urmăriți comentariile marcate cu <code>TODO</code></div>
</li>
<li class="level1"><div class="li"> <strong>[1p]</strong> De ce, în continuare, se afișează și mesajul greșit? Modificați sursa astfel încât să nu se mai afișeze mesajul greșit.</div>
</li>
</ol>

</div>
<!-- EDIT19 SECTION "[2p] 3. Grumpy jumps" [16613-17028] -->
<h3 class="sectionedit20" id="p_4_sets">[3p] 4. Sets</h3>
<div class="level3">

<p>
Pornind de la scheletul de cod din directorul <code>4-sets</code> va trebui să implementați operații pe mulțimi ce pot conține elemente între 0 și 31 (fiecare registru având 4 octeți). Un mod eficient
de a face asta (atât din punct de vedere al spațiului cât și al vitezei) ar fi să reprezentăm mulțimile
astfel încât un registru să reprezinte o mulțime. Fiecare bit din registru va reprezenta un element din mulțime
(dacă bit-ul i este setat atunci mulțimea conține elementul i)
<p><div class="notetip">
Exemplu: dacă eax ar conține reprezentarea mulțimii <code>{0,2,4}</code>, valoarea registrului ar fi <code>2^0 + 2^2 + 2^4 = 1 + 4 + 16 = 21</code>. Documentați-vă despre instrucțiunile disponibile pe arhitectura <a href="http://www.cs.virginia.edu/~evans/cs216/guides/x86.html" class="urlextern" title="http://www.cs.virginia.edu/~evans/cs216/guides/x86.html"  rel="nofollow">x86</a>.

</div></p>
</p>

<p>
<strong>[0.5p]</strong> Aveți definite 2 mulțimi. Ce valori conțin? Realizați reuniunea celor 2 mulțimi.
</p>

<p>
<strong>[0.5p]</strong> Folosiți instrucțiunea <code>or</code> pentru a adăuga două elemente noi în mulțime.
</p>

<p>
<p><div class="notetip">
Folosiți-vă de faptul că mulțumile curente, deși au “spațiu” pentru 32 de biți, au doar 8 biți folosiți. Dacă veți face <code>or</code> cu un număr mai mare de 255 (<code>0xff</code>, <code>2^8-1</code>) care are doi biți activi, veți adăuga practic două elemente noi la mulțime.

</div></p>
</p>

<p>
<strong>[0.5p]</strong> Faceți intersecția celor 2 mulțimi.
</p>

<p>
<strong>[0.5p]</strong> Determinați elementele care lipsesc din mulțimea <code>eax</code> pentru ca acesta să fie completă.
</p>

<p>
<p><div class="notetip">
Adică trebuie să faceți complementul numărului folosind instrucțiunea <code>not</code>.
</p>

<p>
Pentru a afișa o reprezentare negativă, puteți folosi <code>PRINT_UDEC</code> în loc de <code>PRINT_DEC</code>. Sau puteți folosi <code>PRINT_HEX</code>.

</div></p>
</p>

<p>
<strong>[0.5p]</strong> Eliminați un element din prima mulțime.
</p>

<p>
<strong>[0.5p]</strong> Faceți diferența între mulțimi.
</p>

<p>
<p><div class="noteclassic">
Pentru a vă ajuta în afișare puteți folosi construcțiile <code>PRINT_HEX</code> (afișare numere în format hexazecimal) și <code>PRINT_HEX</code> (afișare șiruri de caracter). De exemplu:
</p>
<pre class="code">PRINT_HEX 4, eax
PRINT_STRING &quot;set reunion is: &quot;</pre>

<p>

</div></p>
</p>

</div>
<!-- EDIT20 SECTION "[3p] 4. Sets" [17029-19073] -->
<h3 class="sectionedit21" id="p_5_min">[1p] 5. Min</h3>
<div class="level3">

<p>
Calculați minimul dintre numerele din 2 registre (eax și ebx) folosind o instrucțiune de salt și instrucțiunea <code>xchg</code>.
</p>

</div>
<!-- EDIT21 SECTION "[1p] 5. Min" [19074-19222] -->
<h3 class="sectionedit22" id="p_6_bonusfibonacci">[1p] 6. BONUS: Fibonacci</h3>
<div class="level3">

<p>
Calculați al <code>N</code>-lea număr Fibonacci, unde <code>N</code> este dat prin intermediul registrului <code>eax</code>.
</p>

</div>
<!-- EDIT22 SECTION "[1p] 6. BONUS: Fibonacci" [19223-19357] -->
<h2 class="sectionedit23" id="resurse_utile">Resurse utile</h2>
<div class="level2">
<ul>
<li class="level1"><div class="li"> <a href="http://savannah.nongnu.org/projects/pgubook/" class="urlextern" title="http://savannah.nongnu.org/projects/pgubook/"  rel="nofollow">Programming from the Ground Up</a></div>
</li>
<li class="level1"><div class="li"> <a href="http://beginners.re/" class="urlextern" title="http://beginners.re/"  rel="nofollow">Reverse Engineering for Beginners</a></div>
</li>
<li class="level1"><div class="li"> <a href="http://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-instruction-set-reference-manual-325383.pdf" class="urlextern" title="http://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-instruction-set-reference-manual-325383.pdf"  rel="nofollow">Intel 64 and IA-32 Architectures Software Developer Manual</a></div>
</li>
<li class="level1"><div class="li"> <a href="http://css.csail.mit.edu/6.858/2015/readings/i386.pdf" class="urlextern" title="http://css.csail.mit.edu/6.858/2015/readings/i386.pdf"  rel="nofollow">Intel 80386 Programmer&#039;s Reference Manual</a></div>
</li>
<li class="level1"><div class="li"> <a href="http://cs.stanford.edu/people/eroberts/courses/soco/projects/risc/risccisc/" class="urlextern" title="http://cs.stanford.edu/people/eroberts/courses/soco/projects/risc/risccisc/"  rel="nofollow">RISC vs. CISC</a></div>
</li>
<li class="level1"><div class="li"> <a href="http://unixwiz.net/techtips/x86-jumps.html" class="urlextern" title="http://unixwiz.net/techtips/x86-jumps.html"  rel="nofollow">Intel x86 JUMP Quick Reference</a></div>
</li>
</ul>

</div>
<!-- EDIT23 SECTION "Resurse utile" [19358-] --></div>
</body>
</html>
