    
    

<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
  <meta charset="utf-8" />
  <title>iocla:laboratoare:laborator-12</title>
<meta name="generator" content="DokuWiki"/>
<meta name="robots" content="index,follow"/>
<meta name="date" content="2016-09-28T16:03:05+0300"/>
<meta name="keywords" content="iocla,laboratoare,laborator-12"/>
<link rel="search" type="application/opensearchdescription+xml" href="../../../../lib/exe/opensearch.php" title="CS Open CourseWare"/>
<link rel="start" href="../../../../../courses.1.html"/>
<link rel="alternate" type="application/rss+xml" title="Recent Changes" href="../../../../feed.php"/>
<link rel="alternate" type="application/rss+xml" title="Current Namespace" href="../../../../feed.php%3Fmode=list&amp;ns=iocla:laboratoare"/>
<link rel="alternate" type="text/html" title="Plain HTML" href="laborator-12.html"/>
<link rel="canonical" href="../../../../iocla/laboratoare/laborator-12.html"/>
<link rel="stylesheet" type="text/css" href="../../../../lib/exe/css.php%3Ft=arctic&amp;tseed=1476798676.css"/>
<script type="text/javascript">/*<![CDATA[*/var NS='iocla:laboratoare';var JSINFO = {"id":"iocla:laboratoare:laborator-12","namespace":"iocla:laboratoare","isadmin":0,"isauth":0};
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="../../../../lib/exe/js.php%3Ftseed=1476798676"></script>
<script type="text/x-mathjax-config">/*<![CDATA[*/MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ["$","$"], ["\\(","\\)"] ],
        displayMath: [ ["$$","$$"], ["\\[","\\]"] ],
        processEscapes: true
    }
});
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
<script type="text/javascript">/*<![CDATA[*/
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
		  
/*!]]>*/</script>
<script type="text/javascript">/*<![CDATA[*/
var pageTracker = _gat._getTracker("UA-38383934-1");
pageTracker._initData();
pageTracker._trackPageview();
		  
/*!]]>*/</script>
</head>
<body>
<div class="dokuwiki export">
<!-- TOC START -->
<div id="dw__toc">
<h3 class="toggle">Table of Contents</h3>
<div>

<ul class="toc">
<li class="level1"><div class="li"><a href="laborator-12.html#laborator_12calcul_in_virgula_mobila">Laborator 12: Calcul în virgulă mobilă</a></div>
<ul class="toc">
<li class="level2"><div class="li"><a href="laborator-12.html#reprezentarea_numerelor_in_virgula_mobila">Reprezentarea numerelor în virgulă mobilă</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="laborator-12.html#standarde_de_reprezentare_in_virgula_mobila">Standarde de reprezentare în virgulă mobilă</a></div></li>
<li class="level3"><div class="li"><a href="laborator-12.html#valori_speciale">Valori speciale</a></div></li>
</ul>
</li>
<li class="level2"><div class="li"><a href="laborator-12.html#unitatea_de_calcul_in_virgula_mobila">Unitatea de calcul în virgulă mobilă</a></div></li>
<li class="level2"><div class="li"><a href="laborator-12.html#instructiuni_pentru_calcul_in_virgula_mobila">Instrucțiuni pentru calcul în virgulă mobilă</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="laborator-12.html#instructiuni_de_tip_push">Instrucțiuni de tip push</a></div></li>
<li class="level3"><div class="li"><a href="laborator-12.html#instructiuni_de_tip_pop">Instrucțiuni de tip pop</a></div></li>
<li class="level3"><div class="li"><a href="laborator-12.html#instructiuni_de_comparatie">Instrucțiuni de comparație</a></div></li>
<li class="level3"><div class="li"><a href="laborator-12.html#instructiuni_matematice">Instrucțiuni matematice</a></div></li>
<li class="level3"><div class="li"><a href="laborator-12.html#exemple">Exemple</a></div></li>
</ul>
</li>
<li class="level2"><div class="li"><a href="laborator-12.html#exercitii">Exerciții</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="laborator-12.html#p_0_completare_formular_de_feedback_iocla">[1p] 0. Completare formular de feedback IOCLA</a></div></li>
<li class="level3"><div class="li"><a href="laborator-12.html#p_1_tutorialsuma_unui_vector_de_numere_fractionare">[1p] 1. Tutorial: Suma unui vector de numere fracționare</a></div></li>
<li class="level3"><div class="li"><a href="laborator-12.html#p_2_media_unui_vector_de_numere_fractionare">[1p] 2. Media unui vector de numere fracționare</a></div></li>
<li class="level3"><div class="li"><a href="laborator-12.html#p_3_impartirea_a_doua_numere_intregi_cu_rezultat_fractionar">[1p] 3. Împărțirea a două numere întregi cu rezultat fracționar</a></div></li>
<li class="level3"><div class="li"><a href="laborator-12.html#p_4_extragere_parte_intreaga_si_fractionara">[2p] 4. Extragere parte întreagă și fracționară</a></div></li>
<li class="level3"><div class="li"><a href="laborator-12.html#p_5_media_unui_vector_de_intregi_cu_rezultat_fractionar">[2p] 5. Media unui vector de întregi cu rezultat fracționar</a></div></li>
<li class="level3"><div class="li"><a href="laborator-12.html#p_6_maximul_dintr-un_vector_de_numere_fractionare">[2p] 6. Maximul dintr-un vector de numere fracționare</a></div></li>
<li class="level3"><div class="li"><a href="laborator-12.html#p_bonus_7_implementare_arcsin">[2p Bonus] 7. Implementare arcsin</a></div></li>
</ul></li>
</ul></li>
</ul>
</div>
</div>
<!-- TOC END -->

<h1 class="sectionedit1" id="laborator_12calcul_in_virgula_mobila">Laborator 12: Calcul în virgulă mobilă</h1>
<div class="level1">

<p>
Până acum, pe parcursul laboratorului de IOCLA am învățat despre cum putem efectua operații cu numere întregi, pozitive sau negative, de diverse dimensiuni. Dar cum rămâne cu numerele cu virgulă? Multe din procesoarele folosite astăzi dispun de o unitate de calcul în virgulă mobilă (<strong>Floating Point Unit</strong> - FPU), care oferă funcții de calcul pentru astfel de valori.
</p>

<p>
În acest laborator vom vedea cum putem folosi instrucțiunile puse la dispoziție de FPU pentru a efectua eficient calcule în virgulă mobilă.
</p>

</div>
<!-- EDIT1 SECTION "Laborator 12: Calcul în virgulă mobilă" [1-591] -->
<h2 class="sectionedit2" id="reprezentarea_numerelor_in_virgula_mobila">Reprezentarea numerelor în virgulă mobilă</h2>
<div class="level2">

<p>
Primul aspect pe care trebuie să înțelegem este cum putem să reprezentăm numerele cu virgulă în formă binară. Ca și în cazul numerelor întregi, valorile fracționare se reprezintă pe un anumit număr de biți.
</p>

<p>
Principalele obiective ale unei reprezentări pe un anumit număr de biți sunt:
* posibilitatea de a reprezenta cât mai multe valori intre valoarea minimă și valoarea maximă
* o precizie cât mai bună a valorilor (numărul maxim de cifre după virgulă)
</p>

<p>
Pentru a reprezenta valorile fracționare vom folosi <strong>Reprezentarea în virgulă mobilă</strong> (<strong>Floating Point Representation</strong>). În această reprezentare, numerele au următoarea structură:
</p>

<p>
<a href="http://ocw.cs.pub.ro/courses/_detail/laboratoare/lab12-equation1.png?id=iocla%3Alaboratoare%3Alaborator-12" class="media wikilink2" title="laboratoare:lab12-equation1.png"><img src="http://ocw.cs.pub.ro/courses/_media/laboratoare/lab12-equation1.png?w=500&amp;tok=91a88a" class="mediacenter" alt="" width="500" /></a>
</p>

<p>
După cum putem observa mai sus, valorile trebuie transformate astfel încât partea întreagă să fie 1. Această formă poartă 
numele de formă normală, iar operația de transformare în această formă poartă numele de <strong>normalizare</strong>.
</p>

<p>
În forma binară, valorile se reprezintă astfel:
<a href="http://ocw.cs.pub.ro/courses/_detail/laboratoare/2000px-ieee_754_double_floating_point_format.png?id=iocla%3Alaboratoare%3Alaborator-12" class="media wikilink2" title="laboratoare:2000px-ieee_754_double_floating_point_format.png"><img src="http://ocw.cs.pub.ro/courses/_media/laboratoare/2000px-ieee_754_double_floating_point_format.png?w=600&amp;tok=9a6761" class="mediacenter" alt="" width="600" /></a>
</p>

<p>
<strong>Semnul</strong> este dat de primul bit din reprezentarea binară: 1 = negativ, 0 = pozitiv.<br/>

<strong>Mantisa</strong> dă partea fracționară a numărului în forma normală. Numărul de biți pe care mantisa este reprezentată dă precizia maximă a reprezentării.<br/>

<strong>Baza</strong> este de obicei 2, 10 sau 16 și este dată de standardul de reprezentare ales.<br/>

<strong>Exponentul</strong> dă valoarea la care este ridicată baza și numărul de biți pe care este reprezentat dă valorile valorile maxime și minime ce pot fi reprezentate.<br/>

</p>

</div>
<!-- EDIT2 SECTION "Reprezentarea numerelor în virgulă mobilă" [592-2255] -->
<h3 class="sectionedit3" id="standarde_de_reprezentare_in_virgula_mobila">Standarde de reprezentare în virgulă mobilă</h3>
<div class="level3">

<p>
Cele mai folosite standarde de reprezentare în virgulă mobilă sunt cu precizie simplă (<strong>Single Precision</strong>) și cu precizie dublă (<strong>Double Precision</strong>).
</p>

<p>
Reprezentarea cu <strong>precizie simplă</strong> presupune folosirea a 32 de biți și corespunde valorilor float din limbajul C. În acest caz baza folosită este 2, exponentul are 8 biți, iar restul de 23 de biți corespund mantisei.
</p>

<p>
Reprezentarea cu <strong>precizie dublă</strong> presupune folosirea a 64 de biți și corespunde valorilor de tip double. În acest caz, baza este 2, exponentul are 11 biți, iar restul de 52 de biți corespund mantisei.
</p>

<p>
<p><div class="noteclassic">
În ambele cazuri, exponentul folosit în calcul nu este cel extras din numărul în forma binară, ci este calculat astfel:
* În precizie simplă, exponentul este dat de valoarea <code>(exponentul pe 8 de biți) - 127</code> (adică se scade o valoare fixă din valoarea efectivă a exponentului)
* În precizie dublă, exponentul este dat de valoarea <code>(exponentul pe 11 de biți) - 1023</code> (adică se scade o valoare fixă din valoarea efectivă a exponentului)
</p>

<p>

</div></p>
</p>

</div>
<!-- EDIT3 SECTION "Standarde de reprezentare în virgulă mobilă" [2256-3386] -->
<h3 class="sectionedit4" id="valori_speciale">Valori speciale</h3>
<div class="level3">

<p>
În ambele standarde de reprezentare, valorile ce au ca exponent 0 sau valoarea maximă (255 pentru precizie simplă șu 2047 pentru precizie dublă) sunt valori speciale. Printre acestea se numără:
* Valoarea 0: toți biții (de semn, exponent și mantisă) sunt 0
* Valorile +/-infinit, ce rezultă în urma oricărei împărțiri la 0. Aceste valori se reprezintă prin mantisă 0 și exponent maxim (255 pentru precizie simplă și 2047 pentru precizie dublă).
* Valoarea NaN (not a number), ce rezultă în urma operațiilor invalide, precum 0/0 sau infinit - infinit. Această valoarea este reprezentată prin exponent maxim și mantisă diferită de 0.
</p>

</div>
<!-- EDIT4 SECTION "Valori speciale" [3387-4078] -->
<h2 class="sectionedit5" id="unitatea_de_calcul_in_virgula_mobila">Unitatea de calcul în virgulă mobilă</h2>
<div class="level2">

<p>
În procesoarele vechi, calculele matematice erau efectuate pe un chip separat, numit <strong>coprocesor matematic</strong> care comunica cu procesorul principal. Procesoarele moderne au acest chip încorporat sub forma Floating Point Unit, care le permite să efectueze eficient calcule matematice cu numere fracționare folosind un set separat de instrucțiuni.
</p>

<p>
Unitatea de calcul în virgulă mobilă deține o stivă proprie pe care o folosește pentru a citi operanzii și a stoca rezultatele operațiilor.
</p>

<p>
De exemplu, o instrucțiune de tip adunare scoate primele două valori de pe această stivă, efectuează operația de adunare și pune rezultatul înapoi în vârful stivei. Deci, înainte de efectuarea oricărei operații va trebui să punem operanzii necesari pe stivă și, după efectuarea operației, vom obține rezultatul folosind o instrucțiune de tip pop.
</p>

</div>
<!-- EDIT5 SECTION "Unitatea de calcul în virgulă mobilă" [4079-4999] -->
<h2 class="sectionedit6" id="instructiuni_pentru_calcul_in_virgula_mobila">Instrucțiuni pentru calcul în virgulă mobilă</h2>
<div class="level2">

</div>
<!-- EDIT6 SECTION "Instrucțiuni pentru calcul în virgulă mobilă" [5000-5061] -->
<h3 class="sectionedit7" id="instructiuni_de_tip_push">Instrucțiuni de tip push</h3>
<div class="level3">
<div class="table sectionedit8"><table class="inline">
	<tr class="row0">
		<th class="col0 leftalign"> Instrucțiune      </th><th class="col1 leftalign"> Descriere          </th>
	</tr>
	<tr class="row1">
		<td class="col0 leftalign"> fld1              </td><td class="col1"> Stochează constanta 1 în vârful stivei </td>
	</tr>
	<tr class="row2">
		<td class="col0 leftalign"> fldz              </td><td class="col1 leftalign"> Stochează constanta 0 în vârful stivei  </td>
	</tr>
	<tr class="row3">
		<td class="col0 leftalign"> fldpi             </td><td class="col1 leftalign"> Stochează constanta π în vârful stivei  </td>
	</tr>
	<tr class="row4">
		<td class="col0 leftalign"> fld DWORD [registru]  </td><td class="col1 leftalign"> Stochează valoarea de tip float (4 octeți) de la adresa indicată de registru  </td>
	</tr>
	<tr class="row5">
		<td class="col0"> fild DWORD [registru] </td><td class="col1"> Stochează valoarea de tip integer (4 octeți) de la adresa indicată de registru </td>
	</tr>
	<tr class="row6">
		<td class="col0 leftalign"> fld QWORD [registru]  </td><td class="col1"> Stochează valoarea de tip double (8 octeți) de la adresa indicată de registru </td>
	</tr>
	<tr class="row7">
		<td class="col0 leftalign"> fld st0               </td><td class="col1"> Duplică valoarea din vârful stivei </td>
	</tr>
	<tr class="row8">
		<td class="col0 leftalign"> fxch                  </td><td class="col1"> Interschimbă primele două valori de pe stivă . </td>
	</tr>
</table></div>
<!-- EDIT8 TABLE [5099-5814] -->
</div>
<!-- EDIT7 SECTION "Instrucțiuni de tip push" [5062-5814] -->
<h3 class="sectionedit9" id="instructiuni_de_tip_pop">Instrucțiuni de tip pop</h3>
<div class="level3">
<div class="table sectionedit10"><table class="inline">
	<tr class="row0">
		<th class="col0 leftalign"> Instrucțiune      </th><th class="col1 leftalign"> Descriere          </th>
	</tr>
	<tr class="row1">
		<td class="col0"> fstp DWORD [registru] </td><td class="col1"> Citește o valoare de tip float (4 octeți) din vârful stivei și o salvează la adresa indicată de registru. Valoarea este eliminată de pe stivă. </td>
	</tr>
	<tr class="row2">
		<td class="col0 leftalign"> fst DWORD [registru]  </td><td class="col1"> Similar cu instrucțiunea anterioară, dar valoarea rămâne în vârful stivei. </td>
	</tr>
	<tr class="row3">
		<td class="col0 leftalign"> fstp QWORD [registru]  </td><td class="col1"> Citește o valoare de tip double (8 octeți) din vârful stivei și o salvează la adresa indicată de registru, eliminând valoarea de pe stivă </td>
	</tr>
	<tr class="row4">
		<td class="col0"> fst QWORD [registru] </td><td class="col1"> Similar cu instrucțiunea anterioară, dar valoare rămâne în vârful stivei. </td>
	</tr>
</table></div>
<!-- EDIT10 TABLE [5851-6464] -->
</div>
<!-- EDIT9 SECTION "Instrucțiuni de tip pop" [5815-6465] -->
<h3 class="sectionedit11" id="instructiuni_de_comparatie">Instrucțiuni de comparație</h3>
<div class="level3">
<div class="table sectionedit12"><table class="inline">
	<tr class="row0">
		<th class="col0 leftalign"> Instrucțiune      </th><th class="col1 leftalign"> Descriere          </th>
	</tr>
	<tr class="row1">
		<td class="col0 leftalign"> fcom       </td><td class="col1"> Compară primele două valori de pe stivă și setează flag-urile interne FPU. </td>
	</tr>
	<tr class="row2">
		<td class="col0 leftalign"> fcomip      </td><td class="col1"> Similar cu prima instrucțiune, dar elimină prima valoare din vârful stivei </td>
	</tr>
	<tr class="row3">
		<td class="col0 leftalign"> fcomi       </td><td class="col1"> Similar cu prima instrucțiune, dar setează flag-urile ZF, PF și CF din registrul EFLAGS. </td>
	</tr>
	<tr class="row4">
		<td class="col0 leftalign"> fcomip      </td><td class="col1"> Similar cu prima instrucțiune, dar setează flag-urile și elimină prima valoare din vârful stivei </td>
	</tr>
	<tr class="row5">
		<td class="col0"> ficom word [registru] </td><td class="col1"> Compara prima valoare de pe stivă cu un număr întreg pe 2 octeți de la adresa indicată de registru </td>
	</tr>
	<tr class="row6">
		<td class="col0"> ficom dword [registru] </td><td class="col1"> Compară prima valoare de pe stivă cu un număr întreg pe 4 octeți de la adresa indicată de registru </td>
	</tr>
	<tr class="row7">
		<td class="col0"> ficom qword [registru] </td><td class="col1"> Compară prima valoare de pe stivă cu un număr întreg pe 8 octeți de la adresa indicată de registru </td>
	</tr>
	<tr class="row8">
		<td class="col0"> ficomp word/dword/qword [registru] </td><td class="col1"> Similar cu instrucțiunile anterioare, dar elimină și prima valoare de pe stivă </td>
	</tr>
	<tr class="row9">
		<td class="col0"> ftst </td><td class="col1"> Compară prima valoare de pe stivă cu 0.0. </td>
	</tr>
</table></div>
<!-- EDIT12 TABLE [6506-7551] -->
<p>
<p><div class="noteimportant">
Doar instrucțiunile fcomi și fcomip setează flag-urile din registrul EFLAGS. Restul instrucțiunilor modifică doar un registru de flag-uri intern FPU-ului. Cu alte cuvinte, dacă folosiți o altă instrucțiune nu puteți face un salt condiționat de rezultatul instrucțiunii, pentru că flag-urile sunt nealterate. Pentru a putea face acest lucru trebuie să citiți registrul intern de flag-uri din FPU și să setați flag-urile din EFLAGS conform cu acesta. Puteți face acest lucru ca în exemplul următor:
</p>
<pre class="code asm"><span class="kw2">ftst</span>       <span class="co1">; compară valoarea din vârful stivei cu +0.0</span>
<span class="kw2">fstsw</span> <span class="kw4">ax</span>   <span class="co1">; copiază registrul de stare intern FPU-ului în AX</span>
<span class="kw2">fwait</span>      <span class="co1">; așteaptă completarea instrucțiunii precedente</span>
<span class="kw1">sahf</span>       <span class="co1">; copiază flag-urile din AX în registrul de stare EFLAGS</span>
&nbsp;
<span class="co1">; acum flag-urile sunt setate în funcție de rezultatul instrucțiunii FTST</span>
<span class="kw1">jg</span> &lt;LABEL&gt;</pre>

<p>

</div></p>
</p>

</div>
<!-- EDIT11 SECTION "Instrucțiuni de comparație" [6466-8457] -->
<h3 class="sectionedit13" id="instructiuni_matematice">Instrucțiuni matematice</h3>
<div class="level3">
<div class="table sectionedit14"><table class="inline">
	<tr class="row0">
		<th class="col0 leftalign"> Instrucțiune      </th><th class="col1 leftalign"> Descriere          </th>
	</tr>
	<tr class="row1">
		<td class="col0"> fabs </td><td class="col1"> Înlocuiește prima valoare de pe stivă cu valoarea ei absolută. </td>
	</tr>
	<tr class="row2">
		<td class="col0"> fchs </td><td class="col1"> Change sign - schimbă semnul valorii din vârful stivei. </td>
	</tr>
	<tr class="row3">
		<td class="col0"> frndint </td><td class="col1"> Round to integer - rotunjește prima valoare de pe stivă la întreg. </td>
	</tr>
	<tr class="row4">
		<td class="col0"> fadd dword/qword [registru] </td><td class="col1"> Adună prima valoare de pe stivă cu cea indicată de adresa din registru (pe 4/8 octeți). </td>
	</tr>
	<tr class="row5">
		<td class="col0"> fdiv dword/qword [registru] </td><td class="col1"> Împarte prima valoare de pe stivă cu cea indicată de adresa din registru (pe 4/8 octeți) </td>
	</tr>
	<tr class="row6">
		<td class="col0"> fdivr dword/qword [registru] </td><td class="col1"> Similar cu instrucțiunea precedentă, dar împărțirea este inversă. </td>
	</tr>
	<tr class="row7">
		<td class="col0"> fmul dword/qword [registru] </td><td class="col1"> Înmulțește prima valoare de pe stivă cu cea indicată de adresa din registru (pe 4/8 octeți). </td>
	</tr>
	<tr class="row8">
		<td class="col0"> fsub dword/qword [registru] </td><td class="col1"> Scade din prima valoare de pe stivă valoarea indicată de adresa din registru (pe 4/8 octeți). </td>
	</tr>
	<tr class="row9">
		<td class="col0"> fsubr dword/qword [registru] </td><td class="col1"> Similar cu instrucțiunea anterioară, dar ordinea operanzilor se schimbă </td>
	</tr>
	<tr class="row10">
		<td class="col0"> fsqrt </td><td class="col1"> Înlocuiește prima valoare de pe stivă cu rădăcina ei pătrată </td>
	</tr>
	<tr class="row11">
		<td class="col0 leftalign"> fsin  </td><td class="col1"> Înlocuiește prima valoare de pe stivă cu rezultatul funcției sin. </td>
	</tr>
	<tr class="row12">
		<td class="col0 leftalign"> fcos  </td><td class="col1"> Înlocuiește prima valoare de pe stivă cu rezultatul funcției cos. </td>
	</tr>
</table></div>
<!-- EDIT14 TABLE [8495-9747] -->
<p>
Instrucțiunile <code>fiadd</code>, <code>fisub</code>, <code>fidiv</code>, <code>fimul</code> funcționează exact ca cele din tabelul de mai sus, dar primesc ca arguument o valoare întreagă de 2/4 octeți (word/dword).
</p>

<p>
Lista completă a instucțiunilor poate fi văzută <a href="https://docs.oracle.com/cd/E18752_01/html/817-5477/eoizy.html" class="urlextern" title="https://docs.oracle.com/cd/E18752_01/html/817-5477/eoizy.html"  rel="nofollow">aici</a>
</p>

</div>
<!-- EDIT13 SECTION "Instrucțiuni matematice" [8458-10060] -->
<h3 class="sectionedit15" id="exemple">Exemple</h3>
<div class="level3">

<p>
Mai jos este prezentat un exemplu de adunare a două numere cu virgulă, reprezentate pe 8 octeți (de tip double). Am folosit valori double pentru a putea folosi printf pentru afișare, întrucât acesta nu poate afișa valori cu precizie simplă.
</p>
<pre class="code asm"><span class="kw5">%include</span> <span class="st0">&quot;io.inc&quot;</span>
&nbsp;
<span class="kw5">extern</span> printf
&nbsp;
<span class="kw5">section</span> <span class="kw5">.data</span>
    n1    <span class="kw5">dq</span>    <span class="nu0">1.1</span>
    n2    <span class="kw5">dq</span>    <span class="nu0">4.3</span>
    format    <span class="kw5">db</span>     <span class="st0">&quot;%f&quot;</span><span class="sy1">,</span> <span class="nu0">10</span><span class="sy1">,</span> <span class="nu0">0</span>
&nbsp;
<span class="kw5">section</span> <span class="kw5">.text</span>
    <span class="kw5">global</span> CMAIN
CMAIN<span class="sy1">:</span>
    <span class="kw1">mov</span> <span class="kw4">ebp</span><span class="sy1">,</span> <span class="kw4">esp</span>
&nbsp;
    <span class="kw2">fld</span> <span class="kw6">qword</span> <span class="br0">&#91;</span>n1<span class="br0">&#93;</span>
    <span class="kw2">fadd</span> <span class="kw6">qword</span> <span class="br0">&#91;</span>n2<span class="br0">&#93;</span>
&nbsp;
    <span class="kw1">sub</span> <span class="kw4">esp</span><span class="sy1">,</span> <span class="nu0">8</span>      <span class="co1">; rezervă loc pe stivă pentru rezultat, pasat ca argument funcției printf.</span>
    <span class="kw2">fstp</span> <span class="kw6">qword</span> <span class="br0">&#91;</span><span class="kw4">esp</span><span class="br0">&#93;</span><span class="co1">; mută rezultatul adunării în spațiul rezervat.</span>
&nbsp;
    <span class="kw1">push</span> format
    <span class="kw1">call</span> printf
    <span class="kw1">add</span> <span class="kw4">esp</span><span class="sy1">,</span> <span class="nu0">12</span>
&nbsp;
    <span class="kw1">ret</span></pre>

<p>
Exemplul de mai jos citește o valoare de tip double de la tastatură și afișează rezultatul expresiei sin(x * pi).
</p>
<pre class="code asm"><span class="kw5">%include</span> <span class="st0">&quot;io.inc&quot;</span>
&nbsp;
<span class="kw5">extern</span> printf
<span class="kw5">extern</span> scanf
&nbsp;
<span class="kw5">section</span> <span class="kw5">.data</span>
    x            <span class="kw5">dq</span>     <span class="nu0">0.0</span>
    scan_format  <span class="kw5">db</span>     <span class="st0">&quot;%lf&quot;</span>
    print_format <span class="kw5">db</span>     <span class="st0">&quot;sin(pi * x) = %f&quot;</span><span class="sy1">,</span> <span class="nu0">10</span><span class="sy1">,</span> <span class="nu0">0</span>
&nbsp;
<span class="kw5">section</span> <span class="kw5">.text</span>
    <span class="kw5">global</span> CMAIN
CMAIN<span class="sy1">:</span>
    <span class="kw1">mov</span> <span class="kw4">ebp</span><span class="sy1">,</span> <span class="kw4">esp</span>
&nbsp;
    <span class="kw1">push</span> x
    <span class="kw1">push</span> scan_format
    <span class="kw1">call</span> scanf
&nbsp;
    <span class="kw1">add</span> <span class="kw4">esp</span><span class="sy1">,</span> <span class="nu0">8</span>
&nbsp;
    <span class="kw2">fldpi</span>
    <span class="kw2">fmul</span> <span class="kw6">qword</span> <span class="br0">&#91;</span>x<span class="br0">&#93;</span>
    <span class="kw2">fsin</span>
&nbsp;
    <span class="kw1">sub</span> <span class="kw4">esp</span><span class="sy1">,</span> <span class="nu0">8</span>
    <span class="kw2">fstp</span> <span class="kw6">qword</span> <span class="br0">&#91;</span><span class="kw4">esp</span><span class="br0">&#93;</span>
&nbsp;
    <span class="kw1">push</span> print_format
    <span class="kw1">call</span> printf
    <span class="kw1">add</span> <span class="kw4">esp</span><span class="sy1">,</span> <span class="nu0">12</span>
&nbsp;
    <span class="kw1">ret</span></pre>

</div>
<!-- EDIT15 SECTION "Exemple" [10061-11388] -->
<h2 class="sectionedit16" id="exercitii">Exerciții</h2>
<div class="level2">

<p>
Pentru exercițiile din acest laborator vom folosi fișierele din <a href="http://elf.cs.pub.ro/asm/res/laboratoare/lab-12-tasks.zip" class="urlextern" title="http://elf.cs.pub.ro/asm/res/laboratoare/lab-12-tasks.zip"  rel="nofollow">această arhivă</a>. Rezolvarea exercițiilor o vom face în SASM.
</p>

</div>
<!-- EDIT16 SECTION "Exerciții" [11389-11605] -->
<h3 class="sectionedit17" id="p_0_completare_formular_de_feedback_iocla">[1p] 0. Completare formular de feedback IOCLA</h3>
<div class="level3">

<p>
Pentru a îmbunătăți cursul de IOCLA, componentele sale și modul de desfășurare, ne sunt foarte utile opiniile voastre. Pentru aceasta, vă rugăm, să accesați și completați <a href="http://cs.curs.pub.ro/2015/blocks/simplehtml/view.php?courseid=276&amp;blockid=1468" class="urlextern" title="http://cs.curs.pub.ro/2015/blocks/simplehtml/view.php?courseid=276&amp;blockid=1468"  rel="nofollow">formularul de feedback de pe site-ul cs.curs.pub.ro</a>. Trebuie să fiți autentificați și înrolați în cadrul cursului.
</p>

<p>
Formularul este anonim și este activ în perioada 4-20 ianuarie 2016. Rezultatele vor fi vizibile în cadrul echipei cursului doar după încheierea sesiunii. Găsiți <a href="http://cs.curs.pub.ro/2015/blocks/simplehtml/view.php?courseid=276&amp;blockid=1468" class="urlextern" title="http://cs.curs.pub.ro/2015/blocks/simplehtml/view.php?courseid=276&amp;blockid=1468"  rel="nofollow">formularul</a> în partea dreaptă a paginii principale de IOCLA de pe cs.curs.pub.ro într-un frame intitulat &quot;FEEDBACK&quot;,
</p>

<p>
Vă invităm să evaluați activitatea echipei de IOCLA și să precizați punctele tari și punctele slabe și sugestiile voastre de îmbunătățire a disciplinei. Feedback-ul vostru este foarte important pentru noi să creștem calitatea materiei în anii următori și să îmbunătățim disciplinele pe care le veți face în continuare.
</p>

<p>
Ne interesează în special:
</p>
<ul>
<li class="level1"><div class="li"> Ce nu v-a plăcut și ce credeți că nu a mers bine?</div>
</li>
<li class="level1"><div class="li"> De ce nu v-a plăcut și de ce credeți că nu a mers bine?</div>
</li>
<li class="level1"><div class="li"> Ce ar trebuie să facem ca lucrurile să fie plăcute și să meargă bine?</div>
</li>
</ul>

<p>
Vă mulțumim!
</p>

</div>
<!-- EDIT17 SECTION "[1p] 0. Completare formular de feedback IOCLA" [11606-13025] -->
<h3 class="sectionedit18" id="p_1_tutorialsuma_unui_vector_de_numere_fractionare">[1p] 1. Tutorial: Suma unui vector de numere fracționare</h3>
<div class="level3">

<p>
În fișierul <code>suma.asm</code> din subdirectorul <code>ex1/</code> găsiți un exemplu de adunare a valorilor dintr-un vector de numere fracționare. La final, rezultatul este afișat folosind funcția <code>printf</code>. 
</p>

<p>
Parcurgeți și înțelegeți exemplul dat. Deschideți-l folosind SASM și rulați-l.
</p>

</div>
<!-- EDIT18 SECTION "[1p] 1. Tutorial: Suma unui vector de numere fracționare" [13026-13387] -->
<h3 class="sectionedit19" id="p_2_media_unui_vector_de_numere_fractionare">[1p] 2. Media unui vector de numere fracționare</h3>
<div class="level3">

<p>
Acum că am văzut cum putem calcula suma elementelor unui vector, ne propunem să calculăm media acestora. Pentru aceasta trebuie să calculăm mai întai suma (vă puteți inspira din exemplul anterior) și să împărțim la numărul de elemente.
</p>

<p>
Urmăriți comentariile marcate cu <code>TODO</code> din fișierul <code>media.asm</code> din subdirectorul <code>ex2/</code> și completați corespunzător pentru calcularea mediei vectorului de elemente <code>vector</code>.
</p>

<p>
<p><div class="notetip">
Împărțirea se face la un număr întreg (adică se împarte la lungimea vectorului <code>vector</code>). Folosiți instrucțiunea <code>fidiv</code> pentru a împărți valoarea din vârful stivei FPU la un număr cu reprezentare de număr întreg.

</div></p>
</p>

</div>
<!-- EDIT19 SECTION "[1p] 2. Media unui vector de numere fracționare" [13388-14144] -->
<h3 class="sectionedit20" id="p_3_impartirea_a_doua_numere_intregi_cu_rezultat_fractionar">[1p] 3. Împărțirea a două numere întregi cu rezultat fracționar</h3>
<div class="level3">

<p>
În fișierul <code>integer-div.asm</code> din subdirectorul <code>ex3/</code>, completați locurile marcate cu <code>TODO</code> pentru a efectua împărțirea numerelor întregi <code>n1</code> și <code>n2</code>, iar rezultatul să fie un număr fracționar. La final, afișați rezultatul.
</p>

<p>
<p><div class="notetip">
Pentru a împărți la o valoare întreagă (la un număr cu rezentare de număr întreg) folosiți instrucțiunea <code>fidiv</code>.
</p>

<p>
Deîmpărțitul trebuie să fie încărcat în prealabil (<strong>înaintea</strong> împărțirii folosind <code>fidiv</code>) pe stiva FPU tot ca întreg. Pentru a încărca un număr cu reprezentare ca număr întreg pe stiva FPU folosiți instrucțiunea <code>fild</code>.

</div></p>
</p>

</div>
<!-- EDIT20 SECTION "[1p] 3. Împărțirea a două numere întregi cu rezultat fracționar" [14145-14869] -->
<h3 class="sectionedit21" id="p_4_extragere_parte_intreaga_si_fractionara">[2p] 4. Extragere parte întreagă și fracționară</h3>
<div class="level3">

<p>
Completați secțiunile marcate cu <code>TODO</code> din fișierul <code>extract.asm</code> din subdirectorul <code>ex4/</code>, pentru a extrage partea întreagă și partea fracționară a numărului fracționar <code>n</code>.
</p>

<p>
<p><div class="notetip">
Pentru a extrage partea întreagă puteți folosi instrucțiunea <code>fisttp dword &lt;adresa&gt;</code>, care extrage prima valoare din vârful stivei FPU, o trunchiază și o stochează ca un întreg la adresa specificată.

</div></p>
</p>

<p>
<p><div class="notetip">
Instrucțiunea <code>fisttp</code> este o instrucțiune validă, chiar dacă nu este colorată în <code>SASM</code>.

</div></p>
</p>

<p>
<p><div class="notetip">
Instrucțiunea <code>fisttp</code> face și pop la valoarea din vârful stivei FPU. De aceea, pentru obținerea părții fracționare, va trebui să reîncărcați valoarea numărului fracționar <code>n</code> (folosind <code>fld</code>) înainte de scădea valoarea întregii din acesta folosind instrucțiunea <code>fisub</code>.

</div></p>
</p>

</div>
<!-- EDIT21 SECTION "[2p] 4. Extragere parte întreagă și fracționară" [14870-15797] -->
<h3 class="sectionedit22" id="p_5_media_unui_vector_de_intregi_cu_rezultat_fractionar">[2p] 5. Media unui vector de întregi cu rezultat fracționar</h3>
<div class="level3">

<p>
Similar cu exercițiul 2, ne propunem să calculăm media unui vector de elemente, dar în acest caz valorile sunt întregi. Rezultatul trebuie, bineînțeles, să fie fracționar. Completați locurile marcate cu <code>TODO</code> din fișierul <code>media-int.asm</code>, directorul <code>ex5</code>.
</p>

<p>
<p><div class="notetip">
Întrucât numerele care se adună sunt întregi veți folosi pentru aceasta instrucțiunea <code>fiadd</code> care adună numere în reprezentare de număr întreg.
</p>

<p>
De asemenea, când faceți împărțirea, veți folosi instrucțiunea <code>fidiv</code>.
</p>

<p>
Rezultatul operației de împărțire va fi unul fracționar, deci îl veți recupera folosind instrucțiunea <code>fstp</code>.

</div></p>
</p>

</div>
<!-- EDIT22 SECTION "[2p] 5. Media unui vector de întregi cu rezultat fracționar" [15798-16525] -->
<h3 class="sectionedit23" id="p_6_maximul_dintr-un_vector_de_numere_fractionare">[2p] 6. Maximul dintr-un vector de numere fracționare</h3>
<div class="level3">

<p>
Completați fișierul <code>max.asm</code> din subdirectorul <code>ex6/</code> pentru a afla valoarea maximă din vector. Parcurgerea elementelor și comparația cu valoarea maximă este implementată. Urmăriți comentariile ce conțin <code>TODO</code>.
</p>

<p>
<p><div class="notetip">
Pentru a determina instrucțiunea de jump folosită după <code>fcomip</code> urmăriți răspunsul de <a href="http://stackoverflow.com/a/7057771" class="urlextern" title="http://stackoverflow.com/a/7057771"  rel="nofollow">aici</a>.

</div></p>
</p>

<p>
<p><div class="notetip">
Pentru a scoate prima valoare de pe stiva FPU fără a o stoca la o adresă, puteți folosi instrucțiunea <code>fstp ST0</code>.

</div></p>
</p>

<p>
<p><div class="notetip">
Valoarea variabilei <code>max</code> trebuie să ajungă pe stivă. Întrucât valoarea are 8 octeți sunt necesare două operații de tip <code>push dword ...</code>. Întâi faceți push la ultimii 4 octeți ai valorii variabilei <code>max</code> și apoi la primii 4 octeți. Astfel vârful stivei va referi primii 4 octeți ai valorii variabilei <code>max</code> urmați de ultimii 4 octeți.

</div></p>
</p>

</div>
<!-- EDIT23 SECTION "[2p] 6. Maximul dintr-un vector de numere fracționare" [16526-17505] -->
<h3 class="sectionedit24" id="p_bonus_7_implementare_arcsin">[2p Bonus] 7. Implementare arcsin</h3>
<div class="level3">

<p>
În fișierul <code>arcsin.asm</code> din subdirectorul <code>ex7/</code>, calculați valoarea unghiului pentru care funcția sin întoarce valoarea din variabila <code>valoare_sin</code>.
</p>

<p>
Pentru rezolvare veți căuta în intervalul [0, pi/2], folosind metoda bisecției: la fiecare pas calculați valoarea funcției sin în valoarea de la jumătatea intervalului și alegeți jumătatea de interval în care se găsește valoarea căutată (funcția este crescătoare pe intervalul [0, pi/2]). Algoritmul se va opri atunci când eroarea este mai mică decât <code>0.0005</code> (diferența între valoarea obținută și valoarea căutată).
</p>

</div>
<!-- EDIT24 SECTION "[2p Bonus] 7. Implementare arcsin" [17506-] --></div>
</body>
</html>
