    
    

<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
  <meta charset="utf-8" />
  <title>iocla:laboratoare:laborator-01</title>
<meta name="generator" content="DokuWiki"/>
<meta name="robots" content="index,follow"/>
<meta name="date" content="2016-10-07T19:43:05+0300"/>
<meta name="keywords" content="iocla,laboratoare,laborator-01"/>
<link rel="search" type="application/opensearchdescription+xml" href="../../../../lib/exe/opensearch.php" title="CS Open CourseWare"/>
<link rel="start" href="../../../../../courses.1.html"/>
<link rel="alternate" type="application/rss+xml" title="Recent Changes" href="../../../../feed.php"/>
<link rel="alternate" type="application/rss+xml" title="Current Namespace" href="../../../../feed.php%3Fmode=list&amp;ns=iocla:laboratoare"/>
<link rel="alternate" type="text/html" title="Plain HTML" href="laborator-01.html"/>
<link rel="canonical" href="../../../../iocla/laboratoare/laborator-01.html"/>
<link rel="stylesheet" type="text/css" href="../../../../lib/exe/css.php%3Ft=arctic&amp;tseed=1476798676.css"/>
<script type="text/javascript">/*<![CDATA[*/var NS='iocla:laboratoare';var JSINFO = {"id":"iocla:laboratoare:laborator-01","namespace":"iocla:laboratoare","isadmin":0,"isauth":0};
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="../../../../lib/exe/js.php%3Ftseed=1476798676"></script>
<script type="text/x-mathjax-config">/*<![CDATA[*/MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ["$","$"], ["\\(","\\)"] ],
        displayMath: [ ["$$","$$"], ["\\[","\\]"] ],
        processEscapes: true
    }
});
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
<script type="text/javascript">/*<![CDATA[*/
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
		  
/*!]]>*/</script>
<script type="text/javascript">/*<![CDATA[*/
var pageTracker = _gat._getTracker("UA-38383934-1");
pageTracker._initData();
pageTracker._trackPageview();
		  
/*!]]>*/</script>
</head>
<body>
<div class="dokuwiki export">
<!-- TOC START -->
<div id="dw__toc">
<h3 class="toggle">Table of Contents</h3>
<div>

<ul class="toc">
<li class="level1"><div class="li"><a href="laborator-01.html#laborator_01introducere">Laborator 01: Introducere</a></div>
<ul class="toc">
<li class="level2"><div class="li"><a href="laborator-01.html#sistemele_binar_si_hexazecimal">Sistemele binar și hexazecimal</a></div>
<ul class="toc">
<li class="clear">
<ul class="toc">
<li class="level4"><div class="li"><a href="laborator-01.html#conversia_din_zecimal_in_binarhexazecimal">Conversia din zecimal în binar/hexazecimal</a></div></li>
<li class="level4"><div class="li"><a href="laborator-01.html#conversia_din_binarhexazecimal_in_zecimal">Conversia din binar/hexazecimal în zecimal</a></div></li>
<li class="level4"><div class="li"><a href="laborator-01.html#conversia_intre_binar_si_hexazecimal">Conversia intre binar și hexazecimal</a></div></li>
</ul>
</li>
</ul>
</li>
<li class="level2"><div class="li"><a href="laborator-01.html#reprezentarea_numerelor">Reprezentarea numerelor</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="laborator-01.html#integer_overflow">Integer overflow</a></div></li>
<li class="level3"><div class="li"><a href="laborator-01.html#numere_cu_semn_si_fara_semn">Numere cu semn și fără semn</a></div></li>
<li class="level3"><div class="li"><a href="laborator-01.html#ordinea_de_reprezentare_a_numerelor_mai_mari_de_un_octet_little-endian_vs_big-endian">Ordinea de reprezentare a numerelor mai mari de un octet (Little-Endian vs Big-Endian)</a></div>
<ul class="toc">
<li class="level4"><div class="li"><a href="laborator-01.html#avantaje_little-endian">Avantaje Little-Endian</a></div></li>
<li class="level4"><div class="li"><a href="laborator-01.html#avantaje_big-endian">Avantaje Big-Endian</a></div></li>
</ul>
</li>
</ul>
</li>
<li class="level2"><div class="li"><a href="laborator-01.html#operatii_cu_valori_reprezentate_in_binar">Operații cu valori reprezentate în binar</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="laborator-01.html#operatii_aritmetice">Operații aritmetice</a></div></li>
<li class="level3"><div class="li"><a href="laborator-01.html#operatii_logice">Operații logice</a></div>
<ul class="toc">
<li class="level4"><div class="li"><a href="laborator-01.html#operatori_pe_valori_binare">Operatori pe valori binare</a></div></li>
<li class="level4"><div class="li"><a href="laborator-01.html#deplasari_shifts">Deplasări (Shifts)</a></div></li>
<li class="level4"><div class="li"><a href="laborator-01.html#rotatii">Rotații</a></div></li>
</ul>
</li>
</ul>
</li>
<li class="level2"><div class="li"><a href="laborator-01.html#exercitii">Exerciții</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="laborator-01.html#p_1_conversii">[4p] 1. Conversii</a></div></li>
<li class="level3"><div class="li"><a href="laborator-01.html#p_2_dimensiune_tipuri_de_date">[1p] 2. Dimensiune tipuri de date</a></div></li>
<li class="level3"><div class="li"><a href="laborator-01.html#p_3_afisare_in_hexazecimal">[1p] 3. Afișare în hexazecimal</a></div></li>
<li class="level3"><div class="li"><a href="laborator-01.html#p_4_afisare_sir_din_format_codificat_hexazecimal">[1p] 4. Afișare șir din format codificat hexazecimal</a></div></li>
<li class="level3"><div class="li"><a href="laborator-01.html#p_5_afisare_date_din_memorie">[1p] 5. Afișare date din memorie</a></div></li>
<li class="level3"><div class="li"><a href="laborator-01.html#p_6_afisare_variabile">[1p] 6. Afișare variabile</a></div></li>
<li class="level3"><div class="li"><a href="laborator-01.html#p_7_operatie_xor_intre_numere_in_format_hexazecimal">[1p] 7. Operație XOR între numere în format hexazecimal</a></div></li>
</ul></li>
</ul></li>
</ul>
</div>
</div>
<!-- TOC END -->

<h1 class="sectionedit1" id="laborator_01introducere">Laborator 01: Introducere</h1>
<div class="level1">

<p>
Pentru reprezentarea informațiilor (instrucțiuni și date), calculatoarele folosesc sistemul binar (baza 2). În cazul scrierii programelor în limbaj de asamblare este preferat sistemul hexazecimal (baza 16), pentru că scutește programatorul de scrierea șirurilor lungi de 1 și 0, iar conversia din/în binar se poate face mult mai ușor decât în cazul sistemului zecimal (baza 10).
</p>

<p>
<p><div class="notetip">
Pentru reprezentarea numerelor în binar vom folosi prefixul <strong>0b</strong>, iar pentru cele în hexazecimal vom folosi <strong>0x</strong>.

</div></p>
</p>

<p>
Să presupunem următoarea instrucțiune în limbajul C:
</p>
<pre class="code c"><span class="kw4">char</span> a <span class="sy0">=</span> <span class="nu0">113</span><span class="sy0">;</span></pre>

<p>
Această instrucțiune are ca efect stocarea în memorie a unui octet cu valoarea 113, care va fi reprezentat în forma binară: <strong>0b01110001</strong>. Aceeași valoare poate fi scrisă în hexazecimal ca <strong>0x71</strong>.
</p>

</div>
<!-- EDIT1 SECTION "Laborator 01: Introducere" [1-873] -->
<h2 class="sectionedit2" id="sistemele_binar_si_hexazecimal">Sistemele binar și hexazecimal</h2>
<div class="level2">

<p>
Înainte de a începe lucrul cu limbajul de asamblare, este necesar să ne familiarizăm cu sistemele binar și hexazecimal și cu modalitățile de conversie între ele.
</p>

<p>
În <strong>sistemul binar</strong> (baza 2), valorile sunt reprezentate ca un șir de 0 și 1. Fiecare cifră din șir reprezintă un bit, iar un grup de 8 biți formează un <strong>octet</strong> (<strong>byte</strong>). Un grup de 4 biți poartă denumirea de <strong>nibble</strong>, sau <strong>half-byte</strong>.
</p>

<p>
În <strong>sistemul hexazecimal</strong> (baza 16), valorile sunt reprezentate sub forma unui șir de caractere din intervalul &#039;0&#039;-&#039;9&#039; sau &#039;a&#039;-&#039;f&#039;. Un octet este format din două astfel de caractere, deci fiecare caracter corespunde unui grup de 4 biți (un nibble).
</p>

</div>

<h4 id="conversia_din_zecimal_in_binarhexazecimal">Conversia din zecimal în binar/hexazecimal</h4>
<div class="level4">
<ul>
<li class="level1"><div class="li"> Se împarte succesiv numărul la numărul bazei (2 sau 16) și se rețin resturile</div>
</li>
<li class="level1"><div class="li"> Când câtul împărțirii devine 0, se scriu resturile în ordine inversă.</div>
</li>
<li class="level1"><div class="li"> În cazul bazei 16, atunci când restul este mai mare decât 9 se folosesc literele a-f (10=a, 15=f)</div>
</li>
</ul>

</div>

<h5 id="exempluconversia_numarului_113_in_hexazecimal">Exemplu: conversia numărului 113 în hexazecimal</h5>
<div class="level5">
<ul>
<li class="level1"><div class="li"> Pas 1: 113/16 = 7, rest <strong>1</strong></div>
</li>
<li class="level1"><div class="li"> Pas 2: 7 / 16 = 0, rest <strong>7</strong></div>
</li>
<li class="level1"><div class="li"> Câtul este 0, deci putem obține numărul în hexazecimal scriind resturile în ordine inversă: <strong>0x71</strong></div>
</li>
</ul>

</div>

<h4 id="conversia_din_binarhexazecimal_in_zecimal">Conversia din binar/hexazecimal în zecimal</h4>
<div class="level4">

<p>
Un număr convertit din baza X în baza 10 are valoarea egală cu suma produselor dintre fiecare cifră din numărul în baza X și X la puterea egală cu poziția cifrei în numărul respectiv (numărarea se face de la dreapta la stânga, începând cu 0).
</p>

</div>

<h5 id="exempluconversia_numarului_0xd9b1_in_zecimal">Exemplu: conversia numărului 0xD9B1 în zecimal</h5>
<div class="level5">

<p>
0xD9B1 = 1*16<sup>0</sup> + 11*16<sup>1</sup> + 9*16<sup>2</sup> + 13*16<sup>3</sup> = 55729
</p>

</div>

<h4 id="conversia_intre_binar_si_hexazecimal">Conversia intre binar și hexazecimal</h4>
<div class="level4">

<p>
După cum am precizat anterior, o cifră din cadrul unui număr în hexazecimal corespunde unui grup de 4 biți (un nibble). Astfel, pentru a converti un număr din hexazecimal în binar este suficient să transformăm fiecare cifră în grupul de 4 biți echivalent.
</p>

</div>

<h5 id="exempluconversia_numarului_0xd9b1_in_binar">Exemplu: Conversia numărului 0xD9B1 în binar</h5>
<div class="level5">
<ul>
<li class="level1"><div class="li"> 0x1 = 0b0001</div>
</li>
<li class="level1"><div class="li"> 0xB = 0b1011</div>
</li>
<li class="level1"><div class="li"> 0x9 = 0b1001</div>
</li>
<li class="level1"><div class="li"> 0xD = 0b1101</div>
</li>
</ul>

<p>
Astfel, numărul obținut în binar este <strong>0b1101100110110001</strong>.
</p>

<p>
Operația inversă, conversia din binar în hexazecimal se poate face convertind fiecare grup de 4 biți în cifra corespunzătoare în hexazecimal.
</p>

</div>
<!-- EDIT2 SECTION "Sistemele binar și hexazecimal" [874-3386] -->
<h2 class="sectionedit3" id="reprezentarea_numerelor">Reprezentarea numerelor</h2>
<div class="level2">

<p>
În memoria unui calculator o valoare este memorată pe un număr fix de biți.
Dimensiunea cuvântului (<strong>word size</strong>) arhitecturii unui procesor reprezintă numărul maxim de biți cu care procesorul îi poate accesa printr-o singură operație.
</p>

<p>
Dimensiunile tipurilor de date uzuale folosite în C sunt dependente atât de procesor, cât și de platforma cu ajutorul căreia a fost compilat programul (sistem de operare, compilator). 
În tabelul de mai jos sunt prezentate dimensiunile tipurilor de date pe un procesor cu dimensiunea cuvântului arhitecturii de 32 de biți, în cazul în care programul este compilat folosind gcc, sub Linux.
</p>
<div class="table sectionedit4"><table class="inline">
	<tr class="row0">
		<th class="col0"> Tip de date </th><th class="col1 leftalign"> Număr biți      </th><th class="col2 leftalign"> Număr octeți          </th>
	</tr>
	<tr class="row1">
		<td class="col0 leftalign"> char        </td><td class="col1 leftalign"> 8               </td><td class="col2 leftalign"> 1                     </td>
	</tr>
	<tr class="row2">
		<td class="col0 leftalign"> short       </td><td class="col1 leftalign"> 16              </td><td class="col2 leftalign"> 2                     </td>
	</tr>
	<tr class="row3">
		<td class="col0 leftalign"> int         </td><td class="col1 leftalign"> 32              </td><td class="col2 leftalign"> 4                     </td>
	</tr>
	<tr class="row4">
		<td class="col0 leftalign"> long        </td><td class="col1 leftalign"> 32              </td><td class="col2 leftalign"> 4                     </td>
	</tr>
	<tr class="row5">
		<td class="col0 leftalign"> long long   </td><td class="col1 leftalign"> 64              </td><td class="col2 leftalign"> 8                     </td>
	</tr>
	<tr class="row6">
		<td class="col0 leftalign"> pointer     </td><td class="col1 leftalign"> 32              </td><td class="col2 leftalign"> 4                     </td>
	</tr>
</table></div>
<!-- EDIT4 TABLE [4073-4482] -->
</div>
<!-- EDIT3 SECTION "Reprezentarea numerelor" [3387-4484] -->
<h3 class="sectionedit5" id="integer_overflow">Integer overflow</h3>
<div class="level3">

<p>
În cazul în care un număr trebuie reprezentat în binar pe un număr de biți mai mare decât numărul maxim alocat, atunci vor fi păstrați doar biții care încap (începând din partea dreaptă), iar restul sunt ignorați. Această situație poartă denumirea de <strong>integer overflow</strong>.
</p>

<p>
Un overflow poate să apară și în cazul în care se efectuează o operație (de exemplu adunare), iar rezultatul se dorește să fie reprezentat pe același număr de biți ca și operanzii. În acest caz este posibil ca rezultatul să nu încapă pe numărul respectiv de biți, iar primul bit (din stânga) să fie ignorat. O soluție folosită în procesoare pentru această situație este memorarea separată a unui bit în cazul în care operația duce la integer overflow, numit bit de depășire (carry bit).
</p>

</div>

<h5 id="exemplu_de_integer_overflow_la_adunare">Exemplu de integer overflow la adunare</h5>
<div class="level5">

<p>
Să presupunem că dorim să adunăm două valori stocate pe un octet, iar rezultatul să fie memorat tot pe un octet.
</p>
<pre class="code">O1 = 171 = 0b10101011
O2 = 113 = 0b01110001
Rezultatul așteptat: 171+113 = 0b100011100
Rezultatul memorat pe 8 biți: 0b00011100
Carry bit = 1</pre>

</div>
<!-- EDIT5 SECTION "Integer overflow" [4485-5651] -->
<h3 class="sectionedit6" id="numere_cu_semn_si_fara_semn">Numere cu semn și fără semn</h3>
<div class="level3">

<p>
Folosind N biți putem memora 2<sup>N</sup> valori, de exemplu între 0 și 2<sup>N</sup>-1. Aceste valori sunt fără semn (toate sunt pozitive), pentru că nu putem face deosebirea între cele pozitive și negative. Dacă dorim și reprezentarea valorilor negative, trebuie să alocăm o parte din combinațiile binare posibile pe N biți pentru aceste valori.
</p>

<p>
În practică se împart combinațiile posibile astfel:
</p>
<ul>
<li class="level1"><div class="li"> prima jumătate este folosită pentru numere pozitive între 0 și 2<sup>N-1</sup>-1.</div>
</li>
<li class="level1"><div class="li"> a doua jumătate este alocată numerelor negative, între -2<sup>N-1</sup> și -1.</div>
</li>
</ul>

<p>
De exemplu, pentru valori reprezentate pe 8 biți, împărțirea se face astfel:
</p>
<ul>
<li class="level1"><div class="li"> combinațiile binare între 0b00000000 și 0b011111111 corespund valorilor între 0 și 127.</div>
</li>
<li class="level1"><div class="li"> combinațiile între 0b10000000 și 0b11111111 corespund valorilor între -128 și -1 (0b10000000=-128, 0b11111111=-1).</div>
</li>
</ul>

<p>
Această reprezentare a fost aleasă pentru că prezintă o serie de avantaje:
</p>
<ul>
<li class="level1"><div class="li"> Putem determina foarte ușor dacă un număr este negativ sau pozitiv, după valoarea primului bit (1=negativ, 0=pozitiv)</div>
</li>
<li class="level1"><div class="li"> Pentru numere pozitive avem aceeași reprezentare ca în cazul numerelor fără semn.</div>
</li>
<li class="level1"><div class="li"> Operațiile aritmetice se fac exact ca în cazul numerelor fără semn</div>
</li>
</ul>

<p>
Pentru negarea unui număr (transformarea în complement față de 2) se procedează astfel:
</p>
<ol>
<li class="level1"><div class="li"> Se neagă toți biții din reprezentarea numărului în baza 2</div>
</li>
<li class="level1"><div class="li"> Se adună valoarea 1.</div>
</li>
</ol>

</div>

<h5 id="exemplureprezentarea_valorii_-29_in_binar">Exemplu: Reprezentarea valorii -29 în binar</h5>
<div class="level5">
<ul>
<li class="level1"><div class="li"> 29 = 0b00011101.</div>
</li>
<li class="level1"><div class="li"> Valoarea negată: 0b11100010.</div>
</li>
<li class="level1"><div class="li"> -29 = 0b11100010 + 1 = 0b11100011</div>
</li>
</ul>

<p>
<p><div class="noteimportant">
Aceeași valoare în binar are semnificații diferite în zecimal dacă reprezentarea se consideră cu semn sau fără. De exemplu, valoarea 0b11100011 este interpretată ca 227 în reprezentarea fără semn și ca -29 în reprezentarea cu semn.

</div></p>
</p>

</div>
<!-- EDIT6 SECTION "Numere cu semn și fără semn" [5652-7569] -->
<h3 class="sectionedit7" id="ordinea_de_reprezentare_a_numerelor_mai_mari_de_un_octet_little-endian_vs_big-endian">Ordinea de reprezentare a numerelor mai mari de un octet (Little-Endian vs Big-Endian)</h3>
<div class="level3">

<p>
Pentru reprezentarea valorilor mai mari de un octet există două metode posibile, ambele folosite în practică:
</p>
<ul>
<li class="level1"><div class="li"> Little-Endian: cel mai puțin semnificativ octet este memorat primul (octeții sunt memorații în ordine inversă). Acest model este folosit de familia de procesoare Intel x86.</div>
</li>
<li class="level1"><div class="li"> Big-Endian: cel mai semnificativ octet este memorat primul.</div>
</li>
</ul>

<p>
<strong>Exemplu:</strong> Dorim să stocăm valoarea 0x4a912480 în memorie pe 32 de biți (4 octeți), începând cu adresa 0x100, folosind cele două metode:
</p>
<div class="table sectionedit8"><table class="inline">
	<tr class="row0">
		<th class="col0 leftalign"> Metoda      </th><th class="col1 leftalign"> Adresa 0x100    </th><th class="col2 leftalign"> Adresa 0x101      </th><th class="col3 leftalign"> Adresa 0x102  </th><th class="col4"> Adresa 0x103 </th>
	</tr>
	<tr class="row1">
		<td class="col0 leftalign"> Little-Endian        </td><td class="col1 leftalign"> 0x80   </td><td class="col2 leftalign"> 0x24   </td><td class="col3 leftalign"> 0x91    </td><td class="col4"> 0x4a </td>
	</tr>
	<tr class="row2">
		<td class="col0 leftalign"> Big-Endian           </td><td class="col1 leftalign"> 0x4a   </td><td class="col2 leftalign"> 0x91   </td><td class="col3 leftalign"> 0x24    </td><td class="col4"> 0x80 </td>
	</tr>
</table></div>
<!-- EDIT8 TABLE [8177-8381] -->
</div>

<h4 id="avantaje_little-endian">Avantaje Little-Endian</h4>
<div class="level4">

<p>
<strong>1.</strong> Valorile mici (pe un octet) sunt stocate mereu la aceeași adresă, indiferent de dimensiunea tipului de date folosit.<br/>

<strong>Exemplu</strong>: Dorim stocarea valorii 0x49 la adresa 0x2000 cu tipurile char, short și int:
</p>
<div class="table sectionedit9"><table class="inline">
	<tr class="row0">
		<th class="col0 leftalign"> Tip de date   </th><th class="col1 leftalign"> 0x2000   </th><th class="col2 leftalign"> 0x2001   </th><th class="col3 leftalign"> 0x2002   </th><th class="col4 leftalign"> 0x2003    </th>
	</tr>
	<tr class="row1">
		<td class="col0 leftalign"> char        </td><td class="col1 leftalign"> 0x49   </td><td class="col2 leftalign"> -      </td><td class="col3 leftalign"> -      </td><td class="col4 leftalign"> -      </td>
	</tr>
	<tr class="row2">
		<td class="col0 leftalign"> short       </td><td class="col1 leftalign"> 0x49   </td><td class="col2 leftalign"> 0x00   </td><td class="col3 leftalign"> -      </td><td class="col4 leftalign"> -      </td>
	</tr>
	<tr class="row3">
		<td class="col0 leftalign"> int         </td><td class="col1 leftalign"> 0x49   </td><td class="col2 leftalign"> 0x00   </td><td class="col3 leftalign"> 0x00   </td><td class="col4 leftalign"> 0x00   </td>
	</tr>
</table></div>
<!-- EDIT9 TABLE [8634-8852] -->
<p>
<strong>2.</strong> Oferă ușurință în efectuarea operațiilor aritmetice. Majoritatea operațiilor se efectuează începând cu cel mai puțin semnificativ octet, iar acesta este stocat primul în cadrul acestui mod de reprezentare, deci putem efectua operațiile pe mai mulți octeți parcurgând operanzii de la adresa cea mai mică adresă la cea mai mare.
</p>

</div>

<h4 id="avantaje_big-endian">Avantaje Big-Endian</h4>
<div class="level4">

<p>
<strong>1.</strong> Valorile nu necesită transformări în momentul în care se transmit pe rețea. Pentru a se putea realiza comunicația între două calculatoare care folosesc metode diferite de reprezentare, toate valorile transmise sunt reprezentate în formatul <strong>Network byte order</strong>, care este echivalent cu Big-Endian.
</p>

<p>
<strong>2.</strong> Valorile pe mai mulți octeți sunt mai ușor de citit în momentul examinării unei zone de memorie.
</p>

</div>
<!-- EDIT7 SECTION "Ordinea de reprezentare a numerelor mai mari de un octet (Little-Endian vs Big-Endian)" [7570-9659] -->
<h2 class="sectionedit10" id="operatii_cu_valori_reprezentate_in_binar">Operații cu valori reprezentate în binar</h2>
<div class="level2">

</div>
<!-- EDIT10 SECTION "Operații cu valori reprezentate în binar" [9660-9715] -->
<h3 class="sectionedit11" id="operatii_aritmetice">Operații aritmetice</h3>
<div class="level3">

<p>
<a href="http://academic.evergreen.edu/projects/biophysics/technotes/misc/bin_math.htm" class="urlextern" title="http://academic.evergreen.edu/projects/biophysics/technotes/misc/bin_math.htm"  rel="nofollow">Ghid pentru operații aritmetice.</a>
</p>

</div>
<!-- EDIT11 SECTION "Operații aritmetice" [9716-9864] -->
<h3 class="sectionedit12" id="operatii_logice">Operații logice</h3>
<div class="level3">

</div>

<h4 id="operatori_pe_valori_binare">Operatori pe valori binare</h4>
<div class="level4">
<ol>
<li class="level1"><div class="li"> <strong>Inversare</strong> (<strong>NOT</strong>): se inversează fiecare bit. Exemplu: INV(0b10011010) = 0b01100101</div>
</li>
<li class="level1"><div class="li"> <strong>Și logic</strong> (<strong>AND</strong>): se efectuează operația &#039;și&#039; între biții de pe aceleași poziții din operanzi. Exemplu: 0b1001 AND 0b0111 = 0b0001</div>
</li>
<li class="level1"><div class="li"> <strong>Sau logic</strong> (<strong>OR</strong>): se efectuează operația &#039;sau&#039; între biții de pe aceleași poziții din operanzi. Exemplu: 0b1001 OR 0b0111 = 0b1111</div>
</li>
<li class="level1"><div class="li"> <strong>Sau exclusiv</strong> (<strong>XOR</strong>): dacă biții de pe aceleași poziții din operanzi au valori egale, bitul rezultat are valoarea 0, altfel are valoarea 1. Exemplu: 0b1001 XOR 0b0111 = 0b1110</div>
</li>
</ol>

</div>

<h4 id="deplasari_shifts">Deplasări (Shifts)</h4>
<div class="level4">

</div>

<h5 id="deplasari_logice">Deplasări logice</h5>
<div class="level5">

<p>
Deplasările logice dreapta/stânga presupun mutarea cu o poziție a fiecărui bit. Cum rezultatul trebuie să fie pe același număr de biți ca valoarea inițială, primul bit este pierdut, iar spațiul gol este completat cu bitul 0.
</p>
<div class="table sectionedit13"><table class="inline">
	<tr class="row0">
		<td class="col0"> <a href="../../../../_detail/iocla/laboratoare/left-logical-shift.png%3Fid=iocla%253Alaboratoare%253Alaborator-01.html" class="media" title="iocla:laboratoare:left-logical-shift.png"><img src="../../../../_media/iocla/laboratoare/left-logical-shift.png%3Fw=200&amp;tok=6a273c" class="media" alt="" width="200" /></a> </td><td class="col1"> <a href="../../../../_detail/iocla/laboratoare/right-logical-shift.png%3Fid=iocla%253Alaboratoare%253Alaborator-01.html" class="media" title="iocla:laboratoare:right-logical-shift.png"><img src="../../../../_media/iocla/laboratoare/right-logical-shift.png%3Fw=200&amp;tok=4990cc" class="media" alt="" width="200" /></a> </td>
	</tr>
	<tr class="row1">
		<td class="col0 leftalign"> Deplasare logică la stânga                   </td><td class="col1 leftalign"> Deplasare logică la dreapta                   </td>
	</tr>
</table></div>
<!-- EDIT13 TABLE [10802-11010] -->
</div>

<h5 id="deplasari_aritmetice">Deplasări aritmetice</h5>
<div class="level5">

<p>
Deplasarea aritmetică stânga este identică cu cea logică. În schimb, deplasarea aritmetică dreapta păstrează semnul valorii (în cazul în care primul bit este 1, deci numărul este negativ, rezultatul trebuie să fie tot negativ).
</p>
<div class="table sectionedit14"><table class="inline">
	<tr class="row0">
		<td class="col0"> <a href="../../../../_detail/iocla/laboratoare/left-arithmetic-shift.png%3Fid=iocla%253Alaboratoare%253Alaborator-01.html" class="media" title="iocla:laboratoare:left-arithmetic-shift.png"><img src="../../../../_media/iocla/laboratoare/left-arithmetic-shift.png%3Fw=200&amp;tok=dc311c" class="media" alt="" width="200" /></a> </td><td class="col1"> <a href="../../../../_detail/iocla/laboratoare/right-arithmetic-shift.png%3Fid=iocla%253Alaboratoare%253Alaborator-01.html" class="media" title="iocla:laboratoare:right-arithmetic-shift.png"><img src="../../../../_media/iocla/laboratoare/right-arithmetic-shift.png%3Fw=200&amp;tok=69e6b5" class="media" alt="" width="200" /></a> </td>
	</tr>
	<tr class="row1">
		<td class="col0 leftalign"> Deplasare aritmetică la stânga                   </td><td class="col1 leftalign"> Deplasare aritmetică la dreapta                   </td>
	</tr>
</table></div>
<!-- EDIT14 TABLE [11282-11504] -->
<p>
<p><div class="noteclassic">
Operația de shiftare la stânga a unei valori este echivalentă cu înmulțirea valorii respective cu 2. Generalizând, o shiftare a unei valori cu N poziții la stânga este echivalentă cu înmulțirea valorii respective cu 2<sup>N</sup>.
</p>

<p>
Similar, deplasarea unei valori cu N poziții la dreapta este echivalentă cu împărțirea valorii respective la 2<sup>N</sup> (și rotunjirea rezultatului la partea întreagă).

</div></p>
</p>

</div>

<h4 id="rotatii">Rotații</h4>
<div class="level4">

<p>
Operația de rotire (numită și deplasare circulară) este similară cu cea de deplasare, singura diferență fiind aceea că spațiul gol generat de deplasare este înlocuit cu bitul eliminat.
</p>
<div class="table sectionedit15"><table class="inline">
	<tr class="row0">
		<td class="col0"> <a href="../../../../_detail/iocla/laboratoare/left-rotate.png%3Fid=iocla%253Alaboratoare%253Alaborator-01.html" class="media" title="iocla:laboratoare:left-rotate.png"><img src="../../../../_media/iocla/laboratoare/left-rotate.png%3Fw=200&amp;tok=4efa48" class="media" alt="" width="200" /></a> </td><td class="col1"> <a href="../../../../_detail/iocla/laboratoare/right-rotate.png%3Fid=iocla%253Alaboratoare%253Alaborator-01.html" class="media" title="iocla:laboratoare:right-rotate.png"><img src="../../../../_media/iocla/laboratoare/right-rotate.png%3Fw=200&amp;tok=7eae6b" class="media" alt="" width="200" /></a> </td>
	</tr>
	<tr class="row1">
		<td class="col0 leftalign"> Rotire la stânga                      </td><td class="col1 leftalign"> Rotire la dreapta                      </td>
	</tr>
</table></div>
<!-- EDIT15 TABLE [12160-12338] -->
<p>
Majoritatea procesoarelor permit un tip special de rotire, și anume rotire folosind un bit auxiliar. De obicei, ca bit auxiliar se folosește bitul de carry.
În acest caz, spațiul gol este înlocuit cu bitul auxiliar, iar bitul eliminat este memorat în acest bit.
</p>
<div class="table sectionedit16"><table class="inline">
	<tr class="row0">
		<td class="col0"> <a href="../../../../_detail/iocla/laboratoare/left-rotate-carry.png%3Fid=iocla%253Alaboratoare%253Alaborator-01.html" class="media" title="iocla:laboratoare:left-rotate-carry.png"><img src="../../../../_media/iocla/laboratoare/left-rotate-carry.png%3Fw=200&amp;tok=0cfa78" class="media" alt="" width="200" /></a> </td><td class="col1"> <a href="../../../../_detail/iocla/laboratoare/right-rotate-carry.png%3Fid=iocla%253Alaboratoare%253Alaborator-01.html" class="media" title="iocla:laboratoare:right-rotate-carry.png"><img src="../../../../_media/iocla/laboratoare/right-rotate-carry.png%3Fw=200&amp;tok=d0fb4b" class="media" alt="" width="200" /></a> </td>
	</tr>
	<tr class="row1">
		<td class="col0 leftalign"> Rotire la stânga cu un bit auxiliar         </td><td class="col1 leftalign"> Rotire la dreapta cu un bit auxiliar         </td>
	</tr>
</table></div>
<!-- EDIT16 TABLE [12610-12812] -->
</div>
<!-- EDIT12 SECTION "Operații logice" [9865-12813] -->
<h2 class="sectionedit17" id="exercitii">Exerciții</h2>
<div class="level2">

<p>
<p><div class="noteclassic">
Pentru a crea și rula aplicații în Windows aveți două posibilități.
</p>

<p>
Puteți folosi Visual Studio (în laborator Visual C++ Express 2010) pentru a crea o aplicație. Creați un proiect folosind <code>New Project → Console Application → Application Settings → Empty Project</code>, apoi adăugați în directorul <code>Sources</code> un fișier cod sursă C. Apoi scrieți codul și compilați folosind meniul <code>Debug → Build Application</code>; pentru rulare folosiți <code>Debug → Start debugging</code>.
</p>

<p>
Creați fișierul cod sursă C în editorul preferat. Apoi accesați consola Visual Studio (pe sistemele din laborator este pe Desktop <code>Visual Studio Command Prompt (2010)</code>). Accesați directorul în care este fișierul cod sursă C și rulați comanda
</p>
<pre class="code">cl myfile.c</pre>

<p>
unde <code>myfile.c</code> este numele fișierului vostru. Înlocuiți cu numele folosit de voi. Apoi rulați executabilul rezultat folosind comanda <code>myfile</code> (numele executabilului); puteți folosi comanda <code>dir</code> pentru a lista conținutul directorului curent
</p>
<pre class="code">dir
...
myfile</pre>

<p>

</div></p>
</p>

</div>
<!-- EDIT17 SECTION "Exerciții" [12814-13907] -->
<h3 class="sectionedit18" id="p_1_conversii">[4p] 1. Conversii</h3>
<div class="level3">

<p>
Efectuați următoarele conversii între sisteme de numerație:
</p>

<p>
a. Din decimal în binar și hexazecimal:
</p>
<ul>
<li class="level1"><div class="li"> 58</div>
</li>
<li class="level1"><div class="li"> 121</div>
</li>
<li class="level1"><div class="li"> 18446</div>
</li>
</ul>

<p>
b. Convertiți în zecimal:
</p>
<ul>
<li class="level1"><div class="li"> 0b11000</div>
</li>
<li class="level1"><div class="li"> 0b1011</div>
</li>
<li class="level1"><div class="li"> 0b1100010111010010</div>
</li>
<li class="level1"><div class="li"> 0xD8</div>
</li>
<li class="level1"><div class="li"> 0x7A</div>
</li>
<li class="level1"><div class="li"> 0xBB29</div>
</li>
</ul>

<p>
c. Din hexazecimal în binar:
</p>
<ul>
<li class="level1"><div class="li"> 0x5E</div>
</li>
<li class="level1"><div class="li"> 0x4A01</div>
</li>
<li class="level1"><div class="li"> 0x0941D583</div>
</li>
</ul>

<p>
d. Din binar în hexazecimal:
</p>
<ul>
<li class="level1"><div class="li"> 0b01111101</div>
</li>
<li class="level1"><div class="li"> 0b1000110000011111</div>
</li>
<li class="level1"><div class="li"> 0b1111101011101011</div>
</li>
</ul>

</div>
<!-- EDIT18 SECTION "[4p] 1. Conversii" [13908-14331] -->
<h3 class="sectionedit19" id="p_2_dimensiune_tipuri_de_date">[1p] 2. Dimensiune tipuri de date</h3>
<div class="level3">

<p>
Aflați dimensiunile principalelor tipuri de date din C pe sistemele din laborator: <code>char</code>, <code>short</code>, <code>int</code>, <code>unsigned int</code>, <code>long</code>, <code>long long</code>, <code>void *</code>.
</p>

<p>
<p><div class="notetip">
Folosiți operatorul <a href="http://www.c4learn.com/c-programming/sizeof-operator/" class="urlextern" title="http://www.c4learn.com/c-programming/sizeof-operator/"  rel="nofollow">sizeof</a> și afișați dimensiunea tipurilor de date.

</div></p>
</p>

</div>
<!-- EDIT19 SECTION "[1p] 2. Dimensiune tipuri de date" [14332-14697] -->
<h3 class="sectionedit20" id="p_3_afisare_in_hexazecimal">[1p] 3. Afișare în hexazecimal</h3>
<div class="level3">

<p>
<a href="http://linux.die.net/man/1/xxd" class="urlextern" title="http://linux.die.net/man/1/xxd"  rel="nofollow">xxd</a> este un utilitar Linux ce permite afișarea fișierelor binare în diferite formate. Puteți găsi o versiune pentru Windows aici: <a href="../../../../_media/iocla/laboratoare/xxd.zip" class="media mediafile mf_zip" title="iocla:laboratoare:xxd.zip (35.8 KB)">xxd.zip</a>.
</p>

<p>
Se dă fișierul binar din arhiva următoare: <a href="../../../../_media/iocla/laboratoare/binary_file.zip" class="media mediafile mf_zip" title="iocla:laboratoare:binary_file.zip (220 B)">binary_file.zip</a>.
Să se afișeze folosind xxd conținutul acestui fișier în următoarele formate:
</p>
<ul>
<li class="level1"><div class="li"> <abbr title="American Standard Code for Information Interchange">ASCII</abbr> (ca text) - nu trebuie să folosiți xxd.</div>
</li>
<li class="level1"><div class="li"> binar</div>
</li>
<li class="level1"><div class="li"> hexazecimal</div>
</li>
</ul>

</div>
<!-- EDIT20 SECTION "[1p] 3. Afișare în hexazecimal" [14698-15194] -->
<h3 class="sectionedit21" id="p_4_afisare_sir_din_format_codificat_hexazecimal">[1p] 4. Afișare șir din format codificat hexazecimal</h3>
<div class="level3">

<p>
Scrieți un program C cu ajutorul căruia să afișați următorul șir hexazecimal ca text <code>48455820526f636b73210a</code>.
</p>

<p>
<p><div class="notetip">
Fiecare caracter <abbr title="American Standard Code for Information Interchange">ASCII</abbr> are echivalent un cod numeric pe un octet. Fiecare octet din șirul dat corespunde unui caracter <abbr title="American Standard Code for Information Interchange">ASCII</abbr>.

</div></p>
</p>

<p>
<p><div class="notetip">
În C puteți folosi codurile în format hexazecimal în locul caracterelor <abbr title="American Standard Code for Information Interchange">ASCII</abbr> în șiruri de caractere cu ajutorul prefixului <code>\x</code>.
</p>

<p>
De exemplu, cele două construcții de mai jos sunt echivalente:
</p>
<pre class="code">char a[] = &quot;\x41\x42\x43&quot;;
char a[] = &quot;ABC&quot;</pre>

<p>
Puteți vedea <a href="http://www.asciitable.com/" class="urlextern" title="http://www.asciitable.com/"  rel="nofollow">aici</a> un tabel cu codurile caracterelor <abbr title="American Standard Code for Information Interchange">ASCII</abbr>).

</div></p>
</p>

</div>
<!-- EDIT21 SECTION "[1p] 4. Afișare șir din format codificat hexazecimal" [15195-15904] -->
<h3 class="sectionedit22" id="p_5_afisare_date_din_memorie">[1p] 5. Afișare date din memorie</h3>
<div class="level3">

<p>
Se dau următoarele declarații de variabile în C:
</p>
<pre class="code c"><span class="co2">#include &lt;stdio.h&gt;</span>
&nbsp;
<span class="kw4">int</span> main<span class="br0">&#40;</span><span class="kw4">void</span><span class="br0">&#41;</span>
<span class="br0">&#123;</span>
    <span class="kw4">unsigned</span> <span class="kw4">int</span> a <span class="sy0">=</span> <span class="nu0">4127</span><span class="sy0">;</span>
    <span class="kw4">int</span> b <span class="sy0">=</span> <span class="sy0">-</span><span class="nu0">27714</span><span class="sy0">;</span>
    <span class="kw4">unsigned</span> <span class="kw4">long</span> c <span class="sy0">=</span> <span class="nu12">0x12345678</span><span class="sy0">;</span>
    <span class="kw4">char</span> d<span class="br0">&#91;</span><span class="br0">&#93;</span> <span class="sy0">=</span> <span class="br0">&#123;</span><span class="st0">'I'</span><span class="sy0">,</span> <span class="st0">'O'</span><span class="sy0">,</span> <span class="st0">'C'</span><span class="sy0">,</span> <span class="st0">'L'</span><span class="sy0">,</span> <span class="st0">'A'</span><span class="br0">&#125;</span><span class="sy0">;</span>
&nbsp;
    <span class="co1">// TODO</span>
&nbsp;
    <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">&#125;</span></pre>

<p>
Observați cum sunt memorate aceste variabile în memorie.
</p>

<p>
<p><div class="notetip">
Puteți parcurge memoria octet cu octet începând de la o anumită adresă folosind un pointer de tipul <code>unsigned char *</code> (pentru că tipul char este reprezentat pe un octet).
</p>

<p>
De exemplu, pentru variabila <code>a</code> veți folosi o construcție de forma:
</p>
<pre class="code">    unsigned char *p;
    
    p = &amp;a;
    printf(&quot;a: 0x%02x 0x%02x 0x%02x 0x%02x\n&quot;, p[0], p[1], p[2], p[3]);</pre>

<p>
sau, mai elegant
</p>
<pre class="code">    unsigned char *p;
    size_t i;
    
    p = &amp;a;
    printf(&quot;a:&quot;);
    for (i = 0; i &lt; sizeof(a); i++)
        printf(&quot; 0x%02x&quot;, p[i]);
    printf(&quot;\n&quot;);</pre>

<p>

</div></p>
</p>

</div>
<!-- EDIT22 SECTION "[1p] 5. Afișare date din memorie" [15905-16864] -->
<h3 class="sectionedit23" id="p_6_afisare_variabile">[1p] 6. Afișare variabile</h3>
<div class="level3">

<p>
Afișați valorile variabilelor c, d și e din programul de mai jos și explicați rezultatele (puteți converti valorile în binar pentru a observa mai ușor cauzele):
</p>
<pre class="code c"><span class="co2">#include &lt;stdio.h&gt;</span>
&nbsp;
<span class="kw4">int</span> main<span class="br0">&#40;</span><span class="kw4">void</span><span class="br0">&#41;</span>
<span class="br0">&#123;</span>
    <span class="kw4">short</span> a <span class="sy0">=</span> <span class="nu0">20000</span><span class="sy0">;</span>
    <span class="kw4">short</span> b <span class="sy0">=</span> <span class="nu0">14000</span><span class="sy0">;</span>
&nbsp;
    <span class="kw4">short</span> c <span class="sy0">=</span> a <span class="sy0">+</span> b<span class="sy0">;</span>
    <span class="kw4">unsigned</span> <span class="kw4">short</span> d <span class="sy0">=</span> <span class="nu0">3</span> <span class="sy0">*</span> a <span class="sy0">+</span> b<span class="sy0">;</span>
    <span class="kw4">short</span> e <span class="sy0">=</span> a <span class="sy0">&lt;&lt;</span> <span class="nu0">1</span><span class="sy0">;</span>
&nbsp;
    <span class="co1">// TODO</span>
&nbsp;
    <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">&#125;</span></pre>

</div>
<!-- EDIT23 SECTION "[1p] 6. Afișare variabile" [16865-17281] -->
<h3 class="sectionedit24" id="p_7_operatie_xor_intre_numere_in_format_hexazecimal">[1p] 7. Operație XOR între numere în format hexazecimal</h3>
<div class="level3">

<p>
Scrieți un program C cu ajutorul căruia să efectuați operația XOR între următoarele șiruri hexazecimale (octet cu octet) și afișați rezultatul ca text:
</p>
<ul>
<li class="level1"><div class="li"> <code>4c26e3b44c86c21ef8908970c7af7475c17e834c7c01aa702e77</code></div>
</li>
<li class="level1"><div class="li"> <code>004382c622a6b671d8e5fa15e7c7110de107ec395c6cdf035a56</code></div>
</li>
</ul>

<p>
<p><div class="notetip">
În C, operatorul pentru operația XOR este <code>^</code> (simbolul căciulă).

</div></p>
</p>

</div>
<!-- EDIT24 SECTION "[1p] 7. Operație XOR între numere în format hexazecimal" [17282-] --></div>
</body>
</html>
