    
    

<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
  <meta charset="utf-8" />
  <title>iocla:laboratoare:laborator-06</title>
<meta name="generator" content="DokuWiki"/>
<meta name="robots" content="index,follow"/>
<meta name="date" content="2016-11-11T10:48:26+0200"/>
<meta name="keywords" content="iocla,laboratoare,laborator-06"/>
<link rel="search" type="application/opensearchdescription+xml" href="../../../../lib/exe/opensearch.php" title="CS Open CourseWare"/>
<link rel="start" href="../../../../../courses.1.html"/>
<link rel="alternate" type="application/rss+xml" title="Recent Changes" href="../../../../feed.php"/>
<link rel="alternate" type="application/rss+xml" title="Current Namespace" href="../../../../feed.php%3Fmode=list&amp;ns=iocla:laboratoare"/>
<link rel="alternate" type="text/html" title="Plain HTML" href="laborator-06.html"/>
<link rel="canonical" href="../../../../iocla/laboratoare/laborator-06.html"/>
<link rel="stylesheet" type="text/css" href="../../../../lib/exe/css.php%3Ft=arctic&amp;tseed=1476798676.css"/>
<script type="text/javascript">/*<![CDATA[*/var NS='iocla:laboratoare';var JSINFO = {"id":"iocla:laboratoare:laborator-06","namespace":"iocla:laboratoare","isadmin":0,"isauth":0};
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="../../../../lib/exe/js.php%3Ftseed=1476798676"></script>
<script type="text/x-mathjax-config">/*<![CDATA[*/MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ["$","$"], ["\\(","\\)"] ],
        displayMath: [ ["$$","$$"], ["\\[","\\]"] ],
        processEscapes: true
    }
});
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
<script type="text/javascript">/*<![CDATA[*/
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
		  
/*!]]>*/</script>
<script type="text/javascript">/*<![CDATA[*/
var pageTracker = _gat._getTracker("UA-38383934-1");
pageTracker._initData();
pageTracker._trackPageview();
		  
/*!]]>*/</script>
</head>
<body>
<div class="dokuwiki export">
<!-- TOC START -->
<div id="dw__toc">
<h3 class="toggle">Table of Contents</h3>
<div>

<ul class="toc">
<li class="level1"><div class="li"><a href="laborator-06.html#laborator_06apeluri_de_functii">Laborator 06: Apeluri de funcții</a></div>
<ul class="toc">
<li class="level2"><div class="li"><a href="laborator-06.html#mediul_de_lucru">Mediul de lucru</a></div></li>
<li class="level2"><div class="li"><a href="laborator-06.html#cunostinte_si_abilitati_ce_vor_fi_dobandite">Cunoștințe și abilități ce vor fi dobândite</a></div></li>
<li class="level2"><div class="li"><a href="laborator-06.html#exercitii">Exerciții</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="laborator-06.html#p_1_recapitulareprogram_in_limbaj_de_asamblare">[1p] 1. Recapitulare: Program în limbaj de asamblare</a></div></li>
<li class="level3"><div class="li"><a href="laborator-06.html#p_2_dezasamblarea_unui_program_scris_in_c">[1p] 2. Dezasamblarea unui program scris în C</a></div></li>
<li class="level3"><div class="li"><a href="laborator-06.html#breviarapelul_unei_functii">Breviar: Apelul unei funcții</a></div>
<ul class="toc">
<li class="level4"><div class="li"><a href="laborator-06.html#functionarea_stivei">Funcționarea stivei</a></div></li>
<li class="level4"><div class="li"><a href="laborator-06.html#exemplu_de_apelare_de_functie_in_assembly">Exemplu de apelare de funcție în assembly</a></div></li>
</ul>
</li>
<li class="level3"><div class="li"><a href="laborator-06.html#p_3_afisarea_unui_sir">[1p] 3. Afișarea unui șir</a></div></li>
<li class="level3"><div class="li"><a href="laborator-06.html#p_4_afisarea_lungimii_unui_sir">[2p] 4. Afișarea lungimii unui șir</a></div></li>
<li class="level3"><div class="li"><a href="laborator-06.html#p_5_afisarea_sirului_inversat">[3p] 5. Afișarea șirului inversat</a></div></li>
<li class="level3"><div class="li"><a href="laborator-06.html#breviarapelatul_in_cadrul_unei_functii">Breviar: Apelatul în cadrul unei funcții</a></div></li>
<li class="level3"><div class="li"><a href="laborator-06.html#p_6_implementarea_functiei_toupper">[2p] 6. Implementarea funcției toupper</a></div></li>
<li class="level3"><div class="li"><a href="laborator-06.html#p_bonustoupper_doar_pentru_litere_mici">[2p] Bonus: toupper doar pentru litere mici</a></div></li>
<li class="level3"><div class="li"><a href="laborator-06.html#p_bonusrot13">[2p] Bonus: rot13</a></div></li>
<li class="level3"><div class="li"><a href="laborator-06.html#p_bonusrot131">[2p] Bonus: rot13++</a></div></li>
</ul>
</li>
<li class="level2"><div class="li"><a href="laborator-06.html#alte_resurse">Alte resurse</a></div></li>
</ul></li>
</ul>
</div>
</div>
<!-- TOC END -->

<h1 class="sectionedit1" id="laborator_06apeluri_de_functii">Laborator 06: Apeluri de funcții</h1>
<div class="level1">

<p>
În acest laborator vom prezenta modul în care se realizează apeluri de funcții. Vom vedea cum putem folosi instrucțiunile <code>call</code> și <code>ret</code> pentru a realiza apeluri de funcții și cum folosim stiva pentru a transmite parametrii unei funcții.
</p>

<p>
Laboratorul este de forma <em>learn by doing</em> partea practică alternând între secțiuni de tip tutorial, cu parcurgere pas cu pas și prezentarea soluției, și exerciții care trebuie să fie rezolvate.
</p>

</div>
<!-- EDIT1 SECTION "Laborator 06: Apeluri de funcții" [1-509] -->
<h2 class="sectionedit2" id="mediul_de_lucru">Mediul de lucru</h2>
<div class="level2">

<p>
Pentru acest laborator vom folosi un sistem Microsoft Windows, asamblorul <a href="http://www.nasm.us/" class="urlextern" title="http://www.nasm.us/"  rel="nofollow">nasm</a> și IDE-ul <a href="http://dman95.github.io/SASM/english.html" class="urlextern" title="http://dman95.github.io/SASM/english.html"  rel="nofollow">SASM</a>. Pentru compilarea codului sursă C vom folosi compilatorul din suita Microsoft Visual Studio (<code>cl</code>).
</p>

</div>
<!-- EDIT2 SECTION "Mediul de lucru" [510-808] -->
<h2 class="sectionedit3" id="cunostinte_si_abilitati_ce_vor_fi_dobandite">Cunoștințe și abilități ce vor fi dobândite</h2>
<div class="level2">
<ul>
<li class="level1"><div class="li"> Traducerea apelului și implementării unei funcții din limbajul C în limbaj de asamblare</div>
</li>
<li class="level1"><div class="li"> Folosirea instrucțiunilor <code>call</code> și <code>ret</code> pentru a realiza un apel de funcție</div>
</li>
<li class="level1"><div class="li"> Implementarea unei funcții în limbaj de asamblare</div>
</li>
<li class="level1"><div class="li"> Folosirea stivei pentru a transmite parametrii unei funcții</div>
</li>
<li class="level1"><div class="li"> Apelarea unei funcții externe (aflată în biblioteca standard C) din limbaj de asamblare</div>
</li>
</ul>

</div>
<!-- EDIT3 SECTION "Cunoștințe și abilități ce vor fi dobândite" [809-1274] -->
<h2 class="sectionedit4" id="exercitii">Exerciții</h2>
<div class="level2">

<p>
În cadrul exercițiilor vom folosi <a href="http://elf.cs.pub.ro/asm/res/laboratoare/lab-06-tasks.zip" class="urlextern" title="http://elf.cs.pub.ro/asm/res/laboratoare/lab-06-tasks.zip"  rel="nofollow">arhiva de laborator</a>.
</p>

<p>
Descărcați arhiva, decomprimați-o și accesați directorul aferent.
</p>

</div>
<!-- EDIT4 SECTION "Exerciții" [1275-1490] -->
<h3 class="sectionedit5" id="p_1_recapitulareprogram_in_limbaj_de_asamblare">[1p] 1. Recapitulare: Program în limbaj de asamblare</h3>
<div class="level3">

<p>
În SASM deschideți fișierul <code>NASMHello.asm</code>, fișier din instalarea implicită de SASM și compilați-l și rulați-l. Observați afișarea mesajului <em>Hello, world!</em>
</p>

<p>
<p><div class="notetip">
Pentru deschiderea fișierului, accesați în SASM, meniul <code>File</code> și apoi opțiunea <code>Open</code>. Vi se va deschide un file browser în directorul cu fișierele din instalarea implicită de SASM. De acolo veți putea deschide fișierul <code>NASMHello.asm</code>.
</p>

<p>
Pentru compilare/rulare puteți folosi opțiunea <code>Build</code> din meniu, sau direct tasta <code>F9</code>.

</div></p>
</p>

<p>
Deschideți în SASM fișierul <code>hello-world.asm</code> din arhiva de laborator. Compilați-l și rulați-l și pe acesta și observați comportamentul.
</p>

<p>
Sunt câteva diferențe între cele două programe:
</p>
<ul>
<li class="level1"><div class="li"> Programul <code>hello-world.asm</code> folosește apelul funcției <code>puts</code> (funcție externă modulului curent) pentru a efectua a afișarea. Pentru aceasta pune argumentul pe stivă și apelează funcția.</div>
</li>
<li class="level1"><div class="li"> Variabila <code>msg</code> din programul <code>hello-world.asm</code> conține octeții <code>13</code> și <code>10</code>. Aceștia simbolizează caracterele <em>carriage-return</em> și <em>line-feed</em>, mai cunoscute și sub numele forma <code>\r\n</code>, folosite pentru a adăuga o linie nouă pe Windows.</div>
</li>
</ul>

<p>
Încheierea cu <code>\r\n</code> este, în general, utilă pentru afișarea șirurilor. Întrucât însă funcția <code>puts</code> pune automat o linie nouă după șirul afișat, prezența acestor caractere este opțională. Este, însă, utilă în cazul folosirii funcției <code>printf</code>.
</p>

</div>
<!-- EDIT5 SECTION "[1p] 1. Recapitulare: Program în limbaj de asamblare" [1491-3042] -->
<h3 class="sectionedit6" id="p_2_dezasamblarea_unui_program_scris_in_c">[1p] 2. Dezasamblarea unui program scris în C</h3>
<div class="level3">

<p>
După cum spuneam, în final, totul ajunge în limbaj de asamblare. Adesea ajungem să avem acces doar la codul obiect al unor programe și vrem să inspectăm modul în care arată.
</p>

<p>
Pentru a observa acest lucru, haideți să compilăm până la codul obiect un program scris în C și apoi să-l dezasamblăm. Este vorba de programul <code>test.c</code> din arhiva de laborator.
</p>

<p>
Pentru a compila un program vom folosi linia de comandă și de acolo comanda <code>cl</code> care reprezintă compilatorul și linker-ul din Visual Studio.
</p>

<p>
<p><div class="notetip">
Pentru a compila un fișier cod sursă C/C++ în linia de comandă folosind Visual Studio, urmați pașii:
</p>
<ol>
<li class="level1"><div class="li"> Deschideți prompt-ul pentru Visual Studio folosind icon-ul de pe Desktop intitulat <code>Visual Studio Command Prompt 2010</code>.</div>
</li>
<li class="level1"><div class="li"> Accesați directorul în care aveți codul sursă. De exemplu, pentru a accesa desktop-ul, folosiți comanda<pre class="code">cd c:\Users\Student\Desktop</pre>
</div>
</li>
<li class="level1"><div class="li"> Folosiți comanda<pre class="code">cl &lt;nume-fisier&gt;.c</pre>

<p>
 unde <code>&lt;nume-fisier&gt;</code> este numele fișierului.
</p>
</div>
</li>
<li class="level1"><div class="li"> Dacă doriți <strong>doar</strong> să compilați fișierul (<strong>fără</strong> să-l link-ați), atunci folosiți comanda<pre class="code">cl /c &lt;nume-fisier&gt;.c</pre>

<p>
 unde <code>&lt;nume-fisier&gt;</code> este numele fișierului.
</p>
</div>
</li>
</ol>

<p>

</div></p>
</p>

<p>
În cazul nostru, întrucât dorim doar să compilăm fișierul <code>test.c</code> la modulul obiect, vom accesa din prompt-ul Visual Studio directorul în care se găsește fișierul și apoi vom rula comanda
</p>
<pre class="code">cl /c test.c</pre>

<p>
În urma rulării comenzii de mai sus în directorul curent vom avea fișierul obiect test.obj.
</p>

<p>
Putem obține și forma în limbaj de asamblare a acestuia folosind comanda
</p>
<pre class="code">cl /c /FAs test.c</pre>

<p>
În urma rulării comenzii de mai sus obținem fișierul <code>test.asm</code> pe care îl putem vizualiza folosind comanda
</p>
<pre class="code">type test.asm</pre>

<p>
Pentru a dezasambla codul unui modul obiect vom folosi un utilitar frecvent întâlnit în lumea Unix: <code>objdump</code>. Pentru aceasta trebuie ca în prompt-ul Visual Studio sau în alt prompt să accesați directorul de binare al SASM. Este vorba de <code>C:\Program Files (x86)\SASM\MinGW64\bin</code>. De acolo, pentru dezasamblare, vom rula comanda
</p>
<pre class="code">.\objdump.exe -d &lt;path-to-obj-file&gt;</pre>

<p>
unde <code>&lt;path-to-obj-file&gt;</code> este calea către fișierul obiect <code>test.obj</code>.
</p>

<p>
Veți obține un output similar celui de mai jos
</p>
<pre class="code">C:\Program Files (x86)\SASM\MinGW\bin&gt;.\objdump.exe -d -M intel C:\Users\razvan\test.obj

C:\Users\razvan\test.obj:     file format pe-i386


Disassembly of section .text:

00000000 &lt;_main&gt;:
   0:   55                      push   ebp
   1:   8b ec                   mov    ebp,esp
   3:   6a 0f                   push   0xf
   5:   e8 00 00 00 00          call   a &lt;_main+0xa&gt;
   a:   83 c4 04                add    esp,0x4
   d:   50                      push   eax
   e:   68 00 00 00 00          push   0x0
  13:   e8 00 00 00 00          call   18 &lt;_main+0x18&gt;
  18:   83 c4 08                add    esp,0x8
  1b:   33 c0                   xor    eax,eax
  1d:   5d                      pop    ebp
  1e:   c3                      ret
  1f:   cc                      int3

00000020 &lt;_first_func&gt;:
  20:   55                      push   ebp
  21:   8b ec                   mov    ebp,esp
  23:   51                      push   ecx
  24:   c7 45 fc 03 00 00 00    mov    DWORD PTR [ebp-0x4],0x3
  2b:   68 00 00 00 00          push   0x0
  30:   e8 00 00 00 00          call   35 &lt;_first_func+0x15&gt;
  35:   83 c4 04                add    esp,0x4
  38:   8b 45 fc                mov    eax,DWORD PTR [ebp-0x4]
  3b:   50                      push   eax
  3c:   8d 4d 08                lea    ecx,[ebp+0x8]
  3f:   51                      push   ecx
  40:   e8 00 00 00 00          call   45 &lt;_first_func+0x25&gt;
  45:   83 c4 08                add    esp,0x8
  48:   8b 45 08                mov    eax,DWORD PTR [ebp+0x8]
  4b:   8b e5                   mov    esp,ebp
  4d:   5d                      pop    ebp
  4e:   c3                      ret
  4f:   cc                      int3

00000050 &lt;_second_func&gt;:
  50:   55                      push   ebp
  51:   8b ec                   mov    ebp,esp
  53:   8b 45 08                mov    eax,DWORD PTR [ebp+0x8]
  56:   8b 08                   mov    ecx,DWORD PTR [eax]
  58:   03 4d 0c                add    ecx,DWORD PTR [ebp+0xc]
  5b:   8b 55 08                mov    edx,DWORD PTR [ebp+0x8]
  5e:   89 0a                   mov    DWORD PTR [edx],ecx
  60:   5d                      pop    ebp
  61:   c3</pre>

<p>
Există multe alte utilitare care permit dezasamblare de module obiect, majoritatea cu interfața grafică și oferind și suport pentru debugging. <code>objdump</code> este un utilitar simplu care poate fi rapid folosit în linia de comandă.
</p>

<p>
Este interesant de urmărit, atât în fișierul <code>test.asm</code> cât și în dezasamblarea sa, modul în care se face un apel de funcție, lucru despre care vom discuta în continuare.
</p>

</div>
<!-- EDIT6 SECTION "[1p] 2. Dezasamblarea unui program scris în C" [3043-8015] -->
<h3 class="sectionedit7" id="breviarapelul_unei_functii">Breviar: Apelul unei funcții</h3>
<div class="level3">

<p>
Atunci când apelăm o funcție, pașii sunt următorii:
</p>
<ul>
<li class="level1"><div class="li"> Punem argumentele pe stivă, apelul de tip push fiind în ordinea inversă în care sunt trimiși ca argumente funcției.</div>
</li>
<li class="level1"><div class="li"> Apelăm call.</div>
</li>
<li class="level1"><div class="li"> Restaurăm stiva la sfârșitul apelului.</div>
</li>
</ul>

</div>

<h4 id="functionarea_stivei">Funcționarea stivei</h4>
<div class="level4">

<p>
După cum știm, operațiile pe stivă sunt de două tipuri:
</p>
<ul>
<li class="level1"><div class="li"> <code>push val</code> în care valoarea <code>val</code> este plasată pe stivă</div>
</li>
<li class="level1"><div class="li"> <code>pop reg/mem</code> în care ce se găsește în vârful stivei se plasează în registru sau într-o zonă de memorie</div>
</li>
</ul>

<p>
În momentul în care se face <code>push</code> spunem că stiva <strong>crește</strong> (se adaugă elemente). În mod oarecum paradoxal însă, pointerul de stivă (indicat de registrul <code>esp</code> pe 32 de biți) scade. Acest lucru se întâmplă întrucât stiva crește în jos, de la adresa mari către adrese mici.
</p>

<p>
La fel, în momentul care facem <code>pop</code> spunem că stiva <strong>scade</strong> (se scot elemente). Acum pointer-ul de stivă (indicat de registrul <code>esp</code> pe 32 de biți) crește.
</p>

<p>
Un sumar al acestui lucru este explicat foarte bine la acest link: <a href="https://en.wikibooks.org/wiki/X86_Disassembly/The_Stack" class="urlextern" title="https://en.wikibooks.org/wiki/X86_Disassembly/The_Stack"  rel="nofollow">https://en.wikibooks.org/wiki/X86_Disassembly/The_Stack</a>
</p>

</div>

<h4 id="exemplu_de_apelare_de_functie_in_assembly">Exemplu de apelare de funcție în assembly</h4>
<div class="level4">

<p>
După cum spuneam, în momentul în care realizăm un apel de funcție în assembly acesta se traduce în cei trei pași de mai sus. De exemplu, în fișierul <code>hello-world.asm</code> am apelat funcția <code>puts</code> folosind sintaxa:
</p>
<pre class="code">    push msg
    call puts
    add esp, 4</pre>

<p>
În primă fază am plasat pe stivă argumentul funcției <code>puts</code> adică adresa șirului <code>msg</code>. Apoi am apelat funcția <code>puts</code>. Apoi am restaurat stiva (care crescuse prin apelul <code>push</code>) adăugând <code>4</code> octeți (dimensiunea unui cuvânt pe 32 de biți) la registrul de stivă (<code>esp</code>).
</p>

<p>
Astfel sunt traduse majoritatea apelurilor de funcții. Dacă urmărim dezasamblarea fișierul <code>test.obj</code> putem observa acest șablon de apel și în alte părți. Mai jos sunt secvențele extrase din dezasamblarea de mai sus:
</p>
<pre class="code">   d:   50                      push   %eax
   e:   68 00 00 00 00          push   $0x0
  13:   e8 00 00 00 00          call   18 &lt;_main+0x18&gt;
  18:   83 c4 08                add    $0x8,%esp

  2b:   68 00 00 00 00          push   $0x0
  30:   e8 00 00 00 00          call   35 &lt;_first_func+0x15&gt;
  35:   83 c4 04                add    $0x4,%esp

  3b:   50                      push   %eax
  3c:   8d 4d 08                lea    0x8(%ebp),%ecx
  3f:   51                      push   %ecx
  40:   e8 00 00 00 00          call   45 &lt;_first_func+0x25&gt;
  45:   83 c4 08                add    $0x8,%esp</pre>

<p>
Contează mai puțin, pentru înțelegerea noastră din acest moment, de ce unele instrucțiuni arată cum arată, este importantă înțelegerea pașilor urmați pentru apelarea unei funcții: plasarea argumentelor pe stivă, apelul funcției, restaurarea stivei.
</p>

</div>
<!-- EDIT7 SECTION "Breviar: Apelul unei funcții" [8016-10913] -->
<h3 class="sectionedit8" id="p_3_afisarea_unui_sir">[1p] 3. Afișarea unui șir</h3>
<div class="level3">

<p>
Pentru afișarea unui string în SASM putem folosi macro-ul <code>PRINT_STRING</code>. Sau putem folosi o funcție precum <code>puts</code>. În fișierul <code>print-string.asm</code> este implementată afișarea unui string folosind macro-ul <code>PRINT_STRING</code>.
</p>

<p>
Urmărind fișierul <code>hello-world.asm</code> ca exemplu, implementați afișarea șirului folosind și <code>puts</code>.
</p>

<p>
<p><div class="notetip">
Urmăriți și indicațiile din secțiunea de mai sus, legate de apelul unei funcții.

</div></p>
</p>

</div>
<!-- EDIT8 SECTION "[1p] 3. Afișarea unui șir" [10914-11404] -->
<h3 class="sectionedit9" id="p_4_afisarea_lungimii_unui_sir">[2p] 4. Afișarea lungimii unui șir</h3>
<div class="level3">

<p>
Programul <code>print-string-len.asm</code> afișează lungimea unui șir folosind macro-ul <code>PRINT_DEC</code>. Calculul lungimii șirului <code>mystring</code> are loc în cadrul programului (este deja implementat).
</p>

<p>
Implementați programul pentru a face afișarea lungimii șirului folosind funcția <code>printf</code>.
</p>

<p>
La sfârșit veți avea afișată de două ori lungimea șirului: o dată cu apelul macro-ului SASM <code>PRINT_DEC</code> și apoi cu apelul funcției externe <code>printf</code>.
</p>

<p>
<p><div class="notetip">
Gândiți-vă că apelul <code>printf</code> este de forma <code>printf(&quot;String length is %u\n&quot;, len);</code>. Trebuie să construiți stiva pentru acest apel.
</p>

<p>
Pașii de urmat sunt:
</p>
<ol>
<li class="level1"><div class="li"> Marcarea simbolului <code>printf</code> ca simbol extern.</div>
</li>
<li class="level1"><div class="li"> Definirea șirului de formatare <code>&quot;String length is %u&quot;, 13, 10, 0</code>.</div>
</li>
<li class="level1"><div class="li"> Realizarea apelului funcției <code>printf</code>, adică:</div>
<ol>
<li class="level2"><div class="li"> Punerea celor două argumente pe stivă: șirul de formatarea și lungimea.</div>
</li>
<li class="level2"><div class="li"> Apelul <code>printf</code> folosind <code>call</code>.</div>
</li>
<li class="level2"><div class="li"> Restaurarea stivei.</div>
</li>
</ol>
</li>
</ol>

<p>
Lungimea șirului se găsește în registrul <code>ecx</code>.

</div></p>
</p>

</div>
<!-- EDIT9 SECTION "[2p] 4. Afișarea lungimii unui șir" [11405-12488] -->
<h3 class="sectionedit10" id="p_5_afisarea_sirului_inversat">[3p] 5. Afișarea șirului inversat</h3>
<div class="level3">

<p>
În soluția de mai sus adăugați funcția <code>reverse_string</code> astfel încât să aveți un listing similar celui de mai jos:
</p>
<pre class="code">[...]
section .text
global CMAIN

reverse_string:
    push ebp
    mov ebp, esp

    mov eax, dword [ebp+8]
    mov ecx, dword [ebp+12]
    add eax, ecx
    dec eax
    mov edx, dword [ebp+16]

copy_one_byte:
    mov bl, byte [eax]
    mov byte [edx], bl
    dec eax
    inc edx
    loopnz copy_one_byte

    inc edx
    mov byte [edx], 0

    leave
    ret

CMAIN:
    push ebp
    mov ebp, esp
[...]</pre>

<p>
<p><div class="noteimportant">
Când copiați funcția <code>reverse_string</code> în programul vostru, rețineți că fucția începe la eticheta <code>reverse_string</code> și se oprește la eticheta <code>CMAIN</code>. Eticheta <code>copy_one_byte</code> este parte a funcției <code>reverse_string</code>.

</div></p>
</p>

<p>
Funcția <code>reverse_string</code> inversează un șir și are următoarea signatură: <code>void reverse_string(const char *src, size_t len, char *dst);</code>. Astfel ca primele <code>len</code> caractere și șirul <code>src</code> sunt inversate în șirul <code>dst</code>.
</p>

<p>
Realizați inversarea șirului <code>mystring</code> într-un nou șir și afișați acel nou șir.
</p>

<p>
<p><div class="notetip">
Pentru a defini un nou șir, recomandăm ca, în secțiunea de date să folosiți construcția
</p>
<pre class="code">    store_string times 64 db 0</pre>

<p>
Construcția creează un șir de 64 de octeți de zero, suficient pentru a stoca inversul șirului.
</p>

<p>
Apelul echivalent în C al funcției este <code>reverse_string(mystring, ecx, store_string);</code>. În registrul <code>ecx</code> am presupus că este calculată lungimea șirului.
</p>

<p>
Nu puteți folosi direct valoarea <code>ecx</code> în forma ei curentă. După apelul funcției <code>printf</code> pentru afișare numărului valoarea <code>ecx</code> se pierde. Ca să o păstrați, aveți două opțiuni:
</p>
<ol>
<li class="level1"><div class="li"> Stocați valoarea registrului <code>ecx</code> în prealabil pe stivă (folosind <code>push ecx</code> înaintea apelului <code>printf</code>) și apoi să o restaurați după apelul <code>printf</code> (folosind <code>pop ecx</code>).</div>
</li>
<li class="level1"><div class="li"> Stocați valoarea registrului <code>ecx</code> într-o variabilă globală, pe care o definiți în secțiunea <code>.data</code>.</div>
</li>
</ol>

<p>
Nu puteți folosi un alt registru pentru că sunt șanse foarte mari ca și acel registru să fie modificat de apelul <code>printf</code> pentru afișarea lungimii șirului.

</div></p>
</p>

</div>
<!-- EDIT10 SECTION "[3p] 5. Afișarea șirului inversat" [12489-14772] -->
<h3 class="sectionedit11" id="breviarapelatul_in_cadrul_unei_functii">Breviar: Apelatul în cadrul unei funcții</h3>
<div class="level3">

<p>
Atunci când apelăm o funcție spune că funcția care apelează (contextul care apelează) se cheamă <strong>apelant</strong> (sau <strong>caller</strong>) iar funcția apelată se cheamă <strong>apelat</strong> (sau <strong>callee</strong>). Până acum am discutat despre cum arată lucrurile la nivelul apelantului (cum construim stiva acolo). Haideți să urmărim ce se întâmplă la nivelul apelatului.
</p>

<p>
Până în momentul instrucțiunii <code>call</code> stiva conține parametrii funcției. Apelul <code>call</code> poate fi echivalat grosier următoarei secvențe:
</p>
<pre class="code">    push eip
    jmp function_name</pre>

<p>
Adică și apelul <code>call</code> folosește în continuare stiva și salvează adresa următoarei instrucțiuni, cea de după <code>call</code> numită și instrucțiunea de retur sau adresa de retur (<em>return value</em>, <em>return address</em>). Aceasta este necesară pentru a ști, în apelat, unde să revenim.
</p>

<p>
Suplimentar, în apelat, la începutul său (numit preambul, <em>preamble</em>) se salvează frame pointer-ul (în arhitectura i386 este vorba de registrul <code>ebp</code>) urmând ca frame pointer-ul să refere adresa curentă de pe stivă (adică tocmai fostul frame pointer). Deși nu este obligatorie, salvarea frame pointer-ului ajută la debugging și este în cele mai multe cazuri folosită. Din aceste motive, orice apel de funcție va avea în general, preambulul:
</p>
<pre class="code">    push ebp
    mov ebp, esp</pre>

<p>
Aceste modificări au loc în apelat. De aceea este responsabilitatea apelatului să restaureze stiva la vechea sa valoare. De aceea este uzuală existența unui epilog care să readucă stiva la starea sa inițială; acest epilog este:
</p>
<pre class="code">    leave</pre>

<p>
În acest moment stiva este ca la începutul funcției, adică imediat după <code>call</code>, referind adresa de retur. Urmează apelul
</p>
<pre class="code">    ret</pre>

<p>
care este grosier echivalentul instrucțiunii:
</p>
<pre class="code">    pop eip</pre>

<p>
Adică ia valoarea din vârful stivei și o plasează în <code>eip</code> urmând continuarea execuției programului de la acea adresă.
</p>

<p>
Un sumar al acestui comportament, plasat pe apelul echivalent <code>reverse_string(mystring, len, store_string);</code> este indicat în diagrama de mai jos, accesibilă în format PDF și original DIA la adresa: <a href="http://elf.cs.pub.ro/asm/res/laboratoare/lab-04-img/" class="urlextern" title="http://elf.cs.pub.ro/asm/res/laboratoare/lab-04-img/"  rel="nofollow">http://elf.cs.pub.ro/asm/res/laboratoare/lab-04-img/</a>
</p>

<p>
<a href="../../../../_detail/iocla/laboratoare/stack-in-function-call.png%3Fid=iocla%253Alaboratoare%253Alaborator-06.html" class="media" title="iocla:laboratoare:stack-in-function-call.png"><img src="../../../../_media/iocla/laboratoare/stack-in-function-call.png%3Fw=600&amp;tok=2b8152" class="mediacenter" alt="" width="600" /></a>
</p>

<p>
De observat că pe parcursul execuției funcției, ceea ce nu se schimbă este poziția frame pointer-ul. Acesta este și motivul denumirii sale: pointează la frame-ul curent de funcției. De aceea este comun ca accesarea parametrilor unei funcții să se realizeze prin intermediul frame pointer-ului. Presupunând un sistem pe 32 de biți și parametri de dimensiunea cuvântului procesorului (32 de biți, 4 octeți) vom avea:
</p>
<ul>
<li class="level1"><div class="li"> primul argument se găsește la adresa <code>ebp+8</code></div>
</li>
<li class="level1"><div class="li"> al doilea argument se găsește la adresa <code>ebp+12</code></div>
</li>
<li class="level1"><div class="li"> al treilea argument se găsește la adresa <code>ebp+16</code></div>
</li>
<li class="level1"><div class="li"> etc.</div>
</li>
</ul>

<p>
Acesta este motivul pentru care, pentru a obține parametrii funcției <code>reverse_string</code> în registrele respectiv <code>eax</code>, <code>ecx</code>, <code>edx</code>, folosim construcțiile:
</p>
<pre class="code">    mov eax, dword [ebp+8]   ; retrieve first function argument in eax
    mov ecx, dword [ebp+12]  ; retrieve second function argument in ecx
    mov edx, dword [ebp+16]  ; retrieve third function argument in edx</pre>

</div>
<!-- EDIT11 SECTION "Breviar: Apelatul în cadrul unei funcții" [14773-18122] -->
<h3 class="sectionedit12" id="p_6_implementarea_functiei_toupper">[2p] 6. Implementarea funcției toupper</h3>
<div class="level3">

<p>
Ne propunem implementarea funcției <code>toupper</code> care traduce literele mici în litere mari. Pentru aceasta, porniți de la fișierul <code>toupper.asm</code> din arhiva de exerciții a laboratorului și completați corpul funcției <code>topupper</code>.
</p>

<p>
Șirul folosit este <code>mystring</code> și presupunem că este un șir valid. Acest șir este transmis ca argument funcției <code>toupper</code> în momentul apelului.
</p>

<p>
Faceți înlocuirea <em>in place</em>, nu este nevoie de un alt șir.
</p>

<p>
<p><div class="notetip">
Ca să traduceți o litera mică în literă mare, trebuie să <strong>scădeți</strong> <code>0x20</code> din valoare. Aceasta este diferența între litere mici și mari; de exemplu <code>a</code> este <code>0x61</code> iar <code>A</code> este <code>0x41</code>. Puteți vedea în <a href="http://man7.org/linux/man-pages/man7/ascii.7.html" class="urlextern" title="http://man7.org/linux/man-pages/man7/ascii.7.html"  rel="nofollow">pagina de manual ascii</a>.
</p>

<p>
Ca să citiți sau să scrieți octet cu octet folosiți construcția <code>byte [reg]</code> așa cum apare și în implementarea determinării lungimii unui șir  în fișierul <code>print-string-len.asm</code>, unde <code>[reg]</code> este registrul de tip pointer în care este stocată adresa șirului în acel punct.
</p>

<p>
Vă opriți atunci când ați ajuns la valoarea <code>0</code> (<code>NUL</code> byte). Pentru verificare puteți folosi <code>test</code> așa cum se întâmplă și în implementarea determinării unui șir în fișierul <code>print-string-len.asm</code>.

</div></p>
</p>

</div>
<!-- EDIT12 SECTION "[2p] 6. Implementarea funcției toupper" [18123-19476] -->
<h3 class="sectionedit13" id="p_bonustoupper_doar_pentru_litere_mici">[2p] Bonus: toupper doar pentru litere mici</h3>
<div class="level3">

<p>
Implementați funcția <code>toupper</code> astfel încât translatarea să aibă loc doar pentru caractare reprezentând litere mici, nu litere mari sau alte tipuri de caractere.
</p>

</div>
<!-- EDIT13 SECTION "[2p] Bonus: toupper doar pentru litere mici" [19477-19702] -->
<h3 class="sectionedit14" id="p_bonusrot13">[2p] Bonus: rot13</h3>
<div class="level3">

<p>
Realizați și folosiți o funcție care face translatarea <a href="http://www.decode.org/" class="urlextern" title="http://www.decode.org/"  rel="nofollow">rot13</a> a unui șir.
</p>

</div>
<!-- EDIT14 SECTION "[2p] Bonus: rot13" [19703-19837] -->
<h3 class="sectionedit15" id="p_bonusrot131">[2p] Bonus: rot13++</h3>
<div class="level3">

<p>
Implementați <code>rot13</code> pe un array de șiruri: șirurile sunt continue în memorie separate prin terminatorul de șirul (<code>NUL</code>-byte, <code>0</code>). De exemplu: <code>ana\0are\0mere\0</code> este un array de trei șiruri.
</p>

<p>
<p><div class="notetip">
Va trebui să știți când sa vă opriți din parcurgerea array-ului de șiruri. Cel mai simplu este să definiți o variabilă de lungime în secțiunea <code>.data</code>, de forma
</p>
<pre class="code">    len dd 10</pre>

<p>
în care să rețineți fie lungimea totală a șirului (de la începutul până la ultimul <code>NUL</code>-byte), fie numărul de șiruri din array.

</div></p>
</p>

</div>
<!-- EDIT15 SECTION "[2p] Bonus: rot13++" [19838-20442] -->
<h2 class="sectionedit16" id="alte_resurse">Alte resurse</h2>
<div class="level2">
<ul>
<li class="level1"><div class="li"> <a href="http://www.nasm.us/" class="urlextern" title="http://www.nasm.us/"  rel="nofollow">nasm</a></div>
</li>
<li class="level1"><div class="li"> <a href="http://dman95.github.io/SASM/english.html" class="urlextern" title="http://dman95.github.io/SASM/english.html"  rel="nofollow">SASM</a></div>
</li>
</ul>

</div>
<!-- EDIT16 SECTION "Alte resurse" [20443-] --></div>
</body>
</html>
