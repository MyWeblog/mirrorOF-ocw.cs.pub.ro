    
    

<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
  <meta charset="utf-8" />
  <title>iocla:bune-practici</title>
<meta name="generator" content="DokuWiki"/>
<meta name="robots" content="index,follow"/>
<meta name="date" content="2016-11-05T21:10:34+0200"/>
<meta name="keywords" content="iocla,bune-practici"/>
<link rel="search" type="application/opensearchdescription+xml" href="../../../lib/exe/opensearch.php" title="CS Open CourseWare"/>
<link rel="start" href="../../../../courses.1.html"/>
<link rel="alternate" type="application/rss+xml" title="Recent Changes" href="../../../feed.php"/>
<link rel="alternate" type="application/rss+xml" title="Current Namespace" href="../../../feed.php%3Fmode=list&amp;ns=iocla"/>
<link rel="alternate" type="text/html" title="Plain HTML" href="bune-practici.html"/>
<link rel="canonical" href="../../../iocla/bune-practici.html"/>
<link rel="stylesheet" type="text/css" href="../../../lib/exe/css.php%3Ft=arctic&amp;tseed=1476798676.css"/>
<script type="text/javascript">/*<![CDATA[*/var NS='iocla';var JSINFO = {"id":"iocla:bune-practici","namespace":"iocla","isadmin":0,"isauth":0};
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="../../../lib/exe/js.php%3Ftseed=1476798676"></script>
<script type="text/x-mathjax-config">/*<![CDATA[*/MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ["$","$"], ["\\(","\\)"] ],
        displayMath: [ ["$$","$$"], ["\\[","\\]"] ],
        processEscapes: true
    }
});
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
<script type="text/javascript">/*<![CDATA[*/
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
		  
/*!]]>*/</script>
<script type="text/javascript">/*<![CDATA[*/
var pageTracker = _gat._getTracker("UA-38383934-1");
pageTracker._initData();
pageTracker._trackPageview();
		  
/*!]]>*/</script>
</head>
<body>
<div class="dokuwiki export">
<!-- TOC START -->
<div id="dw__toc">
<h3 class="toggle">Table of Contents</h3>
<div>

<ul class="toc">
<li class="level1"><div class="li"><a href="bune-practici.html#bune_practici">Bune practici</a></div>
<ul class="toc">
<li class="level2"><div class="li"><a href="bune-practici.html#exemple">Exemple</a></div></li>
<li class="level2"><div class="li"><a href="bune-practici.html#erori_des_intalnite">Erori des întâlnite</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="bune-practici.html#confuzii_la_accesarea_datelor_in_memorie_operatorul_de_dereferentiere">Confuzii la accesarea datelor în memorie (operatorul de dereferenţiere)</a></div></li>
<li class="level3"><div class="li"><a href="bune-practici.html#incarcarea_datelor_in_registre">Încărcarea datelor în registre</a></div>
<ul class="toc">
<li class="level4"><div class="li"><a href="bune-practici.html#o_prima_rezolvare">O primă rezolvare</a></div></li>
<li class="level4"><div class="li"><a href="bune-practici.html#cum_sa_eviti_sa_te_impusti_singur_in_picior">Cum să eviţi să te împuşti singur în picior ?</a></div></li>
</ul>
</li>
<li class="level3"><div class="li"><a href="bune-practici.html#segmentation_fault_debugginggdb_quicky">Segmentation Fault debugging: GDB quicky</a></div></li>
</ul>
</li>
<li class="level2"><div class="li"><a href="bune-practici.html#sabloane_de_cod">Șabloane de cod</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="bune-practici.html#blocul_if">Blocul if</a></div></li>
<li class="level3"><div class="li"><a href="bune-practici.html#blocul_for">Blocul for</a></div></li>
<li class="level3"><div class="li"><a href="bune-practici.html#bucle_for_imbricate">Bucle for îmbricate</a></div></li>
<li class="level3"><div class="li"><a href="bune-practici.html#blocul_while">Blocul while</a></div></li>
<li class="level3"><div class="li"><a href="bune-practici.html#iterarea_peste_un_vector">Iterarea peste un vector</a></div></li>
<li class="level3"><div class="li"><a href="bune-practici.html#variabile_locale">Variabile locale</a></div></li>
<li class="level3"><div class="li"><a href="bune-practici.html#functii">Funcții</a></div></li>
</ul></li>
</ul></li>
</ul>
</div>
</div>
<!-- TOC END -->

<h1 class="sectionedit1" id="bune_practici">Bune practici</h1>
<div class="level1">

<p>
Mai jos găsiți un ghid bune practici, recomandări și greșeli frecvente care apar în momentul în care lucrați în limbajul de asamblare. Să țineți cont, vă rugăm, de acestea în momentul în care lucrați în laboratoare sau teme de casă.
</p>

</div>
<!-- EDIT1 SECTION "Bune practici" [1-282] -->
<h2 class="sectionedit2" id="exemple">Exemple</h2>
<div class="level2">
<ul>
<li class="level1"><div class="li"> Program care afișează <code>&quot;Hello, World!&quot;</code> folosind asamblare cu NASM în linia de comandă (x86, 32 de biți)</div>
<ul>
<li class="level2"><div class="li"> <a href="https://gist.github.com/razvand/782d6471f23352300f11" class="urlextern" title="https://gist.github.com/razvand/782d6471f23352300f11"  rel="nofollow">https://gist.github.com/razvand/782d6471f23352300f11</a></div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Program care afișează <code>&quot;Hello, World!&quot;</code> folosind asamblare cu NASM în linia de comandă (x86, 64 de biți)</div>
<ul>
<li class="level2"><div class="li"> <a href="https://gist.github.com/razvand/49aa3bbc13ee29f4f46b" class="urlextern" title="https://gist.github.com/razvand/49aa3bbc13ee29f4f46b"  rel="nofollow">https://gist.github.com/razvand/49aa3bbc13ee29f4f46b</a></div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Program care apelează funcții externe pe Windows (x86, 32 de biți)</div>
<ul>
<li class="level2"><div class="li"> <a href="https://gist.github.com/razvand/a9dbb356d2344723408c" class="urlextern" title="https://gist.github.com/razvand/a9dbb356d2344723408c"  rel="nofollow">https://gist.github.com/razvand/a9dbb356d2344723408c</a></div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Program care apelează funcții externe pe Linux (x86, 32 de biți)</div>
<ul>
<li class="level2"><div class="li"> <a href="https://gist.github.com/razvand/65dc30fbb64b37f4d617" class="urlextern" title="https://gist.github.com/razvand/65dc30fbb64b37f4d617"  rel="nofollow">https://gist.github.com/razvand/65dc30fbb64b37f4d617</a></div>
</li>
</ul>
</li>
</ul>

</div>
<!-- EDIT2 SECTION "Exemple" [283-926] -->
<h2 class="sectionedit3" id="erori_des_intalnite">Erori des întâlnite</h2>
<div class="level2">

</div>
<!-- EDIT3 SECTION "Erori des întâlnite" [927-960] -->
<h3 class="sectionedit4" id="confuzii_la_accesarea_datelor_in_memorie_operatorul_de_dereferentiere">Confuzii la accesarea datelor în memorie (operatorul de dereferenţiere)</h3>
<div class="level3">

<p>
Pentru cei care sunt la început de drum la a învăţa assembly, este o confunzie foarte mare cum se foloseşte operatorul de dereferenţiere din asamblare: <code>[ ]</code><br/>

Care este diferenţa între <code>op reg, var</code> şi <code>op reg, [var]</code>?<br/>

În 99.999999999999% din cazuri, operaţia fără paranteze pătrate înseamnă să foloseşti adresa acelei variabile pe post de operand. Exemple:
</p>
<pre class="code asm"><span class="kw5">section</span> <span class="kw5">.data</span>
	var<span class="sy1">:</span> <span class="kw5">DD</span> <span class="nu0">34</span>
<span class="kw5">section</span> <span class="kw5">.text</span>
	<span class="kw1">mov</span> <span class="kw4">eax</span><span class="sy1">,</span> var <span class="co1">; put var's &gt;&gt;address&lt;&lt; into the eax register</span>
	<span class="kw1">add</span> <span class="kw4">eax</span><span class="sy1">,</span> var <span class="co1">; add to eax, the &gt;&gt;address&lt;&lt; of var</span></pre>

<p>
Acest cod este echivalent cu următorul cod din <strong>C</strong>:
</p>
<pre class="code c"><span class="kw4">int</span> var <span class="sy0">=</span> <span class="nu0">34</span><span class="sy0">;</span>
eax <span class="sy0">=</span> <span class="sy0">&amp;</span>var<span class="sy0">;</span> <span class="coMULTI">/* mov eax, var */</span>
eax <span class="sy0">=</span> eax <span class="sy0">+</span> <span class="sy0">&amp;</span>var<span class="sy0">;</span> <span class="coMULTI">/* add eax, var */</span></pre>

<p>
În cazul în care foloseşti paranteze pătrate:
</p>
<pre class="code asm"><span class="kw5">section</span> <span class="kw5">.data</span>
	var<span class="sy1">:</span> <span class="kw5">DD</span> <span class="nu0">34</span>
<span class="kw5">section</span> <span class="kw5">.text</span>
	<span class="kw1">mov</span> <span class="kw4">eax</span><span class="sy1">,</span> <span class="br0">&#91;</span>var<span class="br0">&#93;</span> <span class="co1">; put var's &gt;&gt;value&lt;&lt; into eax</span>
	<span class="kw1">add</span> <span class="kw4">eax</span><span class="sy1">,</span> <span class="br0">&#91;</span>var<span class="br0">&#93;</span> <span class="co1">; add to eax, the &gt;&gt;value&lt;&lt; of var</span></pre>

<p>
Acest lucru ar fi echivalent în <strong>C</strong> cu:
</p>
<pre class="code c"><span class="kw4">int</span> var <span class="sy0">=</span> <span class="nu0">34</span><span class="sy0">;</span>
eax <span class="sy0">=</span> var<span class="sy0">;</span> <span class="coMULTI">/* mov eax, [var] */</span>
eax <span class="sy0">=</span> eax <span class="sy0">+</span> var<span class="sy0">;</span> <span class="coMULTI">/* add eax, [var] */</span></pre>

<p>
Printre singurele instrucţiuni care fac abatare de la aceste reguli, este <strong>lea</strong> (load effective address).
</p>
<pre class="code asm"><span class="kw5">section</span> <span class="kw5">.data</span>
	var<span class="sy1">:</span> <span class="kw5">DD</span> <span class="nu0">34</span>
<span class="kw5">section</span> <span class="kw5">.text</span>
	<span class="kw1">lea</span> <span class="kw4">eax</span><span class="sy1">,</span> <span class="br0">&#91;</span>var<span class="br0">&#93;</span> <span class="co1">; put var's &gt;&gt;address&lt;&lt; into the eax register</span></pre>

<p>
În rest, toate celelalte instrucţiuni aderă la regulile enunţate mai sus. Dacă or mai exista şi alte instrucţiuni care se comportă ca <strong>lea</strong>, cel mai probabil nu vor fi tratate în aceste laboratoare.
</p>

</div>
<!-- EDIT4 SECTION "Confuzii la accesarea datelor în memorie (operatorul de dereferenţiere)" [961-2546] -->
<h3 class="sectionedit5" id="incarcarea_datelor_in_registre">Încărcarea datelor în registre</h3>
<div class="level3">

<p>
Adesea apar erori chiar la încărcarea datelor în registre.
</p>
<dl class="file">
<dt><a href="../../code/iocla/bune-practici%3Fcodeblock=5" title="Download Snippet" class="mediafile mf_asm">load.asm</a></dt>
<dd><pre class="code file asm"><span class="kw5">extern</span> printf
&nbsp;
<span class="kw5">section</span> <span class="kw5">.data</span>
	nr<span class="sy1">:</span> <span class="kw5">DB</span> <span class="nu0">23</span>
	<span class="kw1">str</span><span class="sy1">:</span> <span class="kw5">DB</span> <span class="st0">'number: %d'</span><span class="sy1">,</span> <span class="nu0">0</span>
&nbsp;
<span class="kw5">section</span> <span class="kw5">.text</span>
&nbsp;
<span class="kw5">global</span> main
&nbsp;
main<span class="sy1">:</span>
	<span class="kw1">mov</span> <span class="kw4">eax</span><span class="sy1">,</span> <span class="br0">&#91;</span>nr<span class="br0">&#93;</span>
	<span class="kw1">push</span> <span class="kw4">eax</span>
	<span class="kw1">push</span> <span class="kw1">str</span>
	<span class="kw1">call</span> printf
	<span class="kw1">add</span> <span class="kw4">esp</span><span class="sy1">,</span> <span class="nu0">8</span>
	<span class="kw1">ret</span></pre>
</dd></dl>

<p>
În momentul în care se face <code>mov eax, [nr]</code>, instrucţiunea <strong>mov</strong> încearcă să deducă dimensiunea mutării (câte date/bytes să ia de la adresa de la care începe <strong>nr</strong>?). <strong>nr</strong> fiind doar o adresă în memorie, nu-i spune nimica compilatorului. Din acest motiv, compilatorul încearcă să se uite dacă nu cumva în această instrucţiune nu există şi un registru implicat. Îl vede pe <strong>eax</strong>. În consecinţă, compilatorul va codifica instrucţiunea astfel încât în <strong>eax</strong> să se aducă sizeof(eax) (adică 4 bytes) de la adresa lui <strong>nr</strong>.<br/>

Deşi <strong>nr</strong> are valoarea 23, programul afişează <strong>number: 1836412439</strong>.<br/>

De ce? Pentru că la <strong>nr</strong> find un singur byte, procesorul continuă să aducă din memorie încă 3 bytes astfel încât să îl poate umple pe <strong>eax</strong>. În cazul nostru, după <strong>nr</strong>, în memorie, este declarat vectorul <strong>str</strong>, aşa că va lua încă 3 bytes de la el pentru a-l umple pe <strong>eax</strong>.
<p><div class="noteimportant">Intuitiv, v-aţi aştepta ca asamblorul/compilatorul să urle la voi “că uite domne, eu am declarat variabila de 1 byte, şi am scris din greşeală că vreau să aduc 4 bytes de acolo”. Ca şi în cazul limbajului <strong>C</strong>, limbajul de asamblare te lasă să te împuşti singur în picior. Nu este treaba lui să facă check-uri. Dacă tu vrei <strong>1 milion de bytes</strong> de la adresa <strong>0xB00B5</strong>, el o să-ţi codifice programul în binar astfel încât să-ţi aducă date de la adresa <strong>0xB00B5</strong>. Că după îţi bubuie programul în faţă cu un <strong>Segmentation Fault</strong> pentru că ai încercat să accesezi o zonă de memorie care nu ţi-a fost alocată, e deja treaba sistemului de operare şi a procesorului.
</div></p>
</p>

</div>

<h4 id="o_prima_rezolvare">O primă rezolvare</h4>
<div class="level4">

<p>
O primă încercare de a rezolva problema ar fi să încercăm să-l aducem pe <strong>nr</strong> direct într-un registru de 1 byte.
</p>
<dl class="file">
<dt><a href="../../code/iocla/bune-practici%3Fcodeblock=6" title="Download Snippet" class="mediafile mf_asm">load_byte.asm</a></dt>
<dd><pre class="code file asm"><span class="kw5">extern</span> printf
&nbsp;
<span class="kw5">section</span> <span class="kw5">.data</span>
	nr<span class="sy1">:</span> <span class="kw5">DB</span> <span class="nu0">23</span>
	<span class="kw1">str</span><span class="sy1">:</span> <span class="kw5">DB</span> <span class="st0">'number: %d'</span><span class="sy1">,</span> <span class="nu0">0</span>
&nbsp;
<span class="kw5">section</span> <span class="kw5">.text</span>
&nbsp;
<span class="kw5">global</span> main
&nbsp;
main<span class="sy1">:</span>
	<span class="kw1">mov</span> <span class="kw4">al</span><span class="sy1">,</span> <span class="br0">&#91;</span>nr<span class="br0">&#93;</span> <span class="co1">; modified line</span>
	<span class="kw1">push</span> <span class="kw4">eax</span>
	<span class="kw1">push</span> <span class="kw1">str</span>
	<span class="kw1">call</span> printf
	<span class="kw1">add</span> <span class="kw4">esp</span><span class="sy1">,</span> <span class="nu0">8</span>
	<span class="kw1">ret</span></pre>
</dd></dl>

<p>
Mie, personal, s-a întâmplat ca acum să-mi dea corect afişarea. Dar programul nu este încă corect. Noi îi transmitem lui <strong>printf</strong> să afişeze un număr reprezentat pe 4 bytes. Deşi noi am încărcat datele în <strong>al</strong>, noi îi spunem lui <strong>printf</strong> să afişeze conţinutul la tot <strong>eax</strong>, nu doar la <strong>al</strong>. În unele cazuri, s-ar putea ca conţinutul părţii superioare a lui <strong>eax</strong> să nu fie curat, din cauza codului care s-a executat anterior. S-ar putea ca cei mai semnificativi 3 bytes să fie plini cu garbage (date random), şi afişarea noastră tot să nu fie corectă.
Astfel că mai este nevoie de încă o corectură:
</p>
<dl class="file">
<dt><a href="../../code/iocla/bune-practici%3Fcodeblock=7" title="Download Snippet" class="mediafile mf_asm">load_byte.asm</a></dt>
<dd><pre class="code file asm"><span class="kw5">extern</span> printf
&nbsp;
<span class="kw5">section</span> <span class="kw5">.data</span>
	nr<span class="sy1">:</span> <span class="kw5">DB</span> <span class="nu0">23</span>
	<span class="kw1">str</span><span class="sy1">:</span> <span class="kw5">DB</span> <span class="st0">'number: %d'</span><span class="sy1">,</span> <span class="nu0">0</span>
&nbsp;
<span class="kw5">section</span> <span class="kw5">.text</span>
&nbsp;
<span class="kw5">global</span> main
&nbsp;
main<span class="sy1">:</span>
	<span class="kw1">xor</span> <span class="kw4">eax</span><span class="sy1">,</span> <span class="kw4">eax</span> <span class="co1">; eax = 0</span>
	<span class="kw1">mov</span> <span class="kw4">al</span><span class="sy1">,</span> <span class="br0">&#91;</span>nr<span class="br0">&#93;</span> <span class="co1">; modified line</span>
	<span class="kw1">push</span> <span class="kw4">eax</span>
	<span class="kw1">push</span> <span class="kw1">str</span>
	<span class="kw1">call</span> printf
	<span class="kw1">add</span> <span class="kw4">esp</span><span class="sy1">,</span> <span class="nu0">8</span>
	<span class="kw1">ret</span></pre>
</dd></dl>

<p>
Tot registrul <strong>eax</strong> trebuie iniţializat la <strong>0</strong>, ca să fim singuri că nu există junk în partea superioară.
</p>

</div>

<h4 id="cum_sa_eviti_sa_te_impusti_singur_in_picior">Cum să eviţi să te împuşti singur în picior ?</h4>
<div class="level4">

<p>
Există un set de cuvinte cheie în <strong>NASM</strong> care îi specifică asamblorului/compilatorului <strong>pe câţi bytes</strong> are loc operaţia.
Acestea sunt: byte, word şi dword (double word).
</p>
<dl class="file">
<dt><a href="../../code/iocla/bune-practici%3Fcodeblock=8" title="Download Snippet" class="mediafile mf_asm">load.asm</a></dt>
<dd><pre class="code file asm"><span class="kw5">extern</span> printf
&nbsp;
<span class="kw5">section</span> <span class="kw5">.data</span>
	nr<span class="sy1">:</span> <span class="kw5">DW</span> <span class="nu0">23</span> <span class="co1">; declare a variable of word type (2 bytes)</span>
	<span class="kw1">str</span><span class="sy1">:</span> <span class="kw5">DB</span> <span class="st0">'number: %d'</span><span class="sy1">,</span> <span class="nu0">0</span>
&nbsp;
<span class="kw5">section</span> <span class="kw5">.text</span>
&nbsp;
<span class="kw5">global</span> main
&nbsp;
main<span class="sy1">:</span>
	<span class="kw1">mov</span> <span class="kw4">eax</span><span class="sy1">,</span> <span class="kw6">word</span> <span class="br0">&#91;</span>nr<span class="br0">&#93;</span> <span class="co1">; try to access a varible of word type ; try to bring 2 bytes into eax</span>
	<span class="kw1">push</span> <span class="kw4">eax</span>
	<span class="kw1">push</span> <span class="kw1">str</span>
	<span class="kw1">call</span> printf
	<span class="kw1">add</span> <span class="kw4">esp</span><span class="sy1">,</span> <span class="nu0">8</span>
	<span class="kw1">ret</span></pre>
</dd></dl>

<p>
Dacă de exemplu ai declarat un vector/variabilă de words, peste tot unde se accesează un element din acel vector/varibilă prefixează accesul cu tipul variabilei (byte, word, dword, etc.). În felul acesta, asamblorul îţi va da o eroare sugestivă prin care să-ţi dai seama că codul tău nu este tocmai în regulă:
</p>
<pre class="code">arcade@Arcade-PC:~/workspace/asm_exemple &gt; nasm -f elf32 load.asm 
load.asm:12: error: invalid combination of opcode and operands</pre>

<p>
Poate că nu ai un cod care compilează, dar măcar nu ai un cod care compilează şi ruleaza greşit.
</p>

</div>
<!-- EDIT5 SECTION "Încărcarea datelor în registre" [2547-7011] -->
<h3 class="sectionedit6" id="segmentation_fault_debugginggdb_quicky">Segmentation Fault debugging: GDB quicky</h3>
<div class="level3">

<p>
<strong>gdb</strong> este un debugger în linie de comandă. Unul din lucrurile la care ne poate ajuta acesta este să găsim punctele în care ne dă <strong>Segmentation Fault</strong> un program. Mulţi abordează această problemă prin imbricarea de <strong>printf</strong>-uri în puncte intermediare în program. Acest lucru nu prea ajută. Uitaţi cam cum este prelucrat un program de un procesor:
</p>
<ol>
<li class="level1"><div class="li"> Într-o singură etapă se aduc mai multe instrucţiuni din memorie. Accesul la memorie este scump, şi dacă la fiecare instrucţiune de 5-6 bytes ne-am duce în memorie, nu am avea o performanţă foarte bună. Din acest motiv s-a inventat un modul în procesor, numit prefetching, în care se înmagazinează mai multe instrucţiuni de la adresa de la care se aduce cod/instrucţiuni, pentru ca execuţia să fie mai fluidă.</div>
</li>
<li class="level1"><div class="li"> În momentul în care procesorul îşi dă seama că una din instrucţiuni accesează o zonă nevalidă din memorie, trimite un semnal către sistemul de operare. Şi sistemul de operare este tot o bucată de cod care se execută pe procesor. Până când acest semnal trezeşte codul din sistemul de operare, e foarte posibil ca programul să mai fi executat o căruţă de instrucţiuni, din acest motiv, o înşiruire de printf-uri s-ar putea executa şi după instrucţiunea care a produs Segmentation Fault-ul.</div>
</li>
<li class="level1"><div class="li"> Sistemul de operare se trezeşte şi închide forţat programul care a cauzat probleme. Printre datele primite de la semnal se regăseşte şi adresa instrucţiunii care a cauzat Segmentation Fault. Cu un debugger, se poate afla şi din userspace ce instrucţiune a cauzat Segmentation Fault.</div>
</li>
</ol>

<p>
Exemplu de cod cu probleme:
</p>
<dl class="file">
<dt><a href="../../code/iocla/bune-practici%3Fcodeblock=10" title="Download Snippet" class="mediafile mf_asm">segfault.asm</a></dt>
<dd><pre class="code file asm"><span class="kw5">extern</span> printf
&nbsp;
<span class="kw5">section</span> <span class="kw5">.data</span>
	<span class="kw1">str</span><span class="sy1">:</span> <span class="kw5">DB</span> `number<span class="sy1">:</span> <span class="sy1">%</span>d\n`
	nr<span class="sy1">:</span> <span class="kw5">DD</span> <span class="nu0">1</span><span class="sy1">,</span> <span class="nu0">2</span><span class="sy1">,</span> <span class="nu0">3</span><span class="sy1">,</span> <span class="nu0">4</span><span class="sy1">,</span> <span class="nu0">5</span>
	len<span class="sy1">:</span> <span class="kw5">DD</span> <span class="nu0">4000</span>
&nbsp;
<span class="kw5">section</span> <span class="kw5">.text</span>
&nbsp;
<span class="kw5">global</span> main
&nbsp;
main<span class="sy1">:</span>
	<span class="kw1">xor</span> <span class="kw4">ecx</span><span class="sy1">,</span> <span class="kw4">ecx</span>
keep_printing<span class="sy1">:</span>
	<span class="kw1">push</span> <span class="kw4">ecx</span> <span class="co1">; save ecx, because it will be destroyed by printf call</span>
	<span class="kw1">push</span> <span class="kw6">dword</span> <span class="br0">&#91;</span>nr <span class="sy1">+</span> <span class="nu0">4</span><span class="sy1">*</span><span class="kw4">ecx</span><span class="br0">&#93;</span>
	<span class="kw1">push</span> <span class="kw1">str</span>
	<span class="kw1">call</span> printf
	<span class="kw1">add</span> <span class="kw4">esp</span><span class="sy1">,</span> <span class="nu0">8</span>
	<span class="kw1">pop</span> <span class="kw4">ecx</span> <span class="co1">; restore ecx</span>
	<span class="kw1">inc</span> <span class="kw4">ecx</span>
	<span class="kw1">cmp</span> <span class="kw4">ecx</span><span class="sy1">,</span> <span class="br0">&#91;</span>len<span class="br0">&#93;</span>
	<span class="kw1">jl</span> keep_printing
	<span class="kw1">ret</span></pre>
</dd></dl>

<p>
Programul parcurge un vector şi afişează valorile sale. Deşi programul are doar 5 elemente, <strong>len</strong>-ul este setat greşit la 4000 de elemente. Dacă compilăm şi rulam programul acesta ne va da un <strong>segfault</strong>:
</p>
<pre class="code bash"><span class="co0"># ...</span>
number: <span class="nu0">0</span>
number: <span class="nu0">0</span>
number: <span class="nu0">0</span>
Segmentation fault</pre>

<p>
Cum rulăm gdb:
</p>
<pre class="code">gdb nume_binar</pre>

<p>
Exemplu:
</p>
<pre class="code bash">catalin.vasile3004<span class="sy0">@</span>fep ~ $ <span class="kw2">gdb</span> .<span class="sy0">/</span>segfault
GNU <span class="kw2">gdb</span> <span class="br0">&#40;</span>GDB<span class="br0">&#41;</span> Red Hat Enterprise Linux <span class="br0">&#40;</span><span class="nu0">7.2</span>-<span class="nu0">60</span>.el6<span class="br0">&#41;</span>
Copyright <span class="br0">&#40;</span>C<span class="br0">&#41;</span> <span class="nu0">2010</span> Free Software Foundation, Inc.
License GPLv3+: GNU GPL version <span class="nu0">3</span> or later <span class="sy0">&lt;</span>http:<span class="sy0">//</span>gnu.org<span class="sy0">/</span>licenses<span class="sy0">/</span>gpl.html<span class="sy0">&gt;</span>
This is <span class="kw2">free</span> software: you are <span class="kw2">free</span> to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type <span class="st0">&quot;show copying&quot;</span>
and <span class="st0">&quot;show warranty&quot;</span> <span class="kw1">for</span> details.
This GDB was configured <span class="kw2">as</span> <span class="st0">&quot;x86_64-redhat-linux-gnu&quot;</span>.
For bug reporting instructions, please see:
<span class="sy0">&lt;</span>http:<span class="sy0">//</span>www.gnu.org<span class="sy0">/</span>software<span class="sy0">/</span>gdb<span class="sy0">/</span>bugs<span class="sy0">/&gt;</span>...
Reading symbols from <span class="sy0">/</span>export<span class="sy0">/</span>home<span class="sy0">/</span>acs<span class="sy0">/</span>stud<span class="sy0">/</span>c<span class="sy0">/</span>catalin.vasile3004<span class="sy0">/</span>load...<span class="br0">&#40;</span>no debugging symbols found<span class="br0">&#41;</span>...done.
<span class="br0">&#40;</span><span class="kw2">gdb</span><span class="br0">&#41;</span></pre>

<p>
În acest moment s-a deschis consola debugger-ului, <strong>dar programul NU rulează</strong>.
Pentru a rula programul:
</p>
<pre class="code">set disassembly-flavor intel
run param1 param2 param3 &lt; fisier.in &gt; fisier.out</pre>

<p>
Cu <strong>run</strong>-ul dat ca exemplu, e ca şi cum am fi rulat programul în felul următor:
</p>
<pre class="code bash">.<span class="sy0">/</span>segfault param1 param2 param3 <span class="sy0">&lt;</span> fisier.in <span class="sy0">&gt;</span> fisier.out</pre>

<p>
<code>set disassembly-flavor intel</code> vă ajută pentru a afişa eventualele printări de cod de asamblare într-o sintaxă cunoscută<sup><a href="bune-practici.html#fn__1" id="fnt__1" class="fn_top">1)</a></sup>. Limbajul de asamblare reprezintă un set de alias-uri pentru instrucţiunile din binarul unui program. Aceste alias-uri nu au o formă standardizată motiv pentru care acestea diferă de la un asamblor la altul. By default, tool-urile din Linux folosesc sintaxa <a href="https://en.wikibooks.org/wiki/X86_Assembly/GAS_Syntax" class="urlextern" title="https://en.wikibooks.org/wiki/X86_Assembly/GAS_Syntax"  rel="nofollow">AT&amp;T</a>. 99% din tool-urile din Linux (gdb NU se află printre ele) pot primii argumentul <code>-M intel</code> pentru a afişa sau a trata codul de asamblare ca şi cum ar fi în sintaxa recomandată de Intel (care se regăseşte şi la NASM). Programe care pot primi acest flag sunt: gcc (gas), objdump, etc.<br/>

<strong>Revenind la gdb</strong>, în momentul în care rulăm o să ne dea următoarea eroare:
</p>
<pre class="code bash"><span class="co0"># ...</span>
number: <span class="nu0">0</span>
number: <span class="nu0">0</span>
number: <span class="nu0">0</span>
number: <span class="nu0">0</span>
&nbsp;
Program received signal SIGSEGV, Segmentation fault.
0x08048423 <span class="kw1">in</span> keep_printing <span class="br0">&#40;</span><span class="br0">&#41;</span></pre>

<p>
Pentru a vedea ce instrucţiunea a provocat segfault, putem da următoarea comandă:
</p>
<pre class="code bash"><span class="br0">&#40;</span><span class="kw2">gdb</span><span class="br0">&#41;</span> display<span class="sy0">/</span>10i <span class="re1">$pc</span>
<span class="nu0">1</span>: x<span class="sy0">/</span>10i <span class="re1">$pc</span>
=<span class="sy0">&gt;</span> 0x8048423 <span class="sy0">&lt;</span>keep_printing+<span class="nu0">1</span><span class="sy0">&gt;</span>:	push   DWORD PTR <span class="br0">&#91;</span>ecx<span class="sy0">*</span><span class="nu0">4</span>+0x804a02c<span class="br0">&#93;</span>
   0x804842a <span class="sy0">&lt;</span>keep_printing+<span class="nu0">8</span><span class="sy0">&gt;</span>:	push   0x804a020
   0x804842f <span class="sy0">&lt;</span>keep_printing+<span class="nu0">13</span><span class="sy0">&gt;</span>:	call   0x80482f0 <span class="sy0">&lt;</span><span class="kw3">printf</span><span class="sy0">@</span>plt<span class="sy0">&gt;</span>
   0x8048434 <span class="sy0">&lt;</span>keep_printing+<span class="nu0">18</span><span class="sy0">&gt;</span>:	add    esp,0x8
   0x8048437 <span class="sy0">&lt;</span>keep_printing+<span class="nu0">21</span><span class="sy0">&gt;</span>:	pop    ecx
   0x8048438 <span class="sy0">&lt;</span>keep_printing+<span class="nu0">22</span><span class="sy0">&gt;</span>:	inc    ecx
   0x8048439 <span class="sy0">&lt;</span>keep_printing+<span class="nu0">23</span><span class="sy0">&gt;</span>:	<span class="kw2">cmp</span>    ecx,DWORD PTR ds:0x804a040
   0x804843f <span class="sy0">&lt;</span>keep_printing+<span class="nu0">29</span><span class="sy0">&gt;</span>:	jl     0x8048422 <span class="sy0">&lt;</span>keep_printing<span class="sy0">&gt;</span>
   0x8048441 <span class="sy0">&lt;</span>keep_printing+<span class="nu0">31</span><span class="sy0">&gt;</span>:	ret    
   0x8048442 <span class="sy0">&lt;</span>keep_printing+<span class="nu0">32</span><span class="sy0">&gt;</span>:	xchg   ax,ax</pre>
<ul>
<li class="level1"><div class="li"> <strong>$pc</strong> este o variabilă <strong>gdb</strong>, şi vine de la <strong>P</strong>rogram <strong>C</strong>ounter (este pointer-ul la instrucţiunea curentă).</div>
</li>
<li class="level1"><div class="li"> <strong>display</strong> face dump de la un pointer dat ca argument, în cazul nostru <strong>$pc</strong></div>
</li>
<li class="level1"><div class="li"> <strong>i</strong>-ul îi spune lui <strong>display</strong> să interpreteze datele de acolo ca şi cum ar fi instrucţiuni</div>
</li>
<li class="level1"><div class="li"> <strong>10</strong> îi spune lui <strong>display</strong> câţi operanzi de tipul <strong>i</strong> (instrucţiune) să afişeze<br/>
<br/>
</div>
</li>
</ul>

<p>
Prin <code>&lt;keep_printing+some_number&gt;</code>, <strong>gdb</strong> incearcă să ne arate cam pe unde ar fi această instrucţiune. În cazul nostru instrucţiunea este aproape de label-ul <strong>keep_printing</strong>.<br/>

Pentru a vedea ce valoare a avut un registru la momentul în care s-a declanşat <strong>segfault</strong>-ul, puteţi da:
</p>
<pre class="code">(gdb) print $nume_registru</pre>

<p>
În cazul nostru s-ar putea să ne intereseze ce valoare are <strong>ecx</strong>. Pentru a afla acest lucru:
</p>
<pre class="code">(gdb) print $ecx</pre>

</div>
<!-- EDIT6 SECTION "Segmentation Fault debugging: GDB quicky" [7012-13063] -->
<h2 class="sectionedit7" id="sabloane_de_cod">Șabloane de cod</h2>
<div class="level2">

<p>
Această secțiune are scopul de a vă familiariza cu șabloane de cod pe care le puteți folosi în assembly. Cele mai multe sunt inspirate din codul pe care îl generează compilatorul gcc. Inspectarea codului assembly generat de compilator vă familiarizează cu “lumea assembly-ului” și vă pregătește pentru analiza statică a unui executabil. Două resurse foarte bune sunt site-ul: <a href="https://gcc.godbolt.org/" class="urlextern" title="https://gcc.godbolt.org/"  rel="nofollow">https://gcc.godbolt.org/</a> unde puteți vedea cum se convertește codul C++ în asm și cartea <a href="http://beginners.re/" class="urlextern" title="http://beginners.re/"  rel="nofollow">http://beginners.re/</a> în care puteți învăța asm pentru x86, ARM și MIPS pornind de la codul generat de compilatoare și de asemenea puteți observa diferențe între diferite compilatoare de C/C++.
</p>

<p>
De asemenea, vă va asigura o trecere mai ușoara de la a scrie cod C la cod assembly.
</p>

</div>
<!-- EDIT7 SECTION "Șabloane de cod" [13064-13873] -->
<h3 class="sectionedit8" id="blocul_if">Blocul if</h3>
<div class="level3">

<p>
Cod scris în C:
</p>
<pre class="code c"><span class="kw4">int</span> a <span class="sy0">=</span> ..<span class="sy0">;</span>
<span class="kw1">if</span> <span class="br0">&#40;</span>a <span class="sy0">&gt;</span> <span class="nu0">5</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="co1">// bloc cod A</span>
<span class="br0">&#125;</span> <span class="kw1">else</span> <span class="kw1">if</span> <span class="br0">&#40;</span>a <span class="sy0">==</span> <span class="nu0">5</span><span class="br0">&#41;</span>  <span class="br0">&#123;</span>
	<span class="co1">// bloc cod B</span>
<span class="br0">&#125;</span> <span class="kw1">else</span> <span class="br0">&#123;</span>
	<span class="co1">// bloc cod C</span>
<span class="br0">&#125;</span></pre>

<p>
Varianta în assembly:
</p>
<pre class="code asm">comparație_ințială<span class="sy1">:</span>
<span class="kw1">cmp</span> <span class="kw4">eax</span><span class="sy1">,</span> <span class="nu0">5</span>
<span class="kw1">jg</span> CodA
<span class="kw1">je</span> CodB
&nbsp;
CodC<span class="sy1">:</span> <span class="sy1">...</span>
<span class="kw1">jmp</span> Final_If
&nbsp;
CodA<span class="sy1">:</span> <span class="sy1">...</span>
<span class="kw1">jmp</span> Final_If
&nbsp;
CodB<span class="sy1">:</span> <span class="sy1">....</span>
&nbsp;
Final_If<span class="sy1">:</span> <span class="sy1">...</span></pre>

<p>
<p><div class="noteimportant">
Compilatoarele adesea generează nume generice pentru etichete precum L1, L2. Când scrieți cod în assembly recomandăm să le denumiți cât mai sugestiv pentru a fi mai ușor de înteles programul si de depanat.

</div></p>
</p>

<p>
<p><div class="noteimportant">
Compilatoarele generează de obicei două instrucțiuni de cmp, însă a doua nu este necesara în acest caz pentru că else if se raportează la aceeași valoare.

</div></p>
</p>

</div>
<!-- EDIT8 SECTION "Blocul if" [13874-14632] -->
<h3 class="sectionedit9" id="blocul_for">Blocul for</h3>
<div class="level3">
<pre class="code c"><span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> <span class="nu0">100</span><span class="sy0">;</span> <span class="sy0">++</span> i<span class="br0">&#41;</span> <span class="br0">&#123;</span>
    <span class="co1">// Bloc cod A..</span>
<span class="br0">&#125;</span></pre>
<pre class="code asm">initializare_for<span class="sy1">:</span>
<span class="kw1">mov</span> <span class="kw4">ecx</span><span class="sy1">,</span> <span class="nu0">100</span>
Bucla_for<span class="sy1">:</span>
codA
<span class="kw1">loop</span> bucla_for</pre>

<p>
Instrucțiunea loop decrementează ecx, iar dacă acesta are valoarea diferită de 0 se execută un jump la etichetă, altfel se încarcă instrucțiunea următoare
</p>

<p>
<p><div class="notewarning">
Instrucțiunea loop folosește registrul ecx, așadar dacă aveați o valoare importantă în acesta trebuie sa îi faceți o copie (un push ecx înainte și pop ecx la sfârșit).

</div></p>
</p>

</div>
<!-- EDIT9 SECTION "Blocul for" [14633-15181] -->
<h3 class="sectionedit10" id="bucle_for_imbricate">Bucle for îmbricate</h3>
<div class="level3">
<pre class="code c"><span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> <span class="nu0">100</span><span class="sy0">;</span> <span class="sy0">++</span> i<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> j <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> j <span class="sy0">&lt;</span> <span class="nu0">50</span><span class="sy0">;</span> <span class="sy0">++</span> j<span class="br0">&#41;</span> <span class="br0">&#123;</span>
		<span class="co1">// Bloc cod A</span>
	<span class="br0">&#125;</span>
<span class="br0">&#125;</span></pre>
<pre class="code asm">initializare_for_1<span class="sy1">:</span>
<span class="kw1">mov</span> <span class="kw4">ecx</span><span class="sy1">,</span> <span class="nu0">100</span>
&nbsp;
For_1<span class="sy1">:</span>
initializare_for_2<span class="sy1">:</span>
	<span class="kw1">push</span> <span class="kw4">ecx</span>
	<span class="kw1">mov</span> <span class="kw4">ecx</span><span class="sy1">,</span> <span class="nu0">50</span>
For_2<span class="sy1">:</span>
	codA
	<span class="kw1">loop</span> For_2
&nbsp;
        <span class="kw1">pop</span> <span class="kw4">ecx</span>
	<span class="kw1">loop</span> For_1</pre>

</div>
<!-- EDIT10 SECTION "Bucle for îmbricate" [15182-15476] -->
<h3 class="sectionedit11" id="blocul_while">Blocul while</h3>
<div class="level3">

<p>
Varianta C:
</p>
<pre class="code c"><span class="kw1">while</span> <span class="br0">&#40;</span>it <span class="sy0">&lt;</span> total_no<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="co1">// Bloc cod A</span>
	<span class="sy0">++</span> it<span class="sy0">;</span>
<span class="br0">&#125;</span></pre>

<p>
Varianta assembly:
</p>
<pre class="code asm"><span class="co1">; presupunem ca it e variabila globală declarată în secțiunea data</span>
<span class="co1">; la fel si total_no</span>
&nbsp;
Condiție<span class="sy1">:</span>
	<span class="kw1">mov</span> <span class="kw4">eax</span><span class="sy1">,</span> <span class="kw6">dword</span> <span class="br0">&#91;</span>it<span class="br0">&#93;</span>
	<span class="kw1">mov</span> <span class="kw4">ebx</span><span class="sy1">,</span> <span class="kw6">dword</span> <span class="br0">&#91;</span>total_no<span class="br0">&#93;</span>
	<span class="kw1">cmp</span> <span class="kw4">eax</span><span class="sy1">,</span> <span class="kw4">ebx</span>
        <span class="kw1">jge</span> sfarșit_while
&nbsp;
Corp_while<span class="sy1">:</span>
        CodA
        <span class="kw1">inc</span> <span class="kw6">dword</span> <span class="br0">&#91;</span>it<span class="br0">&#93;</span>
        <span class="kw1">jmp</span> Conditie
Sfarsit_while<span class="sy1">:</span> <span class="sy1">...</span></pre>

</div>
<!-- EDIT11 SECTION "Blocul while" [15477-15900] -->
<h3 class="sectionedit12" id="iterarea_peste_un_vector">Iterarea peste un vector</h3>
<div class="level3">
<pre class="code c"><span class="kw4">int</span> vect<span class="br0">&#91;</span><span class="nu0">100</span><span class="br0">&#93;</span><span class="sy0">;</span>
<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> <span class="nu0">100</span><span class="sy0">;</span> <span class="sy0">++</span> i<span class="br0">&#41;</span>  <span class="br0">&#123;</span>
	Vect<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy0">=</span> <span class="nu0">500</span><span class="sy0">;</span>
<span class="br0">&#125;</span></pre>

<p>
Presupunând că vectorul este declarat global în secțiunea .data vom avea următoarea variantă:
</p>
<pre class="code asm"><span class="kw5">section</span> <span class="kw5">.data</span>
vect <span class="kw5">times</span> <span class="nu0">100</span> dup <span class="nu0">0</span>
&nbsp;
<span class="kw5">section</span> <span class="kw5">.text</span>
<span class="sy1">...</span>
Initializare<span class="sy1">:</span>
    <span class="kw1">mov</span> <span class="kw4">ebx</span><span class="sy1">,</span> vect
    <span class="kw1">mov</span> <span class="kw4">ecx</span><span class="sy1">,</span> <span class="nu0">100</span>
&nbsp;
Bucla_for<span class="sy1">:</span>
    <span class="kw1">mov</span> <span class="kw6">dword</span> <span class="br0">&#91;</span><span class="kw4">ebx</span><span class="br0">&#93;</span><span class="sy1">,</span> <span class="nu0">500</span>
    <span class="kw1">add</span> <span class="kw4">ebx</span><span class="sy1">,</span> <span class="nu0">4</span> 
    <span class="kw1">loop</span> Bucla_for
<span class="sy1">...</span></pre>

</div>
<!-- EDIT12 SECTION "Iterarea peste un vector" [15901-16322] -->
<h3 class="sectionedit13" id="variabile_locale">Variabile locale</h3>
<div class="level3">

<p>
Până acum toate variabilele erau variabile globale declarate în secțiunea .data. Mai putem avea variabile globale in secțiunea .bss, variabile alocate dinamic prin malloc/calloc/realloc/new și variabile locale alocate pe stivă. 
</p>

<p>
Pentru variabilele localte alocate pe stiva avem urmatoarea posibilitate:
</p>
<pre class="code c"><span class="kw4">int</span> f <span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw4">int</span> a <span class="sy0">=</span> <span class="nu0">5</span><span class="sy0">,</span> b <span class="sy0">=</span> <span class="nu0">7</span><span class="sy0">;</span>
&nbsp;
	<span class="kw1">return</span> a <span class="sy0">+</span> b<span class="sy0">;</span>
<span class="br0">&#125;</span></pre>

<p>
Varianta assembly:
</p>
<pre class="code asm"><span class="kw5">section</span> <span class="kw5">.data</span>
    X <span class="kw5">equ</span> <span class="sy1">-</span><span class="nu0">4</span>
    Y <span class="kw5">equ</span> <span class="sy1">-</span><span class="nu0">8</span>
    Z <span class="kw5">equ</span> <span class="sy1">-</span><span class="nu0">12</span>
&nbsp;
<span class="kw5">section</span> <span class="kw5">.text</span>
f<span class="sy1">:</span>
    <span class="kw1">push</span> <span class="kw4">ebp</span>
    <span class="kw1">mov</span> <span class="kw4">ebp</span><span class="sy1">,</span> <span class="kw4">esp</span>
    <span class="kw1">sub</span> <span class="kw4">esp</span><span class="sy1">,</span> <span class="nu0">12</span>
&nbsp;
    <span class="kw1">mov</span> <span class="kw6">dword</span><span class="br0">&#91;</span><span class="kw4">ebp</span> <span class="sy1">+</span> X<span class="br0">&#93;</span><span class="sy1">,</span> <span class="nu0">5</span>
    <span class="kw1">mov</span> <span class="kw6">dword</span><span class="br0">&#91;</span><span class="kw4">ebp</span> <span class="sy1">+</span> Y<span class="br0">&#93;</span><span class="sy1">,</span> <span class="nu0">7</span>
&nbsp;
    <span class="kw1">mov</span> <span class="kw4">eax</span><span class="sy1">,</span> <span class="kw6">dword</span> <span class="br0">&#91;</span><span class="kw4">ebp</span> <span class="sy1">+</span> X<span class="br0">&#93;</span>
    <span class="kw1">mov</span> <span class="kw4">ebx</span><span class="sy1">,</span> <span class="kw6">dword</span> <span class="br0">&#91;</span><span class="kw4">ebp</span> <span class="sy1">+</span> Y<span class="br0">&#93;</span>
    <span class="kw1">add</span> <span class="kw4">eax</span><span class="sy1">,</span> <span class="kw4">ebx</span>
    <span class="kw1">mov</span> <span class="kw6">dword</span> <span class="br0">&#91;</span><span class="kw4">ebp</span> <span class="sy1">+</span> Z<span class="br0">&#93;</span><span class="sy1">,</span> <span class="kw4">eax</span>
&nbsp;
    <span class="kw1">leave</span>
    <span class="kw1">ret</span></pre>

</div>
<!-- EDIT13 SECTION "Variabile locale" [16323-17067] -->
<h3 class="sectionedit14" id="functii">Funcții</h3>
<div class="level3">

<p>
Având funcția:
</p>
<pre class="code c"><span class="kw4">int</span> f<span class="br0">&#40;</span><span class="kw4">int</span> a<span class="sy0">,</span> <span class="kw4">char</span> b<span class="sy0">,</span> <span class="kw4">char</span><span class="sy0">*</span>s<span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>
Vom avea următorul cod echivalent in assembly:
</p>
<pre class="code asm">f<span class="sy1">:</span>
    <span class="kw1">push</span> <span class="kw4">ebp</span>
    <span class="kw1">mov</span> <span class="kw4">ebp</span><span class="sy1">,</span> <span class="kw4">esp</span>
&nbsp;
    <span class="co1">; a = dword [ebp + 8]</span>
    <span class="co1">; b = byte [ebp + 12]</span>
    <span class="co1">; s = dword [ebp + 16]  </span>
&nbsp;
    <span class="sy1">..</span>Cod Functie<span class="sy1">..</span>
&nbsp;
    <span class="kw1">leave</span>
    <span class="kw1">ret</span></pre>

<p>
Caracteristici:
</p>
<ul>
<li class="level1"><div class="li"> Prolog-ul (push, mov) și epilog-ul (leave, ret).</div>
</li>
<li class="level1"><div class="li"> Rezultatul unei funcții este pus în registrul eax.</div>
</li>
<li class="level1"><div class="li"> Paramterii sunt puși în ordine inversă înaintea apelării funcției.</div>
</li>
<li class="level1"><div class="li"> Spațiul pe stivă pentru ei trebuie alocat de asemenea înaintea și după terminarea apelului funcției.</div>
</li>
</ul>

<p>
<p><div class="noteclassic">
Locația și modul în care sunt puși paramterii ține de convenția pe care o folosește compilatorul. În cele mai multe cazuri, compilatoarele vor respecta convenția cdecl(cea enunțată mai sus). Pentru a vedea alte convenții accesați acest <a href="https://en.wikipedia.org/wiki/X86_calling_conventions" class="urlextern" title="https://en.wikipedia.org/wiki/X86_calling_conventions"  rel="nofollow">link</a>.

</div></p>
</p>

<p>
Funcțiile se recunosc ușor după prolog(push, mov) și epilog(leave, ret). Rezultatul este pus în registrul eax. Parametrii sunt puși în ordine inversa înaintea apelării funcției. Spațiul pe stivă pentru ei trebuie alocat de asemenea înaintea apelării și trebuie eliberat dupa terminarea ei. Aceasta este convenția cdecl pentru parametrii și alocarea/dezalocarea spațiului pe stivă folosită de cele mai multe compilatoare. Puteți să vedeți și alte variante aici: <a href="https://en.wikipedia.org/wiki/X86_calling_conventions" class="urlextern" title="https://en.wikipedia.org/wiki/X86_calling_conventions"  rel="nofollow">https://en.wikipedia.org/wiki/X86_calling_conventions</a>.
</p>

</div>
<!-- EDIT14 SECTION "Funcții" [17068-] --><div class="footnotes">
<div class="fn"><sup><a href="bune-practici.html#fnt__1" id="fn__1" class="fn_bot">1)</a></sup> 
salvați această setare în ~/.gdbinit</div>
</div>
</div>
</body>
</html>
