    
    

<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
  <meta charset="utf-8" />
  <title>mps:old:2008-2009:laboratoare:laborator-10</title>
<meta name="generator" content="DokuWiki"/>
<meta name="robots" content="index,follow"/>
<meta name="date" content="2016-09-28T17:08:56+0300"/>
<meta name="keywords" content="mps,old,2008-2009,laboratoare,laborator-10"/>
<link rel="search" type="application/opensearchdescription+xml" href="../../../../../../lib/exe/opensearch.php" title="CS Open CourseWare"/>
<link rel="start" href="../../../../../../../courses.1.html"/>
<link rel="alternate" type="application/rss+xml" title="Recent Changes" href="../../../../../../feed.php"/>
<link rel="alternate" type="application/rss+xml" title="Current Namespace" href="../../../../../../feed.php%3Fmode=list&amp;ns=mps:old:2008-2009:laboratoare"/>
<link rel="alternate" type="text/html" title="Plain HTML" href="laborator-10.html"/>
<link rel="canonical" href="../../../../../../mps/old/2008-2009/laboratoare/laborator-10.html"/>
<link rel="stylesheet" type="text/css" href="../../../../../../lib/exe/css.php%3Ft=arctic&amp;tseed=1479898000.css"/>
<script type="text/javascript">/*<![CDATA[*/var NS='mps:old:2008-2009:laboratoare';var JSINFO = {"id":"mps:old:2008-2009:laboratoare:laborator-10","namespace":"mps:old:2008-2009:laboratoare","isadmin":0,"isauth":0};
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="../../../../../../lib/exe/js.php%3Ftseed=1479898000"></script>
<script type="text/x-mathjax-config">/*<![CDATA[*/MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ["$","$"], ["\\(","\\)"] ],
        displayMath: [ ["$$","$$"], ["\\[","\\]"] ],
        processEscapes: true
    }
});
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
<script type="text/javascript">/*<![CDATA[*/
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
		  
/*!]]>*/</script>
<script type="text/javascript">/*<![CDATA[*/
var pageTracker = _gat._getTracker("UA-38383934-1");
pageTracker._initData();
pageTracker._trackPageview();
		  
/*!]]>*/</script>
</head>
<body>
<div class="dokuwiki export">
<!-- TOC START -->
<div id="dw__toc">
<h3 class="toggle">Table of Contents</h3>
<div>

<ul class="toc">
<li class="level4"><div class="li"><a href="laborator-10.html#definitii_am">Definiții (AM)</a></div></li>
<li class="level4"><div class="li"><a href="laborator-10.html#boundary_testing_-_rd_teorie_mb_exemple">Boundary testing - RD (teorie), MB (exemple)</a></div></li>
<li class="level3"><div class="li"><a href="laborator-10.html#exercitii">Exerciții</a></div></li>
<li class="level3"><div class="li"><a href="laborator-10.html#link-uri_utile">Link-uri utile</a></div></li>
<li class="level4"><div class="li"><a href="laborator-10.html#metrica_-_lg_teorie_ac_exemple">Metrica - LG (teorie) AC (exemple)</a></div></li>
</ul>
</div>
</div>
<!-- TOC END -->

<h5 id="black_box_testing">Black Box Testing</h5>
<div class="level5">

</div>

<h4 id="definitii_am">Definiții (AM)</h4>
<div class="level4">

<p>
* Structură
<strong> Program
</strong>* Programul ce trebuie testat pentru care sursele nu sunt disponibile, ci doar interfața de acces (binarul, o interfața implementată de clasa testată, etc).
<strong> Intrări
</strong>* un set de intrări ce vor fi trimise programului pentru execuție. Intrările nu trebuie neapărat să fie niște fișiere ci pot fi niște apeluri de funcții sau un alt program ce simulează un utilizator al interfeței grafice.
<strong> Ieșiri
</strong>* pentru fiecare intrare se definește un set de ieșire posibile cu care se testează ieșirea programului. În multe din cazuri ieșirea e deterministică și trebuie doar comparate ieșirea programului cu ieșirea așteptă, iar în alte cazuri este necesară scrierea unui program
* Cum testezi un program care la intrare primește un string pe care vrea să îl parseze în
<strong> numar intreg
</strong>* o utilă o funcție care face conversia invers
<strong>* limitele inferioare și superioare
</strong>* câteva constante mici (0, -1, 1)
<strong>* câteva constante mari
</strong>* întregi negativi
<strong>* caractere invalide (de exemplu, pentru baza 10 nu putem avea A)
</strong>* numere care au 0 in fata (dar excesiv de lungi gen: 00000000000000000000000000000666)
<strong>* același lucru pentru diferite baze (dacă sunt suportate)
</strong> float
<strong>* ca mai sus, dar în principal trebuie ținut cont de valorile speciale definite in standardul <a href="http://ieeexplore.ieee.org/xpl/freeabs_all.jsp?arnumber=4610935" class="urlextern" title="http://ieeexplore.ieee.org/xpl/freeabs_all.jsp?arnumber=4610935"  rel="nofollow">IEEE 754</a>
</strong>* -0.0 != 0.0
<strong>* Nan, -Nan
</strong>* inf, -inf
<strong> un șir de caractere
</strong>* limbajul acceptat (ala LFA)
<strong> un vector
</strong>* se aplica cazurile de la numere intregi (pentru 1 element)
<strong>* 0 elemente, 1 element, 2 elemente, 5 elemente, numar maxim de elemente
</strong>* caractere de despartire elemente/invalide
</p>

</div>

<h4 id="boundary_testing_-_rd_teorie_mb_exemple">Boundary testing - RD (teorie), MB (exemple)</h4>
<div class="level4">

<p>
Boundary testing sau boundary value analysis este o metodă de proiectare a
suitelor de teste pentru cazurile în care se folosesc valori la limita
acceptată de program. În general accentuează testarea “corner case”-urilor.
Unele teste care fac parte din suita boundary testing sunt “stress tests”.
</p>

<p>
În general, boundary value analysis se realizează în doi pași:
# identificarea claselor de echivalență
# proiectarea suitelor de test
</p>

<p>
Primul pas înseamnă de obicei, partiționarea valorilor posibile în clase
valide și invalide. Spre exemplu, un program care primește valori pozitive
până în 99, va avea trei clase:
* clasa validă (0 ⇐ n ⇐ 99)
* prima clasă invalidă (n &lt; 0)
* a doua clasă invlidă (n &gt; 99)
</p>

<p>
Al doilea pas înseamnă proiectarea unei suite de teste care vor selecta
anumite valori care să verifice reacția programului la valori valide sau
invalide. Dacă un program primește valori în domeniul [-999,999], atunci o
suită posibilă de test ar fi:
* testare valoare validă -999
* testare valoare validă 999
* testare valoare invalidă -1000
* testare valoare invalidă 1000
</p>

<p>
În general, testele trebuie să includă prima și ultima valoare posibilă. De
asemenea, se recomandă testarea de condiții extreme de intrare sau ieșire
(valori foarte mici, foarte mari, invalide etc.)
</p>

<p>
Problemele pe care le detectează boundary testing sunt, de obicei:
* folosirea incorectă a operatorilor relaționali (mai mic, mai mare etc.)
* folosirea de valori constante inițializate incorect
* erori de calcul care ar putea realiza overflow sau wrap-around în cazul conversiei între diverse tipuri de date
</p>

</div>

<h3 class="sectionedit1" id="exercitii">Exerciții</h3>
<div class="level3">

<p>
* Definiți o funcție (pseudocod) care primește două argumente indexul unei luni și indexul zilei în acea lună și întoarce un tuplu reprezentând următoarea zi (index lună, index zi) sau (-1, -1) la eroare. (ianuarie este 1, decembrie este 12).
* Cum va arăta un test pentru verificarea corectitudinii funcției de mai sus?
* O funcție are următoare signatură <code>boolean check_range(unsigned long count, unsigned long max)</code>. <code>count</code> reprezintă numărul de dublu cuvinte (32 de biți) de stocat într-o zonă de memorie iar <code>max</code> reprezintă numărul maxim de octeți (8 biți) care poate fi stocat în acea zonă. Funcția verifică dacă se pot aloca <code>count</code> dublu cuvinte și întoarce <code>true</code> la succes și <code>false</code> la insucces. Cum va arăta acea funcție?
* Ce cazuri de test veți folosi pentru verificarea corectitudinii funcției de mai sus?
* Definiți o funcție care primește ca argumente 3 valori întregi cuprinse între 0 și 200 și întoarce true sau false după cum cele trei valori pot reprezenta lungimea laturilor unui triunghi.
* Ce cazuri de test veți folosi pentru verificarea corectitudinii funcției de mai sus?
</p>

</div>
<!-- EDIT1 SECTION "Exerciții" [3471-4655] -->
<h3 class="sectionedit2" id="link-uri_utile">Link-uri utile</h3>
<div class="level3">

<p>
* <a href="http://blogs.msdn.com/imtesty/archive/2008/11/04/boundary-testing-isn-t-guessing-at-numbers.aspx" class="urlextern" title="http://blogs.msdn.com/imtesty/archive/2008/11/04/boundary-testing-isn-t-guessing-at-numbers.aspx"  rel="nofollow">Boundary testing isn&#039;t guessing at numbers</a>
* <a href="http://www.geocities.com/xtremetesting/BoundaryValues.html" class="urlextern" title="http://www.geocities.com/xtremetesting/BoundaryValues.html"  rel="nofollow">boundary values software testing</a>
* <a href="http://www.win.tue.nl/~mousavi/testing/1.pdf" class="urlextern" title="http://www.win.tue.nl/~mousavi/testing/1.pdf"  rel="nofollow">Boundary Value Testing</a>
* <a href="http://www.ccse.kfupm.edu.sa/~wasfi/swe415/072/Handouts/StNotes07.ppt" class="urlextern" title="http://www.ccse.kfupm.edu.sa/~wasfi/swe415/072/Handouts/StNotes07.ppt"  rel="nofollow">Boundary Value Testing Example</a>
* <a href="http://www.cs.swan.ac.uk/~csmarkus/CS339/dissertations/NeateB.pdf" class="urlextern" title="http://www.cs.swan.ac.uk/~csmarkus/CS339/dissertations/NeateB.pdf"  rel="nofollow">Boundary Value Analysis</a>
</p>

</div>

<h4 id="metrica_-_lg_teorie_ac_exemple">Metrica - LG (teorie) AC (exemple)</h4>
<div class="level4">

<p>
* use-case coverage (variante de utilizare testate) spre deosebire de white box unde era code coverage
* error coverage
* domeniul de intrare testat
* util
* valori posibile (probabile)
<strong> corecte
</strong> incorecte
* inutil
* valori neașteptate
</p>

</div>
<!-- EDIT2 SECTION "Link-uri utile" [4656-] --></div>
</body>
</html>
