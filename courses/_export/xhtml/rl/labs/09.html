    
    

<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
  <meta charset="utf-8" />
  <title>rl:labs:09</title>
<meta name="generator" content="DokuWiki"/>
<meta name="robots" content="index,follow"/>
<meta name="date" content="2015-10-05T23:51:20+0300"/>
<meta name="keywords" content="rl,labs,09"/>
<link rel="search" type="application/opensearchdescription+xml" href="../../../../lib/exe/opensearch.php" title="CS Open CourseWare"/>
<link rel="start" href="../../../../../courses.1.html"/>
<link rel="alternate" type="application/rss+xml" title="Recent Changes" href="../../../../feed.php"/>
<link rel="alternate" type="application/rss+xml" title="Current Namespace" href="../../../../feed.php%3Fmode=list&amp;ns=rl:labs"/>
<link rel="alternate" type="text/html" title="Plain HTML" href="09.html"/>
<link rel="canonical" href="../../../../rl/labs/09.html"/>
<link rel="stylesheet" type="text/css" href="../../../../lib/exe/css.php%3Ft=arctic&amp;tseed=1476798676.css"/>
<script type="text/javascript">/*<![CDATA[*/var NS='rl:labs';var JSINFO = {"id":"rl:labs:09","namespace":"rl:labs","isadmin":0,"isauth":0};
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="../../../../lib/exe/js.php%3Ftseed=1476798676"></script>
<script type="text/x-mathjax-config">/*<![CDATA[*/MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ["$","$"], ["\\(","\\)"] ],
        displayMath: [ ["$$","$$"], ["\\[","\\]"] ],
        processEscapes: true
    }
});
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
<script type="text/javascript">/*<![CDATA[*/
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
		  
/*!]]>*/</script>
<script type="text/javascript">/*<![CDATA[*/
var pageTracker = _gat._getTracker("UA-38383934-1");
pageTracker._initData();
pageTracker._trackPageview();
		  
/*!]]>*/</script>
</head>
<body>
<div class="dokuwiki export">



<h1 class="sectionedit1" id="laborator_9_translatarea_de_adrese">Laborator 9. Translatarea de adrese</h1>
<div class="level1">

</div>
<!-- EDIT1 SECTION "Laborator 9. Translatarea de adrese" [12-62] -->
<h2 class="sectionedit2" id="cunostinte_si_abilitati_ce_vor_fi_dobandite">Cunoștințe și abilități ce vor fi dobândite</h2>
<div class="level2">
<ul>
<li class="level1"><div class="li"> Cunoștințe generale legate de translatarea de adrese</div>
</li>
<li class="level1"><div class="li"> Translatarea de adrese pe Linux</div>
</li>
<li class="level1"><div class="li"> Translatarea directă (SNAT, MASQUERADE) și port forwarding (DNAT)</div>
</li>
<li class="level1"><div class="li"> Tunelare SSH</div>
</li>
</ul>

</div>
<!-- EDIT2 SECTION "Cunoștințe și abilități ce vor fi dobândite" [63-310] -->
<h2 class="sectionedit3" id="pregatire_infrastructura_de_laborator">Pregătire infrastructură de laborator</h2>
<div class="level2">
<ul>
<li class="level1"><div class="li"> Vom rula o masină virtuală în <a href="http://cloud.curs.pub.ro" class="urlextern" title="http://cloud.curs.pub.ro"  rel="nofollow"> cloud-ul facultății</a></div>
</li>
<li class="level1"><div class="li"> Pentru a porni o astfel de masină urmăriți tutorialul de la <a href="https://cloud.curs.pub.ro/about/tutorial-for-students/" class="urlextern" title="https://cloud.curs.pub.ro/about/tutorial-for-students/"  rel="nofollow"> această adresă</a></div>
</li>
<li class="level1"><div class="li"> Pentru a pregăti configurația de laborator, pe mașina virtuală (stația <code>host</code>) folosiți comenzile următoare din contul utilizatorului <code>root</code> de pe stația <code>host</code> (puteți da copy/paste la comenzi în terminal):<pre class="code bash"><span class="co4">root@host:~# </span><span class="kw2">wget</span> https:<span class="sy0">//</span>raw.github.com<span class="sy0">/</span>RL-UPB<span class="sy0">/</span>rl-lab-prepare<span class="sy0">/</span>master<span class="sy0">/</span>rl-lab-09-prepare
<span class="co4">root@host:~# </span><span class="kw2">chmod</span> +x rl-lab-09-prepare
<span class="co4">root@host:~# </span>.<span class="sy0">/</span>rl-lab-09-prepare</pre>

<p>
 Comanda durează circa 20 de secunde. Lasați-o să ruleze complet.
</p>
</div>
</li>
<li class="level1"><div class="li"> Deschideți trei noi tab-uri în terminal (folosiți combinația de taste <code>Ctrl+Shift+t</code>), și conectați-vă, din nou, la mașina virtuală folosind comanda <code>ssh</code> de mai sus.</div>
<ul>
<li class="level2"><div class="li"> De pe cele trei noi tab-uri, conectați-vă la cele trei containere (<code>red</code>, <code>green</code> și <code>blue</code>).</div>
</li>
<li class="level2"><div class="li"> Conectați-vă ca utilizatorul <code>root</code>. Veți lucra în cea mai mare parte ca utilizator privilegiat.</div>
</li>
</ul>
</li>
</ul>
<div class="hiddenGlobal  hiddenActive"><div class="hiddenElements"></div><div class="hiddenHead  hiddenSinceBeginning"><div class="hiddenOnHidden">
<p>
(click pentru expandare) Detalii rulare masina virtuala VMware local
</p>
</div><div class="hiddenOnVisible">
<p>
(click pentru expandare) Detalii rulare masina virtuala VMware local
</p>
</div></div> <!-- .hiddenHead --><div class="hiddenBody"><ul>
<li class="level1"><div class="li"> Deschideți VMware și porniți mașina virtuală <code>RL_lab</code>.</div>
</li>
<li class="level1"><div class="li"> Dorim să folosim terminalul sistemului fizic și să lucrăm peste SSH cu mașina virtuală VMware (denumită și <code>host</code>). În acest fel vom putea folosi copy-paste în terminal sau alte facilități. Pentru aceasta urmați pașii de mai jos:</div>
<ul>
<li class="level2"><div class="li"> Autentificați-vă în mașina virtuală folosind contul <code>root</code> cu parola <code>student</code>.</div>
</li>
<li class="level2"><div class="li"> Aflați adresa IP a mașinii virtuale de pe interfața <code>eth0</code>:<pre class="code bash"><span class="co4">root@host:~# </span><span class="kw2">ifconfig</span> eth0</pre>
</div>
</li>
<li class="level2"><div class="li"> De pe sistemul fizic, deschideți un terminal și realizați o sesiune SSH folosind:<pre class="code bash"><span class="co4">student@mjolnir:~$ </span><span class="kw2">ssh</span> root<span class="sy0">@</span><span class="re1">$ADRESA_IP_MV</span></pre>

<p>
unde <code>$ADRESA_IP_MV</code> este adresa IP a mașinii virtuale așa cum ați obținut-o mai sus.
</p>
</div>
</li>
</ul>
</li>
</ul>
</div></div>
<p>
<p><div class="noteclassic">
Pentru a vedea cum accesați stațiile <code>red</code>, <code>green</code> și <code>blue</code> (containere LXC configurate peste mașina virtuală VMware - stația <code>host</code>) urmăriți pașii de <a href="../../../../rl/info/resurse/vm-laborator.html#instructiuni_utilizare" class="wikilink1" title="rl:info:resurse:vm-laborator"> aici</a>.

</div></p>
</p>

<p>
<p><div class="noteclassic">
Conturile de acces la mașina virtuală (stația <code>host</code>) sunt (<code>username:parola</code>):
</p>
<ul>
<li class="level1"><div class="li"> <code>root:student</code></div>
</li>
<li class="level1"><div class="li"> <code>student:student</code></div>
</li>
</ul>

<p>

</div></p>
</p>

</div>
<!-- EDIT3 SECTION "Pregătire infrastructură de laborator" [311-2737] -->
<h2 class="sectionedit4" id="topologie">Topologie</h2>
<div class="level2">

<p>
<a href="../../../../_detail/rl/topologie.png%3Fid=rl%253Alabs%253A09.html" class="media" title="rl:topologie.png"><img src="../../../../_media/rl/topologie.png" class="mediacenter" alt="" /></a>
</p>

</div>
<!-- EDIT4 SECTION "Topologie" [2738-2786] -->
<h2 class="sectionedit5" id="navigare">Navigare</h2>
<div class="level2">

<p>
<strong><span class="curid"><a href="../../../../rl/labs/09.html" class="wikilink1" title="rl:labs:09">Laboratorul 9</a></span></strong>
</p>

</div>
<!-- EDIT6 PLUGIN_INCLUDE_START "rl:labs:09:meta:nav" [0-] --><div class="plugin_include_content plugin_include__rl:labs:09:meta:nav">
<div class="level2">

<div><div id="nojs_indexmenu_887006021583560a247593" data-jsajax="%26skipfile%3D%252B/sidebar/" class="indexmenu_nojs">

<ul class="idx">
<li class="level1"><div class="li"><a href="../../../../rl/labs/09/contents/01.html" class="wikilink1" title="rl:labs:09:contents:01">01. [10p] Configurare translatare de adrese (MASQUERADE)</a></div></li>
<li class="level1"><div class="li"><a href="../../../../rl/labs/09/contents/02.html" class="wikilink1" title="rl:labs:09:contents:02">02. [10p] Format de pachete la translatare</a></div></li>
<li class="level1"><div class="li"><a href="../../../../rl/labs/09/contents/03.html" class="wikilink1" title="rl:labs:09:contents:03">03. [10p] Format de pachete TCP la translatare</a></div></li>
<li class="level1"><div class="li"><a href="../../../../rl/labs/09/contents/04.html" class="wikilink1" title="rl:labs:09:contents:04">04. [10p] Configurare incorectă a translatării</a></div></li>
<li class="level1"><div class="li"><a href="../../../../rl/labs/09/contents/05.html" class="wikilink1" title="rl:labs:09:contents:05">05. [10p] Port forwarding</a></div></li>
<li class="level1"><div class="li"><a href="../../../../rl/labs/09/contents/06.html" class="wikilink1" title="rl:labs:09:contents:06">06. [10p] Extindere port forwarding</a></div></li>
<li class="level1"><div class="li"><a href="../../../../rl/labs/09/contents/07.html" class="wikilink1" title="rl:labs:09:contents:07">07. [10p] Format de pachete la port forwarding</a></div></li>
<li class="level1"><div class="li"><a href="../../../../rl/labs/09/contents/08.html" class="wikilink1" title="rl:labs:09:contents:08">08. [10p] Port forwarding pentru telnet</a></div></li>
<li class="level1"><div class="li"><a href="../../../../rl/labs/09/contents/09.html" class="wikilink1" title="rl:labs:09:contents:09">09. [10p] Configurare persistentă rutare și NAT</a></div></li>
<li class="level1"><div class="li"><a href="../../../../rl/labs/09/contents/10.html" class="wikilink1" title="rl:labs:09:contents:10">10. [10p] Tunel SSH invers</a></div></li>
<li class="level1"><div class="li"><a href="../../../../rl/labs/09/contents/11.html" class="wikilink1" title="rl:labs:09:contents:11">11. [BONUS - 10p] Translatare selectivă de adrese</a></div></li>
</ul>
</div></div>

</div>
<!-- EDIT7 PLUGIN_INCLUDE_END "rl:labs:09:meta:nav" [0-] --></div>
<div class="level2">

</div>
<!-- EDIT5 SECTION "Navigare" [2787-2895] -->
<h2 class="sectionedit8" id="exercitii">Exerciții</h2>
<div class="level2">

<p>
În cadrul exercițiilor din laboratoarele de Linux vom folosi <span class="curid"><a href="../../../../rl/labs/09.html#topologie" class="wikilink1" title="rl:labs:09">topologia de mai sus</a></span>.
</p>

</div>
<!-- EDIT9 PLUGIN_INCLUDE_START "rl:labs:09:contents:01" [0-] --><div class="plugin_include_content plugin_include__rl:labs:09:contents:01">

<h3 class="sectionedit11" id="p_configurare_translatare_de_adrese_masquerade">01. [10p] Configurare translatare de adrese (MASQUERADE)</h3>
<div class="level3">

<p>
Epuizarea adreselor IPv4 în cadrul rețelelor curente a condus la folosirea de adrese IP din clase private (de ex. <code>192.168.0.0/24</code>). Pe lângă comunicația dintre stațiile unei rețele, dorim și accesul la Internet al acestora. De aceea s-a introdus conceptul de translatare de adrese (NAT: <em>Network Address Translation</em>) prin care mai multe stații dispun de acces la Internet folosind aceeași adresă IP rutabilă: adresa gateway-ului. Activarea translatării de adrese (NAT) pe gateway conduce la înlocuirea perechii &lt;adresă IP sursă, port sursă&gt; (aparținând stației) cu perechea &lt;adresa IP gateway, port disponibil&gt;.
</p>

<p>
Configurarea NAT pe Linux se realizează tot prin intermediul comenzii <code>iptables</code>, la fel ca în cazul configurării firewall-ului. Dacă pentru configurarea firewall-ului foloseam tabela <code>filter</code> (tabela implicită a <code>iptables</code>), pentru configurarea translatării de adrese vom folosi tabela <code>nat</code>.
</p>

<p>
Astfel, pentru a activa NAT pe un server Linux executăm comanda
</p>
<pre class="code bash"><span class="co4">root@host:~# </span>iptables <span class="re5">-t</span> nat <span class="re5">-A</span> POSTROUTING <span class="re5">-j</span> MASQUERADE</pre>

<p>
În comanda de mai sus:
</p>
<ul>
<li class="level1"><div class="li"> <code>-t</code> specifică tabela pe care se aplică regula, în cazul nostru tabela <code>nat</code>.</div>
</li>
<li class="level1"><div class="li"> <code>-A</code> înseamnă adăugarea unei reguli la sfârșitul listei de reguli.</div>
</li>
<li class="level1"><div class="li"> <code>POSTROUTING</code> se referă la momentul când va fi realizat procesul de translatare de adrese: după rutare.</div>
<ul>
<li class="level2"><div class="li"> În nomenclatura <code>iptables</code> acesta se numește și de <strong>lanț (chain)</strong>.</div>
</li>
<li class="level2"><div class="li"> Exemple de alte lanțuri: <code>INPUT</code>, <code>OUTPUT</code>, <code>FORWARD</code>, <code>PREROUTING</code>.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> <code>-j</code> este acțiunea ce va fi luată, iar în acest caz este <code>MASQUERADE</code> (acțiune simplă de translatare de adrese).</div>
</li>
</ul>

<p>
Pentru a verifica și valida regula, afișăm intrările din lanțul <code>POSTROUTING</code> din tabela <code>nat</code> folosind comanda
</p>
<pre class="code bash"><span class="co4">root@host:~# </span>iptables <span class="re5">-t</span> nat <span class="re5">-L</span> POSTROUTING <span class="re5">-n</span> <span class="re5">-v</span>
Chain POSTROUTING <span class="br0">&#40;</span>policy ACCEPT <span class="nu0">0</span> packets, <span class="nu0">0</span> bytes<span class="br0">&#41;</span>
 pkts bytes target     prot opt <span class="kw1">in</span>     out     <span class="kw3">source</span>               destination
    <span class="nu0">0</span>     <span class="nu0">0</span> MASQUERADE  all  <span class="re5">--</span>  <span class="sy0">*</span>      <span class="sy0">*</span>       0.0.0.0<span class="sy0">/</span><span class="nu0">0</span>            0.0.0.0<span class="sy0">/</span><span class="nu0">0</span></pre>

<p>
Vrem să verificăm configurarea corectă a NAT. Pentru acesta vom trimite de pe stația <code>red</code> un pachet către <code>8.8.8.8</code>. Pachetul va trece prin gateway (adică stația <code>host</code>) și va fi translatat. Pe stația <code>red</code> rulăm comanda
</p>
<pre class="code bash"><span class="co4">root@red:~# </span><span class="kw2">ping</span> <span class="re5">-c</span> <span class="nu0">2</span> 8.8.8.8
PING 8.8.8.8 <span class="br0">&#40;</span>8.8.8.8<span class="br0">&#41;</span> <span class="nu0">56</span><span class="br0">&#40;</span><span class="nu0">84</span><span class="br0">&#41;</span> bytes of data.
From 192.168.1.2 <span class="re2">icmp_seq</span>=<span class="nu0">1</span> Destination Host Unreachable
From 192.168.1.2 <span class="re2">icmp_seq</span>=<span class="nu0">2</span> Destination Host Unreachable
&nbsp;
<span class="re5">---</span> 8.8.8.8 <span class="kw2">ping</span> statistics <span class="re5">---</span>
<span class="nu0">2</span> packets transmitted, <span class="nu0">0</span> received, +<span class="nu0">2</span> errors, <span class="nu0">100</span><span class="sy0">%</span> packet loss, <span class="kw1">time</span> 999ms</pre>

<p>
Observăm că nu există conectivitate de la stația <code>red</code> către adresa IP <code>8.8.8.8</code>. Consultăm întreaga tabelă <code>nat</code>:
</p>
<pre class="code bash"><span class="co4">root@host:~# </span>iptables <span class="re5">-t</span> nat <span class="re5">-L</span> <span class="re5">-n</span> <span class="re5">-v</span>
Chain PREROUTING <span class="br0">&#40;</span>policy ACCEPT <span class="nu0">2</span> packets, <span class="nu0">168</span> bytes<span class="br0">&#41;</span>
 pkts bytes target     prot opt <span class="kw1">in</span>     out     <span class="kw3">source</span>               destination         
&nbsp;
Chain INPUT <span class="br0">&#40;</span>policy ACCEPT <span class="nu0">0</span> packets, <span class="nu0">0</span> bytes<span class="br0">&#41;</span>
 pkts bytes target     prot opt <span class="kw1">in</span>     out     <span class="kw3">source</span>               destination         
&nbsp;
Chain OUTPUT <span class="br0">&#40;</span>policy ACCEPT <span class="nu0">0</span> packets, <span class="nu0">0</span> bytes<span class="br0">&#41;</span>
 pkts bytes target     prot opt <span class="kw1">in</span>     out     <span class="kw3">source</span>               destination         
&nbsp;
Chain POSTROUTING <span class="br0">&#40;</span>policy ACCEPT <span class="nu0">0</span> packets, <span class="nu0">0</span> bytes<span class="br0">&#41;</span>
 pkts bytes target     prot opt <span class="kw1">in</span>     out     <span class="kw3">source</span>               destination         
    <span class="nu0">0</span>     <span class="nu0">0</span> MASQUERADE  all  <span class="re5">--</span>  <span class="sy0">*</span>      <span class="sy0">*</span>       0.0.0.0<span class="sy0">/</span><span class="nu0">0</span>            0.0.0.0<span class="sy0">/</span><span class="nu0">0</span> </pre>

<p>
Observăm că pachetele ajung în lanțul <code>PREROUTING</code> (înainte de rutare), dar nu ajung în lanțul <code>POSTROUTING</code> (după rutare). Ne gândim că este posibil să fie o problemă cu rutarea pe gateway. Verificăm dacă rutarea este activată:
</p>
<pre class="code bash"><span class="co4">root@host:~# </span>sysctl net.ipv4.ip_forward
net.ipv4.ip_forward = <span class="nu0">0</span></pre>

<p>
Într-adevăr, rutarea nu este activată. Pentru a activa rutarea pe stația <code>host</code> rulăm comanda
</p>
<pre class="code bash"><span class="co4">root@host:~# </span>sysctl <span class="re5">-w</span> net.ipv4.ip_forward=<span class="nu0">1</span>
net.ipv4.ip_forward = <span class="nu0">1</span></pre>

<p>
Intrăm din nou pe stația <code>red</code> și folosim <code>ping</code> pentru a testa conectivitatea la adresa IP <code>8.8.8.8</code>:
</p>
<pre class="code bash"><span class="co4">root@red:~# </span><span class="kw2">ping</span> <span class="re5">-c</span> <span class="nu0">2</span> 8.8.8.8
PING 8.8.8.8 <span class="br0">&#40;</span>8.8.8.8<span class="br0">&#41;</span> <span class="nu0">56</span><span class="br0">&#40;</span><span class="nu0">84</span><span class="br0">&#41;</span> bytes of data.
<span class="nu0">64</span> bytes from 8.8.8.8: <span class="re2">icmp_req</span>=<span class="nu0">1</span> <span class="re2">ttl</span>=<span class="nu0">61</span> <span class="re2">time</span>=<span class="nu0">92.9</span> ms
<span class="nu0">64</span> bytes from 8.8.8.8: <span class="re2">icmp_req</span>=<span class="nu0">2</span> <span class="re2">ttl</span>=<span class="nu0">61</span> <span class="re2">time</span>=<span class="nu0">81.2</span> ms
&nbsp;
<span class="re5">---</span> 8.8.8.8 <span class="kw2">ping</span> statistics <span class="re5">---</span>
<span class="nu0">2</span> packets transmitted, <span class="nu0">2</span> received, <span class="nu0">0</span><span class="sy0">%</span> packet loss, <span class="kw1">time</span> 1001ms
rtt min<span class="sy0">/</span>avg<span class="sy0">/</span>max<span class="sy0">/</span>mdev = <span class="nu0">81.272</span><span class="sy0">/</span><span class="nu0">87.094</span><span class="sy0">/</span><span class="nu0">92.917</span><span class="sy0">/</span><span class="nu0">5.829</span> ms</pre>

<p>
Acum există conectivitate, lucru certificat și de prezența unor pachete în lista prelucrată pe lanțul <code>POSTROUTING</code>:
</p>
<pre class="code bash"><span class="co4">root@host:~# </span>iptables <span class="re5">-t</span> nat <span class="re5">-L</span> POSTROUTING <span class="re5">-n</span> <span class="re5">-v</span>
Chain POSTROUTING <span class="br0">&#40;</span>policy ACCEPT <span class="nu0">0</span> packets, <span class="nu0">0</span> bytes<span class="br0">&#41;</span>
 pkts bytes target     prot opt <span class="kw1">in</span>     out     <span class="kw3">source</span>               destination         
    <span class="nu0">2</span>   <span class="nu0">168</span> MASQUERADE  all  <span class="re5">--</span>  <span class="sy0">*</span>      <span class="sy0">*</span>       0.0.0.0<span class="sy0">/</span><span class="nu0">0</span>            0.0.0.0<span class="sy0">/</span><span class="nu0">0</span></pre>

</div>
<!-- EDIT11 SECTION "01. [10p] Configurare translatare de adrese (MASQUERADE)" [1-] --><!-- EDIT10 PLUGIN_INCLUDE_END "rl:labs:09:contents:01" [0-] --></div>
<div class="level2">

</div>
<!-- EDIT12 PLUGIN_INCLUDE_START "rl:labs:09:contents:02" [0-] --><div class="plugin_include_content plugin_include__rl:labs:09:contents:02">

<h3 class="sectionedit14" id="p_format_de_pachete_la_translatare">02. [10p] Format de pachete la translatare</h3>
<div class="level3">

<p>
Ne propunem să analizăm antetul IP al pachetelor ce sunt generate de stațiile <code>red</code>, <code>green</code> și <code>blue</code> și au ca destinație o rețea din Internet. Pentru acest lucru vom folosi utilitarul de captură <code>tcpdump</code>.
</p>

<p>
Pe stația <code>red</code> pornim comanda <code>ping</code> către <code>8.8.8.8.</code>:
</p>
<pre class="code bash"><span class="co4">root@red:~# </span><span class="kw2">ping</span> 8.8.8.8
PING 8.8.8.8 <span class="br0">&#40;</span>8.8.8.8<span class="br0">&#41;</span> <span class="nu0">56</span><span class="br0">&#40;</span><span class="nu0">84</span><span class="br0">&#41;</span> bytes of data.
<span class="nu0">64</span> bytes from 8.8.8.8: <span class="re2">icmp_req</span>=<span class="nu0">1</span> <span class="re2">ttl</span>=<span class="nu0">127</span> <span class="re2">time</span>=<span class="nu0">42.0</span> ms
<span class="br0">&#91;</span>...<span class="br0">&#93;</span></pre>

<p>
<p><div class="noteclassic">
Atunci când rulăm comanda <code>tcpdump</code> secvența de urmat este:
</p>
<ol>
<li class="level1"><div class="li"> Se rulează comanda <code>tcpdump</code> cu opțiunile aferente într-un terminal, activând astfel captura de pachete. Utilitarul <code>tcpdump</code> așteaptă acum transmiterea de pachete pe interfețele pe care ascultă.</div>
</li>
<li class="level1"><div class="li"> Într-un alt terminal se rulează o comandă specifică unui client de rețea care generează trafic.</div>
</li>
<li class="level1"><div class="li"> Se revine în terminalul în care rulează comanda <code>tcpdump</code> și se urmăresc pachetele capturate.</div>
</li>
<li class="level1"><div class="li"> Când nu mai este nevoie de utilitarul <code>tcpdump</code> se întrerupe captura de pachete folosind combinația de taste <code>Ctrl+c</code>.</div>
</li>
</ol>

<p>

</div></p>
</p>

<p>
Pentru a urmări traficul, pe stația <code>host</code> rulăm comanda
</p>
<pre class="code bash"><span class="co4">root@host:~# </span>tcpdump <span class="re5">-i</span> eth0 <span class="kw2">ip</span> dst host 8.8.8.8
tcpdump: verbose output suppressed, use <span class="re5">-v</span> or <span class="re5">-vv</span> <span class="kw1">for</span> full protocol decode
listening on eth0, link-type EN10MB <span class="br0">&#40;</span>Ethernet<span class="br0">&#41;</span>, capture <span class="kw2">size</span> <span class="nu0">65535</span> bytes
<span class="nu0">12</span>:<span class="nu0">59</span>:<span class="nu0">20.976707</span> IP host.local <span class="sy0">&gt;</span> google-public-dns-a.google.com: ICMP <span class="kw3">echo</span> request, <span class="kw2">id</span> <span class="nu0">625</span>, <span class="kw2">seq</span> <span class="nu0">6</span>, length <span class="nu0">64</span>
<span class="nu0">12</span>:<span class="nu0">59</span>:<span class="nu0">21.977708</span> IP host.local <span class="sy0">&gt;</span> google-public-dns-a.google.com: ICMP <span class="kw3">echo</span> request, <span class="kw2">id</span> <span class="nu0">625</span>, <span class="kw2">seq</span> <span class="nu0">7</span>, length <span class="nu0">64</span></pre>
<div class="hiddenGlobal  hiddenActive"><div class="hiddenElements"></div><div class="hiddenHead  hiddenSinceBeginning"><div class="hiddenOnHidden">
<p>
(click pentru expandare) Detalii rulare masina virtuala VMware local
</p>
</div><div class="hiddenOnVisible">
<p>
(click pentru expandare) Detalii rulare masina virtuala VMware local
</p>
</div></div> <!-- .hiddenHead --><div class="hiddenBody">
<p>
<p><div class="noteimportant">
După rularea comenzii de mai sus, probabil vi se va bloca terminalul. În mașina virtuală VMware apare o mini-fereastră care vă indică intrarea plăcii de rețea în modul <em>promiscuous</em>. Apăsați pe butonul <code>OK</code> al ferestrei pentru a debloca mașina virtuală și, astfel, terminalul.

</div></p>
</p>
</div></div>
<p>
Observăm că adresa IP sursă este <code>host.local</code> chiar dacă stația <code>red</code> este cea care execută comanda <code>ping</code> și generează pachetele de tip <code>ICMP echo request</code>.
</p>

<p>
Pentru a vedea pachetele așa cum sunt generate inițial, rulăm comandă <code>tcpdump</code> pe interfața <code>veth-red</code> în loc de <code>eth0</code>: 
</p>
<pre class="code bash"><span class="co4">root@host:~# </span>tcpdump <span class="re5">-i</span> veth-red <span class="kw2">ip</span> dst host 8.8.8.8
tcpdump: verbose output suppressed, use <span class="re5">-v</span> or <span class="re5">-vv</span> <span class="kw1">for</span> full protocol decode
listening on veth-red, link-type EN10MB <span class="br0">&#40;</span>Ethernet<span class="br0">&#41;</span>, capture <span class="kw2">size</span> <span class="nu0">65535</span> bytes
<span class="nu0">13</span>:01:<span class="nu0">12.557692</span> IP <span class="kw2">red</span> <span class="sy0">&gt;</span> google-public-dns-a.google.com: ICMP <span class="kw3">echo</span> request, <span class="kw2">id</span> <span class="nu0">626</span>, <span class="kw2">seq</span> <span class="nu0">6</span>, length <span class="nu0">64</span>
<span class="nu0">13</span>:01:<span class="nu0">13.559726</span> IP <span class="kw2">red</span> <span class="sy0">&gt;</span> google-public-dns-a.google.com: ICMP <span class="kw3">echo</span> request, <span class="kw2">id</span> <span class="nu0">626</span>, <span class="kw2">seq</span> <span class="nu0">7</span>, length <span class="nu0">64</span></pre>

<p>
Observăm că pe interfața <code>veth-red</code> adresa IP sursă este adresa stației <code>red</code>, adică așa cum este generat de la început pachetul. Motivul este reprezentat de faptul că pachetele ce intră pe intefața <code>veth-red</code> sunt capturate înainte de rutare, iar procesul NAT este aplicat <strong>după rutare</strong> (vezi <a href="../../../../rl/labs/09/contents/01.html" class="wikilink1" title="rl:labs:09:contents:01">01. [10p] Configurare translatare de adrese (MASQUERADE)</a>.
</p>

<p>
Pentru a vedea modul în care se translatează traficul capturăm traficul pe toate interfețele (cele de interes sunt <code>veth-red</code> și <code>eth0</code>)
</p>
<pre class="code bash"><span class="co4">root@host:~# </span>tcpdump <span class="re5">-i</span> any <span class="kw2">ip</span> dst host 8.8.8.8
tcpdump: verbose output suppressed, use <span class="re5">-v</span> or <span class="re5">-vv</span> <span class="kw1">for</span> full protocol decode
listening on any, link-type LINUX_SLL <span class="br0">&#40;</span>Linux cooked<span class="br0">&#41;</span>, capture <span class="kw2">size</span> <span class="nu0">65535</span> bytes
<span class="nu0">10</span>:<span class="nu0">23</span>:<span class="nu0">07.632412</span> IP <span class="kw2">red</span> <span class="sy0">&gt;</span> google-public-dns-a.google.com: ICMP <span class="kw3">echo</span> request, <span class="kw2">id</span> <span class="nu0">707</span>, <span class="kw2">seq</span> <span class="nu0">237</span>, length <span class="nu0">64</span>
<span class="nu0">10</span>:<span class="nu0">23</span>:<span class="nu0">07.632430</span> IP host.local <span class="sy0">&gt;</span> google-public-dns-a.google.com: ICMP <span class="kw3">echo</span> request, <span class="kw2">id</span> <span class="nu0">707</span>, <span class="kw2">seq</span> <span class="nu0">237</span>, length <span class="nu0">64</span>
<span class="nu0">10</span>:<span class="nu0">23</span>:<span class="nu0">08.633936</span> IP <span class="kw2">red</span> <span class="sy0">&gt;</span> google-public-dns-a.google.com: ICMP <span class="kw3">echo</span> request, <span class="kw2">id</span> <span class="nu0">707</span>, <span class="kw2">seq</span> <span class="nu0">238</span>, length <span class="nu0">64</span>
<span class="nu0">10</span>:<span class="nu0">23</span>:<span class="nu0">08.633954</span> IP host.local <span class="sy0">&gt;</span> google-public-dns-a.google.com: ICMP <span class="kw3">echo</span> request, <span class="kw2">id</span> <span class="nu0">707</span>, <span class="kw2">seq</span> <span class="nu0">238</span>, length <span class="nu0">64</span></pre>

<p>
În lista de mai sus observăm atât pachetele care sunt captuarate pe interfața <code>veth-red</code> (generate de stația <code>red</code>) cât și cele capturate pe interfața <code>eth0</code> (translatate de stația <code>host</code>).
</p>

<p>
Capturați și pachetele de reply, care au ca <strong>sursă</strong> adresa <code>8.8.8.8</code>. Folosiți șirul de argumente <code>ip src host 8.8.8.8</code> pentru <code>tcpdump</code>.
</p>

<p>
Repetați testele de mai sus pentru stația <code>green</code>.
</p>

<p>
<p><div class="noteclassic">
Întrucât latența <abbr title="Domain Name System">DNS</abbr> poate fi semnificativă, recomandăm folosirea opțiunii <code>-n</code> a utilitarului <code>tcpdump</code>, opțiune care dezactivează rezolvarea <abbr title="Domain Name System">DNS</abbr>. În exemplele de mai sus, nu am folosit opțiunea <code>-n</code> a utilitarului <code>tcpdump</code> pentru a identifica mai ușor numele stațiilor implicate în conversație.

</div></p>
</p>

</div>
<!-- EDIT14 SECTION "02. [10p] Format de pachete la translatare" [1-] --><!-- EDIT13 PLUGIN_INCLUDE_END "rl:labs:09:contents:02" [0-] --></div>
<div class="level2">

</div>
<!-- EDIT15 PLUGIN_INCLUDE_START "rl:labs:09:contents:03" [0-] --><div class="plugin_include_content plugin_include__rl:labs:09:contents:03">

<h3 class="sectionedit17" id="p_format_de_pachete_tcp_la_translatare">03. [10p] Format de pachete TCP la translatare</h3>
<div class="level3">

<p>
Dorim să urmărim conținutul pachetelor TCP înainte și după translatarea de adrese. În plus față de exercițiul de mai sus, vrem să urmărim și porturile. Pentru aceasta vom genera pachete TCP (HTTP) folosind <code>wget</code> de pe stația <code>red</code> și vom captura pachetele folosind <code>tcpdump</code> pe stația <code>host</code>.
</p>

<p>
Pe stația <code>host</code> capturați pe toate interfețele pachetele HTTP care au ca adresă destinație numele <code>www.upb.ro</code>.
</p>

<p>
<p><div class="notetip">
Va trebui să folosiți argumentele <code>ip dst host www.upb.ro</code> și <code>tcp dst port 80</code> la <code>tcpdump</code>. Legați argumentele prin șirul <code>and</code>. Urmăriți și <a href="http://linux-circles.blogspot.ro/2012/11/how-to-capture-packets-with-tcpdump.html" class="urlextern" title="http://linux-circles.blogspot.ro/2012/11/how-to-capture-packets-with-tcpdump.html"  rel="nofollow">exemplele de aici</a>.
</p>

<p>
Folosiți opțiunea <code>-n</code> a <code>tcpdump</code> ca să afișați în format rezultatele în format numeric (adresă IP și port). Vă va fi mai ușor să urmăriți pachetele și translatarea de adrese.

</div></p>
</p>

<p>
Pe stația <code>red</code> folosiți <code>wget</code> pentru a obține pagina de la <code>www.upb.ro</code>.
</p>

<p>
Urmăriți translatarea adresei IP sursă și a portului sursă în cadrul capturii de pachete realizată cu <code>tcpdump</code> pe <code>host</code>.
</p>

<p>
<p><div class="noteimportant">
O să existe o latență (2-3 secunde) la afișarea pachetelor capturate cu <code>tcpdump</code> datorată rezolvării <abbr title="Domain Name System">DNS</abbr>. Puteți folosi opțiunea <code>-n</code> a <code>tcpdump</code> pentru a dezactivarea rezolvarea <abbr title="Domain Name System">DNS</abbr> și pentru a elimina latența.

</div></p>
</p>

<p>
Observați în cadrul capturii că portul sursă, ales de stația <code>red</code> este același cu cel folosit în urma translatării de stația <code>host</code>. În general implementările de NAT vor păstra portul în urma translatării. În cazul rar în care acel port este ocupat pe stația <code>host</code> (posibil datorită unei alte translatării) se va aloca un alt port.
</p>

<p>
Pe stația <code>host</code> capturați pe toate interfețele pachetele HTTP care au ca adresă numele <code>www.upb.ro</code>; nu contează dacă este sursă sau destinație, capturăm și pachetele de interogare și cele de rășpuns; la fel, portul poate fi sursă sau destinație; folosiți <code>ip host</code> în loc de <code>ip dst host</code> și <code>tcp port</code> în loc de <code>tcp dst port</code>. Pe stația <code>red</code> folosiți, din nou, <code>wget</code> pentru a obține pagina de la <code>www.upb.ro</code>. Urmăriți translatarea adresei IP sursă și a portului sursă pentru pachetele de interogare și translatarea adresei IP destinație și a portului destinație pentru pachetele de răspuns.
</p>

</div>
<!-- EDIT17 SECTION "03. [10p] Format de pachete TCP la translatare" [1-] --><!-- EDIT16 PLUGIN_INCLUDE_END "rl:labs:09:contents:03" [0-] --></div>
<div class="level2">

</div>
<!-- EDIT18 PLUGIN_INCLUDE_START "rl:labs:09:contents:04" [0-] --><div class="plugin_include_content plugin_include__rl:labs:09:contents:04">

<h3 class="sectionedit20" id="p_configurare_incorecta_a_translatarii">04. [10p] Configurare incorectă a translatării</h3>
<div class="level3">

<p>
Comanda folosită mai sus pentru translatare, la <a href="../../../../rl/labs/09/contents/01.html" class="wikilink1" title="rl:labs:09:contents:01">01. [10p] Configurare translatare de adrese (MASQUERADE)</a>, are neajunsuri pe care le vom identifica mai jos.
</p>

<p>
Pe stația <code>green</code> capturăm traficul pe interfața <code>eth0</code> folosind comanda <code>tcpdump</code>:
</p>
<pre class="code bash"><span class="co4">root@green:~# </span>tcpdump <span class="re5">-i</span> eth0
tcpdump: verbose output suppressed, use <span class="re5">-v</span> or <span class="re5">-vv</span> <span class="kw1">for</span> full protocol decode
listening on eth0, link-type EN10MB <span class="br0">&#40;</span>Ethernet<span class="br0">&#41;</span>, capture <span class="kw2">size</span> <span class="nu0">65535</span> bytes</pre>

<p>
Pe stația <code>red</code> executăm comanda <code>ping</code> către stația <code>green</code>:
</p>
<pre class="code bash"><span class="co4">root@red:~# </span><span class="kw2">ping</span> <span class="re5">-c</span> <span class="nu0">2</span> green
PING green <span class="br0">&#40;</span>192.168.2.2<span class="br0">&#41;</span> <span class="nu0">56</span><span class="br0">&#40;</span><span class="nu0">84</span><span class="br0">&#41;</span> bytes of data.
<span class="nu0">64</span> bytes from green <span class="br0">&#40;</span>192.168.2.2<span class="br0">&#41;</span>: <span class="re2">icmp_req</span>=<span class="nu0">1</span> <span class="re2">ttl</span>=<span class="nu0">63</span> <span class="re2">time</span>=<span class="nu0">0.155</span> ms
<span class="nu0">64</span> bytes from green <span class="br0">&#40;</span>192.168.2.2<span class="br0">&#41;</span>: <span class="re2">icmp_req</span>=<span class="nu0">2</span> <span class="re2">ttl</span>=<span class="nu0">63</span> <span class="re2">time</span>=<span class="nu0">0.086</span> ms
<span class="br0">&#91;</span>...<span class="br0">&#93;</span></pre>

<p>
În acest moment, pe stația <code>green</code> avem captura pachetelor în output-ul comenzii <code>tcpdump</code>:
</p>
<pre class="code">11:18:54.535064 IP host &gt; green: ICMP echo request, id 633, seq 17, length 64
11:18:54.535092 IP green &gt; host: ICMP echo reply, id 633, seq 17, length 64</pre>

<p>
Observăm că adresa sursă a pachetelor de tip <code>ICMP echo request</code> este stația <code>host</code>, nu stația <code>red</code>. Acest lucru se întâmplă din cauză că atunci când am activat NAT nu am specificat pentru ce tip de trafic să aplice politica de translatare. Astfel stația <code>host</code> aplică politica de NAT pentru tot traficul care o tranzitează. Dorim să aplicăm politica doar pentru pachetele ce <strong>ies</strong> în Internet, adică cele ale căror <strong>interfață de ieșire</strong> este interfața <code>eth0</code>. Vom șterge vechea regulă de NAT și vom adăuga o regulă corectă.
</p>

<p>
Pentru ștergerea vechii reguli de NAT rulăm pe stația <code>host</code> comanda
</p>
<pre class="code bash"><span class="co4">root@host:~# </span>iptables <span class="re5">-t</span> nat <span class="re5">-D</span> POSTROUTING <span class="re5">-j</span> MASQUERADE</pre>

<p>
Verificăm faptul că nu mai există comanda
</p>
<pre class="code bash"><span class="co4">root@host:~# </span>iptables <span class="re5">-t</span> nat <span class="re5">-L</span> POSTROUTING <span class="re5">-n</span> <span class="re5">-v</span>
Chain POSTROUTING <span class="br0">&#40;</span>policy ACCEPT <span class="nu0">1</span> packets, <span class="nu0">328</span> bytes<span class="br0">&#41;</span>
 pkts bytes target     prot opt <span class="kw1">in</span>     out     <span class="kw3">source</span>               destination</pre>

<p>
Adăugăm din nou regula de NAT, dar de data aceasta vom specifica să aplice politica de NAT pachetelor ce ies prin interfața <code>eth0</code> a stației <code>host</code>:
</p>
<pre class="code bash"><span class="co4">root@host:~# </span>iptables <span class="re5">-t</span> nat <span class="re5">-A</span> POSTROUTING <span class="re5">-o</span> eth0 <span class="re5">-j</span> MASQUERADE</pre>

<p>
Verificați că regula a fost inserată:
</p>
<pre class="code bash"><span class="co4">root@host:~# </span>iptables <span class="re5">-t</span> nat <span class="re5">-L</span> POSTROUTING <span class="re5">-n</span> <span class="re5">-v</span>
Chain POSTROUTING <span class="br0">&#40;</span>policy ACCEPT <span class="nu0">0</span> packets, <span class="nu0">0</span> bytes<span class="br0">&#41;</span>
 pkts bytes target     prot opt <span class="kw1">in</span>     out     <span class="kw3">source</span>               destination
    <span class="nu0">0</span>     <span class="nu0">0</span> MASQUERADE  all  <span class="re5">--</span>  <span class="sy0">*</span>      eth0    0.0.0.0<span class="sy0">/</span><span class="nu0">0</span>            0.0.0.0<span class="sy0">/</span><span class="nu0">0</span></pre>

<p>
Observăm prezența interfaței <code>eth0</code> în coloana <code>out</code>. Înainte apărea caracterul <code>*</code>, adică orice interfață.
</p>

<p>
Repetați testul de la începutul exercițiului și arătați că pachetele trimise de la <code>red</code> către <code>green</code> au adresele IP sursă/destinație nemodificate (nu mai fac trecerea prin NAT), în vreme ce pachetele ce ies în Internet sunt translatate.
</p>

</div>
<!-- EDIT20 SECTION "04. [10p] Configurare incorectă a translatării" [1-] --><!-- EDIT19 PLUGIN_INCLUDE_END "rl:labs:09:contents:04" [0-] --></div>
<div class="level2">

</div>
<!-- EDIT21 PLUGIN_INCLUDE_START "rl:labs:09:contents:05" [0-] --><div class="plugin_include_content plugin_include__rl:labs:09:contents:05">

<h3 class="sectionedit23" id="p_port_forwarding">05. [10p] Port forwarding</h3>
<div class="level3">

<p>
La exercițiile de până acum am folosit NAT pentru a permite stațiilor cu adrese private dintr-o rețea locală să acceseze Internetul. NAT poate fi folosit și pentru a permite unei stații din rețeaua locală să fie accesată din Internet, adică să se inițieze conexiuni din Internet. Acest proces poartă numele de <em>port forwarding</em>.
</p>

<p>
Dorim să putem accesa prin SSH, din Internet, stația <code>red</code>. Acest lucru nu este posibil în mod implicit întrucât stația <code>red</code> are adresă IP privată. Soluția este “deschiderea unui port” pe gateway (adică stația <code>host</code>) și redirectarea acestui port (<em>port forwarding</em>) către portul aferent serviciului SSH (portul TCP <code>22</code>) de pe stația <code>red</code>.
</p>

<p>
Vom aplica pe stația <code>host</code> o regulă prin care redirectăm traficul ce vine către <code>host</code> pe portul <code>10022</code> către portul <code>22</code> (SSH) al stației <code>red</code> (adresa IP <code>192.168.1.2</code>):
</p>
<pre class="code bash"><span class="co4">root@host:~# </span>iptables <span class="re5">-t</span> nat <span class="re5">-A</span> PREROUTING <span class="re5">-p</span> tcp <span class="re5">--dport</span> <span class="nu0">10022</span> <span class="re5">-j</span> DNAT <span class="re5">--to-destination</span> 192.168.1.2:<span class="nu0">22</span></pre>

<p>
Verificăm aplicarea regulii prin consultarea lanțului <code>PREROUTING</code> din tabela NAT:
</p>
<pre class="code bash"><span class="co4">root@host:~# </span>iptables <span class="re5">-t</span> nat <span class="re5">-L</span> PREROUTING <span class="re5">-n</span> <span class="re5">-v</span>
Chain PREROUTING <span class="br0">&#40;</span>policy ACCEPT <span class="nu0">1</span> packets, <span class="nu0">474</span> bytes<span class="br0">&#41;</span>
 pkts bytes target     prot opt <span class="kw1">in</span>     out     <span class="kw3">source</span>               destination         
    <span class="nu0">0</span>     <span class="nu0">0</span> DNAT       tcp  <span class="re5">--</span>  <span class="sy0">*</span>      <span class="sy0">*</span>       0.0.0.0<span class="sy0">/</span><span class="nu0">0</span>            0.0.0.0<span class="sy0">/</span><span class="nu0">0</span>            tcp dpt:<span class="nu0">10022</span> to:192.168.1.2:<span class="nu0">22</span></pre>

<p>
Pentru a verifica rezultatul de mai sus, de pe <code>fep.grid.pub.ro</code> deschidem un nou terminal și ne conectăm prin SSH folosind portul <code>10022</code> la stația <code>host</code>:
</p>
<pre class="code bash">mihai.carabas<span class="sy0">@</span>fep:~$ <span class="kw2">ssh</span> <span class="re5">-l</span> root <span class="re1">$ADRESA_IP_MV</span> <span class="re5">-p</span> <span class="nu0">10022</span> 
root<span class="sy0">@</span>192.168.138.129<span class="st_h">'s password:
[...]
root@red:~#</span></pre>

<p>
 unde <code>$ADRESA_IP_MV</code> este adresa IP a masinii virtuale obținută din dashboard-ul OpenStack.
</p>
<div class="hiddenGlobal  hiddenActive"><div class="hiddenElements"></div><div class="hiddenHead  hiddenSinceBeginning"><div class="hiddenOnHidden">
<p>
Pentru rulare masina virtuala VMware local
</p>
</div><div class="hiddenOnVisible">
<p>
Pentru rulare masina virtuala VMware local
</p>
</div></div> <!-- .hiddenHead --><div class="hiddenBody">
<p>
Daca rulați VMware local, <code>$ADRESA_IP_MV</code> este adresa interfeței <code>eth0</code> a stației <code>host</code>.
</p>
</div></div>
<p>
Observăm că în urma autentificării ne găsim pe stația <code>red</code>. <em>Port forwarding</em> a funcționat.
</p>

<p>
Folosim comanda de conectare SSH la stația <code>host</code> de pe stația <code>green</code>:
</p>
<pre class="code bash"><span class="co4">root@green:~# </span><span class="kw2">ssh</span> <span class="re5">-l</span> root host <span class="re5">-p</span> <span class="nu0">10022</span>
<span class="br0">&#91;</span>...<span class="br0">&#93;</span>
<span class="co4">root@red:~# </span></pre>

<p>
Observăm că și de pe stația <code>green</code> am accesat stația <code>red</code> prin <em>port forwarding</em>. Dorim să limităm <em>port forwarding</em> doar pentru conexiuni de la stațiile din Internet. Pentru aceasta trebuie să actualizăm regula de <em>port forwarding</em>.
</p>

<p>
Ștergeți regula de <em>port forwarding</em> și adăugați o regulă nouă care să permită <strong>doar</strong> stațiilor din Internet să acceseze prin <em>port forwarding</em> stația <code>red</code>.
</p>

<p>
<p><div class="notetip">
Aplicați regula doar pentru pachetele ce <strong>sosesc</strong> pe interfața <code>eth0</code>. Adică <code>eth0</code> este interfața de <strong>intrare</strong>. Folosiți opțiunea <code>-i</code> a <code>iptables</code> pentru precizarea interfeței de <strong>intrare</strong>.

</div></p>
</p>

<p>
Realizați apoi din nou conectare SSH pe portul <code>10022</code> al stației <code>host</code> de pe <code>fep.grid.pub.ro</code> și de pe stația <code>green</code>. Dacă ați configurat corect, nu va merge conexiunea SSH de pe stația <code>green</code> dar va merge în continuare de pe <code>fep.grid.pub.ro</code>.
</p>

</div>
<!-- EDIT23 SECTION "05. [10p] Port forwarding" [1-] --><!-- EDIT22 PLUGIN_INCLUDE_END "rl:labs:09:contents:05" [0-] --></div>
<div class="level2">

</div>
<!-- EDIT24 PLUGIN_INCLUDE_START "rl:labs:09:contents:06" [0-] --><div class="plugin_include_content plugin_include__rl:labs:09:contents:06">

<h3 class="sectionedit26" id="p_extindere_port_forwarding">06. [10p] Extindere port forwarding</h3>
<div class="level3">

<p>
Dorim să accesăm din Internet/exterior stațiile <code>green</code> și <code>blue</code> prin SSH folosindu-ne de stația <code>host</code>. Vom folosi:
</p>
<ul>
<li class="level1"><div class="li"> portul <code>20022</code> de pe stația <code>host</code> pentru a face <em>port forwarding</em>  pe portul 22 al stației <code>green</code>;</div>
</li>
<li class="level1"><div class="li"> portul <code>30022</code> de pe stația <code>host</code> pentru a face <em>port forwarding</em>  pe portul 22 al stației <code>blue</code>.</div>
</li>
</ul>

<p>
Pe modelul <a href="../../../../rl/labs/09/contents/05.html" class="wikilink1" title="rl:labs:09:contents:05">exercițiului anterior</a>, realizați configurarea necesară pentru această extindere de port forwarding. Verificați prin conectare de pe <code>fep.grid.pub.ro</code> (echivalentul Internet-ului/exteriorului) pe porturile respectiv <code>20022</code> și <code>30022</code> de pe stația <code>host</code>.
</p>

<p>
<p><div class="notetip">
Pentru a afla adresele IP ale stațiilor <code>green</code> și <code>blue</code> rulați comanda de afișare a configurării interfeței <code>eth0</code> pe fiecare stație. Verificați, pentru siguranța, faptul că există conectivitate între ele și stația <code>host</code>.

</div></p>
</p>

</div>
<!-- EDIT26 SECTION "06. [10p] Extindere port forwarding" [1-] --><!-- EDIT25 PLUGIN_INCLUDE_END "rl:labs:09:contents:06" [0-] --></div>
<div class="level2">

</div>
<!-- EDIT27 PLUGIN_INCLUDE_START "rl:labs:09:contents:07" [0-] --><div class="plugin_include_content plugin_include__rl:labs:09:contents:07">

<h3 class="sectionedit29" id="p_format_de_pachete_la_port_forwarding">07. [10p] Format de pachete la port forwarding</h3>
<div class="level3">

<p>
La exercițiul <a href="../../../../rl/labs/09/contents/03.html" class="wikilink1" title="rl:labs:09:contents:03">03. [10p] Format de pachete TCP la translatare</a> am observat cum se modifică adresa IP sursă și portul sursă în cazul translatării de adrese. La port forwarding vom observa cum se modifică adresa IP destinație (de aici și numele DNAT: <code>Destination NAT</code>).
</p>

<p>
Vom captura traficul SSH inițiat din exterior către stația <code>red</code>, prin intermediul portului <code>10022</code> al stației <code>host</code>. Este vorba de traficul înainte de <em>port forwarding</em>. Pentru aceasta, pe stația <code>host</code> vom folosi comanda
</p>
<pre class="code bash"><span class="co4">root@host:~# </span>tcpdump <span class="re5">-n</span> <span class="re5">-i</span> eth0 tcp dst port <span class="nu0">10022</span></pre>

<p>
Pe un alt terminal, tot pe stația <code>host</code> capturăm traficul <strong>după</strong> <em>port forwarding</em>, pe interfața <code>veth-red</code> către portul SSH (<code>22</code>) al stației red. Pe stația <code>host</code> folosim comanda
</p>
<pre class="code bash"><span class="co4">root@host:~# </span>tcpdump <span class="re5">-n</span> <span class="re5">-i</span> veth-red tcp dst port <span class="nu0">22</span></pre>

<p>
Pentru a genera trafic, de pe <code>fep.grid.pub.ro</code> realizăm o conexiune SSH la stația <code>host</code> pe portul <code>10022</code>, conexiune ce va fi redirectată la portul <code>22</code> al stației <code>red</code>:
</p>
<pre class="code bash">mihai.carabas<span class="sy0">@</span>fep:~$ <span class="kw2">ssh</span> <span class="re5">-l</span> root <span class="re1">$ADRESA_IP_VM</span> <span class="re5">-p</span> <span class="nu0">10022</span>
root<span class="sy0">@</span>host.local<span class="st_h">'s password: 
[...]
root@red:~# </span></pre>

<p>
În capturile realizate de comenzile de mai sus, observăm cu se translatează adresa IP și portul destinație din perechea <code>&lt;$ADRESA_IP_VM, 10022&gt;</code> în perechea <code>&lt;192.168.1.2, 22&gt;</code>.
</p>

</div>
<!-- EDIT29 SECTION "07. [10p] Format de pachete la port forwarding" [1-] --><!-- EDIT28 PLUGIN_INCLUDE_END "rl:labs:09:contents:07" [0-] --></div>
<div class="level2">

</div>
<!-- EDIT30 PLUGIN_INCLUDE_START "rl:labs:09:contents:08" [0-] --><div class="plugin_include_content plugin_include__rl:labs:09:contents:08">

<h3 class="sectionedit32" id="p_port_forwarding_pentru_telnet">08. [10p] Port forwarding pentru telnet</h3>
<div class="level3">

<p>
În cadrul exercițiilor anterioare am activat <em>port forwarding</em> pentru serviciul SSH. Dorim ca stațiile <code>red</code>, <code>green</code> și <code>blue</code> să fie accesibile și prin <code>telnet</code> din Internet astfel:
</p>
<ul>
<li class="level1"><div class="li"> <code>red</code> să poată fi accesat folosind portul 10023</div>
</li>
<li class="level1"><div class="li"> <code>green</code> să poată fi accesat folosind portul 20023</div>
</li>
<li class="level1"><div class="li"> <code>blue</code> să poată fi accesat folosind portul 30023</div>
</li>
</ul>

<p>
Realizați configurațiile necesare pentru a permite <em>port forwarding</em> pentru <code>telnet</code> așa cum este descris mai sus.
</p>

<p>
<p><div class="noteclassic">
Serviciul <code>telnet</code> ascultă în mod implicit conexiuni pe portul <code>23</code>. Puteți observa acest lucru cu ajutorul uneia dintre comenzile de mai jos:
</p>
<pre class="code">user@host:~$ grep -w &#039;telnet&#039; /etc/services
telnet		23/tcp
tfido		60177/tcp			# fidonet EMSI over telnet

user@host:~$ getent services telnet
telnet                23/tcp</pre>

<p>

</div></p>
</p>

<p>
<p><div class="noteclassic">
Exercițiul este academic. Nu este indicată folosirea <code>telnet</code> cu atât mai puțin <em>port forwarding</em> peste <code>telnet</code> din rațiuni de securitate.

</div></p>
</p>

<p>
Testați de pe <code>fep.grid.pub.ro</code> folosind comanda <code>telnet</code>:
</p>
<pre class="code bash"><span class="co4">mihai.carabas@fep:~# </span>telnet <span class="sy0">&lt;</span>adresa-ip-vm<span class="sy0">&gt;</span> <span class="sy0">&lt;</span>port-redirectat<span class="sy0">&gt;</span></pre>

<p>
unde <code>&lt;adresa-ip-vm&gt;</code> este adresa IP a mașinii virtuale vizibilă de pe fep iar <code>&lt;port-redirectat&gt;</code> este portul care face redirectarea pe stația <code>host</code> (<code>10023</code> sau <code>20023</code> sau <code>30023</code>).
</p>

<p>
<p><div class="noteimportant">
Există o latență de circa 10-15 secunde din momentul conectării până la apariția promptului <code>telnet</code>. Așteptați să apară promptul și apoi autentificați-vă cu username <code>student</code> și parolă <code>student</code> pentru a valida conectivitatea.

</div></p>
</p>

</div>
<!-- EDIT32 SECTION "08. [10p] Port forwarding pentru telnet" [1-] --><!-- EDIT31 PLUGIN_INCLUDE_END "rl:labs:09:contents:08" [0-] --></div>
<div class="level2">

</div>
<!-- EDIT33 PLUGIN_INCLUDE_START "rl:labs:09:contents:09" [0-] --><div class="plugin_include_content plugin_include__rl:labs:09:contents:09">

<h3 class="sectionedit35" id="p_configurare_persistenta_rutare_si_nat">09. [10p] Configurare persistentă rutare și NAT</h3>
<div class="level3">

<p>
Configurările realizate până în acest moment sunt temporare. La repornirea stației <code>host</code> regulile de NAT se pierd. Dorim să configurăm în mod persistent rutarea și regulile NAT.
</p>

<p>
Pentru a configura în mod persistent rutarea pe stația <code>host</code>, edităm fișierul <code>/etc/sysctl.conf</code> și decomentăm linia
</p>
<pre class="code">net.ipv4.ip_forward=1</pre>

<p>
 Astfel la fiecarea pornire a sistemului, rutarea va fi activată.
</p>

<p>
<p><div class="noteimportant">
Rutarea nu se va activa în mod automat după ce decomentați linia din fișier. Trebuie să resetați sistemul sau să rulați comanda
</p>
<pre class="code bash">sysctl <span class="re5">-p</span></pre>

<p>
 pentru a aplica modificările din fișierul de configurare <code>/etc/sysctl.conf</code>.

</div></p>
</p>

<p>
Pentru a salva toate regulile <code>iptables</code> introduse în sistem se poate folosi comanda <code>iptables-save</code>. În mod implicit aceste reguli sunt afișate pe consolă. Noi le vom salva în <code>/etc/iptables-rules</code> folosind comanda:
</p>
<pre class="code bash"><span class="co4">root@host:~# </span>iptables-save <span class="sy0">&gt;</span> <span class="sy0">/</span>etc<span class="sy0">/</span>iptables-rules</pre>

<p>
Regulile pot fi restaurate folosind comanda <code>iptables-restore &lt; /etc/iptables-rules</code>. Așadar trebuie să configurăm sistemul să execute această comanda la pornire. Modul cel mai uzual pentru a face acest lucru este adăugarea acestei comenzi în fișierul de configurare al interfeței:
</p>
<pre class="code bash"><span class="co4">root@host:~# </span><span class="kw2">cat</span> <span class="sy0">/</span>etc<span class="sy0">/</span>network<span class="sy0">/</span>interfaces
<span class="br0">&#91;</span>...<span class="br0">&#93;</span>
<span class="co0"># The primary network interface</span>
auto eth0
iface eth0 inet dhcp
        up iptables-restore <span class="sy0">&lt;</span> <span class="sy0">/</span>etc<span class="sy0">/</span>iptables-rules</pre>

<p>
După ce ați făcut toate configurările, reporniți stația <code>host</code>:
</p>
<pre class="code bash"><span class="co4">root@host:~# </span>reboot</pre>

<p>
În urma repornirii stației <code>host</code> vom vedea aplicată rutarea și regulile de NAT:
</p>
<pre class="code bash"><span class="co4">root@host:~# </span>sysctl net.ipv4.ip_forward
net.ipv4.ip_forward = <span class="nu0">1</span>
<span class="co4">root@host:~# </span>iptables <span class="re5">-t</span> nat <span class="re5">-L</span> <span class="re5">-n</span> <span class="re5">-v</span>
Chain PREROUTING <span class="br0">&#40;</span>policy ACCEPT <span class="nu0">30</span> packets, <span class="nu0">5694</span> bytes<span class="br0">&#41;</span>
 pkts bytes target     prot opt <span class="kw1">in</span>     out     <span class="kw3">source</span>               destination         
    <span class="nu0">0</span>     <span class="nu0">0</span> DNAT       tcp  <span class="re5">--</span>  eth0   <span class="sy0">*</span>       0.0.0.0<span class="sy0">/</span><span class="nu0">0</span>            0.0.0.0<span class="sy0">/</span><span class="nu0">0</span>            tcp dpt:<span class="nu0">10022</span> to:192.168.1.2:<span class="nu0">22</span>
    <span class="nu0">0</span>     <span class="nu0">0</span> DNAT       tcp  <span class="re5">--</span>  eth0   <span class="sy0">*</span>       0.0.0.0<span class="sy0">/</span><span class="nu0">0</span>            0.0.0.0<span class="sy0">/</span><span class="nu0">0</span>            tcp dpt:<span class="nu0">20022</span> to:192.168.2.2:<span class="nu0">22</span>
    <span class="nu0">0</span>     <span class="nu0">0</span> DNAT       tcp  <span class="re5">--</span>  eth0   <span class="sy0">*</span>       0.0.0.0<span class="sy0">/</span><span class="nu0">0</span>            0.0.0.0<span class="sy0">/</span><span class="nu0">0</span>            tcp dpt:<span class="nu0">30022</span> to:192.168.3.2:<span class="nu0">22</span>
    <span class="nu0">0</span>     <span class="nu0">0</span> DNAT       tcp  <span class="re5">--</span>  eth0   <span class="sy0">*</span>       0.0.0.0<span class="sy0">/</span><span class="nu0">0</span>            0.0.0.0<span class="sy0">/</span><span class="nu0">0</span>            tcp dpt:<span class="nu0">10023</span> to:192.168.1.2:<span class="nu0">23</span>
    <span class="nu0">0</span>     <span class="nu0">0</span> DNAT       tcp  <span class="re5">--</span>  eth0   <span class="sy0">*</span>       0.0.0.0<span class="sy0">/</span><span class="nu0">0</span>            0.0.0.0<span class="sy0">/</span><span class="nu0">0</span>            tcp dpt:<span class="nu0">20023</span> to:192.168.2.2:<span class="nu0">23</span>
    <span class="nu0">0</span>     <span class="nu0">0</span> DNAT       tcp  <span class="re5">--</span>  eth0   <span class="sy0">*</span>       0.0.0.0<span class="sy0">/</span><span class="nu0">0</span>            0.0.0.0<span class="sy0">/</span><span class="nu0">0</span>            tcp dpt:<span class="nu0">30023</span> to:192.168.3.2:<span class="nu0">23</span>
&nbsp;
Chain INPUT <span class="br0">&#40;</span>policy ACCEPT <span class="nu0">2</span> packets, <span class="nu0">534</span> bytes<span class="br0">&#41;</span>
 pkts bytes target     prot opt <span class="kw1">in</span>     out     <span class="kw3">source</span>               destination         
&nbsp;
Chain OUTPUT <span class="br0">&#40;</span>policy ACCEPT <span class="nu0">16</span> packets, <span class="nu0">958</span> bytes<span class="br0">&#41;</span>
 pkts bytes target     prot opt <span class="kw1">in</span>     out     <span class="kw3">source</span>               destination         
&nbsp;
Chain POSTROUTING <span class="br0">&#40;</span>policy ACCEPT <span class="nu0">15</span> packets, <span class="nu0">918</span> bytes<span class="br0">&#41;</span>
 pkts bytes target     prot opt <span class="kw1">in</span>     out     <span class="kw3">source</span>               destination         
    <span class="nu0">1</span>    <span class="nu0">40</span> MASQUERADE  all  <span class="re5">--</span>  <span class="sy0">*</span>      eth0    0.0.0.0<span class="sy0">/</span><span class="nu0">0</span>            0.0.0.0<span class="sy0">/</span><span class="nu0">0</span></pre>

</div>
<!-- EDIT35 SECTION "09. [10p] Configurare persistentă rutare și NAT" [1-] --><!-- EDIT34 PLUGIN_INCLUDE_END "rl:labs:09:contents:09" [0-] --></div>
<div class="level2">

</div>
<!-- EDIT36 PLUGIN_INCLUDE_START "rl:labs:09:contents:10" [0-] --><div class="plugin_include_content plugin_include__rl:labs:09:contents:10">

<h3 class="sectionedit38" id="p_tunel_ssh_invers">10. [10p] Tunel SSH invers</h3>
<div class="level3">

<p>
Sunt situații în care dorim ca o stație să fie accesibilă din exterior, dar este dificil să obținem un port în gateway (pentru <em>port forwarding</em>): fie din rațiuni administrative, fie din motive de securitate. Pentru a permite totuși o conexiune din exterior, se poate crea un tunel SSH invers. Tunel SSH invers înseamnă următorii pași:
</p>
<ul>
<li class="level1"><div class="li"> se creează o conexiune SSH de la o stație cu adresă IP privată la un server extern cu adresă IP publică,</div>
</li>
<li class="level1"><div class="li"> se deschide un port pe serverul cu adresă IP publică</div>
</li>
<li class="level1"><div class="li"> traficul către acel port este tunelat prin conexiunea SSH către stația cu adresă IP privată</div>
</li>
</ul>

<p>
Dorim să permitem conectarea la stația <code>red</code> din Internet pe SSH. Vom crea o conexiune SSH “directă” de la stația <code>red</code> la contul vostru de pe <code>fep.grid.pub.ro</code>. Prin această conexiune veți tunela invers traficul SSH către <code>red</code> permițând conexiunea din exterior.
</p>

<p>
Pentru început, de pe stația <code>red</code> creăm o conexiune SSH directă către contul de pe <code>fep.grid.pub.ro</code> (identic cu cel de pe <code>cs.curs.pub.ro</code>):
</p>
<pre class="code bash"><span class="co4">root@red:~# </span><span class="kw2">ssh</span> <span class="re5">-l</span> <span class="re1">$USERNAME</span> fep.grid.pub.ro <span class="re5">-R</span> 100XY:localhost:<span class="nu0">22</span>   
<span class="br0">&#91;</span>...<span class="br0">&#93;</span>
<span class="re1">$USERNAME</span><span class="sy0">@</span>fep.grid.pub.ro<span class="st_h">'s password: 
Last login: Mon Sep  9 09:55:37 2013 from 141.85.225.214
[$USERNAME@fep-62-2 ~]$ netstat -tln | grep 100XY
tcp        0      0 127.0.0.1:100XY             0.0.0.0:*                   LISTEN      
tcp        0      0 ::1:100XY                   :::*                        LISTEN</span></pre>

<p>
 unde <code>$USERNAME</code> este numele contului de pe <code>fep.grid.pub.ro</code>/<code>cs.curs.pub.ro</code>, iar <code>XY</code> este un identificator numeric unic al stației din laborator (dacă nu aveți pe monitorul stației din laborator un identificator discutați cu asistentul). Introduceți parola corespunzătoare contului vostru de pe <code>fep.grid.pub.ro</code>/<code>cs.curs.pub.ro</code>.
</p>

<p>
Observăm că se deschide portul <code>100XY</code> pe <code>fep.grid.pub.ro</code>. Acest port va fi folosit pentru tunelul invers care ne va duce pe stația <code>red</code>.
</p>

<p>
Argumentul <code>-R 100XY:localhost:22</code> transmis comenzii <code>ssh</code> are următoarea semnificație:
</p>
<ul>
<li class="level1"><div class="li"> <code>100XY</code> - portul de pe server pe care se vor asculta conexiuni care vor fi tunelate invers;</div>
</li>
<li class="level1"><div class="li"> <code>localhost</code> - stația către care vor fi trimise pachetele primite prin tunel (chiar stația locală);</div>
</li>
<li class="level1"><div class="li"> <code>22</code> - portul către care vor fi trimise pachetele primite prin tunel (adică portul SSH local).</div>
</li>
</ul>

<p>
După ce alți colegi rulează comenzile similare vă veți putea conecta pe stația <code>red</code> a acestora folosind portul deschis de ei; discutați cu alți colegi ca să vă spună ce port au deschis. Pentru aceasta, veți folosi stația fizică și vă veți conecta conecta pe contul de pe <code>fep.grid.pub.ro</code>.
</p>

<p>
<p><div class="noteimportant">
Pe <code>fep.grid.pub.ro</code> rulează un load balancer pentru SSH. Din acest motiv este posibil să intrați pe “celălalt” sistem. Verificați că numele de host din prompt corespunde cu cel pe care l-ați folosit inițial la crearea tunelului: adică ambele să fie <code>fep-62-2</code> sau <code>fep-62-1</code>. Pentru siguranță folosim și comanda <code>netstat</code>:
</p>
<pre class="code bash"><span class="br0">&#91;</span><span class="re1">$USERNAME_COLEG</span><span class="sy0">@</span>fep-<span class="nu0">62</span>-<span class="nu0">2</span> ~<span class="br0">&#93;</span>$ <span class="kw2">netstat</span> <span class="re5">-tln</span> <span class="sy0">|</span> <span class="kw2">grep</span> 100ZT
tcp        <span class="nu0">0</span>      <span class="nu0">0</span> 127.0.0.1:100ZT             0.0.0.0:<span class="sy0">*</span>                   LISTEN
tcp        <span class="nu0">0</span>      <span class="nu0">0</span> ::<span class="nu0">1</span>:100ZT                   :::<span class="sy0">*</span>                        LISTEN</pre>

<p>
În output-ul comenzii de mai sus <code>100ZT</code> este portul deschis de coleg.

</div></p>
</p>

<p>
După conectarea colegului la <code>fep</code>, realizăm o conexiune prin tunelul SSH pe portul <code>100ZT</code> deschis de coleg:
</p>
<pre class="code bash"><span class="br0">&#91;</span><span class="re1">$USERNAME_COLEG</span><span class="sy0">@</span>fep-<span class="nu0">62</span>-<span class="nu0">2</span> ~<span class="br0">&#93;</span>$ <span class="kw2">ssh</span> <span class="re5">-l</span> root localhost <span class="re5">-p</span> 100ZT
Warning: Permanently added <span class="st_h">'[localhost]:100ZT'</span> <span class="br0">&#40;</span>RSA<span class="br0">&#41;</span> to the list of known hosts.
root<span class="sy0">@</span>localhost<span class="st_h">'s password: 
[...]
root@red:~#</span></pre>

<p>
În cadrul conexiunii ni se cere parola utilizatorului <code>root</code> de pe stația <code>red</code> (adică parola <code>student</code>).
</p>

<p>
În final ați accesat stația <code>red</code> a colegului, o stația cu adresă IP privată inaccesibilă din exterior. Pentru aceasta ați folosit o altă stație (care ar putea fi din altă rețea) pentru a se conecta la <code>fep.grid.pub.ro</code> și de acolo la <code>red</code> prin intermediul tunelului invers creat inițial.
</p>

<p>
Creați un fișier pe stația <code>red</code> proaspăt accesată, iar colegul poate verifica faptul că, într-adevăr, ați accesat container-ul său prin tunelul SSH invers pe care l-a creat anterior.
</p>

</div>
<!-- EDIT38 SECTION "10. [10p] Tunel SSH invers" [1-] --><!-- EDIT37 PLUGIN_INCLUDE_END "rl:labs:09:contents:10" [0-] --></div>
<div class="level2">

</div>
<!-- EDIT39 PLUGIN_INCLUDE_START "rl:labs:09:contents:11" [0-] --><div class="plugin_include_content plugin_include__rl:labs:09:contents:11">

<h3 class="sectionedit41" id="bonus_-_10p_translatare_selectiva_de_adrese">11. [BONUS - 10p] Translatare selectivă de adrese</h3>
<div class="level3">

<p>
Pentru situația în care adresa IP exterioară a gateway-ului este adresă statică (nu dinamică) se recomandă folosirea acțiunii <code>SNAT</code> în loc de <code>MASQUERADE</code> la translatarea de adrese. Pe lângă aceasta, SNAT are avantajul precizării unui spațiu de adrese care să fie noile adrese (cele substituite) și a porturilor.
</p>

<p>
<p><div class="notetip">
Informații despre folosirea <code>SNAT</code> și diferența dintre <code>SNAT</code> și <code>MASQUERADE</code> găsiți <a href="http://www.netfilter.org/documentation/HOWTO/NAT-HOWTO-6.html" class="urlextern" title="http://www.netfilter.org/documentation/HOWTO/NAT-HOWTO-6.html"  rel="nofollow">aici</a>.

</div></p>
</p>

<p>
Ștergeți regula anterioară de tip <code>MASQUERADE</code> și folosiți reguli de tip <code>SNAT</code> pentru a face următoarele translatări:
</p>
<ul>
<li class="level1"><div class="li"> conexiunile TCP către Internet de la stația <code>red</code> să iasă prin porturi din spațiul <code>45000-50000</code>;</div>
</li>
<li class="level1"><div class="li"> conexiunile TCP către Internet de la stația <code>green</code> să iasă prin porturi din spațiul <code>50000-55000</code>;</div>
</li>
<li class="level1"><div class="li"> conexiunile TCP către Internet de la stația <code>blue</code> să iasă prin porturi din spațiul <code>55000-60000</code>;</div>
</li>
<li class="level1"><div class="li"> toate celelalte conexiuni să fie realizate în mod obișnuit, având ca adresă sursă adresa IP de exterior a stației <code>host</code> (această regulă trebuie să fie ultima).</div>
</li>
</ul>

<p>
Verificați translatarea corectă inițiind conexiuni HTTP (folosind <code>wget</code>) către <a href="http://www.upb.ro" class="urlextern" title="http://www.upb.ro"  rel="nofollow">http://www.upb.ro</a> de pe fiecare dintre cele trei stații de tip container (<code>red</code>, <code>green</code> și <code>blue</code>) și folosind <code>tcpdump</code> pe stația <code>host</code> pentru a captura traficul aferent.
</p>

</div>
<!-- EDIT41 SECTION "11. [BONUS - 10p] Translatare selectivă de adrese" [1-] --><!-- EDIT40 PLUGIN_INCLUDE_END "rl:labs:09:contents:11" [0-] --></div>
<div class="level2">

</div>
<!-- EDIT42 PLUGIN_INCLUDE_START "rl:labs:09:contents:sidebar" [0-] --><div class="plugin_include_content plugin_include__rl:labs:09:contents:sidebar">

<h3 class="sectionedit44" id="navigare1">Navigare</h3>
<div class="level3">

<p>
<strong><span class="curid"><a href="../../../../rl/labs/09.html" class="wikilink1" title="rl:labs:09">Laboratorul 9</a></span></strong>
</p>

</div>
<!-- EDIT45 PLUGIN_INCLUDE_START "rl:labs:09:meta:nav" [0-] --><div class="plugin_include_content plugin_include__rl:labs:09:meta:nav">
<div class="level4">

<div><div id="nojs_indexmenu_887006021583560a247593" data-jsajax="%26skipfile%3D%252B/sidebar/" class="indexmenu_nojs">

<ul class="idx">
<li class="level1"><div class="li"><a href="../../../../rl/labs/09/contents/01.html" class="wikilink1" title="rl:labs:09:contents:01">01. [10p] Configurare translatare de adrese (MASQUERADE)</a></div></li>
<li class="level1"><div class="li"><a href="../../../../rl/labs/09/contents/02.html" class="wikilink1" title="rl:labs:09:contents:02">02. [10p] Format de pachete la translatare</a></div></li>
<li class="level1"><div class="li"><a href="../../../../rl/labs/09/contents/03.html" class="wikilink1" title="rl:labs:09:contents:03">03. [10p] Format de pachete TCP la translatare</a></div></li>
<li class="level1"><div class="li"><a href="../../../../rl/labs/09/contents/04.html" class="wikilink1" title="rl:labs:09:contents:04">04. [10p] Configurare incorectă a translatării</a></div></li>
<li class="level1"><div class="li"><a href="../../../../rl/labs/09/contents/05.html" class="wikilink1" title="rl:labs:09:contents:05">05. [10p] Port forwarding</a></div></li>
<li class="level1"><div class="li"><a href="../../../../rl/labs/09/contents/06.html" class="wikilink1" title="rl:labs:09:contents:06">06. [10p] Extindere port forwarding</a></div></li>
<li class="level1"><div class="li"><a href="../../../../rl/labs/09/contents/07.html" class="wikilink1" title="rl:labs:09:contents:07">07. [10p] Format de pachete la port forwarding</a></div></li>
<li class="level1"><div class="li"><a href="../../../../rl/labs/09/contents/08.html" class="wikilink1" title="rl:labs:09:contents:08">08. [10p] Port forwarding pentru telnet</a></div></li>
<li class="level1"><div class="li"><a href="../../../../rl/labs/09/contents/09.html" class="wikilink1" title="rl:labs:09:contents:09">09. [10p] Configurare persistentă rutare și NAT</a></div></li>
<li class="level1"><div class="li"><a href="../../../../rl/labs/09/contents/10.html" class="wikilink1" title="rl:labs:09:contents:10">10. [10p] Tunel SSH invers</a></div></li>
<li class="level1"><div class="li"><a href="../../../../rl/labs/09/contents/11.html" class="wikilink1" title="rl:labs:09:contents:11">11. [BONUS - 10p] Translatare selectivă de adrese</a></div></li>
</ul>
</div></div>

</div>
<!-- EDIT46 PLUGIN_INCLUDE_END "rl:labs:09:meta:nav" [0-] --></div>
<div class="level4">

</div>
<!-- EDIT44 SECTION "Navigare" [1-] --><!-- EDIT43 PLUGIN_INCLUDE_END "rl:labs:09:contents:sidebar" [0-] --></div>
<div class="level2">

</div>
<!-- EDIT8 SECTION "Exerciții" [2896-] --></div>
</body>
</html>
