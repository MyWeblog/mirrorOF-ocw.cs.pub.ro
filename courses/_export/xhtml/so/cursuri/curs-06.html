    
    

<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
  <meta charset="utf-8" />
  <title>so:cursuri:curs-06</title>
<meta name="generator" content="DokuWiki"/>
<meta name="robots" content="index,follow"/>
<meta name="date" content="2015-04-01T14:28:15+0300"/>
<meta name="keywords" content="so,cursuri,curs-06"/>
<link rel="search" type="application/opensearchdescription+xml" href="../../../../lib/exe/opensearch.php" title="CS Open CourseWare"/>
<link rel="start" href="../../../../../courses.1.html"/>
<link rel="alternate" type="application/rss+xml" title="Recent Changes" href="../../../../feed.php"/>
<link rel="alternate" type="application/rss+xml" title="Current Namespace" href="../../../../feed.php%3Fmode=list&amp;ns=so:cursuri"/>
<link rel="alternate" type="text/html" title="Plain HTML" href="curs-06.html"/>
<link rel="canonical" href="../../../../so/cursuri/curs-06.html"/>
<link rel="stylesheet" type="text/css" href="../../../../lib/exe/css.php%3Ft=arctic&amp;tseed=1476798676.css"/>
<script type="text/javascript">/*<![CDATA[*/var NS='so:cursuri';var JSINFO = {"id":"so:cursuri:curs-06","namespace":"so:cursuri","isadmin":0,"isauth":0};
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="../../../../lib/exe/js.php%3Ftseed=1476798676"></script>
<script type="text/x-mathjax-config">/*<![CDATA[*/MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ["$","$"], ["\\(","\\)"] ],
        displayMath: [ ["$$","$$"], ["\\[","\\]"] ],
        processEscapes: true
    }
});
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
<script type="text/javascript">/*<![CDATA[*/
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
		  
/*!]]>*/</script>
<script type="text/javascript">/*<![CDATA[*/
var pageTracker = _gat._getTracker("UA-38383934-1");
pageTracker._initData();
pageTracker._trackPageview();
		  
/*!]]>*/</script>
</head>
<body>
<div class="dokuwiki export">
<!-- TOC START -->
<div id="dw__toc">
<h3 class="toggle">Table of Contents</h3>
<div>

<ul class="toc">
<li class="level1"><div class="li"><a href="curs-06.html#curs_06_-_memoria_virtuala">Curs 06 - Memoria virtuală</a></div>
<ul class="toc">
<li class="level2"><div class="li"><a href="curs-06.html#demo-uri">Demo-uri</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="curs-06.html#alocarea_variabilelor_intr-un_executabil">Alocarea variabilelor într-un executabil</a></div></li>
<li class="level3"><div class="li"><a href="curs-06.html#investigarea_maparii_folosind_pmap">Investigarea mapării folosind pmap</a></div></li>
<li class="level3"><div class="li"><a href="curs-06.html#alocarea_de_memorie_virtuala">Alocarea de memorie virtuală</a></div></li>
<li class="level3"><div class="li"><a href="curs-06.html#paginare_la_cerere_demand_paging">Paginare la cerere (demand paging)</a></div></li>
<li class="level3"><div class="li"><a href="curs-06.html#page_fault-uri_la_fork_copy-on-write">Page fault-uri la fork (copy-on-write)</a></div></li>
</ul></li>
</ul></li>
</ul>
</div>
</div>
<!-- TOC END -->

<h1 class="sectionedit1" id="curs_06_-_memoria_virtuala">Curs 06 - Memoria virtuală</h1>
<div class="level1">

<p>

<iframe src="http://prezi.com/embed/qshrq7oeytj2/?bgcolor=ffffff&amp;lock_to_path=0&amp;autoplay=0&amp;autohide_ctrls=0&amp;features=undefined&amp;disabled_features=undefined" width="550" height="400" frameBorder="0"></iframe>

</p>
<ul>
<li class="level1"><div class="li"> <a href="http://prezi.com/qshrq7oeytj2/?utm_campaign=share&amp;utm_medium=copy&amp;rc=ex0share" class="urlextern" title="http://prezi.com/qshrq7oeytj2/?utm_campaign=share&amp;utm_medium=copy&amp;rc=ex0share"  rel="nofollow"> Curs 06 - Memoria virtuală (vizualizare Prezi)</a></div>
</li>
<li class="level1"><div class="li"> <a href="http://elf.cs.pub.ro/so/res/cursuri/SO_Curs-06.pdf" class="urlextern" title="http://elf.cs.pub.ro/so/res/cursuri/SO_Curs-06.pdf"  rel="nofollow"> Curs 06 - Memoria virtuală (PDF)</a></div>
</li>
</ul>
<ul>
<li class="level1"><div class="li"> Suport curs</div>
<ul>
<li class="level2"><div class="li"> Operating Systems Concepts Essentials</div>
<ul>
<li class="level3"><div class="li"> Capitolul 8 - Virtual Memory</div>
</li>
</ul>
</li>
<li class="level2"><div class="li"> Modern Operating Systems, 2nd Ed.</div>
<ul>
<li class="level3"><div class="li"> Capitolul 4 - Memory Management</div>
<ul>
<li class="level4"><div class="li"> Secțiunile 4.4, 4.5</div>
</li>
</ul>
</li>
</ul>
</li>
<li class="level2"><div class="li"> Modern Operating Systems, 3rd Ed.</div>
<ul>
<li class="level3"><div class="li"> Capitolul 3 - Memory Management</div>
<ul>
<li class="level4"><div class="li"> Secțiunile 3.4, 3.5</div>
</li>
</ul>
</li>
</ul>
</li>
<li class="level2"><div class="li"> <a href="http://duartes.org/gustavo/blog/post/anatomy-of-a-program-in-memory/" class="urlextern" title="http://duartes.org/gustavo/blog/post/anatomy-of-a-program-in-memory/"  rel="nofollow">Anatomy of a Program in Memory</a></div>
</li>
</ul>
</li>
</ul>

</div>
<!-- EDIT1 SECTION "Curs 06 - Memoria virtuală" [1-947] -->
<h2 class="sectionedit2" id="demo-uri">Demo-uri</h2>
<div class="level2">

<p>
Pentru parcurgerea demo-urilor, folosim <a href="http://elf.cs.pub.ro/so/res/cursuri/curs-06-demo.zip" class="urlextern" title="http://elf.cs.pub.ro/so/res/cursuri/curs-06-demo.zip"  rel="nofollow">arhiva aferentă</a>. Demo-urile rulează pe Linux. Descărcăm arhiva folosind comanda
</p>
<pre class="code bash"><span class="kw2">wget</span> http:<span class="sy0">//</span>elf.cs.pub.ro<span class="sy0">/</span>so<span class="sy0">/</span>res<span class="sy0">/</span>cursuri<span class="sy0">/</span>curs-06-demo.zip</pre>

<p>
 și apoi decomprimăm arhiva
</p>
<pre class="code bash"><span class="kw2">unzip</span> curs-06-demo.zip</pre>

<p>
 și accesăm directorul rezultat în urma decomprimării
</p>
<pre class="code bash"><span class="kw3">cd</span> curs-06-demo<span class="sy0">/</span></pre>

<p>
Acum putem parcurge secțiunile cu demo-uri de mai jos.
</p>

</div>
<!-- EDIT2 SECTION "Demo-uri" [948-1449] -->
<h3 class="sectionedit3" id="alocarea_variabilelor_intr-un_executabil">Alocarea variabilelor într-un executabil</h3>
<div class="level3">

<p>
Dorim să investigăm modul în care se alocă variabilele într-un executabil. Pentru aceasta accesăm subdirectorul <code>exec-vars/</code>; urmărim conținutul fișierului <code>exec-vars.c</code>. În acest fișier definim/alocăm variabile în diverse forme: dinamic, static, global. Vrem să vedem cum sunt acestea alocate în executabil și în proces.
</p>

<p>
Compilăm programul folosind <code>make</code>.
</p>

<p>
Investigăm zonele de memorie din executabil în care sunt salvate variabilele, folosind comanda
</p>
<pre class="code bash">objdump <span class="re5">-t</span> addr-space <span class="sy0">|</span> <span class="kw2">grep</span> var</pre>

<p>
De ce apar doar unele variabile?
</p>
<div class="hiddenGlobal  hiddenActive"><div class="hiddenElements"></div><div class="hiddenHead  hiddenSinceBeginning"><div class="hiddenOnHidden">
<p>
Răspuns
</p>
</div><div class="hiddenOnVisible">
<p>
Răspuns
</p>
</div></div> <!-- .hiddenHead --><div class="hiddenBody">
<p>
Pentru variabilele alocate dinamic (pe stivă, heap) se alocă la runtime, adică în momentul în care procesul rulează. Executabilul nu are legătură cu datele alocate la runtime.
</p>
</div></div>
<p>
Ce semnfică <code>l</code> și <code>g</code> în output-ul obținut?
</p>
<div class="hiddenGlobal  hiddenActive"><div class="hiddenElements"></div><div class="hiddenHead  hiddenSinceBeginning"><div class="hiddenOnHidden">
<p>
Răspuns
</p>
</div><div class="hiddenOnVisible">
<p>
Răspuns
</p>
</div></div> <!-- .hiddenHead --><div class="hiddenBody">
<p>
Arată că variabilele respective sunt simboluri globale (<code>g</code> - la nivelul întregului modul) sau locale (<code>l</code> - locale unei funcții).
</p>
</div></div>
<p>
Pentru a afișa conținutul zonei <code>.rodata</code> folosind comanda
</p>
<pre class="code bash">readelf <span class="re5">-x</span> .rodata addr-space</pre>

<p>
Secțiunea <code>.rodata</code> conține variabile read-only, în cazul de față literalul <code>rulz</code>. Literalii și constantele se stocează în secțiunea <code>.rodata</code> a unui executabil.
</p>

</div>
<!-- EDIT3 SECTION "Alocarea variabilelor într-un executabil" [1450-2800] -->
<h3 class="sectionedit4" id="investigarea_maparii_folosind_pmap">Investigarea mapării folosind pmap</h3>
<div class="level3">

<p>
Vrem să vizualizăm spațiul virtual de adrese al unui proces. Pentru aceasta, accesăm subdirectorul <code>pmap/</code>; urmărim conținutul fișierului <code>pmap.c</code>; facem mapări (folosind apelul <code>mmap</code>) folosind diverse flag-uri.
</p>

<p>
Compilăm programul folosind <code>make</code> și apoi îl rulăm:
</p>
<pre class="code bash">.<span class="sy0">/</span>pmap</pre>

<p>
Într-o altă consolă urmărim schimbările din spațiul virtual de adrese al procesului creat folosind comanda
</p>
<pre class="code bash"><span class="kw2">watch</span> <span class="re5">-d</span> pmap $<span class="br0">&#40;</span><span class="kw2">pidof</span> pmap<span class="br0">&#41;</span></pre>

<p>
 Comanda de mai sus urmărește spațiul virtual de adrese. Ca să generăm schimbări în spațiul virtual de adrese, apăsăm <code>ENTER</code> în consola în care rulează programul pentru a continua pașii din cod.
</p>

<p>
Urmărim modificările care apar în urma diferitelor tipuri de mapare din cod. Observăm că se mapează câte o singură pagină; la fiecare operație de mapare spațiul total crește cu 4K, iar la fiecare operație de demapare spațiul total scade cu 4K. Observăm că în cazul mapării partajate permisiunile sunt <code>rw-s</code>; <code>s</code> înseamnă shared. Tot în cazul memoriei partajate apare mapat dispozitivul <code>/dev/zero</code>, unul dintre modurile uzuale de a face mapare partajată.
</p>

<p>
De ce unele biblioteci sunt mapate cu permisiuni de scriere?
</p>
<div class="hiddenGlobal  hiddenActive"><div class="hiddenElements"></div><div class="hiddenHead  hiddenSinceBeginning"><div class="hiddenOnHidden">
<p>
Răspuns
</p>
</div><div class="hiddenOnVisible">
<p>
Răspuns
</p>
</div></div> <!-- .hiddenHead --><div class="hiddenBody">
<p>
Bibliotecile au mai multe secțiuni, similar unui executabil, mapate cu permisiunile corespunzătoare. Secțiunea de cod/text este mapată cu permisiuni de citire și execuție (<code>r-x</code>), cea de date este mapată cu permisiuni de citire și scriere (<code>rw-</code>) iar cea de date read-only este mapată cu permisiuni doar de citire (<code>r–</code>).
</p>
</div></div>
</div>
<!-- EDIT4 SECTION "Investigarea mapării folosind pmap" [2801-4449] -->
<h3 class="sectionedit5" id="alocarea_de_memorie_virtuala">Alocarea de memorie virtuală</h3>
<div class="level3">

<p>
Vrem să urmărim modul în care se alocă memorie virtuală în spațiul virtual de adrese al unui proces. Pentru aceasta, accesăm subdirectorul <code>allocation/</code>; urmărim conținutul fișierului <code>allocation.c</code>; în cadrul fișierului se fac alocări de memorie virtuală folosind pe rând apelul <code>malloc</code> și apelul <code>mmap</code>.
</p>

<p>
Compilăm fișierul folosind comanda <code>make</code>.
</p>

<p>
Deschidem o consolă nouă și rulăm în cele două console astfel:
</p>
<ul>
<li class="level1"><div class="li"> Într-o consolă rulăm executabilul aferent:<pre class="code">./allocation</pre>
</div>
</li>
<li class="level2"><div class="li"> Într-o altă consolă vizualizăm dimensiunea spațiului fizic ocupat și a a spatiului virtual ocupat, folosind comanda<pre class="code bash"><span class="kw2">watch</span> <span class="re5">-n</span> <span class="nu0">1</span> <span class="kw2">ps</span> <span class="re5">-o</span> pid,rss,vsz,cmd <span class="re5">-p</span> $<span class="br0">&#40;</span><span class="kw2">pidof</span> allocation<span class="br0">&#41;</span></pre>
</div>
</li>
</ul>

<p>
Observați cum crește dimensiunea spațiului fizic și a spatiului virtual în cazul folosirii <code>malloc</code> și <strong>doar</strong> a spațiului virtual folosind <code>mmap</code>.
</p>

<p>
Pentru a explica acest comportament, rulăm executabilul prin <code>strace</code>:
</p>
<pre class="code">strace ./allocation</pre>

<p>
Observăm că în cazul funcției de bibliotecă <code>malloc</code> se realizează apelul de sistem <code>brk</code>, în timp ce în cazul funcției de bibliotecă <code>mmap</code> se realizează apelul de sistem <code>mmap</code>. Apelul de sistem <code>mmap</code> alocă <strong>doar</strong> memorie virtuală.
</p>

<p>
Observăm de asemenea, că se realizează un număr redus de apeluri de sistem <code>brk</code> raportat la cele <code>1024</code> de apeluri de bibliotecă <code>malloc</code>. Un apel <code>brk</code> alocă un pool mai mare de memorie care va fi apoi folosit la apeluri viitoare <code>malloc</code>; realizează o prealocare.
</p>

<p>
Pentru a vedea comportamentului funcției de bibliotecă <code>malloc</code>, actualizăm codul astfel încât <code>malloc</code> să aloce, la fel ca <code>mmap</code> calupuri de <code>1MB</code> de memorie. Adică bucla <code>for</code> aferentă să arate așa:
</p>
<pre class="code c">	<span class="kw1">for</span> <span class="br0">&#40;</span>cnt <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> cnt <span class="sy0">&lt;</span> NUM_ROUNDS<span class="sy0">;</span> cnt<span class="sy0">++</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
		<a href="http://www.opengroup.org/onlinepubs/009695399/functions/puts.html"><span class="kw3">puts</span></a><span class="br0">&#40;</span><span class="st0">&quot;Using malloc to allocate 1024 sets of 1024 bytes.&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
		p <span class="sy0">=</span> <a href="http://www.opengroup.org/onlinepubs/009695399/functions/malloc.html"><span class="kw3">malloc</span></a><span class="br0">&#40;</span><span class="nu0">1024</span><span class="sy0">*</span><span class="nu0">1024</span><span class="br0">&#41;</span><span class="sy0">;</span>
		DIE<span class="br0">&#40;</span>p <span class="sy0">==</span> NULL<span class="sy0">,</span> <span class="st0">&quot;malloc&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
		sleep<span class="br0">&#40;</span><span class="nu0">2</span><span class="br0">&#41;</span><span class="sy0">;</span>
	<span class="br0">&#125;</span></pre>

<p>
Compilăm noua sursă folosind comanda <code>make</code>. La fel ca mai devreme rulăm executabilul într-o consolă și comanda de vizualizare în altă consolă. Observăm că acum atât funcția de bibliotecă <code>malloc</code>, cât și funcția de bibliotecă <code>mmap</code> alocă <strong>doar</strong> memorie virtuală.
</p>

<p>
Folosim în continuare <code>strace</code> pentru a investiga:
</p>
<pre class="code bash"><span class="kw2">strace</span> .<span class="sy0">/</span>allocation</pre>

<p>
Observăm că acum și funcția de bibliotecă <code>malloc</code> folosește în spate tot apelul de sistem <code>mmap</code>. Acesta alocă doar memorie virtuală de unde și comportamentul. De la o valoare dată, alocarea cu <code>malloc</code> folosește apelul de sistem <code>mmap</code>.
</p>
<div class="hiddenGlobal  hiddenActive"><div class="hiddenElements"></div><div class="hiddenHead  hiddenSinceBeginning"><div class="hiddenOnHidden">
<p>
Despre apelul malloc
</p>
</div><div class="hiddenOnVisible">
<p>
Despre apelul malloc
</p>
</div></div> <!-- .hiddenHead --><div class="hiddenBody">
<p>
Valoarea de la care funcția de bibliotecă <code>malloc</code> folosește <code>mmap</code> este definită de <code>MMAP_THRESHOLD</code>, în mod implicit configurat la <code>128KB</code>. Detalii se găsesc în <a href="http://man7.org/linux/man-pages/man3/malloc.3.html#NOTES" class="urlextern" title="http://man7.org/linux/man-pages/man3/malloc.3.html#NOTES"  rel="nofollow">pagina de manual a malloc</a>:
</p>
<pre class="code">       Normally, malloc() allocates memory from the heap, and adjusts the
       size of the heap as required, using sbrk(2).  When allocating blocks
       of memory larger than MMAP_THRESHOLD bytes, the glibc malloc()
       implementation allocates the memory as a private anonymous mapping
       using mmap(2).  MMAP_THRESHOLD is 128 kB by default, but is
       adjustable using mallopt(3).  Allocations performed using mmap(2) are
       unaffected by the RLIMIT_DATA resource limit (see getrlimit(2)).</pre>
</div></div>
</div>
<!-- EDIT5 SECTION "Alocarea de memorie virtuală" [4450-7930] -->
<h3 class="sectionedit6" id="paginare_la_cerere_demand_paging">Paginare la cerere (demand paging)</h3>
<div class="level3">

<p>
Vrem să urmărim modul în care se alocă pagini de memorie fizică la cerere, proces care se numește <code>(on) demand paging</code>. Pentru aceasta, accesăm subdirectorul <code>demand-paging/</code>; urmărim conținutul fișierului <code>demand-paging.c</code>; în cadrul fișierului alocăm memorie virtuală folosind <code>mmap</code> și apoi accesăm primul octet al fiecărei pagini alocate.
</p>

<p>
Compilăm codul sursă folosind comanda <code>make</code>.
</p>

<p>
Avem nevoie de două console:
</p>
<ul>
<li class="level1"><div class="li"> Într-o consolă rulăm executabilul aferent:<pre class="code">./demand-paging</pre>
</div>
</li>
<li class="level1"><div class="li"> Într-o altă consolă vizualizăm dimensiunea spațiului fizic ocupat și a a spatiului virtual ocupat, folosind comanda:<pre class="code bash"><span class="kw2">watch</span> <span class="re5">-n</span> <span class="nu0">1</span> <span class="kw2">ps</span> <span class="re5">-o</span> pid,rss,vsz,cmd <span class="re5">-p</span> $<span class="br0">&#40;</span><span class="kw2">pidof</span> demand-paging<span class="br0">&#41;</span></pre>
</div>
</li>
</ul>

<p>
Observăm cum crește dimensiunea spațiului spatiului virtual (coloana <code>VSZ</code>) fără a crește dimensiunea spațiului fizic în prima parte. Se face alocare de memorie virtuală, fără paginare - adică fără alocare de spațiu fizic aferent. În partea a doua, observați cum crește dimensiunea spațiului fizic (coloana <code>RSS</code>) în a doua parte (fără a crește dimensiunea spațiului virtual). Aceasta este <em>(on) demand paging</em>, cu alocarea paginilor fizice necesare la nevoie.
</p>

<p>
Ca să detaliem, urmărim page fault-urile realizate pe parcursul rulării programului. Folosim, la fel, două console:
</p>
<ul>
<li class="level1"><div class="li"> Într-o consolă rulăm executabilul aferent:<pre class="code">./demand-paging</pre>
</div>
</li>
<li class="level1"><div class="li"> Într-o altă consolă vizualizăm numărul de page fault-uri generate de program (<code>min_flt</code> este coloana de interes, <code>maj_flt</code> este pentru interacțiuni cu discul – swapping):<pre class="code bash"><span class="kw2">watch</span> <span class="re5">-n</span> <span class="nu0">1</span> <span class="kw2">ps</span> <span class="re5">-o</span> pid,min_flt,maj_flt,cmd <span class="re5">-p</span> $<span class="br0">&#40;</span><span class="kw2">pidof</span> demand-paging<span class="br0">&#41;</span></pre>
</div>
</li>
</ul>

<p>
Observați cum nu există page fault-uri în prima pare a rulării programului, în momentul în care facem mapări de memorie. Dar apar page fault-uri în a doua parte a rulării programului.
</p>

<p>
Câte page fault-uri sunt generate la o “trecere prin chunk”? De ce?
</p>
<div class="hiddenGlobal  hiddenActive"><div class="hiddenElements"></div><div class="hiddenHead  hiddenSinceBeginning"><div class="hiddenOnHidden">
<p>
Răspuns
</p>
</div><div class="hiddenOnVisible">
<p>
Răspuns
</p>
</div></div> <!-- .hiddenHead --><div class="hiddenBody">
<p>
Se generează 256 page fault-uri. Asta se întâmplă pentru ca la fiecare “trecere prin chunk” se accesează 256 pagini, fiecare pagină având câte 4KB, pentru un total de 1MB. Un page fault înseamnă alocarea (on demand) a unei pagini fizice.
</p>
</div></div>
</div>
<!-- EDIT6 SECTION "Paginare la cerere (demand paging)" [7931-10219] -->
<h3 class="sectionedit7" id="page_fault-uri_la_fork_copy-on-write">Page fault-uri la fork (copy-on-write)</h3>
<div class="level3">

<p>
Vrem să urmărim realizarea page fault-urilor în urma unui apel <code>fork</code>; page fault-urilor vor fi cauzate de mecanismul de copy-on-write în momentul în care unul dintre cele două procese (copil sau părinte) scrie în zona respectivă. Pentru aceasta, accesăm subdirectorul <code>fork-faults</code>; urmărim conținutul fișierului <code>fork-faults.c</code>. În cadrul fișierului <code>fork-faults.c</code> se execută următorii pași:
</p>
<ol>
<li class="level1"><div class="li"> se alocă memorie virtuală folosind <code>mmap</code></div>
</li>
<li class="level1"><div class="li"> se alocă memorie fizică pentru paginile de mai sus, folosind <em>(on) demand paging</em> prin accesarea primului octet al fiecărei pagini</div>
</li>
<li class="level1"><div class="li"> se creează un proces nou</div>
</li>
<li class="level1"><div class="li"> procesul copil citește valoarea din prima jumătate a numărului de pagini (<strong>doar</strong> citește)</div>
</li>
<li class="level1"><div class="li"> procesul copil scrie o valoare în cadrul fiecărei pagini din a două jumătate</div>
</li>
<li class="level1"><div class="li"> procesul părinte scrie o valoare în toate paginile</div>
</li>
</ol>

<p>
Ca să urmărim ce se întâmplă, compilăm fișierul folosind <code>make</code>. Apoi rulăm programul obținut:
</p>
<pre class="code bash">.<span class="sy0">/</span>fork-faults</pre>

<p>
 Folosim <code>ENTER</code> pentru a continua programul, dar după rularea <code>pidstat</code> (mai jos).
</p>

<p>
Într-o altă consolă folosim utilitarul <code>pidstat</code> din pachetul <code>sysstat</code> care permite monitorizarea page fault-urilor unui proces (prin intermediul argumentului <code>-r</code>). Dacă nu există comanda <code>pidstat</code> trebuie să instalăm pachetul <code>sysstat</code> folosind comanda:
</p>
<pre class="code bash"><span class="kw2">apt-get install</span> sysstat</pre>

<p>
Pentru a rula <code>pidstat</code> și a urmări page fault-urile, folosim, pe a doua consolă, comanda
</p>
<pre class="code bash">pidstat <span class="re5">-r</span> <span class="re5">-T</span> ALL <span class="re5">-p</span> $<span class="br0">&#40;</span><span class="kw2">pidof</span> fork-faults<span class="br0">&#41;</span> <span class="nu0">5</span> <span class="nu0">100</span></pre>

<p>
 Comanda de mai sus afișează câte un mesaj la fiecare 5 secunde. În prima consolă apăsăm <code>ENTER</code> pentru a continua rularea și urmărim informațiile afișate de <code>pidstat</code>, apoi continuăm apăsarea <code>ENTER</code> etc.
</p>

<p>
Urmărim, în outputul comenzii <code>pidstat</code>, evoluția numărului de page fault-uri pentru cele două procese: părinte și copil. Page fault-urile care apar în cazul unui copy-on-write în procesul copil vor fi vizibile ulterior și în procesul părinte. Observăm că procesul copil generează page fault-uri doar pe jumătate din pagini (cele în care scrie), iar procesul părinte generează page fault-uri pe toate paginile. Asta pentru că un proces creează o copie a paginilor inițiale, dar lasă acele pagini <code>read-only</code>, iar alt proces primește page fault dar doar schimbă permisiunile din read-only în read-write.
</p>

</div>
<!-- EDIT7 SECTION "Page fault-uri la fork (copy-on-write)" [10220-] --></div>
</body>
</html>
