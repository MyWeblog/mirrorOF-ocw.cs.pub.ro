    
    

<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
  <meta charset="utf-8" />
  <title>so:cursuri:curs-05</title>
<meta name="generator" content="DokuWiki"/>
<meta name="robots" content="index,follow"/>
<meta name="date" content="2014-03-29T18:44:04+0200"/>
<meta name="keywords" content="so,cursuri,curs-05"/>
<link rel="search" type="application/opensearchdescription+xml" href="../../../../lib/exe/opensearch.php" title="CS Open CourseWare"/>
<link rel="start" href="../../../../../courses.1.html"/>
<link rel="alternate" type="application/rss+xml" title="Recent Changes" href="../../../../feed.php"/>
<link rel="alternate" type="application/rss+xml" title="Current Namespace" href="../../../../feed.php%3Fmode=list&amp;ns=so:cursuri"/>
<link rel="alternate" type="text/html" title="Plain HTML" href="curs-05.html"/>
<link rel="canonical" href="../../../../so/cursuri/curs-05.html"/>
<link rel="stylesheet" type="text/css" href="../../../../lib/exe/css.php%3Ft=arctic&amp;tseed=1476798676.css"/>
<script type="text/javascript">/*<![CDATA[*/var NS='so:cursuri';var JSINFO = {"id":"so:cursuri:curs-05","namespace":"so:cursuri","isadmin":0,"isauth":0};
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="../../../../lib/exe/js.php%3Ftseed=1476798676"></script>
<script type="text/x-mathjax-config">/*<![CDATA[*/MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ["$","$"], ["\\(","\\)"] ],
        displayMath: [ ["$$","$$"], ["\\[","\\]"] ],
        processEscapes: true
    }
});
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
<script type="text/javascript">/*<![CDATA[*/
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
		  
/*!]]>*/</script>
<script type="text/javascript">/*<![CDATA[*/
var pageTracker = _gat._getTracker("UA-38383934-1");
pageTracker._initData();
pageTracker._trackPageview();
		  
/*!]]>*/</script>
</head>
<body>
<div class="dokuwiki export">
<!-- TOC START -->
<div id="dw__toc">
<h3 class="toggle">Table of Contents</h3>
<div>

<ul class="toc">
<li class="level1"><div class="li"><a href="curs-05.html#curs_05_-_gestiunea_memoriei">Curs 05 - Gestiunea memoriei</a></div>
<ul class="toc">
<li class="level2"><div class="li"><a href="curs-05.html#demo-uri">Demo-uri</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="curs-05.html#informatii_despre_memoria_sistemului">Informații despre memoria sistemului</a></div></li>
<li class="level3"><div class="li"><a href="curs-05.html#informatii_despre_spatiul_de_adresa_al_unui_proces">Informații despre spațiul de adresă al unui proces</a></div></li>
<li class="level3"><div class="li"><a href="curs-05.html#granularitatea_alocarii_de_memorie">Granularitatea alocării de memorie</a></div></li>
<li class="level3"><div class="li"><a href="curs-05.html#informatii_despre_tlb">Informații despre TLB</a></div></li>
</ul></li>
</ul></li>
</ul>
</div>
</div>
<!-- TOC END -->

<h1 class="sectionedit1" id="curs_05_-_gestiunea_memoriei">Curs 05 - Gestiunea memoriei</h1>
<div class="level1">

<p>

<iframe src="http://prezi.com/embed/gfswijyf3vsk/?bgcolor=ffffff&amp;lock_to_path=0&amp;autoplay=0&amp;autohide_ctrls=0&amp;features=undefined&amp;disabled_features=undefined" width="550" height="400" frameBorder="0" webkitAllowFullScreen mozAllowFullscreen allowfullscreen></iframe>

</p>
<ul>
<li class="level1"><div class="li"> <a href="http://prezi.com/gfswijyf3vsk/?utm_campaign=share&amp;utm_medium=copy&amp;rc=ex0share" class="urlextern" title="http://prezi.com/gfswijyf3vsk/?utm_campaign=share&amp;utm_medium=copy&amp;rc=ex0share"  rel="nofollow"> Curs 05 - Gestiunea memoriei (vizualizare Prezi)</a></div>
</li>
<li class="level1"><div class="li"> <a href="http://elf.cs.pub.ro/so/res/cursuri/SO_Curs-05.pdf" class="urlextern" title="http://elf.cs.pub.ro/so/res/cursuri/SO_Curs-05.pdf"  rel="nofollow"> Curs 05 - Gestiunea memoriei (PDF)</a></div>
</li>
</ul>
<ul>
<li class="level1"><div class="li"> Suport curs</div>
<ul>
<li class="level2"><div class="li"> Operating System Concepts Essentials</div>
<ul>
<li class="level3"><div class="li"> Capitolul 7 - Main Memory</div>
</li>
</ul>
</li>
<li class="level2"><div class="li"> Modern Operating Systems, 2nd Ed.</div>
<ul>
<li class="level3"><div class="li"> Capitolul 4 - Memory Management</div>
<ul>
<li class="level4"><div class="li"> Secțiunile 4.1, 4.2, 4.3, 4.8</div>
</li>
</ul>
</li>
</ul>
</li>
<li class="level2"><div class="li"> Modern Operating Systems, 3rd Ed.</div>
<ul>
<li class="level3"><div class="li"> Capitolul 3 - Memory Management</div>
<ul>
<li class="level4"><div class="li"> Secțiunile 3.1, 3.2, 3.3, 3.7</div>
</li>
</ul>
</li>
</ul>
</li>
<li class="level2"><div class="li"> <a href="http://lwn.net/Articles/250967/" class="urlextern" title="http://lwn.net/Articles/250967/"  rel="nofollow"> Ulrich Drepper - What every programmer should know about memory</a></div>
</li>
</ul>
</li>
</ul>

</div>
<!-- EDIT1 SECTION "Curs 05 - Gestiunea memoriei" [1-1021] -->
<h2 class="sectionedit2" id="demo-uri">Demo-uri</h2>
<div class="level2">

<p>
Pentru parcurgerea demo-urilor, folosim <a href="http://elf.cs.pub.ro/so/res/cursuri/curs-05-demo.zip" class="urlextern" title="http://elf.cs.pub.ro/so/res/cursuri/curs-05-demo.zip"  rel="nofollow">arhiva aferentă</a>. Demo-urile rulează pe Linux. Descărcăm arhiva folosind comanda
</p>
<pre class="code bash"><span class="kw2">wget</span> http:<span class="sy0">//</span>elf.cs.pub.ro<span class="sy0">/</span>so<span class="sy0">/</span>res<span class="sy0">/</span>cursuri<span class="sy0">/</span>curs-05-demo.zip</pre>

<p>
 și apoi decomprimăm arhiva
</p>
<pre class="code bash"><span class="kw2">unzip</span> curs-05-demo.zip</pre>

<p>
 și accesăm directorul rezultat în urma decomprimării
</p>
<pre class="code bash"><span class="kw3">cd</span> curs-05-demo<span class="sy0">/</span></pre>

<p>
Acum putem parcurge secțiunile cu demo-uri de mai jos.
</p>

</div>
<!-- EDIT2 SECTION "Demo-uri" [1022-1523] -->
<h3 class="sectionedit3" id="informatii_despre_memoria_sistemului">Informații despre memoria sistemului</h3>
<div class="level3">

<p>
Ca să aflăm informații despre memoria RAM (fizică) disponibilă pe sistem folosim comanda
</p>
<pre class="code bash"><span class="kw2">free</span> <span class="re5">-m</span></pre>

<p>
Rezultatul afișat este în megaocteți.
</p>

<p>
Altă variantă este consultarea fișierului <code>/proc/meminfo</code>:
</p>
<pre class="code bash"><span class="kw2">cat</span> <span class="sy0">/</span>proc<span class="sy0">/</span>meminfo</pre>

<p>
Spațiul de adresare disponibil îl putem afla prin consultarea fișierului <code>/proc/cpuinfo</code>:
</p>
<pre class="code bash"><span class="kw2">cat</span> <span class="sy0">/</span>proc<span class="sy0">/</span>cpuinfo <span class="sy0">|</span> <span class="kw2">grep</span> <span class="st_h">'address sizes'</span></pre>

<p>
Ni se vor afișa informații despre spațiul adresabil fizic și cel virtual. În general, la sistemele cu arhitectură x86_64, deși registrele sunt pe 64 de biți, spațiul adresabil virtual este de 48 de biți.
</p>

<p>
Pentru a afla informații desre memoria cache a sistemului, folosim comanda
</p>
<pre class="code bash">lscpu</pre>

<p>
 și urmărim liniile care conțin cuvântul <code>cache</code>. Sau folosim comanda
</p>
<pre class="code bash">getconf <span class="re5">-a</span> <span class="sy0">|</span> <span class="kw2">grep</span> <span class="st_h">'CACHE'</span></pre>

<p>
De obicei avem mai multe niveluri de memorie cache. Primul nivel conține în general un cache pentru date și unul pentru instrucțiuni.
</p>

<p>
Pentru a afla dimensiunea paginii sistemului folosim comanda
</p>
<pre class="code bash">getconf PAGE_SIZE</pre>

<p>
Programatic, astfel de informații pot fi determinate prin intermediul apelului <a href="http://man7.org/linux/man-pages/man3/sysconf.3.html" class="urlextern" title="http://man7.org/linux/man-pages/man3/sysconf.3.html"  rel="nofollow">sysconf</a>. O implementare succintă se găsește în subdirectorul <code>system-memory/</code>. În fișierul <code>system-memory.c</code> folosim apelul <code>sysconf</code> pentru a afla dimensiunea paginii sistemului, spațiul de memorie, informații despre memoria cache. Pentru a folosi programul, îl compilăm și îl rulăm:
</p>
<pre class="code bash"><span class="kw2">make</span>
.<span class="sy0">/</span>system-memory</pre>

</div>
<!-- EDIT3 SECTION "Informații despre memoria sistemului" [1524-3147] -->
<h3 class="sectionedit4" id="informatii_despre_spatiul_de_adresa_al_unui_proces">Informații despre spațiul de adresă al unui proces</h3>
<div class="level3">

<p>
Spațiul de adresă al unui proces poate fi vizualizat folosind comanda <code>pmap</code>. De exemplu, dacă dorim să vizualizăm spațiul de adresă al procesului curent folosim comanda
</p>
<pre class="code bash">pmap <span class="re4">$$</span></pre>

<p>
Spațiul de adresă al unui proces cuprinde zona de cod/text (marcată <code>r-x</code>), zone de date (marcate <code>r--</code> și <code>rw-</code>), biblioteci partajate, heap, stivă.
</p>

<p>
Spațiul de adresă al procesului este modificat dinamic (la <em>runtime</em>) prin alocare și dezalocare de memorie. Pentru a urmări modul în care este alterat spațiul de adresă al procesului la alocare și dezalocare folosim programul din subdirectorul <code>address-space/</code>.
</p>

<p>
În fișierul <code>address-space.c</code> alocăm și dezalocăm memorie folosind stiva (la un apel de funcție), apelurile <code>malloc</code> și <code>free</code>, respectiv apelurile <code>mmap</code> și <code>munmap</code>. Înaintea executării unui pas programul așteaptă 5 secunde, timp în care putem urmări evoluția spațiului de adresă.
</p>

<p>
Pentru a urmări evoluția programului avem nevoie de două console. Într-o consolă compilăm și rulăm programul, iar în alta verificăm funcționalitatea sa folosind <code>pmap</code>.
</p>

<p>
Pentru acesta în prima consolă compilăm și rulăm:
</p>
<pre class="code bash"><span class="kw2">make</span>
.<span class="sy0">/</span>address-space</pre>

<p>
Apoi, în cealaltă consolă rulăm periodic comanda:
</p>
<pre class="code bash">pmap $<span class="br0">&#40;</span><span class="kw2">pidof</span> address-space<span class="br0">&#41;</span></pre>

<p>
Observăm cum se modifică dimensiunile diverselor regiuni după alocare. Stiva nu se modifică; stiva este deja alocată iar spațiul ocupat de <code>buffer</code> nu conduce la alterarea stivei. Pentru <code>malloc</code>/<code>free</code> și <code>mmap</code>/<code>munmap</code> se alocă/eliberează dimensiunea cerută în conformitate cu apelul.
</p>

</div>
<!-- EDIT4 SECTION "Informații despre spațiul de adresă al unui proces" [3148-4874] -->
<h3 class="sectionedit5" id="granularitatea_alocarii_de_memorie">Granularitatea alocării de memorie</h3>
<div class="level3">

<p>
Deși un apel de genul <code>malloc</code> permite alocare fină de memorie (de nivelul octeților), în spate sistemul de operare și hardware-ul alocă memorie la nivel de pagină. Un apel de alocare a memoriei va aloca mai mult spațiu pentru a permite viitoare alocări.
</p>

<p>
Pentru a verifica acest lucru folosim subdirectorul <code>allocation-granularity/</code>. Fișierul <code>allocation-granularity.c</code> este un program care primește ca argument dimensiunea care să fie transmisă apelului <code>malloc</code> și apoi așpteaptă 5 secunde înainte și după pentru a putea urmări efectul acestei alocări asupra spațiului de adresă, după care procesul este închis.
</p>

<p>
Vom folosi două console: pe o consolă vom rula programul iar pe alta vom investiga spațiul de adresă aferent. Pentru aceasta pe prima consolă vom compila și vom rula procesul:
</p>
<pre class="code bash"><span class="kw2">make</span>
.<span class="sy0">/</span>allocation-granularity <span class="nu0">1</span></pre>

<p>
 în vreme ce pe a doua consolă vom consulta spațiul de adresă al procesului:
</p>
<pre class="code bash">pmap $<span class="br0">&#40;</span><span class="kw2">pidof</span> allocation-granularity<span class="br0">&#41;</span></pre>

<p>
Prima comandă alocă un singur octet în mod dinamic în cadrul spațiului de adresă. Ultima comandă o vom rula de mai multe ori pentru a verifica modul în care se modifică spațiul de adresă al procesului. Vedem că la o simplă alocare de 1 octet se alocă o zonă mai mare în spațiul de adresă al procesului, conform modului intern de lucru al apelului de bibliotecă <code>malloc</code>.
</p>

</div>
<!-- EDIT5 SECTION "Granularitatea alocării de memorie" [4875-6333] -->
<h3 class="sectionedit6" id="informatii_despre_tlb">Informații despre TLB</h3>
<div class="level3">

<p>
Pentru a afla informații despre TLB instalăm pachetul <code>cpuid</code>. Pe un sistem Debian-based folosim comanda
</p>
<pre class="code bash"><span class="kw2">apt-get install</span> cpuid</pre>

<p>
Ca să determinăm informații despre TLB folosim comanda
</p>
<pre class="code bash">cpuid <span class="sy0">|</span> <span class="kw2">grep</span> TLB</pre>

<p>
Dacă vrem să urmărim numărul de miss-uri pentru TLB putem folosi <code>perf</code>. De exemplu, pentru a urmări TLB miss-urile într-un interval de 10 secunde la nivelul sistemului folosim comanda
</p>
<pre class="code bash"><span class="kw2">sudo</span> perf <span class="kw2">stat</span> <span class="re5">-e</span> iTLB-load-misses <span class="re5">-a</span> <span class="kw2">sleep</span> <span class="nu0">10</span></pre>

<p>
TLB miss-urile cresc în momentul schimbării spațiului de adresă, adică la planificarea proceselor. Dacă avem multe schimbări de spațiu de adresă între procese atunci numărul de TLB miss-uri va crește. Pentru a verifica acest lucru, din <a href="http://elf.cs.pub.ro/so/res/cursuri/curs-04-demo.zip" class="urlextern" title="http://elf.cs.pub.ro/so/res/cursuri/curs-04-demo.zip"  rel="nofollow">arhiva laboratorului 4</a>, din subdirectorul <code>nice/</code> rulăm scriptul <code>start-all</code> (după ce am compilat în prealabil executabilul <code>cpu</code>). După ce am rulat scriptul folosim o altă consolă pentru a măsura numărul de TLB miss-uri, folosind aceeași comandă ca mai sus:
</p>
<pre class="code bash"><span class="kw2">sudo</span> perf <span class="kw2">stat</span> <span class="re5">-e</span> iTLB-load-misses <span class="re5">-a</span> <span class="kw2">sleep</span> <span class="nu0">10</span></pre>

<p>
Observăm un număr semnificativ mai mare de TLB miss-uri datorat numeroaselor schimbări de context ce au loc între procesele pornite de scriptul &#039;&#039;start-all&#039;.
</p>

</div>
<!-- EDIT6 SECTION "Informații despre TLB" [6334-] --></div>
</body>
</html>
