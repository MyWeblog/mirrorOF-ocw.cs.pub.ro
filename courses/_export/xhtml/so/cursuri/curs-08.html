    
    

<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
  <meta charset="utf-8" />
  <title>so:cursuri:curs-08</title>
<meta name="generator" content="DokuWiki"/>
<meta name="robots" content="index,follow"/>
<meta name="date" content="2016-05-22T11:57:17+0300"/>
<meta name="keywords" content="so,cursuri,curs-08"/>
<link rel="search" type="application/opensearchdescription+xml" href="../../../../lib/exe/opensearch.php" title="CS Open CourseWare"/>
<link rel="start" href="../../../../../courses.1.html"/>
<link rel="alternate" type="application/rss+xml" title="Recent Changes" href="../../../../feed.php"/>
<link rel="alternate" type="application/rss+xml" title="Current Namespace" href="../../../../feed.php%3Fmode=list&amp;ns=so:cursuri"/>
<link rel="alternate" type="text/html" title="Plain HTML" href="curs-08.html"/>
<link rel="canonical" href="../../../../so/cursuri/curs-08.html"/>
<link rel="stylesheet" type="text/css" href="../../../../lib/exe/css.php%3Ft=arctic&amp;tseed=1476798676.css"/>
<script type="text/javascript">/*<![CDATA[*/var NS='so:cursuri';var JSINFO = {"id":"so:cursuri:curs-08","namespace":"so:cursuri","isadmin":0,"isauth":0};
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="../../../../lib/exe/js.php%3Ftseed=1476798676"></script>
<script type="text/x-mathjax-config">/*<![CDATA[*/MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ["$","$"], ["\\(","\\)"] ],
        displayMath: [ ["$$","$$"], ["\\[","\\]"] ],
        processEscapes: true
    }
});
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
<script type="text/javascript">/*<![CDATA[*/
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
		  
/*!]]>*/</script>
<script type="text/javascript">/*<![CDATA[*/
var pageTracker = _gat._getTracker("UA-38383934-1");
pageTracker._initData();
pageTracker._trackPageview();
		  
/*!]]>*/</script>
</head>
<body>
<div class="dokuwiki export">
<!-- TOC START -->
<div id="dw__toc">
<h3 class="toggle">Table of Contents</h3>
<div>

<ul class="toc">
<li class="level1"><div class="li"><a href="curs-08.html#curs_08_-_fire_de_executie">Curs 08 - Fire de execuție</a></div>
<ul class="toc">
<li class="level2"><div class="li"><a href="curs-08.html#demo-uri">Demo-uri</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="curs-08.html#timp_de_creare_procese_si_thread-uri">Timp de creare procese și thread-uri</a></div></li>
<li class="level3"><div class="li"><a href="curs-08.html#creare_de_thread-uri_si_spatiul_de_adresa">Creare de thread-uri și spațiul de adresă</a></div></li>
<li class="level3"><div class="li"><a href="curs-08.html#partajare_informatie_intre_procese_si_thread-uri">Partajare informație între procese și thread-uri</a></div></li>
<li class="level3"><div class="li"><a href="curs-08.html#stiva_unui_thread_in_spatiul_de_adresa">Stiva unui thread în spațiul de adresă</a></div></li>
<li class="level3"><div class="li"><a href="curs-08.html#utilitate_apeluri_reentrante">Utilitate apeluri reentrante</a></div></li>
</ul></li>
</ul></li>
</ul>
</div>
</div>
<!-- TOC END -->

<h1 class="sectionedit1" id="curs_08_-_fire_de_executie">Curs 08 - Fire de execuție</h1>
<div class="level1">

<p>

<iframe src="http://prezi.com/embed/3noq9rp6p95k/?bgcolor=ffffff&amp;lock_to_path=0&amp;autoplay=0&amp;autohide_ctrls=0&amp;features=undefined&amp;disabled_features=undefined" width="550" height="400" frameBorder="0"></iframe>

</p>
<ul>
<li class="level1"><div class="li"> <a href="http://prezi.com/3noq9rp6p95k/curs-8-so/?kw=view-3noq9rp6p95k&amp;rc=ref-31844697" class="urlextern" title="http://prezi.com/3noq9rp6p95k/curs-8-so/?kw=view-3noq9rp6p95k&amp;rc=ref-31844697"  rel="nofollow"> Curs 08 - Fire de execuție (vizualizare Prezi)</a></div>
</li>
<li class="level1"><div class="li"> <a href="http://elf.cs.pub.ro/so/res/cursuri/SO_Curs-08.pdf" class="urlextern" title="http://elf.cs.pub.ro/so/res/cursuri/SO_Curs-08.pdf"  rel="nofollow"> Curs 08 - Fire de execuție (PDF)</a></div>
</li>
</ul>
<ul>
<li class="level1"><div class="li"> Suport curs</div>
<ul>
<li class="level2"><div class="li"> Operating Systems Concepts Essentials</div>
<ul>
<li class="level3"><div class="li"> Capitolul 4 - Threads</div>
</li>
</ul>
</li>
<li class="level2"><div class="li"> Modern Operating Systems</div>
<ul>
<li class="level3"><div class="li"> Capitolul 2 - Processes and Threads</div>
<ul>
<li class="level4"><div class="li"> Secțiunea 2.2 - Threads</div>
</li>
</ul>
</li>
</ul>
</li>
<li class="level2"><div class="li"> Beginning Linux Programming</div>
<ul>
<li class="level3"><div class="li"> Capitolul 12 - POSIX Threads</div>
</li>
</ul>
</li>
<li class="level2"><div class="li"> Windows System Programming</div>
<ul>
<li class="level3"><div class="li"> Capitolul 7 - Threads and Scheduling</div>
</li>
<li class="level3"><div class="li"> Capitolul 8 - Thread Synchronization</div>
</li>
</ul>
</li>
</ul>
</li>
</ul>

</div>
<!-- EDIT1 SECTION "Curs 08 - Fire de execuție" [1-913] -->
<h2 class="sectionedit2" id="demo-uri">Demo-uri</h2>
<div class="level2">

<p>
Pentru parcurgerea demo-urilor, folosim <a href="http://elf.cs.pub.ro/so/res/cursuri/curs-08-demo.zip" class="urlextern" title="http://elf.cs.pub.ro/so/res/cursuri/curs-08-demo.zip"  rel="nofollow">arhiva aferentă</a>. Demo-urile rulează pe Linux. Descărcăm arhiva folosind comanda
</p>
<pre class="code bash"><span class="kw2">wget</span> http:<span class="sy0">//</span>elf.cs.pub.ro<span class="sy0">/</span>so<span class="sy0">/</span>res<span class="sy0">/</span>cursuri<span class="sy0">/</span>curs-08-demo.zip</pre>

<p>
 și apoi decomprimăm arhiva
</p>
<pre class="code bash"><span class="kw2">unzip</span> curs-08-demo.zip</pre>

<p>
 și accesăm directorul rezultat în urma decomprimării
</p>
<pre class="code bash"><span class="kw3">cd</span> curs-08-demo<span class="sy0">/</span></pre>

<p>
Acum putem parcurge secțiunile cu demo-uri de mai jos.
</p>

</div>
<!-- EDIT2 SECTION "Demo-uri" [914-1416] -->
<h3 class="sectionedit3" id="timp_de_creare_procese_si_thread-uri">Timp de creare procese și thread-uri</h3>
<div class="level3">

<p>
Dorim să investigăm timpul de creare a proceselor și thread-urilor; timpul de creare al proceselor va fi mai mare, ne interesează cu cât. Pentru aceasta accesăm subdirectorul <code>creation-time/</code>; urmărim conținutul fișierelor <code>process-overhead.c</code> și <code>thread-overhead.c</code>. În aceste fișiere se creează, în 100 de runde, câte 100 de procese, respectiv thread-uri. Vor fi create, respectiv, 100 de procese și 100 de thread-uri.
</p>

<p>
Compilăm cele două programe folosind <code>make</code>. Rezultă două fișiere în format executabil: <code>process-overhead</code> și <code>thread-overhead</code>.
</p>

<p>
Pentru a măsura timpul de creare vom rula cele două executabile sub comanda <code>/usr/bin/time</code>:
</p>
<pre class="code bash"><span class="sy0">/</span>usr<span class="sy0">/</span>bin<span class="sy0">/</span><span class="kw1">time</span> <span class="re5">-v</span> .<span class="sy0">/</span>process-overhead  <span class="sy0">&gt;</span> <span class="sy0">/</span>dev<span class="sy0">/</span>null
<span class="sy0">/</span>usr<span class="sy0">/</span>bin<span class="sy0">/</span><span class="kw1">time</span> <span class="re5">-v</span> .<span class="sy0">/</span>thread-overhead  <span class="sy0">&gt;</span> <span class="sy0">/</span>dev<span class="sy0">/</span>null</pre>

<p>
Acum urmărim diferențele dintre output-ul celor două comenzi.
</p>

<p>
Observăm că timpul de creare al proceselor este 2 până la 3 ori mai mare decât în cazul thread-urilor. Și este încă foarte mic ținând cont de faptul că am creat 10000 de procese: 100 runde a câte 100 de procese. Deși timpul de creare a thread-urilor este mai mic, în termeni absoluți ambii timpi sunt neglijabili. Desigur, contează faptul că se realizează doar <code>fork</code>, fără <code>exec</code>. Mecanismul de copy-on-write aferent <code>fork</code> reduce semnificativ timpul de creare.
</p>

<p>
Observăm, de asemenea, că dimensiunea maximă a spațiului de memorie alocată (<em>Maximum resident set size</em>) este mai mare în cazul thread-urilor. Un thread nou creat ocupă spațiu suplimentar în memorie. Un proces nou creat va avea spațiul virtual creat propriu, dar, pentru început, va folosi spațiul de memorie fizică al primului proces, prin intermediul copy-on-write.
</p>

<p>
Diferențe sesizabile se observă în cazul numărului de page fault-uri și al schimbărilor de context involuntare. Schimbările de context involuntare (la schimbarea cuantei) sunt mai numeroase în cadrul proceselor întrucât se schimbă contextul procesului curent cu procesele pe care le creează. În cazul thread-urilor nu există schimbări de context între thread-uri, deoarece aparțin aceluiași proces. Numărul de page fault-uri în cadrul proceselor este cauzat de accesele de scriere proceselor noi peste zonele marcate copy-on-write. Sunt relativ puține accese, dar se resimt la nivelul numărului de page fault-uri.
</p>

</div>
<!-- EDIT3 SECTION "Timp de creare procese și thread-uri" [1417-3844] -->
<h3 class="sectionedit4" id="creare_de_thread-uri_si_spatiul_de_adresa">Creare de thread-uri și spațiul de adresă</h3>
<div class="level3">

<p>
Dorim să vedem cum afectează crearea thread-urilor spațiul de adresă al procesului. Pentru aceasta accesăm subdirectorul <code>address-space/</code>; urmărim conținutul fișierului <code>address-space.c</code>. În cadrul fișierului se creează 5 thread-uri. La începutul programului și după fiecare creare de thread se așteaptă apăsarea tastei <code>ENTER</code> de utilizator; în această vreme utilizatorul poate inspecta spațiul de adresă. Thread-urile afișează un mesaj simplu și apoi așteaptă <code>100</code> de secunde.
</p>

<p>
Compilăm codul sursă folosind comanda <code>make</code>. Rezultă executabilul <code>address-space</code>.
</p>

<p>
Rulăm executabilul:
</p>
<pre class="code bash">.<span class="sy0">/</span>address-space</pre>

<p>
Pentru a vizualiza spațiul de adrese al procesului, folosim comanda <code>pmap</code>. Deschidem o altă consolă și rulăm comanda <code>pmap</code> din output-ul căreia eliminăm referințele la biblioteci:
</p>
<pre class="code bash">pmap <span class="re5">-p</span> $<span class="br0">&#40;</span><span class="kw2">pidof</span> address-space<span class="br0">&#41;</span> <span class="sy0">|</span> <span class="kw2">grep</span> <span class="re5">-v</span> <span class="st_h">'/lib/'</span></pre>

<p>
Acum se afișează zonele de memorie aferente procesului înainte de crearea unui thread.
</p>

<p>
Apoi apăsăm <code>ENTER</code> în prima consolă. Acum se va crea un thread.
</p>

<p>
Investigăm din nou spațiul de adrese al procesului prin rularea comenzii <code>pmap</code> în forma de mai sus în a doua consolă. Observăm apariția unei zone de <code>8192K</code> (adică 8MB). Apăsăm iarăși <code>ENTER</code> în prima consolă și afișăm spațiul de adrese. Repetăm procesul de încă 3 ori până la crearea tuturor celor 5 thread-uri. Observăm că pentru fiecare thread au fost create două zone: o zonă de <code>8192K</code> cu permisiuni de citire și scriere și încă o pagină de gardă (<code>4K</code>) fără permisiuni.
</p>

<p>
Zona de <code>8192K</code> creată pentru fiecare thread este stiva acelui thread. Se rezervă spațiu virtual pentru stiva fiecărui thread la creare. Observăm că pe un sistem pe 32 de biți, cu dimensiune relativ scăzută a spațiului de adrese, o valoare implicită de <code>8192K</code> a stivei unui thread va limita numărul de thread-uri care pot fi create, întrucât se umple spațiul de adrese.<sup><a href="curs-08.html#fn__1" id="fnt__1" class="fn_top">1)</a></sup>
</p>

</div>
<!-- EDIT4 SECTION "Creare de thread-uri și spațiul de adresă" [3845-6116] -->
<h3 class="sectionedit5" id="partajare_informatie_intre_procese_si_thread-uri">Partajare informație între procese și thread-uri</h3>
<div class="level3">

<p>
Ne propunem să investigăm modul în care thread-urile partajează datele, iar procesele nu. Pentru aceasta accesăm subdirectorul <code>shared-data/</code>; urmărim conținutul fișierelor <code>process.c</code> și <code>thread.c</code>. În ambele fișiere se incrementează o variabilă globală (<code>data_var</code>) în cadrul unui proces nou și într-un thread nou. Variabila globală este inițializată la <code>0</code>.
</p>

<p>
Compilăm cele două programe folosind <code>make</code>. Rezultă două fișiere în format executabil: process și thread.
</p>

<p>
Rulăm cele două executabile:
</p>
<pre class="code bash">$ .<span class="sy0">/</span>process 
data_var = <span class="nu0">1</span>
data_var = <span class="nu0">1</span>
$ .<span class="sy0">/</span>thread 
data_var = <span class="nu0">1</span>
data_var = <span class="nu0">2</span></pre>

<p>
Observăm că procesele au o secțiune de date proprie; fiecare incrementare s-a făcut de la <code>0</code> la <code>1</code>. Thread-urile (aceluiași proces) partajează însă secțiunea de date. În acest caz thread-ul nou creat incrementează variabila de la <code>0</code> la <code>1</code>, pe când thread-ul inițial incrementează variabila de la <code>1</code> la <code>2</code>.
</p>

</div>
<!-- EDIT5 SECTION "Partajare informație între procese și thread-uri" [6117-7155] -->
<h3 class="sectionedit6" id="stiva_unui_thread_in_spatiul_de_adresa">Stiva unui thread în spațiul de adresă</h3>
<div class="level3">

<p>
Ne propunem să urmărim separația efectivă a stivelor thread-urilor aceluiași proces. Pentru aceasta accesăm subdirectorul <code>stack-access/</code>; urmărim conținutul fișierului <code>stack-access.c</code>. În cadrul fișierului se creează două thread-uri, unul care citește și altul care scrie într-o variabilă.
</p>

<p>
Programul este făcut în așa fel încât să se întâmple următoarea secvență:
</p>
<ol>
<li class="level1"><div class="li"> Thread-ul writer doarme preț de <code>2</code> secunde.</div>
</li>
<li class="level1"><div class="li"> Thread-ul reader inițializează variabila <code>local_var</code> la valoarea <code>0x11111111</code>.</div>
</li>
<li class="level1"><div class="li"> Thread-ul reader inițializează variabila globală <code>stack_var_pointer</code> la adresa variabilei <code>local_var</code>.</div>
</li>
<li class="level1"><div class="li"> Thread-ul reader afișează valoarea variabilei <code>local_var</code>.</div>
</li>
<li class="level1"><div class="li"> Thread-ul reader doarme preț de <code>5</code> secunde.</div>
</li>
<li class="level1"><div class="li"> Thread-ul writer modifică valorea zonei referite de <code>stack_var_pointer</code>, adică valoarea variabilei <code>local_var</code> la valoarea <code>0x22222222</code>.</div>
</li>
<li class="level1"><div class="li"> Thread-ul writer își încheie execuția.</div>
</li>
<li class="level1"><div class="li"> Thread-ul reader afișează valoarea variabilei <code>local_var</code>.</div>
</li>
</ol>

<p>
Programul de față arată că un thread poate accesa și scrie fără nici o problemă pe stiva altui thread cât timp știe unde este stiva (sau variabila de pe stivă). În cazul de față este vorba de variabila <code>local_var</code> locală thread-ului reader; adresa acestei variabile este stocată în variabila globală de tip pointer <code>stack_var_pointer</code> accesibilă și thread-ului writer.
</p>

<p>
Pentru a testa programul compilăm folosind <code>make</code>. Obținem fișierul în format executabil <code>stack-access</code> pe care îl rulăm:
</p>
<pre class="code bash">$ .<span class="sy0">/</span>stack-access 
writer: going to <span class="kw2">sleep</span> <span class="kw1">for</span> <span class="nu0">2</span> seconds ...
reader: local_var is 0x11111111, local_var address is: 0x7fcaf4f90f4c
reader: going to <span class="kw1">for</span> <span class="nu0">5</span> seconds ...
writer: <span class="kw2">write</span> 0x22222222 to reader local_var <span class="br0">&#40;</span>address is 0x7fcaf4f90f4c<span class="br0">&#41;</span>
writer: end execution
reader: local_var is 0x22222222
reader: end execution</pre>

<p>
Observăm că, la final, thread-ul reader a afișat valoarea variabilei locale (de pe stiva sa) <code>local_var</code> iar valoarea acesteia este <code>0x22222222</code>, valoare stabilită de thread-ul writer. Thread-ul writer a reușit să scrie în stiva thread-ului reader. Acest lucru este posibil pentru că thread-urile partajează spațiul de adrese al procesului din care fac parte; deși fiecare thread are stiva sa, accesul unui thread la stiva altuia nu este protejat de sistemul de operare; ambele stive se găsesc în același spațiu de adresă și orice thread le poate modifica pe oricare dintre ele.
</p>

</div>
<!-- EDIT6 SECTION "Stiva unui thread în spațiul de adresă" [7156-9704] -->
<h3 class="sectionedit7" id="utilitate_apeluri_reentrante">Utilitate apeluri reentrante</h3>
<div class="level3">

<p>
Dorim să validăm importanța apelurilor reentrante în lucrul cu thread-uri. Pentru aceasta accesăm subdirectorul <code>reentrant/</code>; parcurgem fișierul cod sursă <code>rentrant.c</code>. Fișierul creează <code>NUM_THREADS</code> thread-uri și timp de <code>NUM_THREADS</code> runde apelează funcția nereentrantă <a href="http://man7.org/linux/man-pages/man3/ctime.3.html" class="urlextern" title="http://man7.org/linux/man-pages/man3/ctime.3.html"  rel="nofollow">ctime</a> sau varianta reentrantă a acesteia <a href="http://man7.org/linux/man-pages/man3/ctime.3.html" class="urlextern" title="http://man7.org/linux/man-pages/man3/ctime.3.html"  rel="nofollow">ctime_r</a>.
</p>

<p>
Compilăm programul folosind comanda <code>make</code>. În urma compilării rezultă două fișiere în format executabil:
</p>
<ul>
<li class="level1"><div class="li"> Fișierul <code>reentrant</code> folosește funcția <code>ctime</code> (varianta nereentrantă).</div>
</li>
<li class="level1"><div class="li"> Fișierul <code>reentrant-ok</code> folosește funcția <code>ctime_r</code> (varianta reentrantă).</div>
</li>
</ul>

<p>
Rulăm cele două executabile cu redirectarea output-ului într-un fișier:
</p>
<pre class="code bash">.<span class="sy0">/</span>reentrant <span class="sy0">&gt;</span> out
.<span class="sy0">/</span>reentrant-ok <span class="sy0">&gt;</span> out-ok</pre>

<p>
Urmărim diferențele între cele două fișiere:
</p>
<pre class="code bash">$ <span class="kw2">ls</span> <span class="re5">-l</span>
total <span class="nu0">9596</span>
<span class="br0">&#91;</span>...<span class="br0">&#93;</span> <span class="nu0">4780850</span> Apr  <span class="nu0">8</span> 00:<span class="nu0">47</span> out
<span class="br0">&#91;</span>...<span class="br0">&#93;</span> <span class="nu0">4992000</span> Apr  <span class="nu0">8</span> 00:<span class="nu0">48</span> out-ok</pre>

<p>
Observăm că fișierul de ieșire în cazul executabilului cu varianta nereentrantă are dimensiunea mai mică, deci absența reentranței a cauzat incoerența datelor obținute. Acest lucru se întâmplă întrucât, în momentul în care un thread folosește funcția <code>printf</code> pentru a afișa bufferul <code>str_time[i]</code> un alt thread îl poate modifica chiar în acel moment, iar datele devin incoerente.
</p>

<p>
Dacă folosim comanda <code>file</code> vom vedea că se raportează că fișierul <code>out</code> este conținut binar, încă o dovadă a incoerenței informațiilor furnizate:
</p>
<pre class="code bash">$ <span class="kw2">file</span> out
out: data
$ <span class="kw2">file</span> out-ok 
out-ok: ASCII text</pre>

<p>
În cazul folosirii programelor cu thread-uri, trebuie folosite versiunile reentrante ale funcțiilor de bibliotecă.
</p>

</div>
<!-- EDIT7 SECTION "Utilitate apeluri reentrante" [9705-] --><div class="footnotes">
<div class="fn"><sup><a href="curs-08.html#fnt__1" id="fn__1" class="fn_bot">1)</a></sup> 
Dimensiunea la creare a stivei unui thread poate fi schimbată de la valoarea implicită cu ajutorul apelului <a href="http://man7.org/linux/man-pages/man3/pthread_attr_setstacksize.3.html" class="urlextern" title="http://man7.org/linux/man-pages/man3/pthread_attr_setstacksize.3.html"  rel="nofollow">pthread_attr_setstacksize</a>.</div>
</div>
</div>
</body>
</html>
