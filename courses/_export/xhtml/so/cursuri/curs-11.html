    
    

<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
  <meta charset="utf-8" />
  <title>so:cursuri:curs-11</title>
<meta name="generator" content="DokuWiki"/>
<meta name="robots" content="index,follow"/>
<meta name="date" content="2016-05-22T12:24:46+0300"/>
<meta name="keywords" content="so,cursuri,curs-11"/>
<link rel="search" type="application/opensearchdescription+xml" href="../../../../lib/exe/opensearch.php" title="CS Open CourseWare"/>
<link rel="start" href="../../../../../courses.1.html"/>
<link rel="alternate" type="application/rss+xml" title="Recent Changes" href="../../../../feed.php"/>
<link rel="alternate" type="application/rss+xml" title="Current Namespace" href="../../../../feed.php%3Fmode=list&amp;ns=so:cursuri"/>
<link rel="alternate" type="text/html" title="Plain HTML" href="curs-11.html"/>
<link rel="canonical" href="../../../../so/cursuri/curs-11.html"/>
<link rel="stylesheet" type="text/css" href="../../../../lib/exe/css.php%3Ft=arctic&amp;tseed=1476798676.css"/>
<script type="text/javascript">/*<![CDATA[*/var NS='so:cursuri';var JSINFO = {"id":"so:cursuri:curs-11","namespace":"so:cursuri","isadmin":0,"isauth":0};
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="../../../../lib/exe/js.php%3Ftseed=1476798676"></script>
<script type="text/x-mathjax-config">/*<![CDATA[*/MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ["$","$"], ["\\(","\\)"] ],
        displayMath: [ ["$$","$$"], ["\\[","\\]"] ],
        processEscapes: true
    }
});
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
<script type="text/javascript">/*<![CDATA[*/
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
		  
/*!]]>*/</script>
<script type="text/javascript">/*<![CDATA[*/
var pageTracker = _gat._getTracker("UA-38383934-1");
pageTracker._initData();
pageTracker._trackPageview();
		  
/*!]]>*/</script>
</head>
<body>
<div class="dokuwiki export">
<!-- TOC START -->
<div id="dw__toc">
<h3 class="toggle">Table of Contents</h3>
<div>

<ul class="toc">
<li class="level1"><div class="li"><a href="curs-11.html#curs_11_-_networking_in_sistemul_de_operare">Curs 11 - Networking în sistemul de operare</a></div>
<ul class="toc">
<li class="level2"><div class="li"><a href="curs-11.html#demo-uri">Demo-uri</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="curs-11.html#pregatire_infrastructura">Pregătire infrastructură</a></div></li>
<li class="level3"><div class="li"><a href="curs-11.html#folosire_server">Folosire server</a></div></li>
<li class="level3"><div class="li"><a href="curs-11.html#folosire_alte_servere">Folosire alte servere</a></div></li>
<li class="level3"><div class="li"><a href="curs-11.html#concluzii">Concluzii</a></div></li>
</ul></li>
</ul></li>
</ul>
</div>
</div>
<!-- TOC END -->

<h1 class="sectionedit1" id="curs_11_-_networking_in_sistemul_de_operare">Curs 11 - Networking în sistemul de operare</h1>
<div class="level1">

<p>

    <iframe src="http://docs.google.com/viewer?url=http://elf.cs.pub.ro/so/res/cursuri/SO_Curs-11.pdf&embedded=true" width="600" height="480" style="border: none;">
    </iframe>

</p>
<ul>
<li class="level1"><div class="li"> <a href="http://elf.cs.pub.ro/so/res/cursuri/SO_Curs-11.pdf" class="urlextern" title="http://elf.cs.pub.ro/so/res/cursuri/SO_Curs-11.pdf"  rel="nofollow">Curs 11 - Networking în sistemul de operare (PDF)</a></div>
</li>
</ul>
<ul>
<li class="level1"><div class="li"> Suport curs</div>
<ul>
<li class="level2"><div class="li"> The Illustrated Network (Walter Goralski)</div>
<ul>
<li class="level3"><div class="li"> Capitolele 11 și 12</div>
</li>
</ul>
</li>
<li class="level2"><div class="li"> The Linux Programming Interface</div>
<ul>
<li class="level3"><div class="li"> Capitolele 58, 60 și 61</div>
</li>
</ul>
</li>
</ul>
</li>
</ul>

</div>
<!-- EDIT1 SECTION "Curs 11 - Networking în sistemul de operare" [1-531] -->
<h2 class="sectionedit2" id="demo-uri">Demo-uri</h2>
<div class="level2">

<p>
Pentru parcurgerea demo-urilor, folosim <a href="http://elf.cs.pub.ro/so/res/cursuri/curs-11-demo.zip" class="urlextern" title="http://elf.cs.pub.ro/so/res/cursuri/curs-11-demo.zip"  rel="nofollow">arhiva aferentă</a>. Demo-urile rulează pe Linux. Descărcăm arhiva folosind comanda
</p>
<pre class="code bash"><span class="kw2">wget</span> http:<span class="sy0">//</span>elf.cs.pub.ro<span class="sy0">/</span>so<span class="sy0">/</span>res<span class="sy0">/</span>cursuri<span class="sy0">/</span>curs-<span class="nu0">11</span>-demo.zip</pre>

<p>
 și apoi decomprimăm arhiva
</p>
<pre class="code bash"><span class="kw2">unzip</span> curs-<span class="nu0">11</span>-demo.zip</pre>

<p>
 și accesăm directorul rezultat în urma decomprimării
</p>
<pre class="code bash"><span class="kw3">cd</span> curs-<span class="nu0">11</span>-demo<span class="sy0">/</span></pre>

<p>
Acum putem parcurge secțiunile cu demo-uri de mai jos.
</p>

</div>
<!-- EDIT2 SECTION "Demo-uri" [532-1033] -->
<h3 class="sectionedit3" id="pregatire_infrastructura">Pregătire infrastructură</h3>
<div class="level3">

<p>
Ne propunem să urmărim modul în care se comportă comunicația între un client și un server pentru un număr mare de conexiuni și diverse configurații ale serverului. Vom varia dimensiunea bufferului de transmitere folosit de server și tipurile de implementare pentru server:
</p>
<ul>
<li class="level1"><div class="li"> server simplu</div>
</li>
<li class="level1"><div class="li"> server cu suport <a href="http://man7.org/linux/man-pages/man2/sendfile.2.html" class="urlextern" title="http://man7.org/linux/man-pages/man2/sendfile.2.html"  rel="nofollow">sendfile</a> (<em>zero copy</em>)</div>
</li>
<li class="level1"><div class="li"> server multithreaded</div>
</li>
<li class="level1"><div class="li"> server event-based (folosește <a href="http://man7.org/linux/man-pages/man7/epoll.7.html" class="urlextern" title="http://man7.org/linux/man-pages/man7/epoll.7.html"  rel="nofollow">epoll</a>)</div>
</li>
</ul>

<p>
Pentru început vom genera 10.000 (zece mii) de fișiere a câte 100 KB. Vom rula scriptul
</p>
<pre class="code bash">.<span class="sy0">/</span>create-files</pre>

<p>
Scriptul va dura câteva minute și va genera fișierele în forma <code>fileXYZT</code> în subdirectorul <code>in-data/</code>. Aceste fișiere vor fi prelucrate de server.
</p>

<p>
Pentru a obține executabilele de tip server aferente, vom folosi fișierul <code>Makefile</code>:
</p>
<pre class="code bash"><span class="kw2">make</span></pre>

<p>
În urma rulării comenzii <code>make</code> rezultă patru fișiere executabile de tip server:
</p>
<ul>
<li class="level1"><div class="li"> <code>server</code>: executabil de tip server simplu</div>
</li>
<li class="level1"><div class="li"> <code>sendfile-server</code>: executabil de tip server cu suport <a href="http://man7.org/linux/man-pages/man2/sendfile.2.html" class="urlextern" title="http://man7.org/linux/man-pages/man2/sendfile.2.html"  rel="nofollow">sendfile</a> (<em>zero copy</em>)</div>
</li>
<li class="level1"><div class="li"> <code>threaded-server</code>: server multithreaded</div>
</li>
<li class="level1"><div class="li"> <code>epoll-server</code>: server event-based</div>
</li>
</ul>

<p>
În continuare vom folosi fiecare dintre aceste servere pentru transferul celor 10.000 de fișiere create. Vom exemplifica în secțiunea de mai jos pentru serverul simplu (dat de executabilul <code>server</code>) urmând ca aceeași pași să fie urmați și pentru celelalte trei servere.
</p>

</div>
<!-- EDIT3 SECTION "Pregătire infrastructură" [1034-2644] -->
<h3 class="sectionedit4" id="folosire_server">Folosire server</h3>
<div class="level3">

<p>
Vom exemplifica scenariul de folosire a unui server pe fișierul <code>server.c</code> și executabilul aferent <code>server</code>. În cadrul acestui fișier se creează un socket TCP de tip listener care apoi așteaptă, secvențial, cereri de la clienți și le execută <strong>secvențial</strong>.
</p>

<p>
Presupunem că avem cele 10.000 de fișiere create în subdirectorul <code>in-data/</code>. Serverul va aștepta conexiuni în care i se va preciza numele fișierelor pe care trebuie să le servească (unul pe conexiune).
</p>

<p>
Pentru început pornim serverul:
</p>
<pre class="code bash">.<span class="sy0">/</span>server</pre>

<p>
Acum serverul este în starea de așteptare de conexiuni.
</p>

<p>
Pentru a genera conexiuni care să citească toate fișierele din subdirectorul <code>in-data/</code>, rulăm, într-o altă consolă, scriptul aferent:
</p>
<pre class="code bash"><span class="sy0">/</span>usr<span class="sy0">/</span>bin<span class="sy0">/</span><span class="kw1">time</span> <span class="re5">-v</span> .<span class="sy0">/</span>download-serial</pre>

<p>
Scriptul va dura de ordinul minutelor. Ca urmare a rulării acestui script fișierele vor fi transferate, prin sockeți locali (<em>localhost</em>) în subdirectorul <code>out-data/</code>. Putem verifica transferul corect al acestora cu ajutorul comenzii:
</p>
<pre class="code bash"><span class="kw2">diff</span> <span class="re5">-r</span> in-data<span class="sy0">/</span> out-data<span class="sy0">/</span></pre>

<p>
Pentru a eficientiza transferul în partea clientului putem porni mai multe procese cu ajutorul scriptului
</p>
<pre class="code bash"><span class="sy0">/</span>usr<span class="sy0">/</span>bin<span class="sy0">/</span><span class="kw1">time</span> <span class="re5">-v</span> .<span class="sy0">/</span>download-parallel</pre>

<p>
Scriptul va dura semnificativ mai puțin.
</p>

<p>
Motivul este că serverul livrează foarte rapid fișierele (sunt mici și multe) și este mai eficient să vină mai multe cereri simultane pentru a le servi. Nu la fel ar fi stat lucrurile dacă erau fișiere mai mari și mai puține.
</p>

<p>
Durata mare a rulării scriptului este datorată dimensiunii foarte mici a bufferului folosit în userspace pentru transfer. Observați în output-ul scripturile de mai sus numărul mare de schimbări de context realizate. Pentru a eficientiza acest lucru, vom altera dimensiunea bufferului, adică macro-ul <code>BUFFERSIZE</code> de la valoarea <code>10</code> la valoarea <code>8192</code>. Vom recompila:
</p>
<pre class="code bash"><span class="kw2">make</span></pre>

<p>
și apoi vom rula din nou cele două scripturi de download
</p>
<pre class="code bash"><span class="sy0">/</span>usr<span class="sy0">/</span>bin<span class="sy0">/</span><span class="kw1">time</span> <span class="re5">-v</span> .<span class="sy0">/</span>download-serial
<span class="sy0">/</span>usr<span class="sy0">/</span>bin<span class="sy0">/</span><span class="kw1">time</span> <span class="re5">-v</span> .<span class="sy0">/</span>download-parallel</pre>

<p>
Observăm că timpii au scăzut considerabil, la fel ca numărul de schimbări de context.
</p>

</div>
<!-- EDIT4 SECTION "Folosire server" [2645-4860] -->
<h3 class="sectionedit5" id="folosire_alte_servere">Folosire alte servere</h3>
<div class="level3">

<p>
Aceeași pași ca mai sus pot fi realizați pentru celelalte trei servere:
</p>
<ul>
<li class="level1"><div class="li"> <code>sendfile-server</code></div>
</li>
<li class="level1"><div class="li"> <code>threaded-server</code></div>
</li>
<li class="level1"><div class="li"> <code>epoll-server</code></div>
</li>
</ul>

<p>
În cazul <code>sendfile-server</code>, fiind vorba de un transfer tip zero-copy, nu avem o dimensiune de buffer aferentă; acesta nu va putea fi variată.
</p>

</div>
<!-- EDIT5 SECTION "Folosire alte servere" [4861-5185] -->
<h3 class="sectionedit6" id="concluzii">Concluzii</h3>
<div class="level3">

<p>
În mod obișnuit serverul simplu (<code>server</code>) ar trebui să aibă un comportament mai slab decât celelalte, lucru greu sesizabil în secțiunile de mai sus din câteva motive:
</p>
<ul>
<li class="level1"><div class="li"> Testele se desfășoară pe sistemul local, adică nu se resimte impactul rețelei.</div>
</li>
<li class="level1"><div class="li"> Testele se desfășoară pe sistemul local, adică toate procesele client și server rulează pe același procesor și cu același disc.</div>
</li>
<li class="level1"><div class="li"> Testele nu permit cu adevărat concurența mai multor conexiuni venite de la diverse stații pe Internet. Un server încărcat poate primi cvasi-simultan mii de conexiuni, moment în care varianta threaded sau event-based își dovedesc superioritatea.</div>
</li>
<li class="level1"><div class="li"> Pentru teste am folosit fișiere mici și multe. Asta înseamnă că un fișier este transmis instant și chiar un server cu funcționarea paralelă nu va dobândi un avantaj față de unul cu funcționare serială.</div>
</li>
</ul>

<p>
Abordările de îmbunătățire a serverului nu se exclud. Putem avea un server multithreaded sau multiproces în care fiecare thread se ocupă de un număr dat de conexiuni pe care le gestionează folosind <code>epoll</code> sau un <abbr title="Application Programming Interface">API</abbr> echivalent. De obicei numărul de thread-uri sau procese va fi egal cu numărul de core-uri/hyperthread-uri disponibile la nivelul sistemului pentru a folosi eficient resursele acestuia. De asemenea, pentru servire de conținut static, cu dimensiune precizată, se poate folosi <code>sendfile</code> pentru a delega transferul complet către nucleul sistemului de operare și a eficientiza și mai mult transferul.
</p>

<p>
Un server care se dorește performant va fi supus benchmark-urilor și analizei atente a traficului pe care îl susține. Funcții de cazurile uzuale de folosire, serverul poate fi ajustat (<em>tuned</em>) pentru a servi cât mai eficient conținutul dorit.
</p>

</div>
<!-- EDIT6 SECTION "Concluzii" [5186-] --></div>
</body>
</html>
