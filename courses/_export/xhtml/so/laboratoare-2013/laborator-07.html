    
    

<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
  <meta charset="utf-8" />
  <title>so:laboratoare-2013:laborator-07</title>
<meta name="generator" content="DokuWiki"/>
<meta name="robots" content="index,follow"/>
<meta name="date" content="2014-03-05T22:19:57+0200"/>
<meta name="keywords" content="so,laboratoare-2013,laborator-07"/>
<link rel="search" type="application/opensearchdescription+xml" href="../../../../lib/exe/opensearch.php" title="CS Open CourseWare"/>
<link rel="start" href="../../../../../courses.1.html"/>
<link rel="alternate" type="application/rss+xml" title="Recent Changes" href="../../../../feed.php"/>
<link rel="alternate" type="application/rss+xml" title="Current Namespace" href="../../../../feed.php%3Fmode=list&amp;ns=so:laboratoare-2013"/>
<link rel="alternate" type="text/html" title="Plain HTML" href="laborator-07.html"/>
<link rel="canonical" href="../../../../so/laboratoare-2013/laborator-07.html"/>
<link rel="stylesheet" type="text/css" href="../../../../lib/exe/css.php%3Ft=arctic&amp;tseed=1476798676.css"/>
<script type="text/javascript">/*<![CDATA[*/var NS='so:laboratoare-2013';var JSINFO = {"id":"so:laboratoare-2013:laborator-07","namespace":"so:laboratoare-2013","isadmin":0,"isauth":0};
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="../../../../lib/exe/js.php%3Ftseed=1476798676"></script>
<script type="text/x-mathjax-config">/*<![CDATA[*/MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ["$","$"], ["\\(","\\)"] ],
        displayMath: [ ["$$","$$"], ["\\[","\\]"] ],
        processEscapes: true
    }
});
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
<script type="text/javascript">/*<![CDATA[*/
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
		  
/*!]]>*/</script>
<script type="text/javascript">/*<![CDATA[*/
var pageTracker = _gat._getTracker("UA-38383934-1");
pageTracker._initData();
pageTracker._trackPageview();
		  
/*!]]>*/</script>
</head>
<body>
<div class="dokuwiki export">
<!-- TOC START -->
<div id="dw__toc">
<h3 class="toggle">Table of Contents</h3>
<div>

<ul class="toc">
<li class="level1"><div class="li"><a href="laborator-07.html#laborator_07_-_memoria_virtuala">Laborator 07 - Memoria virtuală</a></div>
<ul class="toc">
<li class="level2"><div class="li"><a href="laborator-07.html#materiale_ajutatoare">Materiale ajutătoare</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="laborator-07.html#nice_to_read">Nice to read</a></div></li>
</ul>
</li>
<li class="level2"><div class="li"><a href="laborator-07.html#memoria_virtuala">Memoria virtuală</a></div></li>
<li class="level2"><div class="li"><a href="laborator-07.html#linux">Linux</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="laborator-07.html#maparea_fisierelor">Maparea fișierelor</a></div>
<ul class="toc">
<li class="level4"><div class="li"><a href="laborator-07.html#section"></a></div></li>
<li class="level4"><div class="li"><a href="laborator-07.html#mmap">mmap</a></div></li>
<li class="level4"><div class="li"><a href="laborator-07.html#msync">msync</a></div></li>
</ul>
</li>
<li class="level3"><div class="li"><a href="laborator-07.html#alocare_de_memorie_in_spatiul_de_adresa_al_procesului">Alocare de memorie în spațiul de adresă al procesului</a></div></li>
<li class="level3"><div class="li"><a href="laborator-07.html#maparea_dispozitivelor">Maparea dispozitivelor</a></div></li>
<li class="level3"><div class="li"><a href="laborator-07.html#demaparea_unei_zone_din_spatiul_de_adresa">Demaparea unei zone din spațiul de adresă</a></div></li>
<li class="level3"><div class="li"><a href="laborator-07.html#redimensionarea_unei_zone_mapate">Redimensionarea unei zone mapate</a></div></li>
<li class="level3"><div class="li"><a href="laborator-07.html#schimbarea_protectiei_unei_zone_mapate">Schimbarea protecției unei zone mapate</a></div></li>
<li class="level3"><div class="li"><a href="laborator-07.html#exemplu">Exemplu</a></div></li>
<li class="level3"><div class="li"><a href="laborator-07.html#optimizari">Optimizări</a></div></li>
<li class="level3"><div class="li"><a href="laborator-07.html#blocarea_paginarii">Blocarea paginării</a></div></li>
<li class="level3"><div class="li"><a href="laborator-07.html#exceptii">Excepții</a></div></li>
<li class="level3"><div class="li"><a href="laborator-07.html#electricfence">ElectricFence</a></div></li>
</ul>
</li>
<li class="level2"><div class="li"><a href="laborator-07.html#windows">Windows</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="laborator-07.html#maparea_fisierelor1">Maparea fișierelor</a></div></li>
<li class="level3"><div class="li"><a href="laborator-07.html#alocare_de_memorie_in_spatiul_de_adresa_al_procesului1">Alocare de memorie în spațiul de adresă al procesului</a></div></li>
<li class="level3"><div class="li"><a href="laborator-07.html#demaparea_unei_zone_din_spatiul_de_adresa1">Demaparea unei zone din spațiul de adresă</a></div></li>
<li class="level3"><div class="li"><a href="laborator-07.html#schimbarea_protectiei_unei_zone_mapate1">Schimbarea protecției unei zone mapate</a></div></li>
<li class="level3"><div class="li"><a href="laborator-07.html#interogarea_zonelor_mapate">Interogarea zonelor mapate</a></div></li>
<li class="level3"><div class="li"><a href="laborator-07.html#blocarea_paginarii1">Blocarea paginării</a></div></li>
<li class="level3"><div class="li"><a href="laborator-07.html#exceptii1">Excepții</a></div></li>
</ul>
</li>
<li class="level2"><div class="li"><a href="laborator-07.html#exercitii">Exerciții</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="laborator-07.html#linux1">Linux</a></div></li>
<li class="level3"><div class="li"><a href="laborator-07.html#bonus_linux">Bonus Linux</a></div></li>
<li class="level3"><div class="li"><a href="laborator-07.html#windows1">Windows</a></div></li>
<li class="level3"><div class="li"><a href="laborator-07.html#extra">EXTRA</a></div></li>
</ul>
</li>
<li class="level2"><div class="li"><a href="laborator-07.html#solutii">Soluții</a></div></li>
<li class="level2"><div class="li"><a href="laborator-07.html#resurse_utile">Resurse Utile</a></div></li>
</ul></li>
</ul>
</div>
</div>
<!-- TOC END -->

<h1 class="sectionedit1" id="laborator_07_-_memoria_virtuala">Laborator 07 - Memoria virtuală</h1>
<div class="level1">

</div>
<!-- EDIT1 SECTION "Laborator 07 - Memoria virtuală" [1-49] -->
<h2 class="sectionedit2" id="materiale_ajutatoare">Materiale ajutătoare</h2>
<div class="level2">
<ul>
<li class="level1"><div class="li"><a href="http://elf.cs.pub.ro/so/res/laboratoare/lab07-slides.pdf" class="urlextern" title="http://elf.cs.pub.ro/so/res/laboratoare/lab07-slides.pdf"  rel="nofollow"> lab07-slides.pdf</a></div>
</li>
<li class="level1"><div class="li"><a href="http://elf.cs.pub.ro/so/res/laboratoare/lab07-refcard.pdf" class="urlextern" title="http://elf.cs.pub.ro/so/res/laboratoare/lab07-refcard.pdf"  rel="nofollow"> lab07-refcard.pdf</a></div>
</li>
</ul>

</div>
<!-- EDIT2 SECTION "Materiale ajutătoare" [50-253] -->
<h3 class="sectionedit3" id="nice_to_read">Nice to read</h3>
<div class="level3">
<ul>
<li class="level1"><div class="li"> TLPI - Chapter 49, Memory mappings </div>
</li>
<li class="level1"><div class="li"> TLPI - Chapter 50, Virtual memory operations</div>
</li>
</ul>

</div>
<!-- EDIT3 SECTION "Nice to read" [254-367] -->
<h2 class="sectionedit4" id="memoria_virtuala">Memoria virtuală</h2>
<div class="level2">

<p>
Mecanismul de memorie virtuală este folosit de către nucleul sistemului de operare pentru a implementa o politică eficientă de gestiune a memoriei. Astfel, cu toate că aplicațiile folosesc în mod curent memoria virtuală, ele nu fac acest lucru în mod explicit. Există însă câteva cazuri în care aplicațiile folosesc memoria virtuală în mod explicit.
</p>

<p>
Sistemul de operare oferă primitive de mapare a fișierelor, a memoriei sau a dispozitivelor în spațiul de adresă al unui proces.
</p>
<ul>
<li class="level1"><div class="li"><strong>Maparea fișierelor</strong> în memorie este folosită în unele sisteme de operare pentru a implementa mecanisme de memorie partajată. De asemenea, acest mecanism face posibilă implementarea paginării la cerere și a bibliotecilor partajate.</div>
</li>
<li class="level1"><div class="li"><strong>Maparea memoriei</strong> în spațiul de adresă este folositoare atunci când un proces dorește să aloce o cantitate mare de memorie.</div>
</li>
<li class="level1"><div class="li"><strong>Maparea dispozitivelor</strong> este folositoare atunci când un proces dorește să folosească direct memoria unui dispozitiv cum ar fi placa video.</div>
</li>
</ul>

</div>
<!-- EDIT4 SECTION "Memoria virtuală" [368-1430] -->
<h2 class="sectionedit5" id="linux">Linux</h2>
<div class="level2">

<p>
Funcțiile cu ajutorul cărora se pot face cereri explicite asupra memoriei virtuale sunt funcțiile din familia <code>mmap(2)</code>. Funcțiile folosesc ca unitate minimă de alocare pagina (adică se poate aloca numai un număr întreg de pagini, iar adresele trebuie să fie aliniate corespunzător).
</p>

</div>
<!-- EDIT5 SECTION "Linux" [1431-1746] -->
<h3 class="sectionedit6" id="maparea_fisierelor">Maparea fișierelor</h3>
<div class="level3">

<p>
În urma mapării unui fișier în spațiul de adresă al unui proces, accesul la acest fișier se poate face similar cu accesarea datelor dintr-un vector. Eficiența metodei vine din faptul că zona de memorie este gestionată similar cu memoria virtuală, supunându-se regulilor de evacuare pe disc atunci când memoria devine insuficientă (în felul acesta se poate lucra cu mapări care depășesc dimensiunea efectivă a memoriei fizice). Mai mult, partea de <code>I/O</code> este realizată de către kernel, programatorul scriind cod care doar preia/stochează valori în regiunea mapată. Astfel nu se mai apelează <code>read</code>, <code>write</code>, <code>lseek</code> - ceea ce adesea simplifică scrierea codului.
</p>

<p>
<strong> Observație </strong>
</p>

</div>
<div class="level4">

<p>
Nu orice descriptor de fișier poate fi mapat în memorie. Socket-urile, pipe-urile, majoritatea dispozitivelor nu permit decât accesul secvențial și sunt incompatibile din această cauză cu conceptele de mapare. Există cazuri în care fișiere obișnuite nu pot fi mapate (spre exemplu, dacă nu au fost deschise pentru a putea fi citite; pentru mai multe informații: <strong>man mmap</strong>).
</p>

</div>

<h4 id="mmap">mmap</h4>
<div class="level4">

<p>
Prototipul funcției <a href="http://linux.die.net/man/2/mmap" class="urlextern" title="http://linux.die.net/man/2/mmap"  rel="nofollow">mmap</a> ce permite maparea unui fișier în spațiul de adresă al unui proces este următorul:
</p>
<pre class="code cpp"><span class="kw4">void</span> <span class="sy2">*</span>mmap<span class="br0">&#40;</span><span class="kw4">void</span> <span class="sy2">*</span>start, <span class="kw4">size_t</span> length, <span class="kw4">int</span> prot, <span class="kw4">int</span> flags, <span class="kw4">int</span> fd, off_t offset<span class="br0">&#41;</span><span class="sy4">;</span></pre>

<p>
Funcția va întoarce în caz de eroare <code>MAP_FAILED</code>. Dacă maparea s-a făcut cu succes, va întoarce un pointer spre o zonă de memorie din spațiul de adresă al procesului, zonă în care a fost mapat fișierul descris de descriptorul <code>fd</code>, începând cu offset-ul <code>offset</code>. Folosirea parametrului <code>start</code> permite propunerea unei anumite zone de memorie la care să se facă maparea. Folosirea valorii <code>NULL</code> pentru parametrul <code>start</code> indică lipsa vreunei preferințe în ceea ce privește zona în care se va face alocarea. Adresa precizată prin parametrul <code>start</code> trebuie să fie multiplu de <em>dimensiunea unei pagini</em>. Dacă sistemul de operare nu poate să mapeze fișierul la adresa cerută, atunci îl va mapa la altă adresă apropiată multiplu de dimensiunea unei pagini. Adresa la care se mapează fișierul este întoarsă de funcție. 
</p>

<p>
Parametrul <code>prot</code> specifică tipul de acces care se dorește; poate fi <code>PROT_READ</code>, <code>PROT_WRITE</code>, <code>PROT_EXEC</code> sau <code>PROT_NONE</code>; dacă zona e folosită altfel decât s-a declarat se va genera un semnal <code>SIGSEGV</code>.
</p>

<p>
Parametrul <code>flags</code> permite stabilirea tipului de mapare ce se dorește; poate lua următoarele valori (combinate prin SAU pe biți; trebuie să existe cel puțin una: fie <code>MAP_PRIVATE</code>, fie <code>MAP_SHARED</code>):
</p>
<ul>
<li class="level1"><div class="li"><code>MAP_PRIVATE</code> - se folosește o politică de tip copy-on-write; zona va conține inițial o copie a fișierului, dar scrierile nu sunt făcute în fișier; modificările nu vor fi vizibile în alte procese dacă există mai multe procese care au făcut <code>mmap</code> pe aceeași zonă din același fișier</div>
</li>
<li class="level1"><div class="li"><code>MAP_SHARED</code> - scrierile sunt actualizate imediat în toate mapările existente (în acest fel toate procesele care au realizat mapări vor vedea modificările); pentru ca modificările să fie vizibile și pentru un proces ce utilizează read/write se poate folosi <code>msync</code>; altfel actualizarea va avea loc la un moment de timp nespecificat</div>
</li>
<li class="level1"><div class="li"><code>MAP_FIXED</code> - dacă nu se poate face alocarea la adresa specificată de <code>start</code>, apelul va eșua</div>
</li>
<li class="level1"><div class="li"><code>MAP_LOCKED</code> - se va bloca paginarea pe această zonă, în maniera <a href="http://linux.die.net/man/2/mlock" class="urlextern" title="http://linux.die.net/man/2/mlock"  rel="nofollow">mlock</a></div>
</li>
<li class="level1"><div class="li"><code>MAP_ANONYMOUS</code> - se mapează memorie (argumentele <code>fd</code> și <code>offset</code> sunt ignorate)</div>
</li>
</ul>

<p>
 Este de remarcat că folosirea <code>MAP_SHARED</code> permite partajarea memoriei între procese care nu sunt înrudite. În acest caz, conținutul fișierului devine conținutul inițial al memoriei partajate, și orice modificare făcută de procese în această zonă este copiată apoi în fișier, asigurând persistență prin sistemul de fișiere.  
</p>

</div>

<h4 id="msync">msync</h4>
<div class="level4">

<p>
Pentru a declanșa în mod explicit sincronizarea fișierului cu maparea din memorie este disponibilă funcția <a href="http://linux.die.net/man/2/msync" class="urlextern" title="http://linux.die.net/man/2/msync"  rel="nofollow">msync</a>:
</p>
<pre class="code c"><span class="kw4">int</span> msync<span class="br0">&#40;</span><span class="kw4">void</span> <span class="sy0">*</span>start<span class="sy0">,</span> <span class="kw4">size_t</span> length<span class="sy0">,</span> <span class="kw4">int</span> flags<span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>
unde <code>flags</code> poate fi:
</p>
<ul>
<li class="level1"><div class="li"><code>MS_SYNC</code> - datele vor fi scrise în fișier și după aceea funcția se va termina.</div>
</li>
<li class="level1"><div class="li"><code>MS_ASYNC</code> - este inițiată secvența de salvare, dar nu se așteaptă terminarea ei.</div>
</li>
<li class="level1"><div class="li"><code>MS_INVALIDATE</code> - se invalidează mapările zonei din alte procese, pentru a forța recitirea paginii în toate celelalte procese la următorul acces.</div>
</li>
</ul>

</div>
<!-- EDIT6 SECTION "Maparea fișierelor" [1747-6386] -->
<h3 class="sectionedit7" id="alocare_de_memorie_in_spatiul_de_adresa_al_procesului">Alocare de memorie în spațiul de adresă al procesului</h3>
<div class="level3">

<p>
În UNIX, tradițional, pentru alocarea <em>memoriei dinamice</em>, se folosește apelul de sistem <a href="http://linux.die.net/man/2/brk" class="urlextern" title="http://linux.die.net/man/2/brk"  rel="nofollow">brk</a>. Acest apel crește sau descrește zona de heap asociată procesului. Odată cu oferirea către aplicații a unor apeluri de sistem de gestiune a memoriei virtuale (<a href="http://linux.die.net/man/2/mmap" class="urlextern" title="http://linux.die.net/man/2/mmap"  rel="nofollow">mmap</a>), a existat posibilitatea ca procesele să aloce memorie folosind aceste noi apeluri de sistem. Practic, procesele pot mapa memorie în spațiul de adresă, nu fișiere.
</p>

<p>
Procesele pot cere alocarea unei zone de memorie de la o anumită adresă din spațiul de adresare, chiar și cu o anumită politică de acces (citire, scriere sau execuție). În UNIX, acest lucru se face tot prin intermediul funcției <a href="http://linux.die.net/man/2/mmap" class="urlextern" title="http://linux.die.net/man/2/mmap"  rel="nofollow">mmap</a>. Pentru acest lucru parametrul de flag-uri trebuie să conțină flag-ul <code>MAP_ANONYMOUS</code>.
</p>

</div>
<!-- EDIT7 SECTION "Alocare de memorie în spațiul de adresă al procesului" [6387-7335] -->
<h3 class="sectionedit8" id="maparea_dispozitivelor">Maparea dispozitivelor</h3>
<div class="level3">

<p>
Există chiar și posibilitatea ca aplicațiile să mapeze în spațiul de adresă al unui proces un dispozitiv de intrare-ieșire. Acest lucru este util de exemplu pentru plăcile video: o aplicație poate mapa în spațiul de adresă memoria plăcii video. În UNIX, dispozitivele fiind reprezentate prin fișiere, pentru a realiza acest lucru nu trebuie decât să deschidem fișierul asociat dispozitivului și să-l folosim într-un apel <code>mmap</code>. Atenție însă, nu toate dispozitivele pot fi mapate în memorie, iar atunci când pot fi mapate, ce înseamnă acest lucru depinde de dispozitiv.
</p>

<p>
Un alt exemplu de dispozitiv care poate fi mapat este chiar memoria. În Linux se poate folosi fișierul <code>/dev/zero</code> pentru a face mapări de memorie, ca și când s-ar folosi flag-ul <code>MAP_ANONYMOUS</code>.
</p>

</div>
<!-- EDIT8 SECTION "Maparea dispozitivelor" [7336-8177] -->
<h3 class="sectionedit9" id="demaparea_unei_zone_din_spatiul_de_adresa">Demaparea unei zone din spațiul de adresă</h3>
<div class="level3">

<p>
Dacă se dorește demaparea unei zone din spațiul de adresă al procesului se poate folosi funcția <a href="http://linux.die.net/man/3/munmap" class="urlextern" title="http://linux.die.net/man/3/munmap"  rel="nofollow">munmap</a>:
</p>
<pre class="code c"> <span class="kw4">int</span> munmap<span class="br0">&#40;</span><span class="kw4">void</span> <span class="sy0">*</span>start<span class="sy0">,</span> <span class="kw4">size_t</span> length<span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>
<code>start</code> reprezintă adresa primei pagini ce va fi demapată (trebuie să fie multiplu de <em>dimensiunea unei pagini</em>). Dacă <code>length</code> nu este o dimensiune care reprezintă un număr întreg de pagini, va fi rotunjit superior. Zona poate să conțină bucăți deja demapate. Se pot astfel demapa mai multe zone în același timp.
</p>

</div>
<!-- EDIT9 SECTION "Demaparea unei zone din spațiul de adresă" [8178-8774] -->
<h3 class="sectionedit10" id="redimensionarea_unei_zone_mapate">Redimensionarea unei zone mapate</h3>
<div class="level3">

<p>
Pentru a executa operații de redimensionare a zonei mapate se poate utiliza funcția <a href="http://linux.die.net/man/2/mremap" class="urlextern" title="http://linux.die.net/man/2/mremap"  rel="nofollow">mremap</a>:
</p>
<pre class="code c"><span class="kw4">void</span> <span class="sy0">*</span>mremap<span class="br0">&#40;</span><span class="kw4">void</span> <span class="sy0">*</span>old_address<span class="sy0">,</span> <span class="kw4">size_t</span> old_size<span class="sy0">,</span> <span class="kw4">size_t</span> new_size<span class="sy0">,</span> <span class="kw4">unsigned</span> <span class="kw4">long</span> flags<span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>
Zona pe care <code>old_adress</code> și <code>old_size</code> o descriu trebuie să aparțină unei singure mapări. O singură opțiune este disponibilă pentru <code>flags</code>: <code>MREMAP_MAYMOVE</code> care arată că este în regulă ca pentru obținerea noii mapări să se realizeze o nouă mapare într-o altă zonă de memorie (vechea zona fiind dealocată).
</p>

</div>
<!-- EDIT10 SECTION "Redimensionarea unei zone mapate" [8775-9394] -->
<h3 class="sectionedit11" id="schimbarea_protectiei_unei_zone_mapate">Schimbarea protecției unei zone mapate</h3>
<div class="level3">

<p>
Uneori este nevoie ca modul (drepturile de acces) în care a fost mapată o zonă să fie schimbat. Pentru acest lucru se poate folosi funcția <a href="http://linux.die.net/man/2/mprotect" class="urlextern" title="http://linux.die.net/man/2/mprotect"  rel="nofollow">mprotect</a>:
</p>
<pre class="code c"><span class="kw4">int</span> mprotect<span class="br0">&#40;</span><span class="kw4">const</span> <span class="kw4">void</span> <span class="sy0">*</span>addr<span class="sy0">,</span> <span class="kw4">size_t</span> len<span class="sy0">,</span> <span class="kw4">int</span> prot<span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>
Funcția primește ca parametri intervalul de adrese [<code>addr</code>, <code>addr</code> + <code>len</code> - 1] și noile drepturi de access (<code>PROT_READ</code>, <code>PROT_WRITE</code>, <code>PROT_EXEC</code>, <code>PROT_NONE</code>). Ca și  la <a href="http://linux.die.net/man/2/munmap" class="urlextern" title="http://linux.die.net/man/2/munmap"  rel="nofollow">munmap</a>, <code>addr</code> trebuie să fie multiplu de <em>dimensiunea unei pagini</em>. Funcția va schimba protecția pentru toate paginile care conțin cel puțin un octet în intervalul specificat.
</p>

</div>
<!-- EDIT11 SECTION "Schimbarea protecției unei zone mapate" [9395-10129] -->
<h3 class="sectionedit12" id="exemplu">Exemplu</h3>
<div class="level3">
<pre class="code cpp"><span class="kw4">int</span> fd <span class="sy1">=</span> open<span class="br0">&#40;</span><span class="st0">&quot;fisier&quot;</span>, O_RDWR<span class="br0">&#41;</span><span class="sy4">;</span>
<span class="kw4">void</span> <span class="sy2">*</span>p <span class="sy1">=</span> mmap<span class="br0">&#40;</span><span class="kw2">NULL</span>, <span class="nu0">2</span><span class="sy2">*</span>getpagesize<span class="br0">&#40;</span><span class="br0">&#41;</span>, PROT_NONE, MAP_SHARED, fd, <span class="nu0">0</span><span class="br0">&#41;</span><span class="sy4">;</span>
<span class="co1">// *(char*)p = 'a'; // segv fault</span>
mprotect<span class="br0">&#40;</span>p, <span class="nu0">2</span><span class="sy2">*</span>getpagesize<span class="br0">&#40;</span><span class="br0">&#41;</span>, PROT_WRITE<span class="br0">&#41;</span><span class="sy4">;</span>
  <span class="sy2">*</span><span class="kw4">char</span><span class="sy2">*</span><span class="br0">&#41;</span>p <span class="sy1">=</span> <span class="st0">'a'</span><span class="sy4">;</span>
munmap<span class="br0">&#40;</span>p, <span class="nu0">2</span><span class="sy2">*</span>getpagesize<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy4">;</span></pre>

</div>
<!-- EDIT12 SECTION "Exemplu" [10130-10390] -->
<h3 class="sectionedit13" id="optimizari">Optimizări</h3>
<div class="level3">

<p>
Pentru ca sistemul de operare să poată implementa cât mai eficient accesele la o zona de memorie mapată, programatorul poate să informeze kernel-ul (prin apelul de sistem <a href="http://linux.die.net/man/2/madvise" class="urlextern" title="http://linux.die.net/man/2/madvise"  rel="nofollow">madvise</a>) despre modul în care zona va fi folosită. 
</p>
<div class="hiddenGlobal  hiddenActive"><div class="hiddenElements"></div><div class="hiddenHead  hiddenSinceBeginning"><div class="hiddenOnHidden">
<p>
Click to display ⇲
</p>
</div><div class="hiddenOnVisible">
<p>
Click to hide ⇱
</p>
</div></div> <!-- .hiddenHead --><div class="hiddenBody">
<p>
<a href="http://linux.die.net/man/2/madvise" class="urlextern" title="http://linux.die.net/man/2/madvise"  rel="nofollow">madvise</a> e utilă mai ales atunci când în spatele memoriei virtuale se află un dispozitiv fizic (de ex., când se mapează fișiere de pe hard-disk, kernel-ul poate citi în avans pagini de pe disc, reducând latența datorată poziționării capului de citire). Prototipul funcției este următorul:
</p>
<pre class="code c"><span class="kw4">int</span> madvise<span class="br0">&#40;</span><span class="kw4">void</span> <span class="sy0">*</span>start<span class="sy0">,</span> <span class="kw4">size_t</span> length<span class="sy0">,</span> <span class="kw4">int</span> advice<span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>
unde valorile acceptate pentru <code>advice</code> sunt:
</p>
<ul>
<li class="level1"><div class="li"><code>MADV_NORMAL</code> - regiunea este una obișnuită și nu are nevoie de un tratament special.</div>
</li>
<li class="level1"><div class="li"><code>MADV_RANDOM</code> - regiunea va fi accesată în mod aleator; sistemul de operare nu va citi în avans pagini.</div>
</li>
<li class="level1"><div class="li"><code>MADV_SEQUENTIAL</code> - regiunea va fi accesată în mod secvențial; sistemul de operare ar putea citi în avans pagini.</div>
</li>
<li class="level1"><div class="li"><code>MADV_WILLNEED</code> - regiunea va fi utilizată undeva în viitorul apropiat (nucleul poate decide să preîncarce paginile în memorie).</div>
</li>
<li class="level1"><div class="li"><code>MADV_DONTNEED</code> - regiunea nu va mai fi utilizată; nucleul poate să elibereze zona alocată din memorie, dar zona nu este demapată; nu se garantează păstrarea datelor la accesări ulterioare.</div>
</li>
</ul>
</div></div>
<p>
<br/>

</p>

</div>
<!-- EDIT13 SECTION "Optimizări" [10391-11841] -->
<h3 class="sectionedit14" id="blocarea_paginarii">Blocarea paginării</h3>
<div class="level3">

<p>
Există o categorie de procese care trebuie să execute anumite acțiuni la momente de timp bine determinate, pentru a se păstra calitatea execuției. Pentru exemplificare, putem considera un player audio/video sau un program ce controlează mersul unui robot biped. Problema cu acest gen de procese este dată de faptul că dacă o anumită pagină nu este prezentă în memorie, va dura un timp până ce ea va fi adusă. Pentru a contracara aceste probleme, sistemele UNIX pun la dispoziție apelurile <a href="http://linux.die.net/man/2/mlock" class="urlextern" title="http://linux.die.net/man/2/mlock"  rel="nofollow">mlock</a> și <a href="http://linux.die.net/man/2/mlockall" class="urlextern" title="http://linux.die.net/man/2/mlockall"  rel="nofollow">mlockall</a>.
</p>
<pre class="code c"><span class="kw4">int</span> mlock<span class="br0">&#40;</span><span class="kw4">const</span> <span class="kw4">void</span> <span class="sy0">*</span>addr<span class="sy0">,</span> <span class="kw4">size_t</span> len<span class="br0">&#41;</span><span class="sy0">;</span>
<span class="kw4">int</span> mlockall<span class="br0">&#40;</span><span class="kw4">int</span> flags<span class="br0">&#41;</span><span class="sy0">;</span></pre>
<div class="hiddenGlobal  hiddenActive"><div class="hiddenElements"></div><div class="hiddenHead  hiddenSinceBeginning"><div class="hiddenOnHidden">
<p>
Click to display ⇲
</p>
</div><div class="hiddenOnVisible">
<p>
Click to hide ⇱
</p>
</div></div> <!-- .hiddenHead --><div class="hiddenBody">
<p>
Funcția <a href="http://linux.die.net/man/2/mlock" class="urlextern" title="http://linux.die.net/man/2/mlock"  rel="nofollow">mlock</a> va bloca paginarea (nu se va mai face swapout) paginilor incluse în intervalul [<code>addr</code>, <code>addr</code> + <code>len</code> - 1]. 
Funcția <a href="http://linux.die.net/man/2/mlockall" class="urlextern" title="http://linux.die.net/man/2/mlockall"  rel="nofollow">mlockall</a> va bloca paginarea tuturor paginilor procesului, în funcție de flag-uri:
</p>
<ul>
<li class="level1"><div class="li"><code>MCL_CURRENT</code> - se va bloca paginarea tuturor paginilor mapate în spațiul de adresă al procesului la momentul apelului</div>
</li>
<li class="level1"><div class="li"><code>MCL_FUTURE</code> - se va bloca paginarea noilor pagini mapate în spațiul de adresă al procesului (noi mapări realizate cu funcția <code>mmap</code>, dar și paginile de stivă mapate automat de sistem)</div>
</li>
</ul>

<p>
<strong> Notă: </strong>
</p>

<p>
Flag-ul <code>MCL_FUTURE</code> nu garantează faptul că paginile de stivă vor fi automat mapate în sistem. Dacă procesul depășește limita de memorie impusă de sistem, va primi semnalul <code>SIGSEGV</code>. Pentru a nu se ajunge în astfel de situații, programul trebuie să folosească <code>mlockall(MCL_CURRENT | MCL_FUTURE)</code> și apoi să aloce dimensiunea maximă a stivei pe care urmează să o folosească (prin declararea unei variabile locale, un vector de exemplu, și accesarea completă a acesteia).
</p>
</div></div>
<p>
<br/>

Există, bineînțeles, și funcții ce readuc lucrurile la normal:
</p>
<pre class="code c"><span class="kw4">int</span> munlock<span class="br0">&#40;</span><span class="kw4">const</span> <span class="kw4">void</span> <span class="sy0">*</span>addr<span class="sy0">,</span> <span class="kw4">size_t</span> len<span class="br0">&#41;</span><span class="sy0">;</span>
<span class="kw4">int</span> munlockall<span class="br0">&#40;</span><span class="kw4">void</span><span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>
Astfel, funcția <a href="http://linux.die.net/man/2/munlock" class="urlextern" title="http://linux.die.net/man/2/munlock"  rel="nofollow">munlock</a> va reporni mecanismul de paginare al tuturor paginilor din intervalul [<code>addr</code>, <code>addr</code> + <code>len</code> - 1], iar funcția <a href="http://linux.die.net/man/2/munlockall" class="urlextern" title="http://linux.die.net/man/2/munlockall"  rel="nofollow">munlockall</a> face același lucru pentru toate paginile procesului, atât curente, cât și viitoare. Trebuie notat faptul că, dacă s-au efectuat mai multe apeluri <a href="http://linux.die.net/man/2/mlock" class="urlextern" title="http://linux.die.net/man/2/mlock"  rel="nofollow">mlock</a> sau <a href="http://linux.die.net/man/2/mlockall" class="urlextern" title="http://linux.die.net/man/2/mlockall"  rel="nofollow">mlockall</a>, este suficient un singur apel <a href="http://linux.die.net/man/2/munlock" class="urlextern" title="http://linux.die.net/man/2/munlock"  rel="nofollow">munlock</a> sau <a href="http://linux.die.net/man/2/munlockall" class="urlextern" title="http://linux.die.net/man/2/munlockall"  rel="nofollow">munlockall</a> pentru a reactiva paginarea.
</p>

</div>
<!-- EDIT14 SECTION "Blocarea paginării" [11842-14531] -->
<h3 class="sectionedit15" id="exceptii">Excepții</h3>
<div class="level3">

<p>
Atunci când se detectează o încălcare a protecției la accesul la memorie, se va trimite semnalul <code>SIGSEGV</code> sau <code>SIGBUS</code> procesului. După cum am văzut atunci când am discutat despre semnale, semnalul poate fi tratat cu două tipuri de funcții pe care aici o să le denumim <code>signal</code> și <a href="http://linux.die.net/man/2/sigaction" class="urlextern" title="http://linux.die.net/man/2/sigaction"  rel="nofollow">sigaction</a>. Funcția de tip <a href="http://linux.die.net/man/2/sigaction" class="urlextern" title="http://linux.die.net/man/2/sigaction"  rel="nofollow">sigaction</a> va primi ca parametru o structură <code>siginfo_t</code>. În cazul semnalelor ce tratează excepții cauzate de un acces incorect la memorie, următoarele câmpuri din această structură sunt setate:
</p>
<ul>
<li class="level1"><div class="li"><code>si_signo</code> - setat la <code>SIGSEGV</code> sau <code>SIGBUS</code></div>
</li>
<li class="level1"><div class="li"><code>si_code</code> - pentru <code>SIGSEGV</code> poate fi <code>SEGV_MAPPER</code> pentru a arăta că zona accesată nu este mapată în spațiul de adresă al procesului, sau <code>SEGV_ACCERR</code> pentru a arăta că zona este mapată dar a fost accesată necorespunzător; pentru <code>SIGBUS</code> poate fi <code>BUS_ADRALN</code> pentru a arăta că s-a făcut un acces nealiniat la memorie, <code>BUS_ADRERR</code> pentru a arăta că s-a încercat accesarea unei adrese fizice inexistente sau <code>BUS_OBJERR</code> pentru a indica o eroare hardware</div>
</li>
<li class="level1"><div class="li"><code>si_addr</code> - adresa care a generat excepția</div>
</li>
</ul>

</div>
<!-- EDIT15 SECTION "Excepții" [14532-15763] -->
<h3 class="sectionedit16" id="electricfence">ElectricFence</h3>
<div class="level3">

<p>
<a href="http://linux.die.net/man/3/efence" class="urlextern" title="http://linux.die.net/man/3/efence"  rel="nofollow">ElectricFence</a> este un pachet ce ajută programatorii la depanarea problemelor de tipul <em>buffer overrun</em>. Aceste probleme sunt cauzate de faptul că anumite date sunt suprascrise fiindcă nu se fac verificări când se modifică date <strong>adiacente</strong>. Soluția folosită de <a href="http://linux.die.net/man/3/efence" class="urlextern" title="http://linux.die.net/man/3/efence"  rel="nofollow">Electric Fence</a> este înlocuirea apelurilor standard <code>malloc</code> și <code>free</code> cu implementări proprii. <a href="http://linux.die.net/man/3/efence" class="urlextern" title="http://linux.die.net/man/3/efence"  rel="nofollow">Electric Fence</a> va plasa zona de memorie alocată în spațiul de adrese al procesului, astfel încât ea să fie mărginită de pagini neaccesibile (protejate la scriere și citire).
</p>

<p>
Din păcate, sistemul de operare și  arhitectura procesorului limitează dimensiunea paginii la cel puțin 1-4K, astfel încât dacă zona de memorie alocată nu este multiplu de această dimensiune, există posibilitatea ca programul să poată citi sau scrie și în zone în care nu ar trebui, fără ca sistemul de operare să oprească executia programului. Pentru a preveni situații de acestă natură, <a href="http://linux.die.net/man/3/efence" class="urlextern" title="http://linux.die.net/man/3/efence"  rel="nofollow">Electric Fence</a> alocă zonele de memorie la limita superioară a unei pagini, mapând o pagină neaccesibilă după aceasta. Această abordare nu previne <em>buffer underrun</em>-ul, în care datele sunt citite sau scrise peste limita inferioară.
</p>

<p>
Pentru a putea verifica și astfel de situații, utilizatorul trebuie să definescă variabila de mediu <code>EF_PROTECT_BELOW</code> înainte de rula programul. În acest caz, <a href="http://linux.die.net/man/3/efence" class="urlextern" title="http://linux.die.net/man/3/efence"  rel="nofollow">Electric Fence</a> va plasa zona de memorie alocată la începutul unei pagini, pagină care la rândul ei este plasată după o pagină inaccesibilă procesului.
</p>

<p>
De ce este importantă detectarea situațiilor de <em>buffer overrun</em>? Așa cum am explicat și în secțiunea precedentă, astfel de situații vor produce în cele din urmă erori, dar la un moment de timp ulterior, când va fi mai greu să determine cauza erorii cu mijloace de depanare obișnuite. În plus, în situațiile de <em>buffer overrun</em> se pot suprascrie nu numai variabile, ci și alte date importante pentru stabilitatea programului cum ar fi datele de control folosite de rutinele <code>malloc</code> și <code>free</code>. Biblioteca <a href="http://linux.die.net/man/3/efence" class="urlextern" title="http://linux.die.net/man/3/efence"  rel="nofollow">Electric Fence</a> poate determina erorile de <em>buffer overrun</em> doar dacă acestea apar în memoria alocată dinamic (adică în zona <em>heap</em>) cu rutinele <code>malloc</code> și <code>free</code>. Pentru a folosi <a href="http://linux.die.net/man/3/efence" class="urlextern" title="http://linux.die.net/man/3/efence"  rel="nofollow">Electric Fence</a> utilizatorul trebuie să folosească la link-editarea bibliotecii <code>libefence</code>. Pentru a vedea utilitatea acestui pachet, să analizăm programul de mai jos:
</p>
<dl class="code">
<dt><a href="../../../code/so/laboratoare-2013/laborator-07%3Fcodeblock=9" title="Download Snippet" class="mediafile mf_c">ef_example.c</a></dt>
<dd><pre class="code c"><span class="co2">#include &lt;stdio.h&gt;</span>
<span class="co2">#include &lt;malloc.h&gt;</span>
&nbsp;
<span class="kw4">int</span> main<span class="br0">&#40;</span><span class="kw4">void</span><span class="br0">&#41;</span>
<span class="br0">&#123;</span>
	<span class="kw4">int</span> i<span class="sy0">;</span>
	<span class="kw4">int</span> <span class="sy0">*</span>data_1<span class="sy0">,</span> <span class="sy0">*</span>data_2<span class="sy0">;</span>
&nbsp;
	data_1 <span class="sy0">=</span> <a href="http://www.opengroup.org/onlinepubs/009695399/functions/malloc.html"><span class="kw3">malloc</span></a><span class="br0">&#40;</span><span class="nu0">11</span> <span class="sy0">*</span> <span class="kw4">sizeof</span><span class="br0">&#40;</span><span class="kw4">int</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
	<span class="kw1">for</span> <span class="br0">&#40;</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;=</span> <span class="nu0">11</span><span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">&#41;</span>
		data_1<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy0">=</span> i<span class="sy0">;</span>
&nbsp;
	data_2 <span class="sy0">=</span> <a href="http://www.opengroup.org/onlinepubs/009695399/functions/malloc.html"><span class="kw3">malloc</span></a><span class="br0">&#40;</span><span class="nu0">11</span> <span class="sy0">*</span> <span class="kw4">sizeof</span><span class="br0">&#40;</span><span class="kw4">int</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
	<span class="kw1">for</span> <span class="br0">&#40;</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;=</span> <span class="nu0">11</span><span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">&#41;</span>
		data_2<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy0">=</span> <span class="nu0">11</span> <span class="sy0">-</span> i<span class="sy0">;</span>
&nbsp;
	<span class="kw1">for</span> <span class="br0">&#40;</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;=</span> <span class="nu0">11</span><span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">&#41;</span>
		<a href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span class="kw3">printf</span></a><span class="br0">&#40;</span><span class="st0">&quot;%d %d<span class="es1">\n</span>&quot;</span><span class="sy0">,</span> data_1<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="sy0">,</span> data_2<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
	<a href="http://www.opengroup.org/onlinepubs/009695399/functions/free.html"><span class="kw3">free</span></a><span class="br0">&#40;</span>data_1<span class="br0">&#41;</span><span class="sy0">;</span> 
	<a href="http://www.opengroup.org/onlinepubs/009695399/functions/free.html"><span class="kw3">free</span></a><span class="br0">&#40;</span>data_2<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
	<span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">&#125;</span></pre>
</dd></dl>

<p>
Aparent totul pare în regulă. La execuția programului însă obținem următorul output:
</p>
<pre class="code bash"> so<span class="sy0">@</span>spook$ <span class="kw2">gcc</span> <span class="re5">-Wall</span> <span class="re5">-g</span> ef_example.c
 so<span class="sy0">@</span>spook$ .<span class="sy0">/</span>a.out
ff: malloc.c:<span class="nu0">3074</span>: sYSMALLOc: Assertion <span class="sy0">`</span><span class="br0">&#40;</span>old_top == <span class="br0">&#40;</span><span class="br0">&#40;</span><span class="br0">&#40;</span>mbinptr<span class="br0">&#41;</span> <span class="br0">&#40;</span><span class="br0">&#40;</span><span class="br0">&#40;</span>char <span class="sy0">*</span><span class="br0">&#41;</span> 
<span class="sy0">&amp;</span><span class="br0">&#40;</span><span class="br0">&#40;</span>av<span class="br0">&#41;</span>-<span class="sy0">&gt;</span>bins<span class="br0">&#91;</span><span class="br0">&#40;</span><span class="br0">&#40;</span><span class="nu0">1</span><span class="br0">&#41;</span> - <span class="nu0">1</span><span class="br0">&#41;</span> <span class="sy0">*</span> <span class="nu0">2</span><span class="br0">&#93;</span><span class="br0">&#41;</span><span class="br0">&#41;</span> - __builtin_offsetof <span class="br0">&#40;</span>struct malloc_chunk, fd<span class="br0">&#41;</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="br0">&#41;</span> 
<span class="sy0">&amp;&amp;</span> old_size == <span class="nu0">0</span><span class="br0">&#41;</span> <span class="sy0">||</span> <span class="br0">&#40;</span><span class="br0">&#40;</span>unsigned long<span class="br0">&#41;</span><span class="br0">&#40;</span>old_size<span class="br0">&#41;</span> <span class="sy0">&gt;</span>= <span class="br0">&#40;</span>unsigned long<span class="br0">&#41;</span>
<span class="br0">&#40;</span><span class="br0">&#40;</span><span class="br0">&#40;</span><span class="br0">&#40;</span>__builtin_offsetof <span class="br0">&#40;</span>struct malloc_chunk, fd_nextsize<span class="br0">&#41;</span><span class="br0">&#41;</span>+<span class="br0">&#40;</span><span class="br0">&#40;</span><span class="nu0">2</span> <span class="sy0">*</span> <span class="br0">&#40;</span>sizeof<span class="br0">&#40;</span>size_t<span class="br0">&#41;</span><span class="br0">&#41;</span><span class="br0">&#41;</span>
 - <span class="nu0">1</span><span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="sy0">&amp;</span> ~<span class="br0">&#40;</span><span class="br0">&#40;</span><span class="nu0">2</span> <span class="sy0">*</span> <span class="br0">&#40;</span>sizeof<span class="br0">&#40;</span>size_t<span class="br0">&#41;</span><span class="br0">&#41;</span><span class="br0">&#41;</span> - <span class="nu0">1</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="sy0">&amp;&amp;</span> <span class="br0">&#40;</span><span class="br0">&#40;</span>old_top<span class="br0">&#41;</span>-<span class="sy0">&gt;</span><span class="kw2">size</span> <span class="sy0">&amp;</span> 0x1<span class="br0">&#41;</span> <span class="sy0">&amp;&amp;</span> 
<span class="br0">&#40;</span><span class="br0">&#40;</span>unsigned long<span class="br0">&#41;</span>old_end <span class="sy0">&amp;</span> pagemask<span class="br0">&#41;</span> == <span class="nu0">0</span><span class="br0">&#41;</span><span class="st_h">' failed.</span></pre>

<p>
Ceva este clar în neregulă. Dacă folosim biblioteca efence și GDB eroarea va fi vizibilă imediat:
</p>
<pre class="code bash"> so<span class="sy0">@</span>spook$ <span class="kw2">gcc</span> <span class="re5">-Wall</span> <span class="re5">-g</span> ef_example.c <span class="re5">-lefence</span>
 so<span class="sy0">@</span>spook$ <span class="kw2">gdb</span> .<span class="sy0">/</span>a.out 
 Reading symbols from <span class="sy0">/</span>home<span class="sy0">/</span>so<span class="sy0">/</span>a.out...done.
 <span class="br0">&#40;</span><span class="kw2">gdb</span><span class="br0">&#41;</span> run
 Starting program: <span class="sy0">/</span>home<span class="sy0">/</span>so<span class="sy0">/</span>a.out 
 <span class="br0">&#91;</span>Thread debugging using libthread_db enabled<span class="br0">&#93;</span>
&nbsp;
   Electric Fence <span class="nu0">2.1</span> Copyright <span class="br0">&#40;</span>C<span class="br0">&#41;</span> <span class="nu0">1987</span>-<span class="nu0">1998</span> Bruce Perens.
&nbsp;
 Program received signal SIGSEGV, Segmentation fault.
 0x08048536 <span class="kw1">in</span> main <span class="br0">&#40;</span><span class="br0">&#41;</span> at ef.c:<span class="nu0">12</span>
 <span class="nu0">12</span>			data_1<span class="br0">&#91;</span>i<span class="br0">&#93;</span> = i;
 <span class="br0">&#40;</span><span class="kw2">gdb</span><span class="br0">&#41;</span> print i
 <span class="re4">$1</span> = <span class="nu0">11</span>
 <span class="br0">&#40;</span><span class="kw2">gdb</span><span class="br0">&#41;</span></pre>

<p>
Se observă că eroarea apare în momentul în care încercăm să inițializăm al 12-lea element al vectorului, deși vectorul nu are decât 11 elemente.
</p>

<p>
Pentru mai multe informații despre <a href="http://linux.die.net/man/3/efence" class="urlextern" title="http://linux.die.net/man/3/efence"  rel="nofollow">Electric Fence</a> consultați pagina de manual (<strong>man efence</strong>).
</p>

</div>
<!-- EDIT16 SECTION "ElectricFence" [15764-20329] -->
<h2 class="sectionedit17" id="windows">Windows</h2>
<div class="level2">

<p>
În Windows funcțiile de control al memoriei virtuale sau mai bine zis al spațiului de adresă al unui proces nu mai sunt grupate, ca în cazul Unix, într-o singură primitivă oferită de sistemul de operare. Avem funcții pentru maparea fișierelor în memorie și funcții pentru alocarea de memorie fizică în spațiul de adresă al unui proces.
</p>

</div>
<!-- EDIT17 SECTION "Windows" [20330-20705] -->
<h3 class="sectionedit18" id="maparea_fisierelor1">Maparea fișierelor</h3>
<div class="level3">

<p>
Pentru a mapa un fișier în spațiul de adresă al unui proces trebuie mai întâi creat un handle către un obiect de tipul <a href="http://msdn.microsoft.com/en-us/library/aa366556%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/aa366556%28VS.85%29.aspx"  rel="nofollow">FileMapping</a> și apoi realizată efectiv maparea. Funcțiile <a href="http://msdn.microsoft.com/en-us/library/aa366537%28v=VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/aa366537%28v=VS.85%29.aspx"  rel="nofollow">CreateFileMapping</a> și <a href="http://msdn.microsoft.com/en-us/library/aa366761%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/aa366761%28VS.85%29.aspx"  rel="nofollow">MapViewOfFile</a> au mai fost prezentate atunci când s-a discutat despre <a href="../../../../so/laboratoare/laborator-05.html#memorie_partajata_filemapping" class="wikilink1" title="so:laboratoare:laborator-05">memoria partajată</a>. 
</p>

<p>
Pentru a crea un obiect de tip <code>FileMapping</code> se folosește funcția <a href="http://msdn.microsoft.com/en-us/library/aa366537%28v=VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/aa366537%28v=VS.85%29.aspx"  rel="nofollow">CreateFileMapping</a>:
</p>
<pre class="code c">HANDLE CreateFileMapping<span class="br0">&#40;</span>
   HANDLE hFile<span class="sy0">,</span>
   LPSECURITY_ATTRIBUTES lpAttributes<span class="sy0">,</span>
   DWORD flProtect<span class="sy0">,</span>
   DWORD dwMaximumSizeHigh<span class="sy0">,</span>
   DWORD dwMaximumSizeLow<span class="sy0">,</span>
   LPCTSTR lpName
 <span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>
Funcția primește ca parametri handle-ul fișierului care se dorește a fi mapat, atribute de securitate care controlează accesul la handle-ul obiectului <code>FileMapping</code> creat, tipul mapării (<code>PAGE_READONLY</code>, <code>PAGE_READWRITE</code>, <code>PAGE_WRITECOPY</code> pentru copy-on-write) și dimensiunea maximă care poate fi mapată cu ajutorul funcției <code>MapViewOfFile</code>. Opțional se poate specifica și un șir care să identifice obiectul <code>FileMapping</code> creat. Dacă mai există un obiect de acest tip, funcția <code>CreateFileMapping</code> nu va crea unul nou, ci îl va folosi pe cel existent. Atenție însă, obiectul trebuie să fi fost creat cu drepturi care să permită procesului apelant să îl deschidă. 
</p>

<p>
Pentru deschiderea unui obiect de tip <code>FileMapping</code> deja creat se mai poate folosi funcția <a href="http://msdn.microsoft.com/en-us/library/aa366791%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/aa366791%28VS.85%29.aspx"  rel="nofollow">OpenFileMapping</a>:
</p>
<pre class="code c">HANDLE OpenFileMapping<span class="br0">&#40;</span>
  DWORD dwDesiredAccess<span class="sy0">,</span>
  BOOL bInheritHandle<span class="sy0">,</span>
  LPCTSTR lpName
<span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>
Maparea în spațiul de adrese al procesului se face folosind funcția <a href="http://msdn.microsoft.com/en-us/library/aa366761%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/aa366761%28VS.85%29.aspx"  rel="nofollow">MapViewOfFile</a>:
</p>
<pre class="code c">LPVOID MapViewOfFile<span class="br0">&#40;</span>
   HANDLE hFileMappingObject<span class="sy0">,</span>
   DWORD dwDesiredAccess<span class="sy0">,</span>
   DWORD dwFileOffsetHigh<span class="sy0">,</span>
   DWORD dwFileOffsetLow<span class="sy0">,</span>
   SIZE_T dwNumberOfBytesToMap
 <span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>
Funcția primește ca parametri un handle către un obiect de tip <code>FileMapping</code>, modul de acces la zona mapată (<code>FILE_MAP_READ</code>, <code>FILE_MAP_WRITE</code>, <code>FILE_MAP_COPY</code> pentru copy-on-write), offset-ul în fișier de unde începe maparea și numărul de octeți de mapat. Funcția va întoarce un pointer în spațiul de adresă al procesului, la zona mapată.
</p>

</div>
<!-- EDIT18 SECTION "Maparea fișierelor" [20706-23365] -->
<h3 class="sectionedit19" id="alocare_de_memorie_in_spatiul_de_adresa_al_procesului1">Alocare de memorie în spațiul de adresă al procesului</h3>
<div class="level3">

<p>
Pentru alocarea de memorie în spațiul de adresă al procesului se pot folosi funcțiile <a href="http://msdn.microsoft.com/en-us/library/aa366887%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/aa366887%28VS.85%29.aspx"  rel="nofollow">VirtualAlloc</a> sau <a href="http://msdn.microsoft.com/en-us/library/aa366890%28v=VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/aa366890%28v=VS.85%29.aspx"  rel="nofollow">VirtualAllocEx</a>:
</p>
<pre class="code c"> LPVOID VirtualAlloc<span class="br0">&#40;</span>
   LPVOID lpAddress<span class="sy0">,</span>
   SIZE_T dwSize<span class="sy0">,</span>
   DWORD flAllocationType<span class="sy0">,</span>
   DWORD flProtect
 <span class="br0">&#41;</span><span class="sy0">;</span></pre>
<pre class="code c"> LPVOID VirtualAllocEx<span class="br0">&#40;</span>
   HANDLE hProcess<span class="sy0">,</span>
   LPVOID lpAddress<span class="sy0">,</span>
   SIZE_T dwSize<span class="sy0">,</span>
   DWORD flAllocationType<span class="sy0">,</span>
   DWORD flProtect
 <span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>
Cu funcția <a href="http://msdn.microsoft.com/en-us/library/aa366890%28v=VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/aa366890%28v=VS.85%29.aspx"  rel="nofollow">VirtualAllocEx</a> se poate aloca memorie în spațiul de adresă al unui proces arbitrar, specificat în parametrul <code>hProcess</code>. Procesul curent trebuie să aibă drepturi corespunzătoare asupra procesului pe care se încearcă operația (<code>PROCESS_VM_OPERATION</code>). Funcțiile întorc un pointer către adresa de start, iar parametrii așteptați de funcții sunt descriși în spoiler:
</p>
<div class="hiddenGlobal  hiddenActive"><div class="hiddenElements"></div><div class="hiddenHead  hiddenSinceBeginning"><div class="hiddenOnHidden">
<p>
Click to display ⇲
</p>
</div><div class="hiddenOnVisible">
<p>
Click to hide ⇱
</p>
</div></div> <!-- .hiddenHead --><div class="hiddenBody"><ul>
<li class="level1"><div class="li"><code>lpAddress</code> - adresa de unde începe alocarea; trebuie să fie multiplu de 4KB pentru alocare și 64KB pentru rezervare; dacă parametrul este <code>NULL</code>, sistemul va furniza automat o adresă</div>
</li>
<li class="level1"><div class="li"><code>dwSize</code> - dimensiunea zonei</div>
</li>
<li class="level1"><div class="li"><code>fAllocationType</code> - specifică tipul operației: rezervare (<code>MEM_RESERVE</code>), alocare (<code>MEM_COMMIT</code>) sau renunțare la zonă (<code>MEM_RESET</code>); rezervarea unei zone înseamnă de fapt “punerea deoparte” a unui interval din spațiul de adrese virtuale al procesului, fără a se aloca însă memorie fizică; dacă se folosește <code>MEM_COMMIT</code>, se alocă  efectiv memorie (dar doar dacă în prealabil zona vizată a fost rezervată); atunci când se renunță la zonă nucleul poate face discard la paginile din zonă, fără a face însă dezalocarea lor; după această operație datele nu se păstrează</div>
</li>
<li class="level1"><div class="li"><code>flProtect</code> - specifică modul de acces permis la zona alocată: <code>PAGE_EXECUTE</code>, <code>PAGE_EXECUTE_READ</code>, <code>PAGE_EXECUTE_READWRITE</code>, <code>PAGE_EXECUTE_WRITECOPY</code>, <code>PAGE_READONLY</code>, <code>PAGE_READWRITE</code>, <code>PAGE_WRITECOPY</code>, <code>PAGE_NOACCESS</code>, <code>PAGE_GUARD</code>, <code>PAGE_NOCACHE</code>. Modurile <code>_WRITECOPY</code> arată că se va folosi mecanismul copy-on-write. Modul <code>PAGE_GUARD</code> specifică faptul că la primul acces la o astfel de zonă se va genera o excepție <code>STATUS_GUARD_PAGE</code>. <code>PAGE_GUARD</code> și <code>PAGE_NOCACHE</code> se pot folosi împreună cu celelalte moduri.</div>
</li>
</ul>
</div></div>
</div>
<!-- EDIT19 SECTION "Alocare de memorie în spațiul de adresă al procesului" [23366-25874] -->
<h3 class="sectionedit20" id="demaparea_unei_zone_din_spatiul_de_adresa1">Demaparea unei zone din spațiul de adresă</h3>
<div class="level3">

<p>
Pentru demaparea unei fișier mapat în memorie se folosește funcția <a href="http://msdn.microsoft.com/en-us/library/aa366882%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/aa366882%28VS.85%29.aspx"  rel="nofollow">UnmapViewOfFile</a>:
</p>
<pre class="code c">BOOL UnmapViewOfFile<span class="br0">&#40;</span>
   LPCVOID lpBaseAddress
<span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>
Funcția primește adresa de început a zonei.
</p>

<p>
Pentru dezalocarea unei zone de memorie din spațiul de adresă se folosesc funcțiile <a href="http://msdn.microsoft.com/en-us/library/aa366892%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/aa366892%28VS.85%29.aspx"  rel="nofollow">VirtualFree</a> și <a href="http://msdn.microsoft.com/en-us/library/aa366894%28v=VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/aa366894%28v=VS.85%29.aspx"  rel="nofollow">VirtualFreeEx</a>:
</p>
<pre class="code c">BOOL VirtualFree<span class="br0">&#40;</span>
   LPVOID lpAddress<span class="sy0">,</span>
   SIZE_T dwSize<span class="sy0">,</span>
   DWORD dwFreeType
<span class="br0">&#41;</span><span class="sy0">;</span></pre>
<pre class="code c">BOOL VirtualFreeEx<span class="br0">&#40;</span>
   HANDLE hProcess<span class="sy0">,</span>
   LPVOID lpAddress<span class="sy0">,</span>
   SIZE_T dwSize<span class="sy0">,</span>
   DWORD dwFreeType
<span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>
Funcția <a href="http://msdn.microsoft.com/en-us/library/aa366894%28v=VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/aa366894%28v=VS.85%29.aspx"  rel="nofollow">VirtualFreeEx</a> va dezaloca o zonă de memorie din spațiul de adresă al unui proces arbitrar, specificat în parametrul <code>hProcess</code>. Procesul curent trebuie să aibă drepturi corespunzătoare asupra procesului pe care se încearcă operația (<code>PROCESS_VM_OPERATION</code>).
</p>

<p>
Parametrii <code>lpAddress</code> și <code>dwSize</code> identifică zona de dezalocat. <code>dwFreeType</code> specifică tipul operației: <code>MEM_DECOMMIT</code>, <code>MEM_RELEASE</code>. Prima operație va demapa paginile din spațiul de adresă, dar ele vor rămâne rezervate. Cea de-a doua operație va anula rezervarea întregii zone „puse deoparte” anterior, astfel încât adresa de start trebuie să coincidă cu adresa de start a zonei rezervate, iar dimensiunea trebuie să fie 0.
</p>

</div>
<!-- EDIT20 SECTION "Demaparea unei zone din spațiul de adresă" [25875-27491] -->
<h3 class="sectionedit21" id="schimbarea_protectiei_unei_zone_mapate1">Schimbarea protecției unei zone mapate</h3>
<div class="level3">

<p>
În Windows, schimbarea drepturilor de acces a unei zone mapate se poate face cu ajutorul funcțiilor <a href="http://msdn.microsoft.com/en-us/library/aa366898%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/aa366898%28VS.85%29.aspx"  rel="nofollow">VirtualProtect</a> și <a href="http://msdn.microsoft.com/en-us/library/aa366899%28v=VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/aa366899%28v=VS.85%29.aspx"  rel="nofollow">VirtualProtectEx</a>:
</p>
<pre class="code c">BOOL VirtualProtect<span class="br0">&#40;</span>
   LPVOID lpAddress<span class="sy0">,</span>
   SIZE_T dwSize<span class="sy0">,</span>
   DWORD flNewProtect<span class="sy0">,</span>
   PDWORD lpflOldProtect
<span class="br0">&#41;</span><span class="sy0">;</span></pre>
<pre class="code c">BOOL VirtualProtectEx<span class="br0">&#40;</span>
   HANDLE hProcess<span class="sy0">,</span>
   LPVOID lpAddress<span class="sy0">,</span>
   SIZE_T dwSize<span class="sy0">,</span>
   DWORD flNewProtect<span class="sy0">,</span>
   PDWORD lpflOldProtect
<span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>
Funcțiile vor schimba protecția paginilor care au măcar un octet în intervalul [<code>lpAddress</code>, <code>lpAddress</code> + <code>dwSize</code> - 1] la cea specificată în <code>flNewProtect</code>. Vechile drepturi de acces sunt salvate în <code>lpfOldProtect</code>.
</p>

<p>
<strong>Atenție!</strong> - Toate paginile din intervalul specificat trebuie să fie din aceeași regiune rezervată cu apelul <code>VirtualAlloc</code> sau <code>VirtualAllocEx</code> folosind <code>MEM_RESERVE</code>. Paginile nu pot fi localizate în regiuni adiacente rezervate prin apeluri separate ale <code>VirtualAlloc</code> sau <code>VirtualAllocEx</code> folosind <code>MEM_RESERVE</code>. 
</p>

</div>
<!-- EDIT21 SECTION "Schimbarea protecției unei zone mapate" [27492-28675] -->
<h3 class="sectionedit22" id="interogarea_zonelor_mapate">Interogarea zonelor mapate</h3>
<div class="level3">

<p>
Pentru a afla informații despre o zonă mapată în spațiul de adresă al unui proces se pot folosi funcțiile <a href="http://msdn.microsoft.com/en-us/library/aa366902%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/aa366902%28VS.85%29.aspx"  rel="nofollow">VirtualQuery</a> și <a href="http://msdn.microsoft.com/en-us/library/aa366907%28v=VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/aa366907%28v=VS.85%29.aspx"  rel="nofollow">VirtualQueryEx</a>. Ele vor oferi informații apelantului despre adresa de start a zonei, protecție, dimensiune etc.
</p>
<pre class="code c">DWORD VirtualQuery<span class="br0">&#40;</span>
   LPCVOID lpAddress<span class="sy0">,</span>
   PMEMORY_BASIC_INFORMATION lpBuffer<span class="sy0">,</span>
   SIZE_T dwLength
<span class="br0">&#41;</span><span class="sy0">;</span></pre>
<pre class="code c">DWORD VirtualQueryEx<span class="br0">&#40;</span>
   HANDLE hProcess<span class="sy0">,</span>
   LPCVOID lpAddress<span class="sy0">,</span>
   PMEMORY_BASIC_INFORMATION lpBuffer<span class="sy0">,</span>
   SIZE_T dwLength
<span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>
Funcțiile primesc ca parametri o adresă din cadrul zonei ce se dorește a fi interogată, un pointer către un buffer alocat ce va primi informații despre zonă și întorc numărul de octeți scriși în buffer. Dacă funcția întoarce 0 înseamnă că nici o informație nu a fost furnizată. Acest lucru se întâmplă dacă funcției îi este pasată o adresă din spațiul kernel.
</p>

<p>
Informațiile primite vor descrie două zone: zona alocată (cu <code>VirtualAlloc</code>) în care este inclusă adresa dată, și zona care conține pagini de același fel (cu aceeași protecție și stare) în care este inclusă adresa dată:
</p>
<pre class="code c"><span class="kw4">typedef</span> <span class="kw4">struct</span> _MEMORY_BASIC_INFORMATION <span class="br0">&#123;</span>
   PVOID BaseAddress<span class="sy0">;</span>
   PVOID AllocationBase<span class="sy0">;</span>
   DWORD AllocationProtect<span class="sy0">;</span>
   SIZE_T RegionSize<span class="sy0">;</span>
   DWORD State<span class="sy0">;</span>
   DWORD Protect<span class="sy0">;</span>
   DWORD Type<span class="sy0">;</span>
<span class="br0">&#125;</span> MEMORY_BASIC_INFORMATION<span class="sy0">,</span> <span class="sy0">*</span>PMEMORY_BASIC_INFORMATION<span class="sy0">;</span></pre>

<p>
Câmpurile <code>AllocationBase</code> și <code>AllocationProtect</code> se referă la zona alocată, iar <code>BaseAddress</code>, <code>RegionSize</code>, <code>Type</code> și <code>Protect</code> la zona ce conține pagini de același fel. <code>State</code> indică starea paginilor din zonă: <code>MEM_COMMIT</code> pentru zonă alocată, <code>MEM_RESERVED</code> pentru zonă rezervată și <code>MEM_FREE</code> pentru zonă nealocată. <code>Type</code> indică dacă în zonă este mapat un fișier (<code>MEM_IMAGE</code> sau <code>MEM_MAPPED</code>) sau nu, și indică de asemenea dacă zona este partajată sau nu (<code>MEM_PRIVATE</code>).
</p>

</div>
<!-- EDIT22 SECTION "Interogarea zonelor mapate" [28676-30788] -->
<h3 class="sectionedit23" id="blocarea_paginarii1">Blocarea paginării</h3>
<div class="level3">

<p>
Pentru blocarea paginării pentru un set de pagini (nu se va mai face swapout - în consecință apelurile ulterioare nu mai produc page fault), sistemul de operare Windows pune la dispoziția utilizatorilor funcția <a href="http://msdn.microsoft.com/en-us/library/aa366895%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/aa366895%28VS.85%29.aspx"  rel="nofollow">VirtualLock</a>:
</p>
<pre class="code c">BOOL VirtualLock<span class="br0">&#40;</span>
   LPVOID lpAddress<span class="sy0">,</span>
   SIZE_T dwSize
<span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>
Funcția primește prin parametri un interval de pagini (alcătuit din paginile care au măcar un octet în intervalul [<code>lpAddress</code>, <code>lpAddess</code> + <code>dwSize</code>]) pentru care se vrea blocarea paginării.
</p>

<p>
Funcția pentru reactivarea paginării este <a href="http://msdn.microsoft.com/en-us/library/aa366910%28v=VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/aa366910%28v=VS.85%29.aspx"  rel="nofollow">VirtualUnlock</a>:
</p>
<pre class="code c">BOOL VirtualUnlock<span class="br0">&#40;</span>
   LPVOID lpAddress<span class="sy0">,</span>
   SIZE_T dwSize
<span class="br0">&#41;</span><span class="sy0">;</span></pre>

</div>
<!-- EDIT23 SECTION "Blocarea paginării" [30789-31612] -->
<h3 class="sectionedit24" id="exceptii1">Excepții</h3>
<div class="level3">

<p>
Atunci când sistemul de operare detectează accese incorecte la memorie, va genera o excepție către procesul care a efectuat accesul. Pentru tratarea excepției se pot folosi construcții <code>__try</code> și <code>__except</code>, pentru care este necesar suport din partea compilatorului, sau se poate folosi funcția <a href="http://msdn.microsoft.com/en-us/library/ms679274%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms679274%28VS.85%29.aspx"  rel="nofollow">AddVectoredExceptionHandler</a>.
</p>
<pre class="code c">PVOID AddVectoredExceptionHandler<span class="br0">&#40;</span>
   ULONG FirstHandler<span class="sy0">,</span>
   PVECTORED_EXCEPTION_HANDLER VectoredHandler
<span class="br0">&#41;</span><span class="sy0">;</span></pre>
<pre class="code c">ULONG RemoveVectoredExceptionHandler<span class="br0">&#40;</span>
   PVOID VectoredHandlerHandle
<span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>
Funcția <a href="http://msdn.microsoft.com/en-us/library/ms679274%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms679274%28VS.85%29.aspx"  rel="nofollow">AddVectoredExceptionHandler</a> va adăuga pe lista funcțiilor de executat atunci când se generează o excepție, pe cea primită ca parametru în <code>VectoredHandler</code>. Parametrul <code>FirstHandler</code> indică dacă funcția dorește să fie adăugată la începutul listei sau la sfârșit. Funcția de tratare a excepțiilor trebuie să aibă următoarea semnătură:
</p>
<pre class="code c">LONG WINAPI VectoredHandler<span class="br0">&#40;</span>
   PEXCEPTION_POINTERS ExceptionInfo
<span class="br0">&#41;</span><span class="sy0">;</span></pre>
<pre class="code c"><span class="kw4">typedef</span> <span class="kw4">struct</span> _EXCEPTION_POINTERS <span class="br0">&#123;</span>
  PEXCEPTION_RECORD ExceptionRecord<span class="sy0">;</span>
  PCONTEXT ContextRecord<span class="sy0">;</span>
<span class="br0">&#125;</span> EXCEPTION_POINTERS<span class="sy0">,</span> <span class="sy0">*</span>PEXCEPTION_POINTERS<span class="sy0">;</span></pre>
<pre class="code c"><span class="kw4">typedef</span> <span class="kw4">struct</span> _EXCEPTION_RECORD <span class="br0">&#123;</span>
  DWORD ExceptionCode<span class="sy0">;</span>
  DWORD ExceptionFlags<span class="sy0">;</span>
  <span class="kw4">struct</span> _EXCEPTION_RECORD<span class="sy0">*</span> ExceptionRecord<span class="sy0">;</span>
  PVOID ExceptionAddress<span class="sy0">;</span>
  DWORD NumberParameters<span class="sy0">;</span>
  ULONG_PTR ExceptionInformation<span class="br0">&#91;</span>EXCEPTION_MAXIMUM_PARAMETERS<span class="br0">&#93;</span><span class="sy0">;</span>
<span class="br0">&#125;</span> EXCEPTION_RECORD<span class="sy0">,</span> <span class="sy0">*</span>PEXCEPTION_RECORD<span class="sy0">;</span></pre>

<p>
În cazul unor excepții cauzate de un acces invalid la memorie, <code>ExceptionCode</code> va fi setat la <code>EXCEPTION_ACCESS_VIOLATION</code> sau <code>EXCEPTION_DATATYPE_MISALIGNMENT</code>, iar <code>ExceptionAddress</code> la adresa instrucțiunii care a cauzat excepția; <code>NumberParameters</code> va fi setat pe 2, iar prima intrare în <code>ExceptionInformation</code> va fi <code>0</code> dacă s-a efectuat o operație de citire sau <code>1</code> dacă s-a efectuat o operație de scriere. A doua intrare din <code>ExceptionInformation</code> va conține adresa virtuală la care s-a încercat accesarea fără drepturi, fapt care a dus la generarea excepției. Așadar, corespondentul câmpului <code>si_addr</code> din structura <code>siginfo_t</code> de pe Linux este <code>ExceptionInformation</code> pe Windows, NU <code>ExceptionAddress</code>.
</p>

<p>
Funcția de tratare a excepției înregistrată cu <a href="http://msdn.microsoft.com/en-us/library/ms679274%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms679274%28VS.85%29.aspx"  rel="nofollow">AddVectoredExceptionHandler</a> trebuie să întoarcă <code>EXCEPTION_CONTINUE_EXECUTION</code>, dacă excepția a fost tratată și se dorește continuarea execuției, sau <code>EXCEPTION_CONTINUE_SEARCH</code> pentru a continua parcurgerea listei de funcții de tratare a excepțiilor, în caz că au fost înregistrate mai multe astfel de funcții.
</p>

</div>
<!-- EDIT24 SECTION "Excepții" [31613-34459] -->
<h2 class="sectionedit25" id="exercitii">Exerciții</h2>
<div class="level2">

<p>
În rezolvarea laboratorului, folosiți arhiva de sarcini <a href="http://elf.cs.pub.ro/so/res/laboratoare/lab07-tasks.zip" class="urlextern" title="http://elf.cs.pub.ro/so/res/laboratoare/lab07-tasks.zip"  rel="nofollow"> lab07-tasks.zip</a>
</p>

<p>
<strong>Observații</strong>: Pentru a vă ajuta la implementarea exercițiilor din laborator, în directorul <code>utils</code> din arhivă există un fișier <code>utils.h</code> cu funcții utile.
</p>

<p>
<p><div class="noteimportant">Platforma este la alegerea voastră. Punctajul maxim se poate obține fie pe Linux, fie pe Windows
</div></p>
</p>

</div>
<!-- EDIT25 SECTION "Exerciții" [34460-34913] -->
<h3 class="sectionedit26" id="linux1">Linux</h3>
<div class="level3">
<ul>
<li class="level1"><div class="li"> <strong>Atentie</strong> Lucrați în masina virtuală</div>
</li>
</ul>
<ol>
<li class="level1"><div class="li"> (<strong>0.5 punct</strong>) Investigarea mapării folosind <a href="http://linux.die.net/man/1/pmap" class="urlextern" title="http://linux.die.net/man/1/pmap"  rel="nofollow"> pmap</a>.</div>
<ul>
<li class="level2"><div class="li"> Intrați în directorul <code>1-intro</code> și compilați sursa <code>intro.c</code>.</div>
</li>
<li class="level2"><div class="li"> Rulați programul <code>intro</code>. Folosiți <code>ENTER</code> pentru a continua programul.</div>
</li>
<li class="level2"><div class="li"> Folosiți comanda <pre class="code bash"> <span class="kw2">watch</span> <span class="re5">-d</span> pmap $<span class="br0">&#40;</span><span class="kw2">pidof</span> intro<span class="br0">&#41;</span> </pre>

<p>
 pentru a urmări modificările asupra memoriei procesului. 
</p>
</div>
</li>
<li class="level2"><div class="li"> Urmăriți modificările care apar în urma diferitelor tipuri de mapare din cod.</div>
</li>
<li class="level2"><div class="li"> De ce unele biblioteci sunt mapate cu drept de scriere?</div>
</li>
<li class="level2"><div class="li"> Analizați mapările făcute de procesul <code>init</code> folosind comanda: <pre class="code bash"><span class="kw2">sudo</span> pmap <span class="nu0">1</span></pre>

<p>
.
</p>
</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> (<strong>1 punct</strong>) Scrierea în fișier - <a href="http://linux.die.net/man/2/write" class="urlextern" title="http://linux.die.net/man/2/write"  rel="nofollow">write</a> vs <a href="http://linux.die.net/man/2/mmap" class="urlextern" title="http://linux.die.net/man/2/mmap"  rel="nofollow">mmap</a>.</div>
<ul>
<li class="level2"><div class="li"> Intrați în directorul <code>2-compare</code> și inspectați sursele <code>write.c</code> și <code>mmap.c</code>, apoi compilați.</div>
</li>
<li class="level2"><div class="li"> Obțineți timpul de execuție al celor două programe folosind comanda <code>time</code>: <pre class="code bash"> <span class="kw1">time</span> .<span class="sy0">/</span><span class="kw2">write</span>; <span class="kw1">time</span> .<span class="sy0">/</span>mmap</pre>
</div>
</li>
<li class="level2"><div class="li"> Care timp este mai mare și de ce? </div>
</li>
<li class="level2"><div class="li"> Hint: </div>
<ul>
<li class="level3"><div class="li"> Folosiți <a href="http://linux.die.net/man/1/strace" class="urlextern" title="http://linux.die.net/man/1/strace"  rel="nofollow">strace</a> pentru a vedea câte apeluri de sistem se realizează pentru rularea fiecărui program.</div>
</li>
</ul>
</li>
<li class="level2"><div class="li"> Ce se întâmplă dacă în programul <code>mmap.c</code> schimbați flagul de creare al memoriei partajate din MAP_SHARED în MAP_PRIVATE? Cum explicați?</div>
</li>
<li class="level2"><div class="li"> Hint: </div>
<ul>
<li class="level3"><div class="li"> <a href="http://linux.die.net/man/2/mmap" class="urlextern" title="http://linux.die.net/man/2/mmap"  rel="nofollow"> man mmap</a>, în special secțiunea despre MAP_PRIVATE.</div>
</li>
<li class="level3"><div class="li"> Ce conține fișierul &#039;test_mmap&#039; în ambele cazuri?</div>
</li>
</ul>
</li>
</ul>
</li>
<li class="level1"><div class="li"> (<strong>1 punct</strong>) Detectare &#039;buffer underrun&#039; utilizând <a href="laborator-07.html#electricfence" title="so:laboratoare-2013:laborator-07 ↵" class="wikilink1">ElectricFence</a>.</div>
<ul>
<li class="level2"><div class="li"> Intrați în directorul <code>3-efence</code> și urmăriți sursa <code>bug.c</code>.</div>
</li>
<li class="level2"><div class="li"> Compilați și rulați executabilul <code>bug</code>.</div>
</li>
<li class="level2"><div class="li"> Folosiți <a href="laborator-07.html#electricfence" title="so:laboratoare-2013:laborator-07 ↵" class="wikilink1">ElectricFence</a> pentru a prinde situația de &#039;buffer underrun&#039;.</div>
</li>
<li class="level2"><div class="li"> Hint: </div>
<ul>
<li class="level3"><div class="li"> Creați și rulați programul <code>ef_bug</code> utilizând makefile-ul <code>Makefile_efence</code>.</div>
<ul>
<li class="level4"><div class="li"> Instalati pachetul <code>electric-fence</code> in cazul in care biblioteca <code>libefence.so</code> nu se gaseste pe sistem.</div>
</li>
</ul>
</li>
<li class="level3"><div class="li"> Setați în bash <pre class="code bash"><span class="kw3">export</span> <span class="re2">EF_PROTECT_BELOW</span>=<span class="nu0">1</span></pre>
</div>
</li>
</ul>
</li>
<li class="level2"><div class="li"> Explicați de ce bug-ul nu s-a manifestat anterior. </div>
</li>
<li class="level2"><div class="li"> Hint: Urmăriți exemplul din secțiunea <a href="laborator-07.html#electricfence" title="so:laboratoare-2013:laborator-07 ↵" class="wikilink1">ElectricFence</a>. </div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> (<strong>2 puncte</strong>) Copierea fișierelor folosind <a href="http://linux.die.net/man/2/mmap" class="urlextern" title="http://linux.die.net/man/2/mmap"  rel="nofollow"> mmap</a>.</div>
<ul>
<li class="level2"><div class="li"> Intrați în directorul <code>4-cp</code>. </div>
</li>
<li class="level2"><div class="li"> Completați sursa <code>mycp.c</code> astfel încât să realizeze copierea unui fișier primit ca argument.</div>
</li>
<li class="level2"><div class="li"> Pentru aceasta, mapați ambele fișiere în memorie.</div>
</li>
<li class="level2"><div class="li"> Realizați copierea ca o simplă copiere de vectori.</div>
</li>
<li class="level2"><div class="li"> Hints:</div>
<ul>
<li class="level3"><div class="li"> Înainte de mapare, aflați dimensiunea fișierului sursă folosind <a href="http://linux.die.net/man/2/fstat" class="urlextern" title="http://linux.die.net/man/2/fstat"  rel="nofollow"> fstat</a>.</div>
</li>
<li class="level3"><div class="li"> Nu uitați să trunchiați fișierul destinație la dimensiunea fișierului sursă.</div>
</li>
<li class="level3"><div class="li"> Urmăriți comentariile cu <code>TODO</code>.</div>
</li>
<li class="level3"><div class="li"> Revedeți secțiunea <a href="laborator-07.html#maparea-fisierelor" title="so:laboratoare-2013:laborator-07 ↵" class="wikilink1">maparea fișierelor</a>.</div>
</li>
</ul>
</li>
<li class="level2"><div class="li"> Puteți testa în felul următor: <pre class="code bash">.<span class="sy0">/</span>mycp Makefile <span class="sy0">/</span>tmp<span class="sy0">/</span>Makefile; <span class="kw2">diff</span> Makefile <span class="sy0">/</span>tmp<span class="sy0">/</span>Makefile</pre>
</div>
</li>
<li class="level2"><div class="li"> Verificați cum realizează utilitarul <a href="http://linux.die.net/man/1/cp" class="urlextern" title="http://linux.die.net/man/1/cp"  rel="nofollow"> cp</a> copierea de fișiere (folosind mmap sau read/write). </div>
<ul>
<li class="level3"><div class="li"> Hint: folosiți <a href="http://linux.die.net/man/1/strace" class="urlextern" title="http://linux.die.net/man/1/strace"  rel="nofollow"> strace</a>.</div>
</li>
</ul>
</li>
<li class="level2"><div class="li"> De ce credeți că se folosește această variantă?</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> (<strong>4 puncte</strong>) Tipuri de acces pentru pagini.</div>
<ol>
<li class="level2"><div class="li"> (<strong>2 puncte</strong>)</div>
<ul>
<li class="level3"><div class="li"> Intrați în directorul <code>5-prot</code> și inspectați sursa <code>prot.c</code>.</div>
</li>
<li class="level3"><div class="li"> Să se creeze trei zone de memorie în spațiul de adresă, cu drepturi de citire, scriere, respectiv nici un drept.</div>
</li>
<li class="level3"><div class="li"> Zonele vor avea dimensiunea de o pagină.</div>
</li>
<li class="level3"><div class="li"> Să se testeze comportamentul programului când se fac accese de citire și scriere în aceste zone.</div>
<ul>
<li class="level4"><div class="li"> Hint: Urmăriți comentariile cu <code>TODO 1</code>.</div>
</li>
</ul>
</li>
</ul>
</li>
<li class="level2"><div class="li"> (<strong>2 puncte</strong>)</div>
<ul>
<li class="level3"><div class="li"> Adăugați un handler de tratare a excepțiilor care să remapeze zonele cu protecție de citire și scriere la generarea excepțiilor.</div>
</li>
<li class="level3"><div class="li"> Hint: Urmăriți comentariile cu <code>TODO 2</code>.</div>
</li>
</ul>
</li>
</ol>
</li>
<li class="level1"><div class="li"> (<strong>0.5 puncte</strong>) Page fault-uri.</div>
<ul>
<li class="level3"><div class="li"> Intrați în directorul <code>6-faults</code> și urmăriți conținutul fișierului <code>fork-faults.c</code>.</div>
</li>
<li class="level3"><div class="li"> <strong>Câte page-fault-uri</strong> credeți că se realizează la rulare?</div>
</li>
<li class="level3"><div class="li"> Compilați fișierul.</div>
</li>
<li class="level3"><div class="li"> Folosiți utilitarul <code>pidstat</code> din pachetul <code>sysstat</code> care permite monitorizarea page fault-urilor unui proces (prin intermediul argumentului <code>-r</code>).</div>
</li>
<li class="level3"><div class="li"> Rulați programul <code>fork-faults</code>. Folosiți <code>ENTER</code> pentru a continua programul.</div>
</li>
<li class="level3"><div class="li"> Folosiți comanda <pre class="code bash">pidstat <span class="re5">-r</span> <span class="re5">-T</span> ALL <span class="re5">-p</span> $<span class="br0">&#40;</span><span class="kw2">pidof</span> fork-faults<span class="br0">&#41;</span> <span class="nu0">5</span> <span class="nu0">100</span></pre>

<p>
 pentru a urmări page fault-urile. Rulați comanda pentru fiecare secvență de program.
</p>
</div>
<ul>
<li class="level4"><div class="li"> Comanda de mai sus vă afișează câte un mesaj la fiecare 5 secunde. Sincronizați apăsarea tastei ENTER cu afișajul comenzii pidstat.</div>
</li>
</ul>
</li>
<li class="level3"><div class="li"> Urmăriți evoluția numărului de page fault-uri pentru cele două procese: părinte și copil. Page fault-urile care apar în cazul unui copy-on-write în procesul copil vor fi vizibile ulterior și în procesul părinte.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> (<strong>1 punct</strong>) Blocarea paginării. </div>
<ul>
<li class="level2"><div class="li"> Vă aflați într-o situație în care trebuie să procesați în timp real datele dintr-un buffer și vreți să evitați swaparea paginilor. </div>
<ul>
<li class="level3"><div class="li"> Intrați în directorul <code>7-paging</code> și completați <code>TODO-urile</code> astfel încât paginarea va fi blocată pentru variabila <em>data</em> pe parcursul lucrului cu aceasta, iar la final va fi deblocată.</div>
</li>
<li class="level3"><div class="li"> Hints:</div>
<ul>
<li class="level4"><div class="li"> Adresa trebuie aliniată la limita unei pagini.</div>
</li>
<li class="level4"><div class="li"> Revedeți secțiunea referitoare la <a href="laborator-07.html#blocarea_paginarii" title="so:laboratoare-2013:laborator-07 ↵" class="wikilink1">blocarea paginării</a>.</div>
</li>
</ul>
</li>
<li class="level3"><div class="li"> Cât de mare poate fi <em>DATA_SIZE</em>? Încercați cu diverse valori și explicați comportamentul. </div>
</li>
<li class="level3"><div class="li"> Memoria blocată este prin definiție memorie rezidentă - nu poate fi trimisă pe swap. Puteți urmări cum se modifică dimensiunea memoriei rezidente (cea care nu poate fi trimisa pe swap) folosind comanda: <pre class="code bash"> <span class="kw2">ps</span> <span class="re5">-p</span> $<span class="br0">&#40;</span><span class="kw2">pidof</span> paging<span class="br0">&#41;</span> <span class="re5">-o</span> pid,rss,vsz,<span class="kw2">comm</span> </pre>

<p>
 după fiecare pas al programului.
</p>
</div>
</li>
</ul>
</li>
</ul>
</li>
</ol>

</div>
<!-- EDIT26 SECTION "Linux" [34914-41113] -->
<h3 class="sectionedit27" id="bonus_linux">Bonus Linux</h3>
<div class="level3">
<ol>
<li class="level1"><div class="li"> (<strong>1 so karma</strong>) Schimbarea tipului de acces pentru pagini din segmentul de cod. </div>
<ul>
<li class="level3"><div class="li"> Intrați în directorul <code>8-hack</code>. </div>
</li>
<li class="level3"><div class="li"> Programul apelează funcția <em>foo()</em>. Având determinată pagina în care se află funcția în spațiul de adresă al procesului, i se schimbă drepturile de acces în <code>PROT_READ|PROT_WRITE|PROT_EXEC</code> și se modifică valoarea de retur a funcției (se scrie în segmentul de cod). Analizați cu atenție programul.</div>
</li>
<li class="level3"><div class="li"> Analizați comportamentul cu <code>gdb</code>. Având <em>pid-ul</em> procesului afișat la <code>stdout</code>, folosiți <a href="http://linux.die.net/man/1/pmap" class="urlextern" title="http://linux.die.net/man/1/pmap"  rel="nofollow">pmap</a> pentru a observa pagina cu drepturile schimbate.</div>
</li>
<li class="level3"><div class="li"> Observați tipul de acces pentru celelalte pagini din spațiul de adresă al procesului.</div>
</li>
<li class="level3"><div class="li"> Modificați drepturile de acces în <code>PROT_READ|PROT_EXEC</code> și recompilați sursa. Ce se întâmplă și de ce?</div>
</li>
</ul>
</li>
</ol>

</div>
<!-- EDIT27 SECTION "Bonus Linux" [41114-42011] -->
<h3 class="sectionedit28" id="windows1">Windows</h3>
<div class="level3">
<ol>
<li class="level1"><div class="li"> (<strong>0.5 puncte</strong>) Maparea memoriei.</div>
<ul>
<li class="level2"><div class="li"> Deschideți proiectul <code>1-intro</code>.</div>
</li>
<li class="level2"><div class="li"> Inspectați și compilați sursa <code>intro.c</code>.</div>
</li>
<li class="level2"><div class="li"> Rulați proiectul, iar în paralel urmăriți comportamentul programului <code>intro</code> în Task Manager - în special coloanele <code>Mem Usage</code> și <code>Page Faults</code>.</div>
</li>
<li class="level2"><div class="li"> Hints:</div>
<ul>
<li class="level3"><div class="li"> Pentru a vedea o listă completă cu coloanele care pot fi activate, Task Manager→View→Select Columns.</div>
</li>
</ul>
</li>
</ul>
</li>
<li class="level1"><div class="li"> (<strong>1 punct</strong>) Crearea unor rutine în mod dinamic. </div>
<ul>
<li class="level3"><div class="li"> Deschideți proiectul <code>2-dyn</code> și urmăriți sursa <code>dyn.c</code>.</div>
</li>
<li class="level3"><div class="li"> Programul alocă memorie în spațiul de adresă al procesului pt a stoca o rutină, de forma <code>dyncode</code>. </div>
<ul>
<li class="level4"><div class="li"> Rutina va incrementa parametrul primit și va întoarce această valoare. Urmăriți conțintul lui <code>code</code>. </div>
</li>
<li class="level4"><div class="li"> Deși în acest caz conținutul rutinei este definit direct în program prin <code>code</code>, el ar putea fi primit în orice alt mod (fișier, etc).</div>
</li>
</ul>
</li>
</ul>
</li>
<li class="level1"><div class="li"> (<strong>2 puncte</strong>) Mapare fișiere în memorie.</div>
<ul>
<li class="level2"><div class="li"> Să se scrie un program care copiază un fișier. Programul primește ca argumente numele fișierului sursă, numele fișierului desținatie, mapează în memorie cele două fișiere și copiază conținutul primului fișier folosind <code>memcpy(3)</code>.</div>
<ul>
<li class="level3"><div class="li"> Folosiți proiectul <code>3-copy</code>.</div>
</li>
<li class="level3"><div class="li"> <strong>Hint</strong>: pentru aflarea lungimii unui fișier folosiți <a href="http://msdn.microsoft.com/en-us/library/aa364946(VS.85).aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/aa364946(VS.85).aspx"  rel="nofollow"> GetFileAttributesEx</a>.</div>
</li>
<li class="level3"><div class="li"> <strong>Atenție</strong>: fișierul destinație trebuie trunchiat la dimensiunea fișierului sursă. Folosiți <a href="http://msdn.microsoft.com/en-us/library/aa365541(VS.85).aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/aa365541(VS.85).aspx"  rel="nofollow"> SetFilePointer</a> și <a href="http://msdn.microsoft.com/en-us/library/aa365531(VS.85).aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/aa365531(VS.85).aspx"  rel="nofollow"> SetEndOfFile</a>.</div>
</li>
</ul>
</li>
</ul>
</li>
<li class="level1"><div class="li"> (<strong>4 puncte</strong>) Tipuri de acces pentru pagini.</div>
<ul>
<li class="level2"><div class="li"> Încărcați proiectul <code>4-prot</code> și inspectați sursa <code>libvm.c</code>.</div>
</li>
</ul>
<ol>
<li class="level2"><div class="li"> (<strong>2 puncte</strong>)</div>
<ul>
<li class="level3"><div class="li"> Să se creeze trei zone de memorie în spațiul de adresă, cu drepturi de citire, scriere, respectiv nici un drept.</div>
</li>
<li class="level3"><div class="li"> Zonele vor avea dimensiunea de o pagină.</div>
</li>
<li class="level3"><div class="li"> Să se testeze comportamentul programului când se fac accese de citire și scriere în aceste zone.</div>
</li>
<li class="level3"><div class="li"> Hint: </div>
<ul>
<li class="level4"><div class="li"> Urmăriți comentariile cu <code>TODO 1</code>.</div>
</li>
<li class="level4"><div class="li"> În Windows se poate apela <a href="http://msdn.microsoft.com/en-us/library/aa366898%28v=VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/aa366898%28v=VS.85%29.aspx"  rel="nofollow">VirtualProtect</a> doar pentru o zonă de memorie alocată cu <a href="http://msdn.microsoft.com/en-us/library/aa366887%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/aa366887%28VS.85%29.aspx"  rel="nofollow">VirtualAlloc</a>.</div>
</li>
</ul>
</li>
</ul>
</li>
<li class="level2"><div class="li"> (<strong>2 puncte</strong>)</div>
<ul>
<li class="level3"><div class="li"> Adăugați un handler de tratare a excepțiilor care să remapeze zonele cu protecție de citire și scriere la generarea excepțiilor.</div>
</li>
<li class="level3"><div class="li"> Hint: </div>
<ul>
<li class="level4"><div class="li"> Revedeți secțiunea despre <a href="laborator-07.html#schimbarea-protectiei-unei-zone-mapate" title="so:laboratoare-2013:laborator-07 ↵" class="wikilink1">Schimbarea protecției unei zone mapate</a>.</div>
</li>
<li class="level4"><div class="li"> Pentru implementarea handlerului, revedeți secțiunea referitoare la <a href="laborator-07.html#exceptii1" title="so:laboratoare-2013:laborator-07 ↵" class="wikilink1">Excepții</a>.</div>
</li>
<li class="level4"><div class="li"> Urmăriți comentariile cu <code>TODO 2</code>.</div>
</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
<li class="level1"><div class="li"> (<strong>1 punct</strong>) Detectare &#039;buffer overrun&#039; - implementare utilitar asemănător cu Electric Fence.</div>
<ul>
<li class="level3"><div class="li"> Încărcați proiectul <code>5-ef</code>.</div>
</li>
<li class="level3"><div class="li"> Inspectați sursa, ignorând pentru moment funcția <code>MyMalloc</code>.</div>
</li>
<li class="level3"><div class="li"> Compilați și rulați proiectul. Ar trebui să apară erori?</div>
</li>
<li class="level3"><div class="li"> Completați funcția <code>MyMalloc</code> astfel încât orice depășire a bufferului alocat să producă eroare.</div>
</li>
<li class="level3"><div class="li"> Hints:</div>
<ul>
<li class="level4"><div class="li"> Alocați cu <a href="http://msdn.microsoft.com/en-us/library/aa366887%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/aa366887%28VS.85%29.aspx"  rel="nofollow">VirtualAlloc</a> memorie de dimensiunea primită ca parametru + încă o pagină la final (o vom numi <code>guard page</code>).</div>
</li>
<li class="level4"><div class="li"> Schimbați dreptul de acces pentru pagina de final în PAGE_NOACCESS utilizând <code><a href="http://msdn.microsoft.com/en-us/library/aa366898%28v=VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/aa366898%28v=VS.85%29.aspx"  rel="nofollow">VirtualProtect</a></code>.</div>
</li>
<li class="level4"><div class="li"> Întoarceți un pointer la o zonă de memorie cu dimensiunea egală cu dimensiunea cerută, dar care se termină fix înainte de <code>guard page</code>).</div>
</li>
<li class="level4"><div class="li"> Urmăriți commentariile cu <code>TODO</code>.</div>
</li>
</ul>
</li>
<li class="level3"><div class="li"> Testați din nou folosind de data aceeasta <code>MyMalloc</code>, atât în cazul în care inițializarea vectorului depășește dimensiunea alocată, cât și în cazul în care nu depășește.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> (<strong>1.5 puncte</strong>) Blocarea paginării. </div>
<ul>
<li class="level2"><div class="li"> Vă aflați într-o situație în care trebuie să procesați în timp real datele dintr-un buffer și vreți să evitați swaparea paginilor. </div>
<ul>
<li class="level3"><div class="li"> Intrați în directorul <code>6-lock</code> și completați <code>TODO-urile</code> astfel încât paginarea să fie blocată pentru variabila <em>data</em> pe parcursul lucrului cu aceasta, iar la final să fie deblocată.</div>
</li>
<li class="level3"><div class="li"> Hints:</div>
<ul>
<li class="level4"><div class="li"> Adresa trebuie aliniată la limita unei pagini.</div>
</li>
<li class="level4"><div class="li"> Revedeți secțiunea referitoare la <a href="laborator-07.html#blocarea-paginarii1" title="so:laboratoare-2013:laborator-07 ↵" class="wikilink1">blocarea paginării în Windows</a>.</div>
</li>
</ul>
</li>
<li class="level3"><div class="li"> Cât de mare poate fi <em>DATA_SIZE</em>? Încercați cu diverse valori și explicați comportamentul.</div>
</li>
<li class="level3"><div class="li"> Urmăriți comportamentul programului în <code>Task Manager</code>.</div>
</li>
</ul>
</li>
</ul>
</li>
</ol>

</div>
<!-- EDIT28 SECTION "Windows" [42012-46900] -->
<h3 class="sectionedit29" id="extra">EXTRA</h3>
<div class="level3">

<p>
Comparați timpii de execuție ai algoritmilor de numărare a liniilor din fișier, aflați în această <a href="../../../../_media/so/laboratoare-2013/lines_counter.zip" class="media mediafile mf_zip" title="so:laboratoare-2013:lines_counter.zip (1.4 KB)">arhivă</a>
</p>
<ul>
<li class="level1"><div class="li"> Cât de performantă este metoda cu mapare a fișierului în memorie?</div>
</li>
<li class="level1"><div class="li"> Care sunt cele mai importante diferențe între metoda mmap din modulul de Python cu același nume și funcția nativă din Linux?</div>
</li>
</ul>

</div>
<!-- EDIT29 SECTION "EXTRA" [46901-47285] -->
<h2 class="sectionedit30" id="solutii">Soluții</h2>
<div class="level2">



</div>
<!-- EDIT30 SECTION "Soluții" [47286-47406] -->
<h2 class="sectionedit31" id="resurse_utile">Resurse Utile</h2>
<div class="level2">
<ul>
<li class="level1"><div class="li"><a href="http://en.wikipedia.org/wiki/Memory_management" class="urlextern" title="http://en.wikipedia.org/wiki/Memory_management"  rel="nofollow"> Wikipedia: Memory Management</a></div>
</li>
<li class="level1"><div class="li"><a href="http://tldp.org/LDP/tlk/mm/memory.html" class="urlextern" title="http://tldp.org/LDP/tlk/mm/memory.html"  rel="nofollow"> Memory Management in Linux</a></div>
</li>
<li class="level1"><div class="li"><a href="http://www.opengroup.org/onlinepubs/009695399/functions/mmap.html" class="urlextern" title="http://www.opengroup.org/onlinepubs/009695399/functions/mmap.html"  rel="nofollow"> Opengroup - mmap</a></div>
</li>
<li class="level1"><div class="li"><a href="http://msdn.microsoft.com/en-us/library/ms810627.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms810627.aspx"  rel="nofollow"> MSDN: Managing Virtual Memory in Win32</a></div>
</li>
<li class="level1"><div class="li"><a href="http://msdn2.microsoft.com/en-us/library/ms810613.aspx" class="urlextern" title="http://msdn2.microsoft.com/en-us/library/ms810613.aspx"  rel="nofollow"> MSDN: Managing Memory-Mapped Files in Win32</a></div>
</li>
<li class="level1"><div class="li"><a href="http://msdn2.microsoft.com/en-us/library/ms680657.aspx" class="urlextern" title="http://msdn2.microsoft.com/en-us/library/ms680657.aspx"  rel="nofollow"> MSDN: Structured Exception Handling</a></div>
</li>
<li class="level1"><div class="li"><a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms681411(v=vs.85).aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/windows/desktop/ms681411(v=vs.85).aspx"  rel="nofollow"> Utilizarea vectorilor de excepție (Windows)</a></div>
</li>
</ul>

</div>
<!-- EDIT31 SECTION "Resurse Utile" [47407-] --></div>
</body>
</html>
