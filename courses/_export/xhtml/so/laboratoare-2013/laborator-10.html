    
    

<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
  <meta charset="utf-8" />
  <title>so:laboratoare-2013:laborator-10</title>
<meta name="generator" content="DokuWiki"/>
<meta name="robots" content="index,follow"/>
<meta name="date" content="2014-03-05T22:19:57+0200"/>
<meta name="keywords" content="so,laboratoare-2013,laborator-10"/>
<link rel="search" type="application/opensearchdescription+xml" href="../../../../lib/exe/opensearch.php" title="CS Open CourseWare"/>
<link rel="start" href="../../../../../courses.1.html"/>
<link rel="alternate" type="application/rss+xml" title="Recent Changes" href="../../../../feed.php"/>
<link rel="alternate" type="application/rss+xml" title="Current Namespace" href="../../../../feed.php%3Fmode=list&amp;ns=so:laboratoare-2013"/>
<link rel="alternate" type="text/html" title="Plain HTML" href="laborator-10.html"/>
<link rel="canonical" href="../../../../so/laboratoare-2013/laborator-10.html"/>
<link rel="stylesheet" type="text/css" href="../../../../lib/exe/css.php%3Ft=arctic&amp;tseed=1479898000.css"/>
<script type="text/javascript">/*<![CDATA[*/var NS='so:laboratoare-2013';var JSINFO = {"id":"so:laboratoare-2013:laborator-10","namespace":"so:laboratoare-2013","isadmin":0,"isauth":0};
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="../../../../lib/exe/js.php%3Ftseed=1479898000"></script>
<script type="text/x-mathjax-config">/*<![CDATA[*/MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ["$","$"], ["\\(","\\)"] ],
        displayMath: [ ["$$","$$"], ["\\[","\\]"] ],
        processEscapes: true
    }
});
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
<script type="text/javascript">/*<![CDATA[*/
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
		  
/*!]]>*/</script>
<script type="text/javascript">/*<![CDATA[*/
var pageTracker = _gat._getTracker("UA-38383934-1");
pageTracker._initData();
pageTracker._trackPageview();
		  
/*!]]>*/</script>
</head>
<body>
<div class="dokuwiki export">
<!-- TOC START -->
<div id="dw__toc">
<h3 class="toggle">Table of Contents</h3>
<div>

<ul class="toc">
<li class="level1"><div class="li"><a href="laborator-10.html#laborator_10_-_operatii_io_avansate_-_windows">Laborator 10 - Operații IO avansate - Windows</a></div>
<ul class="toc">
<li class="clear">
<ul class="toc">
<li class="level3"><div class="li"><a href="laborator-10.html#materiale_ajutatoare">Materiale ajutătoare</a></div></li>
<li class="level3"><div class="li"><a href="laborator-10.html#nice_to_read">Nice to read</a></div></li>
<li class="level3"><div class="li"><a href="laborator-10.html#windows_-_io_asincron_overlapped">Windows - I/O asincron (overlapped)</a></div></li>
<li class="level3"><div class="li"><a href="laborator-10.html#overlapped_io_cu_asteptare">Overlapped I/O cu așteptare</a></div></li>
<li class="level3"><div class="li"><a href="laborator-10.html#file_flag_overlapped">FILE_FLAG_OVERLAPPED</a></div></li>
<li class="level3"><div class="li"><a href="laborator-10.html#structura_overlapped">Structura Overlapped</a></div></li>
<li class="level3"><div class="li"><a href="laborator-10.html#asteptarea_si_interogarea_operatiilor_asincrone">Așteptarea și interogarea operațiilor asincrone</a></div></li>
</ul>
</li>
<li class="level2"><div class="li"><a href="laborator-10.html#windows_-_io_completion_ports">Windows - I/O Completion Ports</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="laborator-10.html#crearea_unui_completion_port">Crearea unui completion port</a></div></li>
<li class="level3"><div class="li"><a href="laborator-10.html#adaugarea_unui_descriptor_la_completion_port">Adăugarea unui descriptor la completion port</a></div></li>
<li class="level3"><div class="li"><a href="laborator-10.html#asteptarea_incheierii_unei_operatii_asincrone">Așteptarea încheierii unei operații asincrone</a></div></li>
<li class="level3"><div class="li"><a href="laborator-10.html#exemplu_de_folosire_completion_ports">Exemplu de folosire completion ports</a></div></li>
</ul>
</li>
<li class="level2"><div class="li"><a href="laborator-10.html#zero-copy_io">Zero-copy I/O</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="laborator-10.html#transmitfile">TransmitFile</a></div></li>
</ul>
</li>
<li class="level2"><div class="li"><a href="laborator-10.html#exercitii">Exerciții</a></div></li>
<li class="level2"><div class="li"><a href="laborator-10.html#solutii">Soluții</a></div></li>
</ul></li>
</ul>
</div>
</div>
<!-- TOC END -->

<h1 class="sectionedit1" id="laborator_10_-_operatii_io_avansate_-_windows">Laborator 10 - Operații IO avansate - Windows</h1>
<div class="level1">

</div>
<!-- EDIT1 SECTION "Laborator 10 - Operații IO avansate - Windows" [1-62] -->
<h3 class="sectionedit2" id="materiale_ajutatoare">Materiale ajutătoare</h3>
<div class="level3">
<ul>
<li class="level1"><div class="li"><a href="http://elf.cs.pub.ro/so/res/laboratoare/lab10-slides.pdf" class="urlextern" title="http://elf.cs.pub.ro/so/res/laboratoare/lab10-slides.pdf"  rel="nofollow"> lab10-slides.pdf</a> </div>
</li>
<li class="level1"><div class="li"><a href="http://elf.cs.pub.ro/so/res/laboratoare/lab10-refcard.pdf" class="urlextern" title="http://elf.cs.pub.ro/so/res/laboratoare/lab10-refcard.pdf"  rel="nofollow"> lab10-refcard.pdf</a></div>
</li>
</ul>

</div>
<!-- EDIT2 SECTION "Materiale ajutătoare" [63-265] -->
<h3 class="sectionedit3" id="nice_to_read">Nice to read</h3>
<div class="level3">
<ul>
<li class="level1"><div class="li"> WSP4 - Chapter 14, Asynchronous Input/Output and Completion Ports</div>
</li>
</ul>

</div>
<!-- EDIT3 SECTION "Nice to read" [266-361] -->
<h3 class="sectionedit4" id="windows_-_io_asincron_overlapped">Windows - I/O asincron (overlapped)</h3>
<div class="level3">

<p>
Operațiile de intrare/ieșire sunt mai lente decât operațiile de procesare din cauza întârzierilor cauzate de:
</p>
<ul>
<li class="level1"><div class="li"> timpul de access la sectoarele hard-disk-urilor</div>
</li>
<li class="level1"><div class="li"> rata de transfer scăzută dintre hard-disk și memoria RAM</div>
</li>
<li class="level1"><div class="li"> transferul de date peste rețea</div>
</li>
</ul>

<p>
În <a href="../../../../so/laboratoare-2013/laborator-02.html" class="wikilink1" title="so:laboratoare-2013:laborator-02">Laboratorul 2</a> au fost studiate operațiile I/O <strong>sincrone</strong>: firul de execuție apelant așteaptă până când operația de I/O se încheie. În cadrul acestui laborator vom afla cum un fir de execuție poate începe o operație de I/O și continua fără a aștepta ca acea operație de I/O să se încheie, adică cum poate efectua o operație <strong><code>asincronă</code></strong>. În final, o dată ce operațiile asincrone au fost înțelese vom analiza <code><span class="curid"><a href="../../../../so/laboratoare-2013/laborator-10.html#windows_io_completion_ports" class="wikilink1" title="so:laboratoare-2013:laborator-10"> I/O Completion Ports</a></span></code>, cel mai eficient model de procesare a cererilor I/O, utilizat în construcția serverelor scalabile.
</p>

<p>
În Windows există trei modalități de realizare a operațiilor asincrone. Acestea diferă atât în modul folosit pentru a porni operațiile de I/O, cât și în modul prin care se determină dacă operația s-a încheiat:
</p>
<ul>
<li class="level1"><div class="li"> <code>multithreaded I/O</code>: fiecare fir de execuție efectuează operații I/O normale, însă celelalte fire își pot continua execuția</div>
</li>
<li class="level1"><div class="li"> <code><span class="curid"><a href="../../../../so/laboratoare-2013/laborator-10.html#overlapped_io_cu_asteptare" class="wikilink1" title="so:laboratoare-2013:laborator-10"> overlapped I/O cu așteptare</a></span></code>: un fir de execuție își continuă execuția după începerea unei operații de I/O. Un fir de execuție (posibil altul decât cel care a inițiat operația I/O) care are nevoie de rezultatele operației de I/O, va așteapta fie pe un <code>file handle</code>, fie pe un eveniment specificat în structura overlapped folosită de către <code><a href="http://msdn.microsoft.com/en-us/library/aa365467%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/aa365467%28VS.85%29.aspx"  rel="nofollow">ReadFile</a></code> și <code><a href="http://msdn.microsoft.com/en-us/library/aa365747%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/aa365747%28VS.85%29.aspx"  rel="nofollow">WriteFile</a></code></div>
</li>
<li class="level1"><div class="li"> <code>overlapped I/O cu rutine de terminare</code>: sistemul de operare apelează o anumită <code>rutină de terminare</code> (completion routine) atunci când respectiva operație de I/O s-a încheiat. Acest tip de operație asincronă mai poartă și numele de <code>extended I/O</code>, nume derivat din cel al funcțiilor folosite <code><a href="http://msdn.microsoft.com/en-us/library/aa365748%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/aa365748%28VS.85%29.aspx"  rel="nofollow"> WriteFileEx</a></code> și <code><a href="http://msdn.microsoft.com/en-us/library/aa365468%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/aa365468%28VS.85%29.aspx"  rel="nofollow"> ReadFileEx</a></code>.</div>
</li>
</ul>

<p>
În continuare vom trata doar cazul operațiilor de tipul <code><span class="curid"><a href="../../../../so/laboratoare-2013/laborator-10.html#overlapped_io_cu_asteptare" class="wikilink1" title="so:laboratoare-2013:laborator-10"> overlapped I/O cu așteptare</a></span></code>.
</p>

</div>
<!-- EDIT4 SECTION "Windows - I/O asincron (overlapped)" [362-2892] -->
<h3 class="sectionedit5" id="overlapped_io_cu_asteptare">Overlapped I/O cu așteptare</h3>
<div class="level3">

</div>
<!-- EDIT5 SECTION "Overlapped I/O cu așteptare" [2893-2932] -->
<h3 class="sectionedit6" id="file_flag_overlapped">FILE_FLAG_OVERLAPPED</h3>
<div class="level3">

<p>
Prima cerință pentru operațiile I/O asincrone indiferent dacă sunt suprapuse (overlapped) sau extinse este setarea atributului <code>overlapped</code> al <code>handle</code>-ului unui fișier. Acest lucru se realizează prin specificarea flag-ului <code>FILE_FLAG_OVERLAPPED</code> pentru parametrul <code>dwAttrsAndFlags</code> la apelul funcției <code><a href="http://msdn.microsoft.com/en-us/library/aa363858%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/aa363858%28VS.85%29.aspx"  rel="nofollow"> CreateFile</a></code> (sau orice alt apel care creează fișiere, pipe-uri cu nume etc.):
</p>
<pre class="code c">HANDLE hFile <span class="sy0">=</span> CreateFile<span class="br0">&#40;</span><span class="st0">&quot;io.txt&quot;</span><span class="sy0">,</span> 
                          GENERIC_READ<span class="sy0">,</span> 
                          <span class="nu0">0</span><span class="sy0">,</span> 
                          NULL<span class="sy0">,</span> 
                          OPEN_EXISTING<span class="sy0">,</span> 
                          FILE_FLAG_OVERLAPPED<span class="sy0">,</span> <span class="coMULTI">/* this must be specified */</span>
                          NULL<span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>
Notă: În Windows, socketii au acest flag activat în mod implicit.
</p>

<p>
Operațiile I/O pe handle-uri care au flag-ul <code>FILE_FLAG_OVERLAPPED</code> setat (handle-uri asincrone) au un comportament special:
</p>
<ul>
<li class="level1"><div class="li"> Operațiile I/O nu blochează firul de execuție apelant. Apelurile <code><a href="http://msdn.microsoft.com/en-us/library/aa365467%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/aa365467%28VS.85%29.aspx"  rel="nofollow"> ReadFile</a></code>, <code><a href="http://msdn.microsoft.com/en-us/library/aa365747%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/aa365747%28VS.85%29.aspx"  rel="nofollow"> WriteFile</a></code> se întorc imediat, indiferent de durata completării cererii I/O.</div>
</li>
<li class="level1"><div class="li"> O valoare <code>FALSE</code> întoarsă nu indică în mod obligatoriu eșecul apelului. Valoarea <code>FALSE</code> întoarsă de funcțiile <code><a href="http://msdn.microsoft.com/en-us/library/aa365467%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/aa365467%28VS.85%29.aspx"  rel="nofollow"> ReadFile</a></code>, <code><a href="http://msdn.microsoft.com/en-us/library/aa365747%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/aa365747%28VS.85%29.aspx"  rel="nofollow"> WriteFile</a></code> indică eșecul în cazul operațiilor de I/O sincrone. În cazul operațiilor I/O asincrone, funcția <code><a href="http://msdn.microsoft.com/en-us/library/ms679360%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms679360%28VS.85%29.aspx"  rel="nofollow"> GetLastError</a></code> va întoarce <code>ERROR_IO_PENDING</code> ceea ce indică faptul că operația se desfășoară asincron.</div>
</li>
<li class="level1"><div class="li"> Numărul de octeți transferați este de asemenea nefolositor dacă operația nu s-a încheiat. </div>
</li>
<li class="level1"><div class="li"> Se pot face mai multe operații asincrone de citire/scriere pe același fișier, deci nici <code>file pointer</code>-ul nu mai poate fi utilizat. </div>
</li>
</ul>

</div>
<!-- EDIT6 SECTION "FILE_FLAG_OVERLAPPED" [2933-5082] -->
<h3 class="sectionedit7" id="structura_overlapped">Structura Overlapped</h3>
<div class="level3">

<p>
Al doilea pas este transmiterea unei structuri de tip OVERLAPPED ca parametru ori de câte ori se face un apel <code><a href="http://msdn.microsoft.com/en-us/library/aa365467%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/aa365467%28VS.85%29.aspx"  rel="nofollow"> ReadFile</a></code>/<code><a href="http://msdn.microsoft.com/en-us/library/aa365747%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/aa365747%28VS.85%29.aspx"  rel="nofollow"> WriteFile</a></code>.
Structura <code><a href="http://msdn.microsoft.com/en-us/library/ms684342%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms684342%28VS.85%29.aspx"  rel="nofollow"> OVERLAPPED</a></code> conține informația folosită în operațiile I/O și arată astfel:
</p>
<pre class="code c"><span class="kw4">typedef</span> <span class="kw4">struct</span> _OVERLAPPED <span class="br0">&#123;</span>
    ULONG_PTR Internal<span class="sy0">;</span>      <span class="coMULTI">/* the error code for the I/O request*/</span>
    ULONG_PTR InternalHigh<span class="sy0">;</span>  <span class="coMULTI">/* the number of bytes transferred */</span>
    <span class="kw4">union</span> <span class="br0">&#123;</span>                  <span class="coMULTI">/* the file position at which to start the I/O request */</span>
           <span class="kw4">struct</span> <span class="br0">&#123;</span>
               DWORD Offset<span class="sy0">;</span>
               DWORD OffsetHigh<span class="sy0">;</span>
           <span class="br0">&#125;</span> <span class="sy0">;</span>
           PVOID  Pointer<span class="sy0">;</span>   <span class="coMULTI">/* reserved */</span>
    <span class="br0">&#125;</span> <span class="sy0">;</span>
    HANDLE    hEvent<span class="sy0">;</span>        <span class="coMULTI">/* handle to the event - is set to signaled when operation has completed */</span>
<span class="br0">&#125;</span> OVERLAPPED<span class="sy0">,</span> <span class="sy0">*</span>LPOVERLAPPED<span class="sy0">;</span></pre>

<p>
Structura <code><a href="http://msdn.microsoft.com/en-us/library/ms684342%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms684342%28VS.85%29.aspx"  rel="nofollow"> OVERLAPPED</a></code> este utilă pentru că:
</p>
<ul>
<li class="level1"><div class="li"> Un program poate porni mai multe operații asincrone de citire sau scriere pe un singur handle de fișier asincron. File pointer-ul asociat cu file handle-ul nu mai are nicio însemnătate.</div>
</li>
<li class="level1"><div class="li"> Un program trebuie să fie capabil să aștepte terminarea operațiilor I/O asincrone. În cazul în care mai multe operații I/O asincrone sunt pornite, programul trebuie să poată determina care dintre operații s-au terminat. Operațiile asincrone nu se termină în mod obligatoriu în ordinea în care au fost pornite.</div>
</li>
</ul>

<p>
Atenție: o operație de I/O asincronă este identificată de către file handle și de structura <code><a href="http://msdn.microsoft.com/en-us/library/ms684342%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms684342%28VS.85%29.aspx"  rel="nofollow"> OVERLAPPED</a></code>. Nu trebuie să trecem cu vederea următoarele lucruri:
</p>
<ul>
<li class="level1"><div class="li"> O structură <code><a href="http://msdn.microsoft.com/en-us/library/ms684342%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms684342%28VS.85%29.aspx"  rel="nofollow"> OVERLAPPED</a></code> nu trebuie refolosită până când operația de I/O asociată nu s-a încheiat.</div>
</li>
<li class="level1"><div class="li"> Dacă există mai multe operații I/O este indicată folosirea evenimentelor pentru sincronizare.</div>
</li>
</ul>

<p>
Evenimentul <code>hEvent</code> trebuie creat de utilizator și trebuie să fie de tip <strong><code>manual-reset</code></strong> (Vezi <a href="../../../../so/laboratoare-2013/laborator-09.html#evenimente" class="wikilink1" title="so:laboratoare-2013:laborator-09"> laboratorul 9</a>). Când o operație I/O asincronă se termină, evenimentul rămâne în starea <code>signaled</code> până când este utilizat în altă operație I/O asincronă. Acest lucru este util pentru că putem avea mai multe fire de execuție care să aștepte după aceeași operație asincronă.
</p>

</div>
<!-- EDIT7 SECTION "Structura Overlapped" [5083-8034] -->
<h3 class="sectionedit8" id="asteptarea_si_interogarea_operatiilor_asincrone">Așteptarea și interogarea operațiilor asincrone</h3>
<div class="level3">

<p>
Pentru determinarea stării operației asincrone se poate folosi funcția <code><a href="http://msdn.microsoft.com/en-us/library/ms683209%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms683209%28VS.85%29.aspx"  rel="nofollow"> GetOverlappedResult</a></code>. În cazul unei operații <code><a href="http://msdn.microsoft.com/en-us/library/ms684342%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms684342%28VS.85%29.aspx"  rel="nofollow"> OVERLAPPED</a></code> apelurile <code><a href="http://msdn.microsoft.com/en-us/library/aa365467%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/aa365467%28VS.85%29.aspx"  rel="nofollow"> ReadFile</a></code>/<code><a href="http://msdn.microsoft.com/en-us/library/aa365747%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/aa365747%28VS.85%29.aspx"  rel="nofollow"> WriteFile</a></code> se vor întoarce imediat. În cele mai multe cazuri, operația de I/O nu se va termina imediat astfel că apelurile <code><a href="http://msdn.microsoft.com/en-us/library/aa365467%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/aa365467%28VS.85%29.aspx"  rel="nofollow"> ReadFile</a></code>/<code><a href="http://msdn.microsoft.com/en-us/library/aa365747%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/aa365747%28VS.85%29.aspx"  rel="nofollow"> WriteFile</a></code> vor întoarce <code>FALSE</code>, iar funcția <code><a href="http://msdn.microsoft.com/en-us/library/ms679360%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms679360%28VS.85%29.aspx"  rel="nofollow"> GetLastError</a></code> va întoarce <code>ERROR_IO_PENDING</code>. Dacă totuși rezultatul întors este <code>TRUE</code>, înseamnă că operația s-a efectuat și puteți cere imediat rezultatul.
</p>

<p>
Așteptarea după o operație I/O asincronă se poate face după oricare dintre următoarele:
</p>
<ul>
<li class="level1"><div class="li"> Handle-ul evenimentului specificat în structura <code><a href="http://msdn.microsoft.com/en-us/library/ms684342%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms684342%28VS.85%29.aspx"  rel="nofollow"> OVERLAPPED</a></code> - în caz că se dorește ca unul sau mai multe fire de execuție să aștepte după aceeași operație asincronă. </div>
</li>
<li class="level1"><div class="li"> Handle-ul fișierului - caz în care doar un singur fir de execuție va aștepta după operația asincronă (parametrul <code>hEvent</code> al structurii <code><a href="http://msdn.microsoft.com/en-us/library/ms684342%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms684342%28VS.85%29.aspx"  rel="nofollow"> OVERLAPPED</a></code> este lăsat NULL)</div>
</li>
</ul>

<p>
După așteptarea pe un obiect de sincronizare (un event sau un handle de fișier) ca operația de I/O să se termine, trebuie să determinăm câți octeți au fost transferați. Acesta este scopul de bază al funcției <code><a href="http://msdn.microsoft.com/en-us/library/ms683209%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms683209%28VS.85%29.aspx"  rel="nofollow"> GetOverlappedResult</a></code>. 
</p>
<table class="columns-plugin">
<tr><td class="columns-plugin first">
<pre class="code c">BOOL WINAPI GetOverlappedResult<span class="br0">&#40;</span>
       HANDLE hFile<span class="sy0">,</span>
       LPOVERLAPPED lpOverlapped<span class="sy0">,</span>
       LPDWORD lpNumberOfBytesTransferred<span class="sy0">,</span>
       BOOL bWait
<span class="br0">&#41;</span><span class="sy0">;</span></pre>
</td><td class="columns-plugin last" style="width:50%;">
<pre class="code c">GetOverlappedResult<span class="br0">&#40;</span>
       myHandle<span class="sy0">,</span> <span class="coMULTI">/* handle of file or event */</span>
       <span class="sy0">&amp;</span>ov<span class="sy0">,</span>      <span class="coMULTI">/* overlapped structure */</span>
       <span class="sy0">&amp;</span>nRead<span class="sy0">,</span>   <span class="coMULTI">/* actual bytes transferred */</span>
       TRUE<span class="br0">&#41;</span><span class="sy0">;</span>    <span class="coMULTI">/* wait for the operation to finish */</span></pre>
</td></tr></table>
<pre class="code c">HANDLE hFile<span class="sy0">;</span>
OVERLAPPED ov<span class="sy0">;</span>
DWORD bytesTransferred<span class="sy0">;</span>
&nbsp;
<span class="coMULTI">/* TODO ... start overlapped I/O operation */</span>
&nbsp;
<span class="coMULTI">/* wait for completion */</span>
GetOverlappedResult<span class="br0">&#40;</span>hFile<span class="sy0">,</span> <span class="sy0">&amp;</span>ov<span class="sy0">,</span> <span class="sy0">&amp;</span>bytesTransferred<span class="sy0">,</span> TRUE<span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>
Obiectul <code>hFile</code> și structura <code>ov</code> sunt folosite pentru a identifica unic operația de I/O a cărei stare dorim să o aflăm.
</p>

<p>
Dacă parametrul <code>bWait</code> este <code>TRUE</code>, funcția <code>GetOverlappedResult</code> va aștepta până când operația de I/O specificată se termină, în caz contrar se va întoarce imediat. În ambele cazuri funcția va întoarce <code>TRUE</code> doar dacă operația de I/O s-a terminat cu succes. 
</p>

<p>
Mai jos regăsiți un exemplu de așteptare a terminării unei operații I/O Overlapped folosind ca obiect de sincronizare un eveniment. Exemplul prezintă folosirea unei operații de citire asincronă:
</p>
<pre class="code c"><span class="co2">#include &quot;utils.h&quot;</span>
<span class="co2">#include &lt;windows.h&gt;</span>
<span class="co2">#include &lt;stdlib.h&gt;</span>
&nbsp;
<span class="co2">#define BUF_SIZE	1024 * 1024 // 1MB</span>
&nbsp;
<span class="kw4">int</span> main<span class="br0">&#40;</span><span class="kw4">int</span> argc<span class="sy0">,</span> <span class="kw4">char</span> <span class="sy0">**</span>argv<span class="br0">&#41;</span>
<span class="br0">&#123;</span>
	OVERLAPPED ov<span class="sy0">;</span>
	HANDLE hFile<span class="sy0">;</span>
	HANDLE hEvent<span class="sy0">;</span>
	DWORD dwRet<span class="sy0">,</span> dwErr<span class="sy0">,</span> dwBytesRead<span class="sy0">;</span>
	<span class="kw4">char</span> <span class="sy0">*</span>buffer <span class="sy0">=</span> <a href="http://www.opengroup.org/onlinepubs/009695399/functions/malloc.html"><span class="kw3">malloc</span></a><span class="br0">&#40;</span>BUF_SIZE <span class="sy0">*</span> <span class="kw4">sizeof</span><span class="br0">&#40;</span><span class="kw4">char</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
	<span class="coMULTI">/* Make sure overlapped structure is clean */</span>
	ZeroMemory<span class="br0">&#40;</span><span class="sy0">&amp;</span>ov<span class="sy0">,</span> <span class="kw4">sizeof</span><span class="br0">&#40;</span>ov<span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy0">;</span>
	<a href="http://www.opengroup.org/onlinepubs/009695399/functions/memset.html"><span class="kw3">memset</span></a><span class="br0">&#40;</span>buffer<span class="sy0">,</span> <span class="nu0">0</span><span class="sy0">,</span> BUF_SIZE<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
	<span class="coMULTI">/* Create manual-reset event */</span>
	hEvent <span class="sy0">=</span> CreateEvent<span class="br0">&#40;</span>NULL<span class="sy0">,</span> TRUE<span class="sy0">,</span> FALSE<span class="sy0">,</span> NULL<span class="br0">&#41;</span><span class="sy0">;</span>
	DIE<span class="br0">&#40;</span>hEvent <span class="sy0">==</span> INVALID_HANDLE_VALUE<span class="sy0">,</span> <span class="st0">&quot;CreateEvent&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
	ov.<span class="me1">hEvent</span> <span class="sy0">=</span> hEvent<span class="sy0">;</span>
&nbsp;
	hFile <span class="sy0">=</span> CreateFile<span class="br0">&#40;</span>argv<span class="br0">&#91;</span><span class="nu0">1</span><span class="br0">&#93;</span><span class="sy0">,</span>
                           GENERIC_READ<span class="sy0">,</span>     <span class="coMULTI">/* access mode */</span>
                           FILE_SHARE_READ<span class="sy0">,</span>  <span class="coMULTI">/* sharing option */</span>
                           NULL<span class="sy0">,</span>             <span class="coMULTI">/* security attributes */</span>
                           OPEN_EXISTING<span class="sy0">,</span>    <span class="coMULTI">/* open only if it exists */</span>
                           FILE_FLAG_OVERLAPPED<span class="sy0">,</span><span class="coMULTI">/* file attributes */</span>
                           NULL<span class="br0">&#41;</span><span class="sy0">;</span>            <span class="coMULTI">/* no template */</span>
	DIE<span class="br0">&#40;</span>hFile <span class="sy0">==</span> INVALID_HANDLE_VALUE<span class="sy0">,</span> <span class="st0">&quot;CreateFile&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
	dwRet <span class="sy0">=</span> ReadFile<span class="br0">&#40;</span>hFile<span class="sy0">,</span> buffer<span class="sy0">,</span> BUF_SIZE<span class="sy0">,</span> <span class="sy0">&amp;</span>dwBytesRead<span class="sy0">,&amp;</span>ov<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
	<span class="kw1">if</span> <span class="br0">&#40;</span>dwRet <span class="sy0">==</span> FALSE<span class="br0">&#41;</span> <span class="br0">&#123;</span>		
		dwErr <span class="sy0">=</span> GetLastError<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
		<span class="kw1">switch</span> <span class="br0">&#40;</span>dwErr<span class="br0">&#41;</span> <span class="br0">&#123;</span>
			<span class="kw1">case</span> ERROR_HANDLE_EOF<span class="sy0">:</span> 
&nbsp;
				<a href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span class="kw3">printf</span></a><span class="br0">&#40;</span><span class="st0">&quot;End of File Reached<span class="es1">\n</span>&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
				<span class="kw2">break</span><span class="sy0">;</span>
&nbsp;
			<span class="kw1">case</span> ERROR_IO_PENDING<span class="sy0">:</span>
&nbsp;
				<span class="coMULTI">/* async io not ready */</span>
				<a href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span class="kw3">printf</span></a><span class="br0">&#40;</span><span class="st0">&quot;Async IO not finished immediately<span class="es1">\n</span>&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
				<span class="coMULTI">/* do some other work  in the meantime */</span>
				Sleep<span class="br0">&#40;</span><span class="nu0">1</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
				<span class="coMULTI">/* Wait for it to finish */</span>
				dwRet <span class="sy0">=</span> GetOverlappedResult<span class="br0">&#40;</span>ov.<span class="me1">hEvent</span><span class="sy0">,</span> <span class="sy0">&amp;</span>ov<span class="sy0">,</span> <span class="sy0">&amp;</span>dwBytesRead<span class="sy0">,</span> TRUE<span class="br0">&#41;</span><span class="sy0">;</span>
				<a href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span class="kw3">printf</span></a><span class="br0">&#40;</span><span class="st0">&quot;nRead = %d<span class="es1">\n</span>&quot;</span><span class="sy0">,</span> dwBytesRead<span class="br0">&#41;</span><span class="sy0">;</span>
				<span class="kw2">break</span><span class="sy0">;</span>
&nbsp;
			<span class="kw1">default</span><span class="sy0">:</span>
				<span class="coMULTI">/* ReadFile failed */</span>
				PrintLastError<span class="br0">&#40;</span><span class="st0">&quot;ReadFile&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
		<span class="br0">&#125;</span>
	<span class="br0">&#125;</span> <span class="kw1">else</span> <span class="br0">&#123;</span>
		<a href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span class="kw3">printf</span></a><span class="br0">&#40;</span><span class="st0">&quot;Async IO finished immediately<span class="es1">\n</span>&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
		<a href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span class="kw3">printf</span></a><span class="br0">&#40;</span><span class="st0">&quot;%d <span class="es1">\n</span>&quot;</span><span class="sy0">,</span> dwBytesRead<span class="br0">&#41;</span><span class="sy0">;</span>
	<span class="br0">&#125;</span>
&nbsp;
	dwRet <span class="sy0">=</span> CloseHandle<span class="br0">&#40;</span>hFile<span class="br0">&#41;</span><span class="sy0">;</span>
	DIE<span class="br0">&#40;</span>dwRet <span class="sy0">==</span> FALSE<span class="sy0">,</span> <span class="st0">&quot;CloseHandle&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
	dwRet <span class="sy0">=</span> CloseHandle<span class="br0">&#40;</span>hEvent<span class="br0">&#41;</span><span class="sy0">;</span>
	DIE<span class="br0">&#40;</span>dwRet <span class="sy0">==</span> FALSE<span class="sy0">,</span> <span class="st0">&quot;CloseHandle&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
	<span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">&#125;</span></pre>

<p>
<strong>Notă:</strong> Când testați acest exemplu, este posibil ca apelul asincron să se întoarcă din prima dacă fișierul din care se citește este deja mapat în RAM (ex: ați copiat înainte fișierul sau l-ați deshis pentru citire).
</p>

</div>
<!-- EDIT8 SECTION "Așteptarea și interogarea operațiilor asincrone" [8035-13438] -->
<h2 class="sectionedit9" id="windows_-_io_completion_ports">Windows - I/O Completion Ports</h2>
<div class="level2">

<p>
Mecanismul de <strong>completion ports</strong> este cel mai scalabil dintre toate cele prezentate până acum. Un server care folosește completion ports poate face față la foarte multe (zeci de mii) conexiuni simultan, fără probleme prea mari. Celelalte metode își ating limitările cu mult înainte.
</p>

<p>
Un <strong>completion port</strong> este un obiect în kernel cu care se asociază alți descriptori (fișiere, sockeți) și prin intermediul căruia se transmit notificările de completare ale unor operații asincrone lansate anterior. Un completion port are asociat un pool de worker threads. Aceste fire de execuție așteaptă să primească notificări de completare a operațiilor asincrone. În momentul în care un fir de execuție primește o notificare va deveni activ și va lucra o perioadă până se va întoarce din nou așteptând următoarea notificare.
</p>

<p>
<a href="../../../../_detail/so/laboratoare-2013/io_completion.png%3Fid=so%253Alaboratoare-2013%253Alaborator-10.html" class="media" title="so:laboratoare-2013:io_completion.png"><img src="../../../../_media/so/laboratoare-2013/io_completion.png%3Fw=700&amp;tok=7ffc81" class="mediacenter" title=" " alt=" " width="700" /></a>
</p>

</div>
<!-- EDIT9 SECTION "Windows - I/O Completion Ports" [13439-14390] -->
<h3 class="sectionedit10" id="crearea_unui_completion_port">Crearea unui completion port</h3>
<div class="level3">

<p>
Funcția <code><a href="http://msdn.microsoft.com/en-us/library/aa363862%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/aa363862%28VS.85%29.aspx"  rel="nofollow"> CreateIoCompletionPort</a></code> are dublu rol:
</p>
<ul>
<li class="level1"><div class="li">creează un nou completion port</div>
</li>
<li class="level1"><div class="li">adaugă un nou handle pe care se va aștepta terminarea unei operații I/O</div>
</li>
</ul>

<p>
Pentru crearea unui completion port se folosește funcția <code><a href="http://msdn.microsoft.com/en-us/library/aa363862%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/aa363862%28VS.85%29.aspx"  rel="nofollow"> CreateIoCompletionPort</a></code> ca în exemplul de mai jos:
</p>
<table class="columns-plugin">
<tr><td class="columns-plugin first">
<pre class="code c">HANDLE WINAPI CreateIoCompletionPort<span class="br0">&#40;</span>
         HANDLE FileHandle<span class="sy0">,</span>
         HANDLE ExistingCompletionPort<span class="sy0">,</span>
         ULONG_PTR CompletionKey<span class="sy0">,</span>
         DWORD NumberOfConcurrentThreads
<span class="br0">&#41;</span><span class="sy0">;</span></pre>
</td><td class="columns-plugin last">
<pre class="code c">HANDLE iocp <span class="sy0">=</span> CreateIoCompletionPort<span class="br0">&#40;</span>
         INVALID_HANDLE_VALUE<span class="sy0">,</span> <span class="coMULTI">/* New Completion Port */</span>
         NULL<span class="sy0">,</span>               
         NULL<span class="sy0">,</span>  
         <span class="nu0">0</span>                     <span class="coMULTI">/* No threads = No Procs */</span>
<span class="br0">&#41;</span><span class="sy0">;</span></pre>
</td></tr></table>

<p>
Pentru crearea unui nou completion port, primul parametru trebuie să fie <code>INVALID_HANDLE_VALUE</code>. În acest caz, ultimul parametru indică numărul maxim de fire de execuție concurente care pot rula. În caz că se specifică 0, atunci numărul de fire de execuție concurente este setat la numărul de procesoare.
</p>

</div>
<!-- EDIT10 SECTION "Crearea unui completion port" [14391-15626] -->
<h3 class="sectionedit11" id="adaugarea_unui_descriptor_la_completion_port">Adăugarea unui descriptor la completion port</h3>
<div class="level3">

<p>
Pentru adăugarea unui descriptor deschis cu opțiunea de overlapped I/O la completion port se folosește tot funcția <a href="http://msdn.microsoft.com/en-us/library/aa363862%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/aa363862%28VS.85%29.aspx"  rel="nofollow"> CreateIoCompletionPort</a>. În această situație primul argument va fi handle-ul fișierului/socket-ului care se dorește adăugat, iar al doilea handle-ul completion port-ului obținut la crearea acestuia:
</p>
<pre class="code c">HANDLE iocp<span class="sy0">;</span>
HANDLE hFile<span class="sy0">;</span>
&nbsp;
<span class="coMULTI">/* create completion port */</span>
iocp <span class="sy0">=</span> CreateIoCompletionPort<span class="br0">&#40;</span>INVALID_HANDLE_VALUE<span class="sy0">,</span> NULL<span class="sy0">,</span> <span class="br0">&#40;</span>ULONG_PTR<span class="br0">&#41;</span> NULL<span class="sy0">,</span> <span class="nu0">0</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
<span class="coMULTI">/* open file for overlapped I/O */</span>
hFile <span class="sy0">=</span> CreateFile<span class="br0">&#40;</span>...<span class="sy0">,</span> FILE_FLAG_OVERLAPPED<span class="sy0">,</span> ...<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
<span class="coMULTI">/* add file handle to completion port */</span>
CreateIoCompletionPort<span class="br0">&#40;</span>hFile<span class="sy0">,</span> iocp<span class="sy0">,</span> <span class="br0">&#40;</span>ULONG_PTR<span class="br0">&#41;</span> hFile <span class="coMULTI">/* use handle as key */</span><span class="sy0">,</span> <span class="nu0">0</span><span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>
După cum se observă, în cazul creării unui completion port, al doilea argument este NULL. La adăugarea unui handle de fișier la completion port al doilea argument este handle-ul de completion port. Al treilea argument este o cheie care va fi folosită pentru identificarea handle-ului în momentul recepționării unei notificări.
</p>

</div>
<!-- EDIT11 SECTION "Adăugarea unui descriptor la completion port" [15627-16788] -->
<h3 class="sectionedit12" id="asteptarea_incheierii_unei_operatii_asincrone">Așteptarea încheierii unei operații asincrone</h3>
<div class="level3">

<p>
Firele de execuție worker sunt folosite pentru așteptarea încheierii operațiilor asincrone și a prelucrărilor ulterioare. Firele de execuție vor primi notificări de la handle-ul completion port-ului folosind funcția <a href="http://msdn.microsoft.com/en-us/library/aa364986%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/aa364986%28VS.85%29.aspx"  rel="nofollow"> GetQueuedCompletionStatus</a>:
</p>
<table class="columns-plugin">
<tr><td class="columns-plugin first">
<pre class="code">BOOL WINAPI GetQueuedCompletionStatus(
         HANDLE CompletionPort,
         LPDWORD lpNumberOfBytes,
         PULONG_PTR lpCompletionKey,
         LPOVERLAPPED *lpOverlapped,
         DWORD dwMilliseconds
);</pre>
</td><td class="columns-plugin last">
<pre class="code c">bRet <span class="sy0">=</span> GetQueuedCompletionStatus<span class="br0">&#40;</span>
         iocp<span class="sy0">,</span>    <span class="coMULTI">/* completion port handle */</span>
         <span class="sy0">&amp;</span>bytes<span class="sy0">,</span>  <span class="coMULTI">/* actual bytes transferred */</span>
         <span class="sy0">&amp;</span>key<span class="sy0">,</span>    <span class="coMULTI">/* return key to indentify the operation */</span>
         <span class="sy0">&amp;</span>ov<span class="sy0">,</span>     <span class="coMULTI">/* overlapped structure used */</span>
         INFINITE <span class="coMULTI">/* wait time */</span>
<span class="br0">&#41;</span><span class="sy0">;</span></pre>
</td></tr></table>

<p>
Pe baza cheii obținute se poate determina handle-ul care a generat notificarea.
</p>

</div>
<!-- EDIT12 SECTION "Așteptarea încheierii unei operații asincrone" [16789-17810] -->
<h3 class="sectionedit13" id="exemplu_de_folosire_completion_ports">Exemplu de folosire completion ports</h3>
<div class="level3">

<p>
În exemplul de mai jos este prezentată folosirea mecanismului de completion ports în cazul operațiilor asincrone pe sockeți. Exemplul este similar cu cel prezentat în secțiunile dedicate funcțiilor de multiplexare I/O pe Linux. Există un fir de execuție worker care va aștepta primirea notificărilor la completion port, iar firul de execuție principal va fi responsabil cu primirea de cereri de conexiune (apeluri accept).
</p>
<pre class="code c">HANDLE iocp<span class="sy0">;</span>
&nbsp;
<span class="coMULTI">/*** main thread ***/</span>
&nbsp;
SOCKET listenfd<span class="sy0">,</span> sockfd<span class="sy0">;</span>        <span class="coMULTI">/* listener socket; connection socket */</span>
&nbsp;
<span class="coMULTI">/* create I/O completion port */</span>
iocp <span class="sy0">=</span> CreateIoCompletionPort<span class="br0">&#40;</span>INVALID_HANDLE_VALUE<span class="sy0">,</span> NULL<span class="sy0">,</span> <span class="br0">&#40;</span>ULONG_PTR<span class="br0">&#41;</span> NULL<span class="sy0">,</span> <span class="nu0">0</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
<span class="coMULTI">/* TODO ... create server socket (listener) */</span>
&nbsp;
<span class="coMULTI">/* TODO ... create worker thread */</span>
&nbsp;
<span class="kw1">while</span> <span class="br0">&#40;</span><span class="nu0">1</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>        <span class="coMULTI">/* server loop */</span>
   <span class="coMULTI">/* TODO ... accept connections */</span>
&nbsp;
   <span class="coMULTI">/* add socket to completion port */</span>
   CreateIoCompletionPort<span class="br0">&#40;</span>sockfd<span class="sy0">,</span> iocp<span class="sy0">,</span> <span class="br0">&#40;</span>ULONG_PTR<span class="br0">&#41;</span> sockfd<span class="coMULTI">/* use handle as key */</span><span class="sy0">,</span> <span class="nu0">0</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
   <span class="coMULTI">/* TODO ... start asynchronous operation */</span>
<span class="br0">&#125;</span>
&nbsp;
&nbsp;
<span class="coMULTI">/*** worker thread ***/</span>
&nbsp;
DWORD bytes<span class="sy0">;</span>
ULONG_PTR key<span class="sy0">;</span>
LPOVERLAPPED ov<span class="sy0">;</span>
&nbsp;
<span class="kw1">while</span> <span class="br0">&#40;</span><span class="nu0">1</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
    <span class="coMULTI">/* wait for notification */</span>
    GetQueuedCompletionStatus<span class="br0">&#40;</span>iocp<span class="sy0">,</span> <span class="sy0">&amp;</span>bytes<span class="sy0">,</span> <span class="sy0">&amp;</span>key<span class="sy0">,</span> <span class="sy0">&amp;</span>ov<span class="sy0">,</span> INFINITE<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
    <span class="coMULTI">/* TODO ... process request */</span>
<span class="br0">&#125;</span></pre>

</div>
<!-- EDIT13 SECTION "Exemplu de folosire completion ports" [17811-19106] -->
<h2 class="sectionedit14" id="zero-copy_io">Zero-copy I/O</h2>
<div class="level2">

<p>
<code>Zero-copy</code> se referă la tehnica prin care procesorul evită operațiile de copiere a datelor dintr-o zonă de memorie într-alta. Operațiile <code>zero-copy</code> reduc numărul de schimbări de context între spațiul utilizator și spațiul kernel, resursele sistemului fiind utilizate eficient.
</p>

<p>
Dacă o aplicație dorește să transmită date dintr-un fișier pe un socket, va folosi în mod normal schema:
<a href="../../../../_detail/so/laboratoare-2013/normal_copy.gif%3Fid=so%253Alaboratoare-2013%253Alaborator-10.html" class="media" title="so:laboratoare-2013:normal_copy.gif"><img src="../../../../_media/so/laboratoare-2013/normal_copy.gif" class="mediacenter" title=" " alt=" " /></a>
</p>

<p>
Se observă că există multiple copieri cu aceleași date. O schemă mai eficientă, care elimină două dintre copierile în plus și totodată două context-switch-uri, este aceasta:
<a href="../../../../_detail/so/laboratoare-2013/zero_copy.gif%3Fid=so%253Alaboratoare-2013%253Alaborator-10.html" class="media" title="so:laboratoare-2013:zero_copy.gif"><img src="../../../../_media/so/laboratoare-2013/zero_copy.gif" class="mediacenter" title=" " alt=" " /></a>
</p>

<p>
Mai multe detalii, inclusiv explicarea mai pe larg a contextului, puteți găsi <a href="http://www.ibm.com/developerworks/library/j-zerocopy/" class="urlextern" title="http://www.ibm.com/developerworks/library/j-zerocopy/"  rel="nofollow"> aici</a>.
</p>

</div>
<!-- EDIT14 SECTION "Zero-copy I/O" [19107-19962] -->
<h3 class="sectionedit15" id="transmitfile">TransmitFile</h3>
<div class="level3">

<p>
Apelul <code><a href="http://msdn.microsoft.com/en-us/library/ms740565%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms740565%28VS.85%29.aspx"  rel="nofollow"> TransmitFile</a></code> este folosit pentru a eficientiza transmiterea de fișiere în rețea. <code><a href="http://msdn.microsoft.com/en-us/library/ms740565%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms740565%28VS.85%29.aspx"  rel="nofollow"> TransmitFile</a></code> folosește cache-ul sistemului de operare. Este o operație <strong><code>zero-copy</code></strong> - nu necesită alocarea de buffere în user-space și diminuează numărul de apeluri de sistem.
</p>

<p>
Pentru a transmite un fișier, acesta trebuie deschis folosind flag-ul FILE_FLAG_OVERLAPPED. Apelul <code><a href="http://msdn.microsoft.com/en-us/library/ms740565%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms740565%28VS.85%29.aspx"  rel="nofollow"> TransmitFile</a></code> primește ca argument socket-ul pe care se realizează comunicația și handle-ul fișierului de trimis.
</p>
<table class="columns-plugin">
<tr><td class="columns-plugin first">
<pre class="code c">BOOL TransmitFile<span class="br0">&#40;</span>
       SOCKET hSocket<span class="sy0">,</span>
       HANDLE hFile<span class="sy0">,</span>
       DWORD nNumberOfBytesToWrite<span class="sy0">,</span>
       DWORD nNumberOfBytesPerSend<span class="sy0">,</span>
       LPOVERLAPPED lpOverlapped<span class="sy0">,</span>
       LPTRANSMIT_FILE_BUFFERS lpTransmitBuffers<span class="sy0">,</span>
       DWORD dwFlags
<span class="br0">&#41;</span><span class="sy0">;</span></pre>
</td><td class="columns-plugin last">
<pre class="code c">result <span class="sy0">=</span> TransmitFile<span class="br0">&#40;</span>
       hSocket<span class="sy0">,</span>   <span class="coMULTI">/* destination socket handle */</span>
       hFile<span class="sy0">,</span>     <span class="coMULTI">/* source file handle */</span>
       <span class="nu0">0</span><span class="sy0">,</span>         <span class="coMULTI">/* nr bytes to write. 0 == send entire file */</span>
       <span class="nu0">0</span><span class="sy0">,</span>         <span class="coMULTI">/* block size. 0 == default block size */</span>
       <span class="sy0">&amp;</span>ov<span class="sy0">,</span>       <span class="coMULTI">/* overlapped I/O structure */</span>
       NULL<span class="sy0">,</span>            
       <span class="nu0">0</span>
<span class="br0">&#41;</span><span class="sy0">;</span></pre>
</td></tr></table>

<p>
O funcție similară este funcția <code><a href="http://msdn.microsoft.com/en-us/library/ms740566%28v=vs.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms740566%28v=vs.85%29.aspx"  rel="nofollow">TransmitPackets</a></code> care transmite date stocate în memorie pe un socket folosind cache-ul intern al sistemului de operare. Datele sunt reprezentate de o structură <code>TRANSMIT_PACKETS_ELEMENT</code>.
</p>

</div>
<!-- EDIT15 SECTION "TransmitFile" [19963-21652] -->
<h2 class="sectionedit16" id="exercitii">Exerciții</h2>
<div class="level2">

<p>
<p><div class="noteimportant">Înainte de a folosi o structură specifică Async I/O Win32 <abbr title="Application Programming Interface">API</abbr>, asigurați-vă că ați zeroizat-o
</div></p>
</p>

<p>
În rezolvarea laboratorului folosiți arhiva de sarcini <a href="http://elf.cs.pub.ro/so/res/laboratoare/lab10-tasks.zip" class="urlextern" title="http://elf.cs.pub.ro/so/res/laboratoare/lab10-tasks.zip"  rel="nofollow"> lab10-tasks.zip</a>
</p>
<ol>
<li class="level1"><div class="li"> <strong>(1 punct)</strong> Test operații asincrone</div>
<ul>
<li class="level2"><div class="li"> Setați proiectul <code>1-test_overlapp</code> ca default (<a href="http://elf.cs.pub.ro/so/wiki/laboratoare/resurse/vs_tips#setarea unui subproiect ca default" class="urlextern" title="http://elf.cs.pub.ro/so/wiki/laboratoare/resurse/vs_tips#setarea unui subproiect ca default"  rel="nofollow"> detalii aici</a>).</div>
</li>
<li class="level2"><div class="li"> Programul realizează citirea unui buffer de 64KB dintr-un fișier, folosind operații overlapped.</div>
</li>
<li class="level2"><div class="li"> Compilați și testați programul: <pre class="code bash"><span class="nu0">1</span>-test_overlapp.exe C:\WINDOWS\explorer.exe</pre>
</div>
</li>
<li class="level2"><div class="li"> Rulați încă o dată aceeași comandă. Diferă output-ul față de rularea anterioară? De ce?</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> <strong>(1.5 puncte)</strong> Zero-copy (TransmitFile)</div>
<ul>
<li class="level3"><div class="li"> Intrați în proiectul <code>2-transmit</code>.</div>
</li>
<li class="level3"><div class="li"> Un client dorește să trimită serverului un fișier folosind operații <a href="laborator-10.html#zero-copy_io" title="so:laboratoare-2013:laborator-10 ↵" class="wikilink1"> zero-copy IO</a>.</div>
</li>
<li class="level3"><div class="li"> Parcurgeți fișierele <code>sock_util.h</code>, <code>sock_util.c</code>, <code>server.c</code> și <code>transmit_client.c</code>.</div>
</li>
<li class="level3"><div class="li"> <strong>Hints</strong>:</div>
<ul>
<li class="level4"><div class="li"> Completați funcțiile marcate cu <code>TODO</code> din fișierul <code>transmit_client.c</code></div>
</li>
<li class="level4"><div class="li"> Revedeți secțiunea despre <a href="laborator-10.html#transmitfile" title="so:laboratoare-2013:laborator-10 ↵" class="wikilink1"> Transmit File</a>.</div>
</li>
<li class="level4"><div class="li"> Clientul transmite fișierul folosind <a href="http://msdn.microsoft.com/en-us/library/ms740565(v=vs.85).aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms740565(v=vs.85).aspx"  rel="nofollow"> TransmitFile</a>.</div>
</li>
</ul>
</li>
<li class="level3"><div class="li"> Puteți genera fișiere de test folosind proiectul <code>generator</code>: <pre class="code bash">generator.exe <span class="kw2">size</span> <span class="sy0">&gt;</span> output_file</pre>
</div>
</li>
<li class="level3"><div class="li"> Porniti serverul!</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> <strong>(3 puncte)</strong> Operații sincrone/asincrone</div>
<ul>
<li class="level2"><div class="li"> Intrați în proiectul <code>3-aio/</code></div>
</li>
<li class="level2"><div class="li"> Urmăriți implementarea funcției <code>do_io_sync</code> și implementați <code>do_io_async</code>.</div>
</li>
<li class="level2"><div class="li"> Alocați spațiu pentru structurile <code>OVERLAPPED</code> pentru toate cele 4 fișiere.</div>
</li>
<li class="level2"><div class="li"> Pentru inițializarea structurilor <code>OVERLAPPED</code> se recomandă implementarea funcției <code>init_overlapped</code>.</div>
</li>
<li class="level2"><div class="li"> Folosiți <code>GetOverlappedResult</code> pentru realizarea operațiilor asincrone pe cele 4 fișiere.</div>
</li>
<li class="level2"><div class="li"> Funcțiile trebuie să scrie conținutul bufferului <code>g_buffer</code> în cele 4 fișiere cu numele dat de vectorul files.</div>
</li>
<li class="level2"><div class="li"> Folosiți macro-ul <code>IO_OP_TYPE</code> pentru a determina comportamentul programului. </div>
</li>
<li class="level2"><div class="li"> <strong>Hints</strong>:</div>
<ul>
<li class="level3"><div class="li"> Revedeți secțiunea despre <a href="laborator-10.html#windows_-_io_asincron_overlapped" title="so:laboratoare-2013:laborator-10 ↵" class="wikilink1"> Overlapped IO</a>.</div>
</li>
</ul>
</li>
</ul>
</li>
<li class="level1"><div class="li"> <strong>(4.5 puncte)</strong> I/O completion ports</div>
<ol>
<li class="level2"><div class="li"> <strong>(1.5 puncte)</strong> </div>
<ul>
<li class="level4"><div class="li"> Intrați în proiectul <code>4-iocp/</code> </div>
</li>
<li class="level4"><div class="li"> Analizați conținutul fișierelor iocp.h și iocp.c</div>
</li>
<li class="level4"><div class="li"> Completați cele 4 funcții definite în iocp.c.</div>
</li>
</ul>
</li>
<li class="level2"><div class="li"> <strong>(3 puncte)</strong> Operații I/O asincrone cu I/O completion ports</div>
<ul>
<li class="level4"><div class="li"> Analizați conținutul fișierului aio.c.</div>
</li>
<li class="level4"><div class="li"> Scopul exercițiului este folosirea I/O completion ports pentru așteptarea încheierii operațiilor I/O asincrone (overlapped I/O).</div>
</li>
<li class="level4"><div class="li"> Implementați funcțiile init_io_async și do_io_async.</div>
</li>
<li class="level4"><div class="li"> Compilați și rulați programul. </div>
</li>
<li class="level4"><div class="li"> <strong>Hints</strong>:</div>
<ul>
<li class="level5"><div class="li"> Revedeți secțiunea despre <a href="laborator-10.html#crearea_unui_completion_port" title="so:laboratoare-2013:laborator-10 ↵" class="wikilink1"> IO completion ports</a>.</div>
</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ol>

</div>
<!-- EDIT16 SECTION "Exerciții" [21653-24788] -->
<h2 class="sectionedit17" id="solutii">Soluții</h2>
<div class="level2">



</div>
<!-- EDIT17 SECTION "Soluții" [24789-] --></div>
</body>
</html>
