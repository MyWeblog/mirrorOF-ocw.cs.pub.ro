    
    

<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
  <meta charset="utf-8" />
  <title>so:laboratoare-2013:resurse:recapitulare</title>
<meta name="generator" content="DokuWiki"/>
<meta name="robots" content="index,follow"/>
<meta name="date" content="2014-03-05T22:19:57+0200"/>
<meta name="keywords" content="so,laboratoare-2013,resurse,recapitulare"/>
<link rel="search" type="application/opensearchdescription+xml" href="../../../../../lib/exe/opensearch.php" title="CS Open CourseWare"/>
<link rel="start" href="../../../../../../courses.1.html"/>
<link rel="alternate" type="application/rss+xml" title="Recent Changes" href="../../../../../feed.php"/>
<link rel="alternate" type="application/rss+xml" title="Current Namespace" href="../../../../../feed.php%3Fmode=list&amp;ns=so:laboratoare-2013:resurse"/>
<link rel="alternate" type="text/html" title="Plain HTML" href="recapitulare.html"/>
<link rel="canonical" href="../../../../../so/laboratoare-2013/resurse/recapitulare.html"/>
<link rel="stylesheet" type="text/css" href="../../../../../lib/exe/css.php%3Ft=arctic&amp;tseed=1479898000.css"/>
<script type="text/javascript">/*<![CDATA[*/var NS='so:laboratoare-2013:resurse';var JSINFO = {"id":"so:laboratoare-2013:resurse:recapitulare","namespace":"so:laboratoare-2013:resurse","isadmin":0,"isauth":0};
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="../../../../../lib/exe/js.php%3Ftseed=1479898000"></script>
<script type="text/x-mathjax-config">/*<![CDATA[*/MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ["$","$"], ["\\(","\\)"] ],
        displayMath: [ ["$$","$$"], ["\\[","\\]"] ],
        processEscapes: true
    }
});
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
<script type="text/javascript">/*<![CDATA[*/
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
		  
/*!]]>*/</script>
<script type="text/javascript">/*<![CDATA[*/
var pageTracker = _gat._getTracker("UA-38383934-1");
pageTracker._initData();
pageTracker._trackPageview();
		  
/*!]]>*/</script>
</head>
<body>
<div class="dokuwiki export">
<!-- TOC START -->
<div id="dw__toc">
<h3 class="toggle">Table of Contents</h3>
<div>

<ul class="toc">
<li class="level1"><div class="li"><a href="recapitulare.html#recapitulare">Recapitulare</a></div>
<ul class="toc">
<li class="level2"><div class="li"><a href="recapitulare.html#exercitii">Exerciții</a></div></li>
</ul></li>
</ul>
</div>
</div>
<!-- TOC END -->

<h1 class="sectionedit1" id="recapitulare">Recapitulare</h1>
<div class="level1">

<p>
Laboratorul constă în subiecte în stilul celor de la examen, însoțite de mici bucăți de cod complete sau aproape complete pe care le puteți rula pentru a vă convinge. Discuția pe marginea subiectelor cu asistentul sau cu colegii este încurajată. Subiectele sunt suficient de multe încât nu pot fi acoperite într-un singur laborator.
</p>

</div>
<!-- EDIT1 SECTION "Recapitulare" [1-376] -->
<h2 class="sectionedit2" id="exercitii">Exerciții</h2>
<div class="level2">

<p>
Utilizați arhiva <a href="http://elf.cs.pub.ro/so/wiki/_media/laboratoare/resurse/recap.tar.gz" class="urlextern" title="http://elf.cs.pub.ro/so/wiki/_media/laboratoare/resurse/recap.tar.gz"  rel="nofollow"> recap.tar.gz</a> aferentă laboratorului.
</p>
<ol>
<li class="level1"><div class="li"> Demand-paging, Copy-on-Write. Intrați în directorul <code>01-cow-dp</code>. </div>
<ul>
<li class="level2"><div class="li"> Rulați comanda:<pre class="code">make &amp;&amp; make run</pre>
</div>
</li>
<li class="level2"><div class="li"> <strong>Explicați</strong> apariția evenimentelor de Demand-paging și de Copy-on-Write.</div>
</li>
<li class="level2"><div class="li"> Pentru testare, utilizați fișierele: <code>fault/fault</code> și <code>fault2/fault</code>.</div>
</li>
<li class="level2"><div class="li"> De ce la ultima pagină din buffer (din fișierul <code>fault/fault</code>) nu se mai face Demand-paging?</div>
</li>
<li class="level2"><div class="li"> <strong>Hints</strong>:</div>
<ul>
<li class="level3"><div class="li"> paginile <strong>gri</strong> reprezintă pagini muliple nemapate reprezentate într-un	interval</div>
</li>
<li class="level3"><div class="li"> paginile <strong>verzi</strong> reprezintă pagini ce aparțin unui singur proces</div>
</li>
<li class="level3"><div class="li"> paginile <strong>roșii</strong> sunt pagini partajate de cel puțin două procese</div>
</li>
<li class="level3"><div class="li"> la <strong>click</strong> pe o pagină se centrează pagina respectivă și toate paginile legate de ea</div>
</li>
<li class="level3"><div class="li"> după ce a a apărut un eveniment de tipul Copy-on-Write <strong>un</strong> click duce la pagina la care este mapată acum, <strong>următorul</strong> click va duce la pagina veche la care era mapată</div>
</li>
</ul>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Subsistemul IO. Intraţi în directorul <code>02-io</code> şi inspectaţi fişierul <code>splice.c</code>. </div>
<ul>
<li class="level2"><div class="li"> Închipuiţi-vă scenariul în care programul rulează repede şi un alt scenariu în care rulează greu (din punctul de vedere al timpului).</div>
</li>
<li class="level2"><div class="li"> <strong>Hints</strong>:</div>
<ul>
<li class="level3"><div class="li"> Ce operaţii se fac la trunchierea fişierului?</div>
</li>
<li class="level3"><div class="li"> Care este rolul fişierului <a href="http://www.linuxinsight.com/proc_sys_vm_drop_caches.html" class="urlextern" title="http://www.linuxinsight.com/proc_sys_vm_drop_caches.html"  rel="nofollow"> /proc/sys/vm/drop_caches</a></div>
</li>
<li class="level3"><div class="li"> Ce fel de mecanism implementează apelul de sistem <code>splice</code>?</div>
</li>
<li class="level3"><div class="li"> <strong>Atenţie</strong>: Asigurați-vă că sistemul dispune de suficientă memorie (RAM) liberă pentru a putea aduce tot fișierul în RAM (i.e. dimensiunea memorie liberă &gt; dimensiunea fișierului).</div>
</li>
<li class="level3"><div class="li"> Utilizaţi scriptul <code>run.sh</code>: <pre class="code">sudo ./run.sh</pre>
</div>
</li>
<li class="level3"><div class="li"> <strong>Ignoraţi mesajul</strong>:<pre class="code">Command terminated by signal 13</pre>
</div>
</li>
</ul>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Threads counter (LD): Un proces crează N thread-uri și un thread apelează fork(); câte threaduri, atât în procesul părinte cât și în procesul copil, există imediat după acest moment? Studiați conținutul directorului <code>03-threads-counter</code>.În ce director din <code>/proc/$PID/</code> se află informațiile despre thread-urile procesului? De ce acestea au asignat un pid?</div>
</li>
<li class="level1"><div class="li"> Function hijacking (LD): De ce în cazul folosirii LD_PRELOAD se pot intercepta apeluri de funcții? Intrați în directorul <code>04-functions-hijacking</code>, compilați (<code>make</code>) și rulați (<code>./test</code> și <code>LD_PRELOAD=./libnative.so ./test</code>. Cum explicați output-ul diferit?</div>
</li>
<li class="level1"><div class="li"> Inițializări (VD): Intrați în directorul <code>05-init</code>. Compilați programul <code>initializari</code>. De ce durează mai mult prima inițializare? De asemenea, încercați să explicați dimensiunea mare a executabilului.</div>
</li>
<li class="level1"><div class="li"> Spațiu de adresă (AF): Intrați în directorul <code>06-addrspc</code> și inspectați fișierul <code>addrspc.c</code>. Ce se întâmplă cu spațiul de adresă al procesului în momentul schimbării de context?</div>
<ul>
<li class="level2"><div class="li"> <strong>Hints</strong>:</div>
<ul>
<li class="level3"><div class="li"> Threadurile rulează alternativ, scriind la stdout atunci când încep rularea</div>
</li>
<li class="level3"><div class="li"> Monitorizați <code>/proc/$PID/maps</code></div>
</li>
</ul>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Reentranță / thread-safety (AF): Catalogați funcțiile din <code>07-reentr/reentr.c</code> ca fiind reentrante / thread-safe. Puteți modifica programul încât să puneți în evidență aceste aspecte.</div>
</li>
<li class="level1"><div class="li"> Stack growth (VD): Scrieți o secvență de cod care să decidă dacă stiva crește în sus sau în jos. Un asemenea exemplu îl aveți în directorul <code>08-stack-growth</code>.</div>
</li>
<li class="level1"><div class="li"> Apeluri de sistem (DB): Câte apeluri de sistem se efectuează în urma rulării secvenţei de mai jos:<pre class="code c">   <span class="kw1">for</span> <span class="br0">&#40;</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> <span class="nu0">10</span><span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
                getpid<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
                write<span class="br0">&#40;</span><span class="nu0">1</span><span class="sy0">,</span> <span class="st0">&quot;A&quot;</span><span class="sy0">,</span> <span class="nu0">1</span><span class="br0">&#41;</span><span class="sy0">;</span>
   <span class="br0">&#125;</span></pre>
</div>
<ul>
<li class="level2"><div class="li"> Intrați în directorul <code>09-syscall</code>.</div>
</li>
<li class="level2"><div class="li"> Analizaţi conţinutul fişierului <code>pid_test.c</code>.</div>
</li>
<li class="level2"><div class="li"> Urmăriţi apelurile de system efectuate rulând comanda <code>strace</code>. <pre class="code bash"><span class="kw2">strace</span> .<span class="sy0">/</span>pid_test </pre>
</div>
</li>
<li class="level2"><div class="li"> <strong>Suplimentar</strong></div>
<ul>
<li class="level3"><div class="li"> Analizaţi conţinutul fişierului <code>fork_test.c</code>.</div>
</li>
<li class="level3"><div class="li"> Rulaţi programul având pentru <code>SYS_TYPE</code> pe rând valorile <code>SYS_NATIVE</code> şi <code>SYS_GLIBC</code>.  *Explicaţi rezultatul obţinut. Citiţi secţiunea <code>NOTES</code> din <code>getpid(2)</code>.</div>
</li>
</ul>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Creare procese (DB): Desenaţi arborele de procese rezultat în urma execuţiei programului <code>fork.c</code> din directorul <code>10-fork</code>.</div>
</li>
<li class="level1"><div class="li"> Descriptori de fisier (OB): Un proces dispune de o tabelă de descriptori de fișiere cu 1024 de intrări. În codul său, procesul deschide un număr mare de fișiere  folosind  open. Totuși, al 964-lea apel open se întoarce cu eroare, iar errno are valoarea EMFILE (maximum number of files open). Care este o posibilă explicație? Vă puteți gândi și la alte explicații decât cea din exemplu?</div>
</li>
<li class="level1"><div class="li"> File descriptor (BD): Completați zona punctată de mai jos cu cod Linux(posix) astfel incat sa conduca la afișarea mesajului “alfa” la ieșirea standard (standard output) și mesajul “beta” la ieșirea de eroare standard (standard error), fara sa alterați simbolurile standard fputs (functie), stderr și stdout (FILE *):</div>
<ul>
<li class="level2"><div class="li"> <pre class="code">/* de completat */
...
fputs(&quot;alfa&quot;, stderr);
fputs(&quot;beta&quot;, stdout);</pre>
</div>
</li>
<li class="level2"><div class="li"> Intrati in directorul <code>12-file</code>, si rulati comanda <pre class="code">./file &gt;out 2&gt;err </pre>
</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Calloc/Malloc (IS): Intrați in directorul <code>13-access</code>. Rulați cele 2 programe atât cu macro-ul TEST_ACCESS definit cât și fără acesta. Măsurați timpii de rulare folosind <em>time</em> și încercați să explicați diferența.</div>
</li>
<li class="level1"><div class="li"> Apeluri de sistem (RD): În urma rulării secvenței de mai jos:<pre class="code">	int page_size = getpagesize();

	for (i = 0; i &lt; 1000; i++)
		ptr[i] = malloc(page_size);</pre>

<p>
 se obține un număr redus de apeluri de sistem, de ordinul zecilor (apelul de sistem folosit de malloc este <code>brk</code>). Cum explicați?
</p>
</div>
<ul>
<li class="level2"><div class="li"> Intrați în directorul <code>14-malloc-syscalls</code>.</div>
</li>
<li class="level2"><div class="li"> Urmăriți conținutul fișierului <code>malloc-syscalls.c</code>.</div>
</li>
<li class="level2"><div class="li"> Compilați fișierul (folosiți <code>make</code>).</div>
</li>
<li class="level2"><div class="li"> Rulați comanda <code>strace -e brk ./malloc-syscall 2&gt;&amp;1 &gt; /dev/null | wc -l</code>.</div>
</li>
<li class="level2"><div class="li"> Rulați comanda <code>ltrace -e malloc ./malloc-syscall 2&gt;&amp;1 &gt; /dev/null | wc -l</code>.</div>
</li>
<li class="level2"><div class="li"> <strong>Suplimentar</strong></div>
<ul>
<li class="level3"><div class="li"> Actualizați macro-ul <code>DO_FREE</code> la valoarea 1.</div>
</li>
<li class="level3"><div class="li"> Câte apeluri <code>brk</code> au loc? Cum explicați? Ce rol are apelul de sistem <code>brk</code>?</div>
</li>
</ul>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Page fault-uri (RD): Câte page fault-uri se obțin în urma rulării secvenței de mai jos?<pre class="code">	char *p;
	int status;
	size_t i;
	int page_size = getpagesize();
	char value;

	p = mmap(NULL, NUM_PAGES * page_size, PROT_READ | PROT_WRITE,
			MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
	if (p == MAP_FAILED) {
		perror(&quot;mmap&quot;);
		exit(EXIT_FAILURE);
	}

	for (i = 0; i &lt; NUM_PAGES; i++)
		p[i*page_size] = i;

	switch (fork()) {
		case -1:    /* handle error */
			perror(&quot;fork&quot;);
			exit(EXIT_FAILURE);

		case 0:     /* child process */

			for (i = 0; i &lt; NUM_PAGES / 2; i++)
				value = p[i*page_size];

			for (i = NUM_PAGES; i &lt; NUM_PAGES; i++)
				p[i*page_size] = page_size-i;

			exit(EXIT_SUCCESS);
			break;

		default:
			break;
	}

	wait(&amp;status);
	for (i = 0; i &lt; NUM_PAGES; i++)
		p[i*page_size] = i;</pre>
</div>
<ul>
<li class="level2"><div class="li"> Intrați în directorul <code>15-faults</code>.</div>
</li>
<li class="level2"><div class="li"> Urmăriți conținutul fișierului <code>fork-faults.c</code>.</div>
</li>
<li class="level2"><div class="li"> Compilați fișierul (folosiți <code>make</code>).</div>
</li>
<li class="level2"><div class="li"> Instalați pachetul <code>sysstat</code>. Pachetul conține utilitarul <code>pidstat</code> care permite monitorizarea page fault-urilor unui proces (prin intermediul argumentului <code>-r</code>).</div>
</li>
<li class="level2"><div class="li"> Rulați programul <code>fork-faults</code>. Folosiți <code>ENTER</code> pentru a continua programul.</div>
</li>
<li class="level2"><div class="li"> Folosiți comanda <code>pidstat -r -T ALL -p $PID</code> pentru a urmări page fault-urile. Rulați comanda pentru fiecare secvență de program.</div>
<ul>
<li class="level3"><div class="li"> <code>$PID</code> reprezintă pid-ul unui proces. Puteți afla atât pid-ul procesului părinte cât și pe cel al procesului copil cu o comandă de forma <code>ps -ef | grep fork-faults</code>.</div>
</li>
</ul>
</li>
<li class="level2"><div class="li"> Urmăriți evoluția numărului de page fault-uri pentru cele două procese: părinte și copil. Page fault-urile care apar în cazul unui copy-on-write în procesul copil vor fi vizibile ulterior și în procesul părinte.</div>
</li>
</ul>
</li>
</ol>

</div>
<!-- EDIT2 SECTION "Exerciții" [377-] --></div>
</body>
</html>
