    
    

<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
  <meta charset="utf-8" />
  <title>so:laboratoare-2013:resurse:threaduri_extra</title>
<meta name="generator" content="DokuWiki"/>
<meta name="robots" content="index,follow"/>
<meta name="date" content="2014-03-05T22:19:57+0200"/>
<meta name="keywords" content="so,laboratoare-2013,resurse,threaduri_extra"/>
<link rel="search" type="application/opensearchdescription+xml" href="../../../../../lib/exe/opensearch.php" title="CS Open CourseWare"/>
<link rel="start" href="../../../../../../courses.1.html"/>
<link rel="alternate" type="application/rss+xml" title="Recent Changes" href="../../../../../feed.php"/>
<link rel="alternate" type="application/rss+xml" title="Current Namespace" href="../../../../../feed.php%3Fmode=list&amp;ns=so:laboratoare-2013:resurse"/>
<link rel="alternate" type="text/html" title="Plain HTML" href="threaduri_extra.html"/>
<link rel="canonical" href="../../../../../so/laboratoare-2013/resurse/threaduri_extra.html"/>
<link rel="stylesheet" type="text/css" href="../../../../../lib/exe/css.php%3Ft=arctic&amp;tseed=1476798676.css"/>
<script type="text/javascript">/*<![CDATA[*/var NS='so:laboratoare-2013:resurse';var JSINFO = {"id":"so:laboratoare-2013:resurse:threaduri_extra","namespace":"so:laboratoare-2013:resurse","isadmin":0,"isauth":0};
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="../../../../../lib/exe/js.php%3Ftseed=1476798676"></script>
<script type="text/x-mathjax-config">/*<![CDATA[*/MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ["$","$"], ["\\(","\\)"] ],
        displayMath: [ ["$$","$$"], ["\\[","\\]"] ],
        processEscapes: true
    }
});
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
<script type="text/javascript">/*<![CDATA[*/
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
		  
/*!]]>*/</script>
<script type="text/javascript">/*<![CDATA[*/
var pageTracker = _gat._getTracker("UA-38383934-1");
pageTracker._initData();
pageTracker._trackPageview();
		  
/*!]]>*/</script>
</head>
<body>
<div class="dokuwiki export">
<!-- TOC START -->
<div id="dw__toc">
<h3 class="toggle">Table of Contents</h3>
<div>

<ul class="toc">
<li class="level1"><div class="li"><a href="threaduri_extra.html#thread-uri_-_extra">Thread-uri - Extra</a></div></li>
<li class="level1"><div class="li"><a href="threaduri_extra.html#linux">Linux</a></div>
<ul class="toc">
<li class="level2"><div class="li"><a href="threaduri_extra.html#terminarea_thread-urilor">Terminarea thread-urilor</a></div></li>
<li class="level2"><div class="li"><a href="threaduri_extra.html#lucrul_cu_atributele_unui_thread">Lucrul cu atributele unui thread</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="threaduri_extra.html#modificarea_atributului_detasabilunificabil">Modificarea atributului detașabil/unificabil</a></div></li>
<li class="level3"><div class="li"><a href="threaduri_extra.html#modificarea_politicii_de_alocare_a_procesorului">Modificarea politicii de alocare a procesorului</a></div></li>
<li class="level3"><div class="li"><a href="threaduri_extra.html#modificarea_prioritatii">Modificarea priorităţii</a></div></li>
<li class="level3"><div class="li"><a href="threaduri_extra.html#modificarea_dimensiunii_si_adresei_de_start_a_stivei">Modificarea dimensiunii și adresei de start a stivei</a></div></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><div class="li"><a href="threaduri_extra.html#windows">Windows</a></div>
<ul class="toc">
<li class="level2"><div class="li"><a href="threaduri_extra.html#fibre_de_executie">Fibre de execuţie</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="threaduri_extra.html#introducere">Introducere</a></div></li>
<li class="level3"><div class="li"><a href="threaduri_extra.html#convertthreadtofiber">ConvertThreadToFiber</a></div></li>
<li class="level3"><div class="li"><a href="threaduri_extra.html#crearea_unei_fibre">Crearea unei fibre</a></div></li>
<li class="level3"><div class="li"><a href="threaduri_extra.html#planificarea_unei_fibre">Planificarea unei fibre</a></div></li>
<li class="level3"><div class="li"><a href="threaduri_extra.html#alte_functii_utile">Alte funcţii utile</a></div></li>
<li class="level3"><div class="li"><a href="threaduri_extra.html#fiber_local_storage">Fiber Local Storage</a></div></li>
<li class="level3"><div class="li"><a href="threaduri_extra.html#stergerea_unei_fibre">Ştergerea unei fibre</a></div></li>
</ul></li>
</ul></li>
</ul>
</div>
</div>
<!-- TOC END -->

<h1 class="sectionedit1" id="thread-uri_-_extra">Thread-uri - Extra</h1>
<div class="level1">

</div>
<!-- EDIT1 SECTION "Thread-uri - Extra" [1-32] -->
<h1 class="sectionedit2" id="linux">Linux</h1>
<div class="level1">

</div>
<!-- EDIT2 SECTION "Linux" [33-51] -->
<h2 class="sectionedit3" id="terminarea_thread-urilor">Terminarea thread-urilor</h2>
<div class="level2">

<p>
Există și posibilitatea ca un fir de execuţie să termine un alt fir, folosind mecanismul de “<em class="u">thread cancellation</em>”. Pentru a face acest lucru se folosește funcţia <code>pthread_cancel</code> care primește ca parametru id-ul firului de execuţie ce urmează să fie terminat :
</p>
<pre class="code c"><span class="kw4">int</span> pthread_cancel<span class="br0">&#40;</span>pthread_t thread<span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>
Un thread unificabil care a fost terminat în acest mod trebuie așteptat folosind <code>pthread_join</code> pentru ca resursele folosite de el să fie eliberate. Un fir terminat cu <code>pthread_cancel</code> va întoarce valoarea PTHREAD_CANCELED.
Totuși trebuie avut grijă la folosirea acestui mecanism, întrucât un thread este posibil să fie terminat înainte de a avea posibilitatea să elibereze anumite resurse folosite. Din aceasta cauză un thread poate să controleze dacă și când poate fi terminat de către un alt thread.
Din punctul de vedere al posibilităţii terminării folosind <code>pthread_cancel</code> un thread poate fi :
</p>
<ul>
<li class="level1"><div class="li">cancelabil asincron - un astfel de fir poate fi terminat de către un alt fir în orice punct al execuţiei.</div>
</li>
<li class="level1"><div class="li">cancelabil sincron - un astfel de fir NU poate fi terminat în orice punct al execuţiei sale, ci numai în anumite puncte specifice.</div>
</li>
<li class="level1"><div class="li">necancelabil - un astfel de fir nu poate fi terminat folosind <code>pthread_cancel</code>.</div>
</li>
</ul>

<p>
Stabilirea tipului unui fir de execuţie din acest punct de vedere se face folosind funcţiile :
</p>
<pre class="code c"><span class="kw4">int</span> pthread_setcancelstate<span class="br0">&#40;</span><span class="kw4">int</span> state<span class="sy0">,</span> <span class="kw4">int</span> <span class="sy0">*</span>oldstate<span class="br0">&#41;</span><span class="sy0">;</span>
<span class="kw4">int</span> pthread_setcanceltype<span class="br0">&#40;</span><span class="kw4">int</span> type<span class="sy0">,</span> <span class="kw4">int</span> <span class="sy0">*</span>oldtype<span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>
Funcţia <code>pthread_setcancelstate</code> poate fi folosită pentru a activa/dezactiva posibilitatea terminării unui fir folosind <code>pthread_cancel</code>. Argumentul <code>state</code> reprezintă noua lui stare care poate fi <code>PTHREAD_CANCEL_ENABLE</code> (pentru activare) sau <code>PTHREAD_CANCEL_DISABLE</code> (pentru dezactivare). În <code>oldstate</code>, dacă nu este NULL, se poate obţine vechea stare.
</p>

<p>
Folosind <code>pthread_setcancelstate</code> pot fi implementate regiuni critice, în sensul că tot codul dintr-o astfel de regiune trebuie executat în întregime sau deloc, practic firul să nu poată fi terminat de către un alt fir în timp ce se găsește într-o astfel de regiune.
</p>

<p>
Funcţia <code>pthread_setcanceltype</code> poate fi folosită pentru a schimba tipul de răspuns la o cerere de terminare : asincron sau sincron. Argumentul <code>type</code> indică noul tip și poate fi <code>PTHREAD_CANCEL_ASYNCHRONOUS</code> (pentru ca firul să poată fi terminat asincron, deci oricând) sau <code>PTHREAD_CANCEL_DEFERRED</code> (pentru ca o cerere de terminare sa fie amânată până când se ajunge într-un punct în care este posibilă terminarea firului). La fel, în <code>oldtype</code>, dacă nu este NULL se poate obţine starea anterioară.
</p>

<p>
În mod implicit la crearea unui fir folosind <code>pthread_create</code> starea lui este caracterizată de <code>PTHREAD_CANCEL_ENABLE</code> și <code>PTHREAD_CANCEL_DEFERRED</code>.
</p>

<p>
Funcţiile <code>pthread_create</code>, <code>pthread_setcancelstate</code> și <code>pthread_setcanceltype</code> întorc 0 în caz de succes și un cod de eroare nenul în caz de eșec.
</p>

<p>
În cazul în care un fir este cancelabil sincron, așa cum a fost precizat, terminarea lui se poate face numai în anumite puncte ale execuţiei sale. Practic cererile de terminare sunt amânate până se ajunge într-un astfel de punct, numit și <code>cancellation point</code>. Când se ajunge într-un astfel de punct se testează dacă există cereri de terminare, și dacă da, firul este terminat. Cel mai direct mod de a crea un astfel de punct este apelând funcţia :
</p>
<pre class="code c"><span class="kw4">void</span> pthread_testcancel<span class="br0">&#40;</span><span class="kw4">void</span><span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>
Dacă într-un program se folosește acest mecanism de terminare a firelor folosind <code>pthread_cancel</code>, această funcţie ar trebui apelată periodic în cadrul unei funcţii asociate unui thread în care se fac multe procesări, în punctele în care firul poate fi terminat fără a rămâne resurse neeliberate și fără a produce alte efecte nedorite.
</p>

<p>
Pe lângă <code>pthread_testcancel</code> mai există o serie de alte funcţii al căror apel reprezintă un punct de cancelare. Aceste funcţii sunt următoarele :
</p>
<ul>
<li class="level1"><div class="li"><code>pthread_join</code></div>
</li>
<li class="level1"><div class="li"><code>pthread_cond_wait</code></div>
</li>
<li class="level1"><div class="li"><code>pthread_cond_timedwait</code></div>
</li>
<li class="level1"><div class="li"><code>sem_wait</code></div>
</li>
<li class="level1"><div class="li"><code>sigwait</code></div>
</li>
</ul>

<p>
De asemenea, orice funcţie care apelează una din aceste funcţii este și ea un astfel de punct de terminare.
</p>

<p>
În general nu este o idee foarte bună folosirea funcţiei <code>pthread_cancel</code> pentru a termina un thread, decât în cazuri excepţionale. În cazuri normale o strategie mai bună este de a indica firului că trebuie să se termine și apoi să se aștepte terminarea lui.
</p>

</div>
<!-- EDIT3 SECTION "Terminarea thread-urilor" [52-4641] -->
<h2 class="sectionedit4" id="lucrul_cu_atributele_unui_thread">Lucrul cu atributele unui thread</h2>
<div class="level2">

<p>
Atributele unui fir de execuţie (cu o excepţie) sunt specificate la crearea firului de execuţie și <em class="u">nu pot fi schimbate</em> pe perioada în care firul de execuţie este folosit.
</p>

<p>
Pentru <em class="u">iniţializarea</em> și respectiv <em class="u">distrugerea</em> unui obiect ce reprezintă atributele unui fir de execuţie avem la dispoziţie funcţiile :
</p>
<pre class="code c"><span class="kw4">int</span> pthread_attr_init<span class="br0">&#40;</span>pthread_attr_t <span class="sy0">*</span>tattr<span class="br0">&#41;</span><span class="sy0">;</span>
<span class="kw4">int</span> pthread_attr_destroy<span class="br0">&#40;</span>pthread_attr_t <span class="sy0">*</span>tattr<span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>
Pentru a stabili anumite atribute specifice ale unui fir, trebuie urmaţi câţiva pași :
</p>

<p>
# se creează un obiect de tipul <code>pthread_attr_t</code>, de exemplu declarând o variabilă de acest tip.
# se apelează funcţia <code>pthread_attr_init</code> căreia i se dă ca parametru un pointer la acest obiect. Această funcţie iniţializează atributele cu valorile lor implicite.
# se modifică obiectul ce contine atributele folosind una din funcţiile prezentate mai jos, pentru ca să se obţină atributele dorite.
# se transmite un pointer la aceste atribute funcţiei <code>pthread_create</code>.
# se apelează funcţia <code>pthread_attr_destroy</code> pentru a elibera obiectul ce reprezintă atributele (variabila de tip <code>pthread_attr_t</code> nu este însă dezalocată, ea poate fi refolosită utilizând <code>pthread_attr_init</code>).
</p>

<p>
Un același obiect de tip <code>pthread_attr_t</code> poate fi folosit pentru crearea mai multor fire de execuţie distincte și nu este necesar să fie păstrat după crearea acestora.
</p>

<p>
În continuare sunt prezentate funcţiile ce modifică atributele cele mai uzuale ale unui fir de execuţie.
</p>

</div>
<!-- EDIT4 SECTION "Lucrul cu atributele unui thread" [4642-6230] -->
<h3 class="sectionedit5" id="modificarea_atributului_detasabilunificabil">Modificarea atributului detașabil/unificabil</h3>
<div class="level3">

<p>
Pentru a seta/verifica tipul unui fir de execuţie din punct de vedere detașabil/unificabil se pot utiliza următoarele funcţii :
</p>
<pre class="code c"><span class="kw4">int</span> pthread_attr_setdetachstate<span class="br0">&#40;</span>pthread_attr_t <span class="sy0">*</span>tattr<span class="sy0">,</span> <span class="kw4">int</span> detachstate<span class="br0">&#41;</span><span class="sy0">;</span>
<span class="kw4">int</span> pthread_attr_getdetachstate<span class="br0">&#40;</span><span class="kw4">const</span> pthread_attr_t <span class="sy0">*</span>tattr<span class="sy0">,</span> <span class="kw4">int</span> <span class="sy0">*</span>detachstate<span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>
Primul parametru este un pointer la obiectul reprezentând atributele, iar al doilea parametru reprezintă starea dorită - unificabil/detașabil. Deoarece implicit sunt create fire unificabile (valoarea <code>PTHREAD_CREATE_JOINABLE</code>), această funcţie trebuie apelată doar dacă se creează fire detașabile și în acest caz al doilea parametru trebuie să aibă valoarea <code>PTHREAD_CREATE_DETACHED</code>.
</p>

<p>
Chiar dacă un fir de execuţie este creat unificabil, el poate fi transformat ulterior într-un fir detașabil apelând funcţia <code>pthread_detach</code>. Însă o data detașat, nu mai poate fi făcut unificabil la loc.
</p>

</div>
<!-- EDIT5 SECTION "Modificarea atributului detașabil/unificabil" [6231-7212] -->
<h3 class="sectionedit6" id="modificarea_politicii_de_alocare_a_procesorului">Modificarea politicii de alocare a procesorului</h3>
<div class="level3">

<p>
Standardul POSIX definește 3 politici de alocare a procesorului :
</p>
<ul>
<li class="level1"><div class="li">SCHED_RR - round robin</div>
</li>
<li class="level1"><div class="li">SCHED_FIFO - first in first out</div>
</li>
<li class="level1"><div class="li">SCHED_OTHER - implementare dependentă de sistem</div>
</li>
</ul>

<p>
Politicile SCHED_RR și SCHED_FIFO sunt opţionale și sunt suportate DOAR de firele de execuţie real time.
</p>

<p>
Funcţia care este folosită pentru a schimba politica de execuţie a firelor este :
</p>
<pre class="code c"><span class="kw4">int</span> pthread_attr_setschedpolicy<span class="br0">&#40;</span>pthread_attr_t <span class="sy0">*</span>tattr<span class="sy0">,</span> <span class="kw4">int</span> policy<span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>
Pentru a afla politica curentă se poate folosi funcţia <code>pthread_attr_getschedpolicy</code> care în momentul de faţă întoarce doar SCHED_OTHER.
</p>
<pre class="code c"><span class="kw4">int</span> pthread_attr_getschedpolicy<span class="br0">&#40;</span><span class="kw4">const</span> pthread_attr_t <span class="sy0">*</span>attr<span class="sy0">,</span> <span class="kw4">int</span> <span class="sy0">*</span>policy<span class="br0">&#41;</span><span class="sy0">;</span></pre>

</div>
<!-- EDIT6 SECTION "Modificarea politicii de alocare a procesorului" [7213-7973] -->
<h3 class="sectionedit7" id="modificarea_prioritatii">Modificarea priorităţii</h3>
<div class="level3">

<p>
Pentru a schimba/verifica prioritatea firelor de execuţie dispunem de următoarele funcţii :
</p>
<pre class="code c"><span class="kw4">int</span> pthread_attr_setschedparam<span class="br0">&#40;</span>pthread_attr_t <span class="sy0">*</span>tattr<span class="sy0">,</span> <span class="kw4">const</span> <span class="kw4">struct</span> sched_param <span class="sy0">*</span>param<span class="br0">&#41;</span><span class="sy0">;</span>
<span class="kw4">int</span> pthread_attr_getschedparam<span class="br0">&#40;</span>pthread_attr_t <span class="sy0">*</span>tattr<span class="sy0">,</span> <span class="kw4">struct</span> sched_param <span class="sy0">*</span>param<span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>
Prioritatea este semnificativă doar dacă politica folosită este SCHED_RR sau SCHED_FIFO.
</p>

</div>
<!-- EDIT7 SECTION "Modificarea priorităţii" [7974-8387] -->
<h3 class="sectionedit8" id="modificarea_dimensiunii_si_adresei_de_start_a_stivei">Modificarea dimensiunii și adresei de start a stivei</h3>
<div class="level3">

<p>
De obicei stivele firelor de execuţie încep la limita unei pagini de memorie, iar orice dimensiune a lor este rotunjită până la limita următoarei pagini. La capătul stivei este adăugată de obicei o pagină pentru care nu avem drepturi de acces și astfel cele mai multe depășiri de stivă (stack overflows) vor genera semnalul SIGSEGV (deci un segmentation fault).
</p>

<p>
Dacă firul a fost creat unificabil stiva nu poate fi eliberată până nu se va termina un apel &lt;tt&gt;pthread_join&lt;/tt&gt; pentru respectivul fir.
</p>

<p>
De obicei biblioteca de fire de execuţie alocă 1M de memorie virtuală pentru fiecare stivă de fir de execuţie.
</p>

<p>
Limita minimă pentru dimensiunea unei stive a unui fir de execuţie este PTHREAD_STACK_MIN.
</p>

<p>
Pentru a seta/afla dimensiunea stivei unui fir de execuţie se pot utiliza funcţiile :
</p>
<pre class="code c"><span class="kw4">int</span> pthread_attr_setstacksize<span class="br0">&#40;</span>pthread_attr_t <span class="sy0">*</span>tattr<span class="sy0">,</span> <span class="kw4">int</span> stacksize<span class="br0">&#41;</span><span class="sy0">;</span>
<span class="kw4">int</span> pthread_attr_getstacksize<span class="br0">&#40;</span>pthread_attr_t <span class="sy0">*</span>tattr<span class="sy0">,</span> <span class="kw4">size_t</span> <span class="sy0">*</span>size<span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>
Pentru a specifica adresa de început a unei stive se poate utiliza funcţia :
</p>
<pre class="code c"><span class="kw4">int</span> pthread_attr_setstackaddr<span class="br0">&#40;</span>pthread_attr_t <span class="sy0">*</span>tattr<span class="sy0">,</span> <span class="kw4">void</span> <span class="sy0">*</span>stackaddr<span class="br0">&#41;</span><span class="sy0">;</span></pre>

</div>
<!-- EDIT8 SECTION "Modificarea dimensiunii și adresei de start a stivei" [8388-9597] -->
<h1 class="sectionedit9" id="windows">Windows</h1>
<div class="level1">

</div>
<!-- EDIT9 SECTION "Windows" [9598-9619] -->
<h2 class="sectionedit10" id="fibre_de_executie">Fibre de execuţie</h2>
<div class="level2">

</div>
<!-- EDIT10 SECTION "Fibre de execuţie" [9620-9651] -->
<h3 class="sectionedit11" id="introducere">Introducere</h3>
<div class="level3">

<p>
Comutarea între firele de execuţie în Windows este costisitoare pentru că presupune trecerea prin kernel-mode. De aceea au fost introduse <em class="u">fibrele</em> (fibers), care sunt planificate în user space de către programele care le-au creat.
</p>

<p>
Fiecare fir de execuţie poate avea mai multe fibre, așa cum un proces poate avea mai multe fire de execuţie. O fibră se execută în contextul firului de execuţie care o planifică.
</p>

<p>
Sistemul de operare nu este conștient de existenţa fibrelor, el vede doar firul de execuţie în cadrul căruia fibrele există (o fibră împrumută identitatea firului de care aparţine). De exemplu dacă o fibră execută <code>ExitThread</code>, firul care a lansat fibra respectivă se va termina.
</p>

<p>
O fibră nu are asociate aceleași informaţii de stare ca și firul de execuţie, ci are asociate doar următoarele informaţii de stare :
</p>
<ul>
<li class="level1"><div class="li">stiva</div>
</li>
<li class="level1"><div class="li">un subset al regiștrilor firului de execuţie</div>
</li>
<li class="level1"><div class="li">datele fibrei furnizate la crearea fibrei</div>
</li>
</ul>

<p>
Cum se face planificarea?
</p>

<p>
Fibrele nu sunt planificate preemptiv (sunt lăsate să ruleze până cedează de buna voie procesorul), cu observaţia că dacă firul din care fac parte este preemptat, automat fibră în execuţie este preemptată. O fibră este planificată printr-o comutare către ea dintr-o altă fibră. Kernelul planifică fire de execuţie, nu fibre.
</p>

</div>
<!-- EDIT11 SECTION "Introducere" [9652-11018] -->
<h3 class="sectionedit12" id="convertthreadtofiber">ConvertThreadToFiber</h3>
<div class="level3">

<p>
Înainte de a planifica prima fibră trebuie apelată funcţia <code>ConvertThreadToFiber</code> pentru a se crea o zonă în care să se salveze informaţii despre starea fibrei. După executarea acestei funcţii, firul apelant devine fibra activă (fibra în curs de execuţie). Informaţia de stare pentru această primă fibră include datele pasate ca argument funcţiei <code>ConvertThreadToFiber</code>.
</p>
<pre class="code c">LPVOID ConvertThreadToFiber <span class="br0">&#40;</span>LPVOID lpParameter<span class="br0">&#41;</span><span class="sy0">;</span></pre>
<ul>
<li class="level1"><div class="li"><code>lpParameter</code> - [in] Pointer la o variabilă pasată fibrei. Fibra va putea obţine aceste date folosind macroul <code>GetFiberData</code>.</div>
</li>
</ul>

<p>
În caz de succes este returnată adresa fibrei. Altfel, rezultatul este NULL și tipul erorii se poate afla folosind <code>GetLastError</code>.
</p>

<p>
Există și funcţia cu efect contrar, <code>ConvertFiberToThread</code> :
</p>
<pre class="code c">BOOL ConvertFiberToThread<span class="br0">&#40;</span><span class="kw4">void</span><span class="br0">&#41;</span><span class="sy0">;</span></pre>

</div>
<!-- EDIT12 SECTION "ConvertThreadToFiber" [11019-11904] -->
<h3 class="sectionedit13" id="crearea_unei_fibre">Crearea unei fibre</h3>
<div class="level3">

<p>
Funcţia <code>CreateFiber</code> este folosită pentru a crea o nouă fibră dintr-una deja existentă (deci DUPĂ apelul <code>ConvertThreadToFiber</code>).
</p>

<p>
Aceasta funcţie creează un obiect de tip fibră, îi alocă o stivă și setează execuţia fibrei să înceapă la adresa de start specificată (funcţia fibrei). Această funcţie NU planifică fibra.
</p>
<pre class="code c">LPVOID CreateFiber <span class="br0">&#40;</span>
	SIZE_T dwStackSize<span class="sy0">,</span>
	LPFIBER_START_ROUTINE lpStartAddress<span class="sy0">,</span>
	LPVOID lpParameter
<span class="br0">&#41;</span><span class="sy0">;</span></pre>
<ul>
<li class="level1"><div class="li"><code>dwStackSize</code> - dimensiunea, în bytes, a stivei.</div>
</li>
<li class="level1"><div class="li"><code>lpStartAddress</code> - pointer la funcţia ce trebuie executată de către fibră. </div>
</li>
</ul>

<p>
<strong>Atentie!</strong> Aceasta nu va fi executată decât după un apel <code>SwitchToFiber</code> către fibră.
Această funcţie arata așa :
</p>
<pre class="code c">VOID CALLBACK FiberProc<span class="br0">&#40;</span>PVOID lpParameter<span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>
unde <code>FiberProc</code> ţine locul numelui funcţiei, iar <code>lpParameter</code> este un pointer la datele fibrei, este același cu <code>lpParameter</code> transmis funcţiei <code>CreateFiber</code>.
</p>
<ul>
<li class="level1"><div class="li"><code>lpParameter</code> - pointer la o variabilă pasată fibrei. Fibra va putea obţine aceste date folosind macroul <code>GetFiberData</code>.</div>
</li>
</ul>

<p>
Numărul de fibre ce poate fi creat de către un fir de execuţie este limitat de către memoria virtuală disponibilă. Implicit, fiecare fibră are 1M rezervat pentru stivă, deci se pot crea cel mult 2028 fibre.
</p>

</div>
<!-- EDIT13 SECTION "Crearea unei fibre" [11905-13254] -->
<h3 class="sectionedit14" id="planificarea_unei_fibre">Planificarea unei fibre</h3>
<div class="level3">

<p>
Pentru a executa o fibra creată cu <code>CreateFiber</code> se folosește funcţia <code>SwitchToFiber</code>. Aceasta va salva starea fibrei curente și va restaura starea fibrei specificate. Se poate apela <code>SwitchToFiber</code> cu adresa unei fibre create de către un fir de execuţie diferit, pentru aceasta însă trebuie cunoscută adresa returnată celuilalt fir de execuţie de către funcţia <code>CreateFiber</code> și trebuie folosită o sincronizare adecvată.
</p>
<pre class="code c">VOID SwitchToFiber<span class="br0">&#40;</span>LPVOID lpFiber<span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>
<code>lpFiber</code> reprezintă adresa fibrei ce este planificată.
</p>

<p>
<strong>Atentie!</strong> Apelul :
</p>
<pre class="code c">SwitchToFiber<span class="br0">&#40;</span>GetCurrentFiber<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>
poate provoca probleme neprevăzute.
</p>

</div>
<!-- EDIT14 SECTION "Planificarea unei fibre" [13255-13963] -->
<h3 class="sectionedit15" id="alte_functii_utile">Alte funcţii utile</h3>
<div class="level3">

<p>
<code>GetFiberData</code> poate fi folosită pentru a obţine datele asociate unei fibre (valoarea parametrului <code>lpParameter</code> din apelul uneia din funcţiile <code>CreateFiber</code> sau <code>ConvertThreadToFiber</code>). Aceeași valoare este primită ca parametru de către funcţia asociată fibrei.
</p>
<pre class="code c">PVOID GetFiberData<span class="br0">&#40;</span><span class="kw4">void</span><span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>
<code>GetCurrentFiber</code> poate fi utilizată pentru a obţine adresa fibrei, care este chiar rezultatul întors de <code>CreateFiber</code> sau <code>ConvertThreadToFiber</code>.
</p>
<pre class="code c">PVOID GetCurrentFiber<span class="br0">&#40;</span><span class="kw4">void</span><span class="br0">&#41;</span><span class="sy0">;</span></pre>

</div>
<!-- EDIT15 SECTION "Alte funcţii utile" [13964-14522] -->
<h3 class="sectionedit16" id="fiber_local_storage">Fiber Local Storage</h3>
<div class="level3">

<p>
Se poate folosi <code>Fiber Local Storage</code> (FLS) pentru a crea o copie unică a unei variabile pentru fiecare fibră. Daca nu apare nici o comutare între fibre FLS se comportă exact ca și TLS. Funcţiile FLS (<code>FlsAlloc</code>, <code>FlsFree</code>, <code>FlsGetValue</code> și <code>FlsSetValue</code>) manipulează FLS-ul asociat fibrei curente. Dacă firul execută o fibră, și fibra se schimbă (prin comutare), atunci și FLS-ul va fi schimbat.
</p>

<p>
Funcţiile folosite pentru crearea, accesarea și distrugerea FLS-ului sunt similare cu cele pentru TLS.
</p>

</div>
<!-- EDIT16 SECTION "Fiber Local Storage" [14523-15081] -->
<h3 class="sectionedit17" id="stergerea_unei_fibre">Ştergerea unei fibre</h3>
<div class="level3">

<p>
Pentru a șterge datele asociate unei fibre se folosește funcţia <code>DeleteFiber</code>. Aceste date includ stiva, un subset al regiștrilor și datele fibrei. Dacă o fibră în execuţie apelează <code>DeleteFiber</code>, firul asociat ei va apela <code>ExitThread</code> și se va termina. Totuși, dacă o fibra activă este ștearsă de către o altă fibră, firul care rulează fibra se va termina anormal, pentru că stiva fibrei (care este și a firului de execuţie) a fost eliberată.
</p>
<pre class="code c"><span class="kw4">void</span> DeleteFiber<span class="br0">&#40;</span>LPVOID lpFiber<span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>
<code>lpFiber</code> specifică adresa fibrei ce va fi ștearsă.
</p>

</div>
<!-- EDIT17 SECTION "Ştergerea unei fibre" [15082-] --></div>
</body>
</html>
