    
    

<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
  <meta charset="utf-8" />
  <title>so:laboratoare:laborator-10</title>
<meta name="generator" content="DokuWiki"/>
<meta name="robots" content="index,follow"/>
<meta name="date" content="2016-05-09T16:23:58+0300"/>
<meta name="keywords" content="so,laboratoare,laborator-10"/>
<link rel="search" type="application/opensearchdescription+xml" href="../../../../lib/exe/opensearch.php" title="CS Open CourseWare"/>
<link rel="start" href="../../../../../courses.1.html"/>
<link rel="alternate" type="application/rss+xml" title="Recent Changes" href="../../../../feed.php"/>
<link rel="alternate" type="application/rss+xml" title="Current Namespace" href="../../../../feed.php%3Fmode=list&amp;ns=so:laboratoare"/>
<link rel="alternate" type="text/html" title="Plain HTML" href="laborator-10.html"/>
<link rel="canonical" href="../../../../so/laboratoare/laborator-10.html"/>
<link rel="stylesheet" type="text/css" href="../../../../lib/exe/css.php%3Ft=arctic&amp;tseed=1476798676.css"/>
<script type="text/javascript">/*<![CDATA[*/var NS='so:laboratoare';var JSINFO = {"id":"so:laboratoare:laborator-10","namespace":"so:laboratoare","isadmin":0,"isauth":0};
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="../../../../lib/exe/js.php%3Ftseed=1476798676"></script>
<script type="text/x-mathjax-config">/*<![CDATA[*/MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ["$","$"], ["\\(","\\)"] ],
        displayMath: [ ["$$","$$"], ["\\[","\\]"] ],
        processEscapes: true
    }
});
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
<script type="text/javascript">/*<![CDATA[*/
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
		  
/*!]]>*/</script>
<script type="text/javascript">/*<![CDATA[*/
var pageTracker = _gat._getTracker("UA-38383934-1");
pageTracker._initData();
pageTracker._trackPageview();
		  
/*!]]>*/</script>
</head>
<body>
<div class="dokuwiki export">
<!-- TOC START -->
<div id="dw__toc">
<h3 class="toggle">Table of Contents</h3>
<div>

<ul class="toc">
<li class="level1"><div class="li"><a href="laborator-10.html#laborator_10_-_operatii_io_avansate_-_windows">Laborator 10 - Operații IO avansate - Windows</a></div>
<ul class="toc">
<li class="clear">
<ul class="toc">
<li class="level3"><div class="li"><a href="laborator-10.html#materiale_ajutatoare">Materiale ajutătoare</a></div></li>
<li class="level3"><div class="li"><a href="laborator-10.html#nice_to_read">Nice to read</a></div></li>
<li class="level3"><div class="li"><a href="laborator-10.html#windows_-_io_asincron_overlapped">Windows - I/O asincron (overlapped)</a></div></li>
<li class="level3"><div class="li"><a href="laborator-10.html#overlapped_io_cu_asteptare">Overlapped I/O cu așteptare</a></div></li>
<li class="level3"><div class="li"><a href="laborator-10.html#file_flag_overlapped">FILE_FLAG_OVERLAPPED</a></div></li>
<li class="level3"><div class="li"><a href="laborator-10.html#structura_overlapped">Structura Overlapped</a></div></li>
<li class="level3"><div class="li"><a href="laborator-10.html#asteptarea_si_interogarea_operatiilor_asincrone">Așteptarea și interogarea operațiilor asincrone</a></div></li>
</ul>
</li>
<li class="level2"><div class="li"><a href="laborator-10.html#windows_-_io_completion_ports">Windows - I/O Completion Ports</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="laborator-10.html#crearea_unui_completion_port">Crearea unui completion port</a></div></li>
<li class="level3"><div class="li"><a href="laborator-10.html#adaugarea_unui_descriptor_la_completion_port">Adăugarea unui descriptor la completion port</a></div></li>
<li class="level3"><div class="li"><a href="laborator-10.html#asteptarea_incheierii_unei_operatii_asincrone">Așteptarea încheierii unei operații asincrone</a></div></li>
<li class="level3"><div class="li"><a href="laborator-10.html#exemplu_de_folosire_completion_ports">Exemplu de folosire completion ports</a></div></li>
</ul>
</li>
<li class="level2"><div class="li"><a href="laborator-10.html#zero-copy_io">Zero-copy I/O</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="laborator-10.html#transmitfile">TransmitFile</a></div></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><div class="li"><a href="laborator-10.html#exercitii_de_laborator">Exerciții de laborator</a></div>
<ul class="toc">
<li class="level2"><div class="li"><a href="laborator-10.html#exercitiul_0_-_joc_interactiv_2p">Exercițiul 0 - Joc interactiv (2p)</a></div></li>
<li class="level2"><div class="li"><a href="laborator-10.html#windows_9p">Windows (9p)</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="laborator-10.html#exercitiul_1_-_test_operatii_asincrone_1p">Exercițiul 1 - Test operații asincrone (1p)</a></div></li>
<li class="level3"><div class="li"><a href="laborator-10.html#exercitiul_2_-_zero-copytransmitfile_2p">Exercițiul 2 - Zero-copy/TransmitFile  (2p)</a></div></li>
<li class="level3"><div class="li"><a href="laborator-10.html#exercitiul_3_-_operatii_sincroneasincrone_3p">Exercițiul 3 - Operații sincrone/asincrone (3p)</a></div></li>
<li class="level3"><div class="li"><a href="laborator-10.html#exercitiul_4_-_io_completion_ports_3p">Exercițiul 4 - I/O completion ports (3p)</a></div>
<ul class="toc">
<li class="level4"><div class="li"><a href="laborator-10.html#crearea_unui_completion_ports_1p">Crearea unui completion ports (1p)</a></div></li>
<li class="level4"><div class="li"><a href="laborator-10.html#operatii_io_asincrone_cu_io_completion_ports_2p">Operații I/O asincrone cu I/O completion ports (2p)</a></div></li>
</ul>
</li>
</ul>
</li>
<li class="level2"><div class="li"><a href="laborator-10.html#solutii">Soluții</a></div></li>
</ul></li>
</ul>
</div>
</div>
<!-- TOC END -->

<h1 class="sectionedit1" id="laborator_10_-_operatii_io_avansate_-_windows">Laborator 10 - Operații IO avansate - Windows</h1>
<div class="level1">

</div>
<!-- EDIT1 SECTION "Laborator 10 - Operații IO avansate - Windows" [1-62] -->
<h3 class="sectionedit2" id="materiale_ajutatoare">Materiale ajutătoare</h3>
<div class="level3">
<ul>
<li class="level1"><div class="li"><a href="http://elf.cs.pub.ro/so/res/laboratoare/lab10-slides.pdf" class="urlextern" title="http://elf.cs.pub.ro/so/res/laboratoare/lab10-slides.pdf"  rel="nofollow"> lab10-slides.pdf</a> </div>
</li>
<li class="level1"><div class="li"><a href="http://elf.cs.pub.ro/so/res/laboratoare/lab10-refcard.pdf" class="urlextern" title="http://elf.cs.pub.ro/so/res/laboratoare/lab10-refcard.pdf"  rel="nofollow"> lab10-refcard.pdf</a></div>
</li>
</ul>

</div>
<!-- EDIT2 SECTION "Materiale ajutătoare" [63-265] -->
<h3 class="sectionedit3" id="nice_to_read">Nice to read</h3>
<div class="level3">
<ul>
<li class="level1"><div class="li"> WSP4 - Chapter 14, Asynchronous Input/Output and Completion Ports</div>
</li>
</ul>

</div>
<!-- EDIT3 SECTION "Nice to read" [266-361] -->
<h3 class="sectionedit4" id="windows_-_io_asincron_overlapped">Windows - I/O asincron (overlapped)</h3>
<div class="level3">

<p>
Operațiile de intrare/ieșire sunt mai lente decât operațiile de procesare din cauza întârzierilor cauzate de:
</p>
<ul>
<li class="level1"><div class="li"> timpul de access la sectoarele hard-disk-urilor</div>
</li>
<li class="level1"><div class="li"> rata de transfer scăzută dintre hard-disk și memoria RAM</div>
</li>
<li class="level1"><div class="li"> transferul de date peste rețea</div>
</li>
</ul>

<p>
În <a href="../../../../so/laboratoare/laborator-02.html" class="wikilink1" title="so:laboratoare:laborator-02">Laboratorul 2</a> au fost studiate operațiile I/O <strong>sincrone</strong>: firul de execuție apelant așteaptă până când operația de I/O se încheie. În cadrul acestui laborator vom afla cum un fir de execuție poate începe o operație de I/O și continuă fără a aștepta ca acea operație de I/O să se încheie, adică cum poate efectua o operație <strong><code>asincronă</code></strong>. În final, o dată ce operațiile asincrone au fost înțelese vom analiza <code><span class="curid"><a href="../../../../so/laboratoare/laborator-10.html#windows_io_completion_ports" class="wikilink1" title="so:laboratoare:laborator-10"> I/O Completion Ports</a></span></code>, cel mai eficient model de procesare a cererilor I/O, utilizat în construcția serverelor scalabile.
</p>

<p>
În Windows există trei modalități de realizare a operațiilor asincrone. Acestea diferă atât în modul folosit pentru a porni operațiile de I/O, cât și în modul prin care se determină dacă operația s-a încheiat:
</p>
<ul>
<li class="level1"><div class="li"> <code>multithreaded I/O</code>: fiecare fir de execuție efectuează operații I/O normale, însă celelalte fire își pot continua execuția</div>
</li>
<li class="level1"><div class="li"> <code><span class="curid"><a href="../../../../so/laboratoare/laborator-10.html#overlapped_io_cu_asteptare" class="wikilink1" title="so:laboratoare:laborator-10"> overlapped I/O cu așteptare</a></span></code>: un fir de execuție își continuă execuția după începerea unei operații de I/O. Un fir de execuție (posibil altul decât cel care a inițiat operația I/O) care are nevoie de rezultatele operației de I/O, va așteapta fie pe un <code>file handle</code>, fie pe un eveniment specificat în structura overlapped folosită de către <code><a href="http://msdn.microsoft.com/en-us/library/aa365467%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/aa365467%28VS.85%29.aspx"  rel="nofollow">ReadFile</a></code> și <code><a href="http://msdn.microsoft.com/en-us/library/aa365747%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/aa365747%28VS.85%29.aspx"  rel="nofollow">WriteFile</a></code></div>
</li>
<li class="level1"><div class="li"> <code>overlapped I/O cu rutine de terminare</code>: sistemul de operare apelează o anumită <code>rutină de terminare</code> (completion routine) atunci când respectiva operație de I/O s-a încheiat. Acest tip de operație asincronă mai poartă și numele de <code>extended I/O</code>, nume derivat din cel al funcțiilor folosite <code><a href="http://msdn.microsoft.com/en-us/library/aa365748%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/aa365748%28VS.85%29.aspx"  rel="nofollow"> WriteFileEx</a></code> și <code><a href="http://msdn.microsoft.com/en-us/library/aa365468%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/aa365468%28VS.85%29.aspx"  rel="nofollow"> ReadFileEx</a></code>.</div>
</li>
</ul>

<p>
În continuare vom trata doar cazul operațiilor de tipul <code><span class="curid"><a href="../../../../so/laboratoare/laborator-10.html#overlapped_io_cu_asteptare" class="wikilink1" title="so:laboratoare:laborator-10"> overlapped I/O cu așteptare</a></span></code>.
</p>

</div>
<!-- EDIT4 SECTION "Windows - I/O asincron (overlapped)" [362-2893] -->
<h3 class="sectionedit5" id="overlapped_io_cu_asteptare">Overlapped I/O cu așteptare</h3>
<div class="level3">

</div>
<!-- EDIT5 SECTION "Overlapped I/O cu așteptare" [2894-2933] -->
<h3 class="sectionedit6" id="file_flag_overlapped">FILE_FLAG_OVERLAPPED</h3>
<div class="level3">

<p>
Prima cerință pentru operațiile I/O asincrone indiferent dacă sunt suprapuse (overlapped) sau extinse este setarea atributului <code>overlapped</code> al <code>handle</code>-ului unui fișier. Acest lucru se realizează prin specificarea flag-ului <code>FILE_FLAG_OVERLAPPED</code> pentru parametrul <code>dwAttrsAndFlags</code> la apelul funcției <code><a href="http://msdn.microsoft.com/en-us/library/aa363858%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/aa363858%28VS.85%29.aspx"  rel="nofollow"> CreateFile</a></code> (sau orice alt apel care creează fișiere, pipe-uri cu nume etc.):
</p>
<pre class="code c">HANDLE hFile <span class="sy0">=</span> CreateFile<span class="br0">&#40;</span><span class="st0">&quot;io.txt&quot;</span><span class="sy0">,</span> 
                          GENERIC_READ<span class="sy0">,</span> 
                          <span class="nu0">0</span><span class="sy0">,</span> 
                          NULL<span class="sy0">,</span> 
                          OPEN_EXISTING<span class="sy0">,</span> 
                          FILE_FLAG_OVERLAPPED<span class="sy0">,</span> <span class="coMULTI">/* this must be specified */</span>
                          NULL<span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>
<p><div class="noteclassic"> În Windows, sockeţii au acest flag activat în mod implicit. 
</div></p>
</p>

<p>
Operațiile I/O pe handle-uri care au flag-ul <code>FILE_FLAG_OVERLAPPED</code> setat (handle-uri asincrone) au un comportament special:
</p>
<ul>
<li class="level1"><div class="li"> Operațiile I/O nu blochează firul de execuție apelant. Apelurile <code><a href="http://msdn.microsoft.com/en-us/library/aa365467%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/aa365467%28VS.85%29.aspx"  rel="nofollow"> ReadFile</a></code>, <code><a href="http://msdn.microsoft.com/en-us/library/aa365747%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/aa365747%28VS.85%29.aspx"  rel="nofollow"> WriteFile</a></code> se întorc imediat, indiferent de durata completării cererii I/O.</div>
</li>
<li class="level1"><div class="li"> O valoare <code>FALSE</code> întoarsă nu indică în mod obligatoriu eșecul apelului. Valoarea <code>FALSE</code> întoarsă de funcțiile <code><a href="http://msdn.microsoft.com/en-us/library/aa365467%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/aa365467%28VS.85%29.aspx"  rel="nofollow"> ReadFile</a></code>, <code><a href="http://msdn.microsoft.com/en-us/library/aa365747%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/aa365747%28VS.85%29.aspx"  rel="nofollow"> WriteFile</a></code> indică eșecul în cazul operațiilor de I/O sincrone. În cazul operațiilor I/O asincrone, funcția <code><a href="http://msdn.microsoft.com/en-us/library/ms679360%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms679360%28VS.85%29.aspx"  rel="nofollow"> GetLastError</a></code> va întoarce <code>ERROR_IO_PENDING</code> ceea ce indică faptul că operația se desfășoară asincron.</div>
</li>
<li class="level1"><div class="li"> Numărul de octeți transferați este de asemenea nefolositor dacă operația nu s-a încheiat. </div>
</li>
<li class="level1"><div class="li"> Se pot face mai multe operații asincrone de citire/scriere pe același fișier, deci nici <code>file pointer</code>-ul nu mai poate fi utilizat. </div>
</li>
</ul>

</div>
<!-- EDIT6 SECTION "FILE_FLAG_OVERLAPPED" [2934-5092] -->
<h3 class="sectionedit7" id="structura_overlapped">Structura Overlapped</h3>
<div class="level3">

<p>
Al doilea pas este transmiterea unei structuri de tip OVERLAPPED ca parametru ori de câte ori se face un apel <code><a href="http://msdn.microsoft.com/en-us/library/aa365467%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/aa365467%28VS.85%29.aspx"  rel="nofollow"> ReadFile</a></code>/<code><a href="http://msdn.microsoft.com/en-us/library/aa365747%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/aa365747%28VS.85%29.aspx"  rel="nofollow"> WriteFile</a></code>.
Structura <code><a href="http://msdn.microsoft.com/en-us/library/ms684342%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms684342%28VS.85%29.aspx"  rel="nofollow"> OVERLAPPED</a></code> conține informația folosită în operațiile I/O și arată astfel:
</p>
<pre class="code c"><span class="kw4">typedef</span> <span class="kw4">struct</span> _OVERLAPPED <span class="br0">&#123;</span>
    ULONG_PTR Internal<span class="sy0">;</span>      <span class="coMULTI">/* the error code for the I/O request*/</span>
    ULONG_PTR InternalHigh<span class="sy0">;</span>  <span class="coMULTI">/* the number of bytes transferred */</span>
    <span class="kw4">union</span> <span class="br0">&#123;</span>                  <span class="coMULTI">/* the file position at which to start the I/O request */</span>
           <span class="kw4">struct</span> <span class="br0">&#123;</span>
               DWORD Offset<span class="sy0">;</span>
               DWORD OffsetHigh<span class="sy0">;</span>
           <span class="br0">&#125;</span> <span class="sy0">;</span>
           PVOID  Pointer<span class="sy0">;</span>   <span class="coMULTI">/* reserved */</span>
    <span class="br0">&#125;</span> <span class="sy0">;</span>
    HANDLE    hEvent<span class="sy0">;</span>        <span class="coMULTI">/* handle to the event - is set to signaled when operation has completed */</span>
<span class="br0">&#125;</span> OVERLAPPED<span class="sy0">,</span> <span class="sy0">*</span>LPOVERLAPPED<span class="sy0">;</span></pre>

<p>
Structura <code><a href="http://msdn.microsoft.com/en-us/library/ms684342%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms684342%28VS.85%29.aspx"  rel="nofollow"> OVERLAPPED</a></code> este utilă pentru că:
</p>
<ul>
<li class="level1"><div class="li"> Un program poate porni mai multe operații asincrone de citire sau scriere pe un singur handle de fișier asincron. File pointer-ul asociat cu file handle-ul nu mai are nicio însemnătate.</div>
</li>
<li class="level1"><div class="li"> Un program trebuie să fie capabil să aștepte terminarea operațiilor I/O asincrone. În cazul în care mai multe operații I/O asincrone sunt pornite, programul trebuie să poată determina care dintre operații s-au terminat. Operațiile asincrone nu se termină în mod obligatoriu în ordinea în care au fost pornite.</div>
</li>
</ul>

<p>
<p><div class="noteimportant"> O operație de I/O asincronă este identificată de către file handle și de structura <code><a href="http://msdn.microsoft.com/en-us/library/ms684342%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms684342%28VS.85%29.aspx"  rel="nofollow"> OVERLAPPED</a></code>. 
</div></p>
Nu trebuie să trecem cu vederea următoarele lucruri:
</p>
<ul>
<li class="level1"><div class="li"> O structură <code><a href="http://msdn.microsoft.com/en-us/library/ms684342%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms684342%28VS.85%29.aspx"  rel="nofollow"> OVERLAPPED</a></code> nu trebuie refolosită până când operația de I/O asociată nu s-a încheiat.</div>
</li>
<li class="level1"><div class="li"> Dacă există mai multe operații I/O este indicată folosirea evenimentelor pentru sincronizare.</div>
</li>
</ul>

<p>
Evenimentul <code>hEvent</code> trebuie creat de utilizator și trebuie să fie de tip <strong><code>manual-reset</code></strong> (Vezi <a href="../../../../so/laboratoare/laborator-09.html#evenimente" class="wikilink1" title="so:laboratoare:laborator-09"> laboratorul 9</a>). Când o operație I/O asincronă se termină, evenimentul rămâne în starea <code>signaled</code> până când este utilizat în altă operație I/O asincronă. Acest lucru este util pentru că putem avea mai multe fire de execuție care să aștepte după aceeași operație asincronă.
</p>

</div>
<!-- EDIT7 SECTION "Structura Overlapped" [5093-8059] -->
<h3 class="sectionedit8" id="asteptarea_si_interogarea_operatiilor_asincrone">Așteptarea și interogarea operațiilor asincrone</h3>
<div class="level3">

<p>
Pentru determinarea stării operației asincrone se poate folosi funcția <code><a href="http://msdn.microsoft.com/en-us/library/ms683209%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms683209%28VS.85%29.aspx"  rel="nofollow"> GetOverlappedResult</a></code>. În cazul unei operații <code><a href="http://msdn.microsoft.com/en-us/library/ms684342%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms684342%28VS.85%29.aspx"  rel="nofollow"> OVERLAPPED</a></code> apelurile <code><a href="http://msdn.microsoft.com/en-us/library/aa365467%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/aa365467%28VS.85%29.aspx"  rel="nofollow"> ReadFile</a></code>/<code><a href="http://msdn.microsoft.com/en-us/library/aa365747%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/aa365747%28VS.85%29.aspx"  rel="nofollow"> WriteFile</a></code> se vor întoarce imediat. În cele mai multe cazuri, operația de I/O nu se va termina imediat astfel că apelurile <code><a href="http://msdn.microsoft.com/en-us/library/aa365467%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/aa365467%28VS.85%29.aspx"  rel="nofollow"> ReadFile</a></code>/<code><a href="http://msdn.microsoft.com/en-us/library/aa365747%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/aa365747%28VS.85%29.aspx"  rel="nofollow"> WriteFile</a></code> vor întoarce <code>FALSE</code>, iar funcția <code><a href="http://msdn.microsoft.com/en-us/library/ms679360%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms679360%28VS.85%29.aspx"  rel="nofollow"> GetLastError</a></code> va întoarce <code>ERROR_IO_PENDING</code>. Dacă totuși rezultatul întors este <code>TRUE</code>, înseamnă că operația s-a efectuat și puteți cere imediat rezultatul.
</p>

<p>
Așteptarea după o operație I/O asincronă se poate face după oricare dintre următoarele:
</p>
<ul>
<li class="level1"><div class="li"> Handle-ul evenimentului specificat în structura <code><a href="http://msdn.microsoft.com/en-us/library/ms684342%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms684342%28VS.85%29.aspx"  rel="nofollow"> OVERLAPPED</a></code> - în caz că se dorește ca unul sau mai multe fire de execuție să aștepte după aceeași operație asincronă. </div>
</li>
<li class="level1"><div class="li"> Handle-ul fișierului - caz în care doar un singur fir de execuție va aștepta după operația asincronă (parametrul <code>hEvent</code> al structurii <code><a href="http://msdn.microsoft.com/en-us/library/ms684342%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms684342%28VS.85%29.aspx"  rel="nofollow"> OVERLAPPED</a></code> este lăsat NULL)</div>
</li>
</ul>

<p>
După așteptarea pe un obiect de sincronizare (un event sau un handle de fișier) ca operația de I/O să se termine, trebuie să determinăm câți octeți au fost transferați. Acesta este scopul de bază al funcției <code><a href="http://msdn.microsoft.com/en-us/library/ms683209%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms683209%28VS.85%29.aspx"  rel="nofollow"> GetOverlappedResult</a></code>. 
</p>
<table class="columns-plugin">
<tr><td class="columns-plugin first">
<pre class="code c">BOOL WINAPI GetOverlappedResult<span class="br0">&#40;</span>
       HANDLE hFile<span class="sy0">,</span>
       LPOVERLAPPED lpOverlapped<span class="sy0">,</span>
       LPDWORD lpNumberOfBytesTransferred<span class="sy0">,</span>
       BOOL bWait
<span class="br0">&#41;</span><span class="sy0">;</span></pre>
</td><td class="columns-plugin last" style="width:50%;">
<pre class="code c">GetOverlappedResult<span class="br0">&#40;</span>
       myHandle<span class="sy0">,</span> <span class="coMULTI">/* handle of file or event */</span>
       <span class="sy0">&amp;</span>ov<span class="sy0">,</span>      <span class="coMULTI">/* overlapped structure */</span>
       <span class="sy0">&amp;</span>nRead<span class="sy0">,</span>   <span class="coMULTI">/* actual bytes transferred */</span>
       TRUE<span class="br0">&#41;</span><span class="sy0">;</span>    <span class="coMULTI">/* wait for the operation to finish */</span></pre>
</td></tr></table>
<pre class="code c">HANDLE hFile<span class="sy0">;</span>
OVERLAPPED ov<span class="sy0">;</span>
DWORD bytesTransferred<span class="sy0">;</span>
&nbsp;
<span class="coMULTI">/* TODO ... start overlapped I/O operation */</span>
&nbsp;
<span class="coMULTI">/* wait for completion */</span>
GetOverlappedResult<span class="br0">&#40;</span>hFile<span class="sy0">,</span> <span class="sy0">&amp;</span>ov<span class="sy0">,</span> <span class="sy0">&amp;</span>bytesTransferred<span class="sy0">,</span> TRUE<span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>
Obiectul <code>hFile</code> și structura <code>ov</code> sunt folosite pentru a identifica unic operația de I/O a cărei stare dorim să o aflăm.
</p>

<p>
Dacă parametrul <code>bWait</code> este <code>TRUE</code>, funcția <code>GetOverlappedResult</code> va aștepta până când operația de I/O specificată se termină, în caz contrar se va întoarce imediat. În ambele cazuri funcția va întoarce <code>TRUE</code> doar dacă operația de I/O s-a terminat cu succes. 
</p>

<p>
Mai jos regăsiți un exemplu de așteptare a terminării unei operații I/O Overlapped folosind ca obiect de sincronizare un eveniment. Exemplul prezintă folosirea unei operații de citire asincronă:
</p>
<pre class="code c"><span class="co2">#include &quot;utils.h&quot;</span>
<span class="co2">#include &lt;windows.h&gt;</span>
<span class="co2">#include &lt;stdlib.h&gt;</span>
&nbsp;
<span class="co2">#define BUF_SIZE	1024 * 1024 // 1MB</span>
&nbsp;
<span class="kw4">int</span> main<span class="br0">&#40;</span><span class="kw4">int</span> argc<span class="sy0">,</span> <span class="kw4">char</span> <span class="sy0">**</span>argv<span class="br0">&#41;</span>
<span class="br0">&#123;</span>
	OVERLAPPED ov<span class="sy0">;</span>
	HANDLE hFile<span class="sy0">;</span>
	HANDLE hEvent<span class="sy0">;</span>
	DWORD dwRet<span class="sy0">,</span> dwErr<span class="sy0">,</span> dwBytesRead<span class="sy0">;</span>
	<span class="kw4">char</span> <span class="sy0">*</span>buffer <span class="sy0">=</span> <a href="http://www.opengroup.org/onlinepubs/009695399/functions/malloc.html"><span class="kw3">malloc</span></a><span class="br0">&#40;</span>BUF_SIZE <span class="sy0">*</span> <span class="kw4">sizeof</span><span class="br0">&#40;</span><span class="kw4">char</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
	<span class="coMULTI">/* Make sure overlapped structure is clean */</span>
	ZeroMemory<span class="br0">&#40;</span><span class="sy0">&amp;</span>ov<span class="sy0">,</span> <span class="kw4">sizeof</span><span class="br0">&#40;</span>ov<span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy0">;</span>
	<a href="http://www.opengroup.org/onlinepubs/009695399/functions/memset.html"><span class="kw3">memset</span></a><span class="br0">&#40;</span>buffer<span class="sy0">,</span> <span class="nu0">0</span><span class="sy0">,</span> BUF_SIZE<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
	<span class="coMULTI">/* Create manual-reset event */</span>
	hEvent <span class="sy0">=</span> CreateEvent<span class="br0">&#40;</span>NULL<span class="sy0">,</span> TRUE<span class="sy0">,</span> FALSE<span class="sy0">,</span> NULL<span class="br0">&#41;</span><span class="sy0">;</span>
	DIE<span class="br0">&#40;</span>hEvent <span class="sy0">==</span> INVALID_HANDLE_VALUE<span class="sy0">,</span> <span class="st0">&quot;CreateEvent&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
	ov.<span class="me1">hEvent</span> <span class="sy0">=</span> hEvent<span class="sy0">;</span>
&nbsp;
	hFile <span class="sy0">=</span> CreateFile<span class="br0">&#40;</span>argv<span class="br0">&#91;</span><span class="nu0">1</span><span class="br0">&#93;</span><span class="sy0">,</span>
                           GENERIC_READ<span class="sy0">,</span>     <span class="coMULTI">/* access mode */</span>
                           FILE_SHARE_READ<span class="sy0">,</span>  <span class="coMULTI">/* sharing option */</span>
                           NULL<span class="sy0">,</span>             <span class="coMULTI">/* security attributes */</span>
                           OPEN_EXISTING<span class="sy0">,</span>    <span class="coMULTI">/* open only if it exists */</span>
                           FILE_FLAG_OVERLAPPED<span class="sy0">,</span><span class="coMULTI">/* file attributes */</span>
                           NULL<span class="br0">&#41;</span><span class="sy0">;</span>            <span class="coMULTI">/* no template */</span>
	DIE<span class="br0">&#40;</span>hFile <span class="sy0">==</span> INVALID_HANDLE_VALUE<span class="sy0">,</span> <span class="st0">&quot;CreateFile&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
	dwRet <span class="sy0">=</span> ReadFile<span class="br0">&#40;</span>hFile<span class="sy0">,</span> buffer<span class="sy0">,</span> BUF_SIZE<span class="sy0">,</span> <span class="sy0">&amp;</span>dwBytesRead<span class="sy0">,&amp;</span>ov<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
	<span class="kw1">if</span> <span class="br0">&#40;</span>dwRet <span class="sy0">==</span> FALSE<span class="br0">&#41;</span> <span class="br0">&#123;</span>		
		dwErr <span class="sy0">=</span> GetLastError<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
		<span class="kw1">switch</span> <span class="br0">&#40;</span>dwErr<span class="br0">&#41;</span> <span class="br0">&#123;</span>
			<span class="kw1">case</span> ERROR_HANDLE_EOF<span class="sy0">:</span> 
&nbsp;
				<a href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span class="kw3">printf</span></a><span class="br0">&#40;</span><span class="st0">&quot;End of File Reached<span class="es1">\n</span>&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
				<span class="kw2">break</span><span class="sy0">;</span>
&nbsp;
			<span class="kw1">case</span> ERROR_IO_PENDING<span class="sy0">:</span>
&nbsp;
				<span class="coMULTI">/* async io not ready */</span>
				<a href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span class="kw3">printf</span></a><span class="br0">&#40;</span><span class="st0">&quot;Async IO not finished immediately<span class="es1">\n</span>&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
				<span class="coMULTI">/* do some other work  in the meantime */</span>
				Sleep<span class="br0">&#40;</span><span class="nu0">1</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
				<span class="coMULTI">/* Wait for it to finish */</span>
				dwRet <span class="sy0">=</span> GetOverlappedResult<span class="br0">&#40;</span>ov.<span class="me1">hEvent</span><span class="sy0">,</span> <span class="sy0">&amp;</span>ov<span class="sy0">,</span> <span class="sy0">&amp;</span>dwBytesRead<span class="sy0">,</span> TRUE<span class="br0">&#41;</span><span class="sy0">;</span>
				<a href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span class="kw3">printf</span></a><span class="br0">&#40;</span><span class="st0">&quot;nRead = %d<span class="es1">\n</span>&quot;</span><span class="sy0">,</span> dwBytesRead<span class="br0">&#41;</span><span class="sy0">;</span>
				<span class="kw2">break</span><span class="sy0">;</span>
&nbsp;
			<span class="kw1">default</span><span class="sy0">:</span>
				<span class="coMULTI">/* ReadFile failed */</span>
				PrintLastError<span class="br0">&#40;</span><span class="st0">&quot;ReadFile&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
		<span class="br0">&#125;</span>
	<span class="br0">&#125;</span> <span class="kw1">else</span> <span class="br0">&#123;</span>
		<a href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span class="kw3">printf</span></a><span class="br0">&#40;</span><span class="st0">&quot;Async IO finished immediately<span class="es1">\n</span>&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
		<a href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span class="kw3">printf</span></a><span class="br0">&#40;</span><span class="st0">&quot;%d <span class="es1">\n</span>&quot;</span><span class="sy0">,</span> dwBytesRead<span class="br0">&#41;</span><span class="sy0">;</span>
	<span class="br0">&#125;</span>
&nbsp;
	dwRet <span class="sy0">=</span> CloseHandle<span class="br0">&#40;</span>hFile<span class="br0">&#41;</span><span class="sy0">;</span>
	DIE<span class="br0">&#40;</span>dwRet <span class="sy0">==</span> FALSE<span class="sy0">,</span> <span class="st0">&quot;CloseHandle&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
	dwRet <span class="sy0">=</span> CloseHandle<span class="br0">&#40;</span>hEvent<span class="br0">&#41;</span><span class="sy0">;</span>
	DIE<span class="br0">&#40;</span>dwRet <span class="sy0">==</span> FALSE<span class="sy0">,</span> <span class="st0">&quot;CloseHandle&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
	<span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">&#125;</span></pre>

<p>
<p><div class="noteclassic"> Când testați acest exemplu, este posibil ca apelul asincron să se întoarcă din prima dacă fișierul din care se citește este deja mapat în RAM (ex: ați copiat înainte fișierul sau l-ați deshis pentru citire). 
</div></p>
</p>

</div>
<!-- EDIT8 SECTION "Așteptarea și interogarea operațiilor asincrone" [8060-13466] -->
<h2 class="sectionedit9" id="windows_-_io_completion_ports">Windows - I/O Completion Ports</h2>
<div class="level2">

<p>
Mecanismul de <strong>completion ports</strong> este cel mai scalabil dintre toate cele prezentate până acum. Un server care folosește completion ports poate face față la foarte multe (zeci de mii) conexiuni simultan, fără probleme prea mari. Celelalte metode își ating limitările cu mult înainte.
</p>

<p>
Un <strong>completion port</strong> este un obiect în kernel cu care se asociază alți descriptori (fișiere, sockeți) și prin intermediul căruia se transmit notificările de completare ale unor operații asincrone lansate anterior. Un completion port are asociat un pool de worker threads. Aceste fire de execuție așteaptă să primească notificări de completare a operațiilor asincrone. În momentul în care un fir de execuție primește o notificare va deveni activ și va lucra o perioadă până se va întoarce din nou așteptând următoarea notificare.
</p>

<p>
<a href="../../../../_detail/so/laboratoare-2013/io_completion.png%3Fid=so%253Alaboratoare%253Alaborator-10.html" class="media" title="so:laboratoare-2013:io_completion.png"><img src="../../../../_media/so/laboratoare-2013/io_completion.png%3Fw=700&amp;tok=7ffc81" class="mediacenter" title=" " alt=" " width="700" /></a>
</p>

</div>
<!-- EDIT9 SECTION "Windows - I/O Completion Ports" [13467-14418] -->
<h3 class="sectionedit10" id="crearea_unui_completion_port">Crearea unui completion port</h3>
<div class="level3">

<p>
Funcția <code><a href="http://msdn.microsoft.com/en-us/library/aa363862%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/aa363862%28VS.85%29.aspx"  rel="nofollow"> CreateIoCompletionPort</a></code> are dublu rol:
</p>
<ul>
<li class="level1"><div class="li">creează un nou completion port</div>
</li>
<li class="level1"><div class="li">adaugă un nou handle pe care se va aștepta terminarea unei operații I/O</div>
</li>
</ul>

<p>
Pentru crearea unui completion port se folosește funcția <code><a href="http://msdn.microsoft.com/en-us/library/aa363862%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/aa363862%28VS.85%29.aspx"  rel="nofollow"> CreateIoCompletionPort</a></code> ca în exemplul de mai jos:
</p>
<table class="columns-plugin">
<tr><td class="columns-plugin first">
<pre class="code c">HANDLE WINAPI CreateIoCompletionPort<span class="br0">&#40;</span>
         HANDLE FileHandle<span class="sy0">,</span>
         HANDLE ExistingCompletionPort<span class="sy0">,</span>
         ULONG_PTR CompletionKey<span class="sy0">,</span>
         DWORD NumberOfConcurrentThreads
<span class="br0">&#41;</span><span class="sy0">;</span></pre>
</td><td class="columns-plugin last">
<pre class="code c">HANDLE iocp <span class="sy0">=</span> CreateIoCompletionPort<span class="br0">&#40;</span>
         INVALID_HANDLE_VALUE<span class="sy0">,</span> <span class="coMULTI">/* New Completion Port */</span>
         NULL<span class="sy0">,</span>               
         NULL<span class="sy0">,</span>  
         <span class="nu0">0</span>                     <span class="coMULTI">/* No threads = No Procs */</span>
<span class="br0">&#41;</span><span class="sy0">;</span></pre>
</td></tr></table>

<p>
Pentru crearea unui nou completion port, primul parametru trebuie să fie <code>INVALID_HANDLE_VALUE</code>. În acest caz, ultimul parametru indică numărul maxim de fire de execuție concurente care pot rula. În caz că se specifică 0, atunci numărul de fire de execuție concurente este setat la numărul de procesoare.
</p>

</div>
<!-- EDIT10 SECTION "Crearea unui completion port" [14419-15654] -->
<h3 class="sectionedit11" id="adaugarea_unui_descriptor_la_completion_port">Adăugarea unui descriptor la completion port</h3>
<div class="level3">

<p>
Pentru adăugarea unui descriptor deschis cu opțiunea de overlapped I/O la completion port se folosește tot funcția <a href="http://msdn.microsoft.com/en-us/library/aa363862%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/aa363862%28VS.85%29.aspx"  rel="nofollow"> CreateIoCompletionPort</a>. În această situație primul argument va fi handle-ul fișierului/socket-ului care se dorește adăugat, iar al doilea handle-ul completion port-ului obținut la crearea acestuia:
</p>
<pre class="code c">HANDLE iocp<span class="sy0">;</span>
HANDLE hFile<span class="sy0">;</span>
&nbsp;
<span class="coMULTI">/* create completion port */</span>
iocp <span class="sy0">=</span> CreateIoCompletionPort<span class="br0">&#40;</span>INVALID_HANDLE_VALUE<span class="sy0">,</span> NULL<span class="sy0">,</span> <span class="br0">&#40;</span>ULONG_PTR<span class="br0">&#41;</span> NULL<span class="sy0">,</span> <span class="nu0">0</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
<span class="coMULTI">/* open file for overlapped I/O */</span>
hFile <span class="sy0">=</span> CreateFile<span class="br0">&#40;</span>...<span class="sy0">,</span> FILE_FLAG_OVERLAPPED<span class="sy0">,</span> ...<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
<span class="coMULTI">/* add file handle to completion port */</span>
CreateIoCompletionPort<span class="br0">&#40;</span>hFile<span class="sy0">,</span> iocp<span class="sy0">,</span> <span class="br0">&#40;</span>ULONG_PTR<span class="br0">&#41;</span> hFile <span class="coMULTI">/* use handle as key */</span><span class="sy0">,</span> <span class="nu0">0</span><span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>
După cum se observă, în cazul creării unui completion port, al doilea argument este NULL. La adăugarea unui handle de fișier la completion port al doilea argument este handle-ul de completion port. Al treilea argument este o cheie care va fi folosită pentru identificarea handle-ului în momentul recepționării unei notificări.
</p>

</div>
<!-- EDIT11 SECTION "Adăugarea unui descriptor la completion port" [15655-16816] -->
<h3 class="sectionedit12" id="asteptarea_incheierii_unei_operatii_asincrone">Așteptarea încheierii unei operații asincrone</h3>
<div class="level3">

<p>
Firele de execuție worker sunt folosite pentru așteptarea încheierii operațiilor asincrone și a prelucrărilor ulterioare. Firele de execuție vor primi notificări de la handle-ul completion port-ului folosind funcția <a href="http://msdn.microsoft.com/en-us/library/aa364986%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/aa364986%28VS.85%29.aspx"  rel="nofollow"> GetQueuedCompletionStatus</a>:
</p>
<table class="columns-plugin">
<tr><td class="columns-plugin first">
<pre class="code">BOOL WINAPI GetQueuedCompletionStatus(
         HANDLE CompletionPort,
         LPDWORD lpNumberOfBytes,
         PULONG_PTR lpCompletionKey,
         LPOVERLAPPED *lpOverlapped,
         DWORD dwMilliseconds
);</pre>
</td><td class="columns-plugin last">
<pre class="code c">bRet <span class="sy0">=</span> GetQueuedCompletionStatus<span class="br0">&#40;</span>
         iocp<span class="sy0">,</span>    <span class="coMULTI">/* completion port handle */</span>
         <span class="sy0">&amp;</span>bytes<span class="sy0">,</span>  <span class="coMULTI">/* actual bytes transferred */</span>
         <span class="sy0">&amp;</span>key<span class="sy0">,</span>    <span class="coMULTI">/* return key to indentify the operation */</span>
         <span class="sy0">&amp;</span>ov<span class="sy0">,</span>     <span class="coMULTI">/* overlapped structure used */</span>
         INFINITE <span class="coMULTI">/* wait time */</span>
<span class="br0">&#41;</span><span class="sy0">;</span></pre>
</td></tr></table>

<p>
Pe baza cheii obținute se poate determina handle-ul care a generat notificarea.
</p>

</div>
<!-- EDIT12 SECTION "Așteptarea încheierii unei operații asincrone" [16817-17838] -->
<h3 class="sectionedit13" id="exemplu_de_folosire_completion_ports">Exemplu de folosire completion ports</h3>
<div class="level3">

<p>
În exemplul de mai jos este prezentată folosirea mecanismului de completion ports în cazul operațiilor asincrone pe sockeți. Exemplul este similar cu cel prezentat în secțiunile dedicate funcțiilor de multiplexare I/O pe Linux. Există un fir de execuție worker care va aștepta primirea notificărilor la completion port, iar firul de execuție principal va fi responsabil cu primirea de cereri de conexiune (apeluri accept).
</p>
<pre class="code c">HANDLE iocp<span class="sy0">;</span>
&nbsp;
<span class="coMULTI">/*** main thread ***/</span>
&nbsp;
SOCKET listenfd<span class="sy0">,</span> sockfd<span class="sy0">;</span>        <span class="coMULTI">/* listener socket; connection socket */</span>
&nbsp;
<span class="coMULTI">/* create I/O completion port */</span>
iocp <span class="sy0">=</span> CreateIoCompletionPort<span class="br0">&#40;</span>INVALID_HANDLE_VALUE<span class="sy0">,</span> NULL<span class="sy0">,</span> <span class="br0">&#40;</span>ULONG_PTR<span class="br0">&#41;</span> NULL<span class="sy0">,</span> <span class="nu0">0</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
<span class="coMULTI">/* TODO ... create server socket (listener) */</span>
&nbsp;
<span class="coMULTI">/* TODO ... create worker thread */</span>
&nbsp;
<span class="kw1">while</span> <span class="br0">&#40;</span><span class="nu0">1</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>        <span class="coMULTI">/* server loop */</span>
   <span class="coMULTI">/* TODO ... accept connections */</span>
&nbsp;
   <span class="coMULTI">/* add socket to completion port */</span>
   CreateIoCompletionPort<span class="br0">&#40;</span>sockfd<span class="sy0">,</span> iocp<span class="sy0">,</span> <span class="br0">&#40;</span>ULONG_PTR<span class="br0">&#41;</span> sockfd<span class="coMULTI">/* use handle as key */</span><span class="sy0">,</span> <span class="nu0">0</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
   <span class="coMULTI">/* TODO ... start asynchronous operation */</span>
<span class="br0">&#125;</span>
&nbsp;
&nbsp;
<span class="coMULTI">/*** worker thread ***/</span>
&nbsp;
DWORD bytes<span class="sy0">;</span>
ULONG_PTR key<span class="sy0">;</span>
LPOVERLAPPED ov<span class="sy0">;</span>
&nbsp;
<span class="kw1">while</span> <span class="br0">&#40;</span><span class="nu0">1</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
    <span class="coMULTI">/* wait for notification */</span>
    GetQueuedCompletionStatus<span class="br0">&#40;</span>iocp<span class="sy0">,</span> <span class="sy0">&amp;</span>bytes<span class="sy0">,</span> <span class="sy0">&amp;</span>key<span class="sy0">,</span> <span class="sy0">&amp;</span>ov<span class="sy0">,</span> INFINITE<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
    <span class="coMULTI">/* TODO ... process request */</span>
<span class="br0">&#125;</span></pre>

</div>
<!-- EDIT13 SECTION "Exemplu de folosire completion ports" [17839-19134] -->
<h2 class="sectionedit14" id="zero-copy_io">Zero-copy I/O</h2>
<div class="level2">

<p>
<code>Zero-copy</code> se referă la tehnica prin care procesorul evită operațiile de copiere a datelor dintr-o zonă de memorie într-alta. Operațiile <code>zero-copy</code> reduc numărul de schimbări de context între spațiul utilizator și spațiul kernel, resursele sistemului fiind utilizate eficient.
</p>

<p>
Dacă o aplicație dorește să transmită date dintr-un fișier pe un socket, va folosi în mod normal schema:
<a href="../../../../_detail/so/laboratoare-2013/normal_copy.gif%3Fid=so%253Alaboratoare%253Alaborator-10.html" class="media" title="so:laboratoare-2013:normal_copy.gif"><img src="../../../../_media/so/laboratoare-2013/normal_copy.gif" class="mediacenter" title=" " alt=" " /></a>
</p>

<p>
Se observă că există multiple copieri cu aceleași date. O schemă mai eficientă, care elimină două dintre copierile în plus și totodată două context-switch-uri, este aceasta:
<a href="../../../../_detail/so/laboratoare-2013/zero_copy.gif%3Fid=so%253Alaboratoare%253Alaborator-10.html" class="media" title="so:laboratoare-2013:zero_copy.gif"><img src="../../../../_media/so/laboratoare-2013/zero_copy.gif" class="mediacenter" title=" " alt=" " /></a>
</p>

<p>
Mai multe detalii, inclusiv explicarea mai pe larg a contextului, puteți găsi <a href="http://www.ibm.com/developerworks/library/j-zerocopy/" class="urlextern" title="http://www.ibm.com/developerworks/library/j-zerocopy/"  rel="nofollow"> aici</a>.
</p>

</div>
<!-- EDIT14 SECTION "Zero-copy I/O" [19135-19990] -->
<h3 class="sectionedit15" id="transmitfile">TransmitFile</h3>
<div class="level3">

<p>
Apelul <code><a href="http://msdn.microsoft.com/en-us/library/ms740565%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms740565%28VS.85%29.aspx"  rel="nofollow"> TransmitFile</a></code> este folosit pentru a eficientiza transmiterea de fișiere în rețea. <code><a href="http://msdn.microsoft.com/en-us/library/ms740565%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms740565%28VS.85%29.aspx"  rel="nofollow"> TransmitFile</a></code> folosește cache-ul sistemului de operare. Este o operație <strong><code>zero-copy</code></strong> - nu necesită alocarea de buffere în user-space și diminuează numărul de apeluri de sistem.
</p>

<p>
Pentru a transmite un fișier, acesta trebuie deschis folosind flag-ul FILE_FLAG_OVERLAPPED. Apelul <code><a href="http://msdn.microsoft.com/en-us/library/ms740565%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms740565%28VS.85%29.aspx"  rel="nofollow"> TransmitFile</a></code> primește ca argument socket-ul pe care se realizează comunicația și handle-ul fișierului de trimis.
</p>
<table class="columns-plugin">
<tr><td class="columns-plugin first">
<pre class="code c">BOOL TransmitFile<span class="br0">&#40;</span>
       SOCKET hSocket<span class="sy0">,</span>
       HANDLE hFile<span class="sy0">,</span>
       DWORD nNumberOfBytesToWrite<span class="sy0">,</span>
       DWORD nNumberOfBytesPerSend<span class="sy0">,</span>
       LPOVERLAPPED lpOverlapped<span class="sy0">,</span>
       LPTRANSMIT_FILE_BUFFERS lpTransmitBuffers<span class="sy0">,</span>
       DWORD dwFlags
<span class="br0">&#41;</span><span class="sy0">;</span></pre>
</td><td class="columns-plugin last">
<pre class="code c">result <span class="sy0">=</span> TransmitFile<span class="br0">&#40;</span>
       hSocket<span class="sy0">,</span>   <span class="coMULTI">/* destination socket handle */</span>
       hFile<span class="sy0">,</span>     <span class="coMULTI">/* source file handle */</span>
       <span class="nu0">0</span><span class="sy0">,</span>         <span class="coMULTI">/* nr bytes to write. 0 == send entire file */</span>
       <span class="nu0">0</span><span class="sy0">,</span>         <span class="coMULTI">/* block size. 0 == default block size */</span>
       <span class="sy0">&amp;</span>ov<span class="sy0">,</span>       <span class="coMULTI">/* overlapped I/O structure */</span>
       NULL<span class="sy0">,</span>            
       <span class="nu0">0</span>
<span class="br0">&#41;</span><span class="sy0">;</span></pre>
</td></tr></table>

<p>
O funcție similară este funcția <code><a href="http://msdn.microsoft.com/en-us/library/ms740566%28v=vs.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms740566%28v=vs.85%29.aspx"  rel="nofollow">TransmitPackets</a></code> care transmite date stocate în memorie pe un socket folosind cache-ul intern al sistemului de operare. Datele sunt reprezentate de o structură <code>TRANSMIT_PACKETS_ELEMENT</code>.
</p>

</div>
<!-- EDIT15 SECTION "TransmitFile" [19991-21680] -->
<h1 class="sectionedit16" id="exercitii_de_laborator">Exerciții de laborator</h1>
<div class="level1">

</div>
<!-- EDIT16 SECTION "Exerciții de laborator" [21681-21718] -->
<h2 class="sectionedit17" id="exercitiul_0_-_joc_interactiv_2p">Exercițiul 0 - Joc interactiv (2p)</h2>
<div class="level2">
<ul>
<li class="level1"><div class="li"> Detalii desfășurare <a href="../../../../so/meta/notare.html#joc_interactiv" class="urlextern" title="http://ocw.cs.pub.ro/courses/so/meta/notare#joc_interactiv"  rel="nofollow">joc</a>.</div>
</li>
</ul>

</div>
<!-- EDIT17 SECTION "Exercițiul 0 - Joc interactiv (2p)" [21719-21862] -->
<h2 class="sectionedit18" id="windows_9p">Windows (9p)</h2>
<div class="level2">

<p>
<p><div class="noteimportant">Înainte de a folosi o structură specifică Async I/O Win32 <abbr title="Application Programming Interface">API</abbr>, asigurați-vă că ați zeroizat-o
</div></p>
</p>

<p>
În rezolvarea laboratorului folosiți arhiva de sarcini <a href="http://elf.cs.pub.ro/so/res/laboratoare/lab10-tasks.zip" class="urlextern" title="http://elf.cs.pub.ro/so/res/laboratoare/lab10-tasks.zip"  rel="nofollow"> lab10-tasks.zip</a>
</p>

</div>
<!-- EDIT18 SECTION "Windows (9p)" [21863-22149] -->
<h3 class="sectionedit19" id="exercitiul_1_-_test_operatii_asincrone_1p">Exercițiul 1 - Test operații asincrone (1p)</h3>
<div class="level3">

<p>
Setați proiectul <code>1-test_overlapp</code> ca default (<a href="../../../../so/laboratoare/resurse/vs_tips.html#setarea_unui_subproiect_ca_default" class="urlextern" title="http://ocw.cs.pub.ro/courses/so/laboratoare/resurse/vs_tips#setarea_unui_subproiect_ca_default"  rel="nofollow"> detalii aici</a>).
</p>

<p>
Programul realizează citirea unui buffer de 64KB dintr-un fișier, folosind operații overlapped.
</p>

<p>
Compilați și testați programul: 
</p>
<pre class="code bash">.\<span class="nu0">1</span>-test_overlapp.exe C:\WINDOWS\explorer.exe</pre>

</div>
<!-- EDIT19 SECTION "Exercițiul 1 - Test operații asincrone (1p)" [22150-22575] -->
<h3 class="sectionedit20" id="exercitiul_2_-_zero-copytransmitfile_2p">Exercițiul 2 - Zero-copy/TransmitFile  (2p)</h3>
<div class="level3">

<p>
Un client dorește să trimită serverului un fișier folosind operații <a href="laborator-10.html#zero-copy_io" title="so:laboratoare:laborator-10 ↵" class="wikilink1"> zero-copy IO</a>.
</p>

<p>
Intrați în proiectul <code>2-transmit</code> și parcurgeți fișierele <code>sock_util.h</code>, <code>sock_util.c</code>, <code>server.c</code> și <code>transmit_client.c</code>. Completați funcțiile marcate cu <code>TODO</code> din fișierul <code>transmit_client.c</code>. Clientul transmite fișierul folosind <a href="http://msdn.microsoft.com/en-us/library/ms740565(v=vs.85).aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms740565(v=vs.85).aspx"  rel="nofollow"> TransmitFile</a>. Folosiți <code>NULL</code> pentru argumentul de tipul <code>LPOVERLAPPED</code>. 
</p>

<p>
Puteți genera fișiere de test folosind proiectul <code>generator</code>:
</p>
<pre class="code bash">.\generator.exe <span class="kw2">size</span> output_file</pre>

<p>
<code>size</code> este dimensiunea în octeți pe care doriți să o aibă fișierul; de exemplu <code>1024</code>, iar <code>output_file</code> este numele fișierului creat.
</p>

<p>
Într-o consolă porniți serverul și într-o altă consolă clientul. Serverul este implementat în cadrul proiectului <code>2-transmit-server</code> din Visual Studio. Compilați acel proiect pentru a obține executabilul <code>2-transmit-server</code> cu care se pornește serverul. Serverul este pornit primul folosind comanda
</p>
<pre class="code bash">.\<span class="nu0">2</span>-transmit-server</pre>

<p>
Clientul este pornit al doilea folosind comanda
</p>
<pre class="code bash">.\<span class="nu0">2</span>-transmit-client output_file</pre>

<p>
În urma rulării serverul generează fișierul <code>output.dat</code>. Pentru a valida transferul corect al fișierului de la client la server folosiți comanda
</p>
<pre class="code bash">comp output_file output.dat</pre>

<p>
Comanda vă va preciza dacă cele două fișiere sunt identice sau nu.
</p>

</div>
<!-- EDIT20 SECTION "Exercițiul 2 - Zero-copy/TransmitFile  (2p)" [22576-24139] -->
<h3 class="sectionedit21" id="exercitiul_3_-_operatii_sincroneasincrone_3p">Exercițiul 3 - Operații sincrone/asincrone (3p)</h3>
<div class="level3">

<p>
Ne propunem să realizăm implementarea unor operații io asincrone pentru popularea unor fișiere cu conținut.
</p>

<p>
Intrați în proiectul <code>3-aio/</code> și urmăriți implementarea funcției <code>do_io_sync</code> și implementați <code>do_io_async</code>.
</p>

<p>
Alocați spațiu pentru structurile <code>OVERLAPPED</code> pentru toate cele 4 fișiere. Pentru inițializarea structurilor <code>OVERLAPPED</code> se recomandă implementarea funcției <code>init_overlapped</code>. În cadrul funcției <code>init_overlapped</code> “zero-izați” structura de tipul <code>OVERLAPPED</code> și apoi completați câmpurile aferente parametrilor transmiși.
</p>

<p>
Când apelați funcția <code>init_overlapped</code> (din cadrul funcției <code>do_io_async</code>), folosiți valorea <code>0</code> ca argument pentru offset și <code>NULL</code> pentru event (nu vom folosi event ca să notifice de încheierea operației). Funcția <code>init_overlapped</code> este apelată într-un ciclu for, pentru fiecare element al array-ului <code>ov</code>. Folosiți <code>GetOverlappedResult</code> pentru realizarea operațiilor asincrone pe cele 4 fișiere. Funcțiile trebuie să scrie conținutul bufferului <code>g_buffer</code> în cele 4 fișiere cu numele dat de vectorul <code>files</code>. Folosiți macro-ul <code>IO_OP_TYPE</code> pentru a determina comportamentul programului (revedeți secțiunea despre <a href="laborator-10.html#windows_-_io_asincron_overlapped" title="so:laboratoare:laborator-10 ↵" class="wikilink1"> Overlapped IO</a>)
</p>

<p>
Rulați programul compilat folosind comanda:
</p>
<pre class="code bash">.\<span class="nu0">3</span>-aio</pre>

<p>
Dacă ați lucrat corect, în urma rulării comenzii de mai sus se vor genera în directorul curent 4 fișiere text (cu extensia <code>.txt</code>) de dimensiune <code>BUFSIZ</code>, conținând caractere random.
</p>

</div>
<!-- EDIT21 SECTION "Exercițiul 3 - Operații sincrone/asincrone (3p)" [24140-25767] -->
<h3 class="sectionedit22" id="exercitiul_4_-_io_completion_ports_3p">Exercițiul 4 - I/O completion ports (3p)</h3>
<div class="level3">

<p>
Vom folosi <abbr title="Application Programming Interface">API</abbr>-ul de I/O completion ports.
</p>

</div>

<h4 id="crearea_unui_completion_ports_1p">Crearea unui completion ports (1p)</h4>
<div class="level4">

<p>
Intrați în proiectul <code>4-iocp/</code> și analizați conținutul fișierelor <code>iocp.h</code> și <code>iocp.c</code>. Completați cele 4 funcții definite în fișierul <code>iocp.c</code> (revedeți secțiunea despre <a href="laborator-10.html#crearea_unui_completion_port" title="so:laboratoare:laborator-10 ↵" class="wikilink1"> IO completion ports</a>).
</p>

</div>

<h4 id="operatii_io_asincrone_cu_io_completion_ports_2p">Operații I/O asincrone cu I/O completion ports (2p)</h4>
<div class="level4">

<p>
Analizați conținutul fișierului <code>aio.c</code>. Scopul exercițiului este folosirea I/O completion ports pentru așteptarea încheierii operațiilor I/O asincrone (overlapped I/O).
</p>

<p>
Implementați funcțiile <code>init_io_async</code> și <code>do_io_async</code>. În funcția <code>do_io_async</code> înainte de a trimite o cerere folosind <code>WriteFile</code>, folosiți funcția <code>init_overlapped</code> pentru a inițializa elementul aferent al vectorului <code>ov</code>.
</p>

<p>
Compilați și rulați programul. 
</p>

</div>
<!-- EDIT22 SECTION "Exercițiul 4 - I/O completion ports (3p)" [25768-26684] -->
<h2 class="sectionedit23" id="solutii">Soluții</h2>
<div class="level2">

<p>
<a href="http://elf.cs.pub.ro/so/res/laboratoare/lab10-sol.zip" class="urlextern" title="http://elf.cs.pub.ro/so/res/laboratoare/lab10-sol.zip"  rel="nofollow"> Soluţii laborator 10</a>
</p>

</div>
<!-- EDIT23 SECTION "Soluții" [26685-] --></div>
</body>
</html>
