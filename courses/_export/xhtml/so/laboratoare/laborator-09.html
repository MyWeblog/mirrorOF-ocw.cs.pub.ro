    
    

<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
  <meta charset="utf-8" />
  <title>so:laboratoare:laborator-09</title>
<meta name="generator" content="DokuWiki"/>
<meta name="robots" content="index,follow"/>
<meta name="date" content="2016-04-27T11:40:49+0300"/>
<meta name="keywords" content="so,laboratoare,laborator-09"/>
<link rel="search" type="application/opensearchdescription+xml" href="../../../../lib/exe/opensearch.php" title="CS Open CourseWare"/>
<link rel="start" href="../../../../../courses.1.html"/>
<link rel="alternate" type="application/rss+xml" title="Recent Changes" href="../../../../feed.php"/>
<link rel="alternate" type="application/rss+xml" title="Current Namespace" href="../../../../feed.php%3Fmode=list&amp;ns=so:laboratoare"/>
<link rel="alternate" type="text/html" title="Plain HTML" href="laborator-09.html"/>
<link rel="canonical" href="../../../../so/laboratoare/laborator-09.html"/>
<link rel="stylesheet" type="text/css" href="../../../../lib/exe/css.php%3Ft=arctic&amp;tseed=1476798676.css"/>
<script type="text/javascript">/*<![CDATA[*/var NS='so:laboratoare';var JSINFO = {"id":"so:laboratoare:laborator-09","namespace":"so:laboratoare","isadmin":0,"isauth":0};
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="../../../../lib/exe/js.php%3Ftseed=1476798676"></script>
<script type="text/x-mathjax-config">/*<![CDATA[*/MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ["$","$"], ["\\(","\\)"] ],
        displayMath: [ ["$$","$$"], ["\\[","\\]"] ],
        processEscapes: true
    }
});
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
<script type="text/javascript">/*<![CDATA[*/
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
		  
/*!]]>*/</script>
<script type="text/javascript">/*<![CDATA[*/
var pageTracker = _gat._getTracker("UA-38383934-1");
pageTracker._initData();
pageTracker._trackPageview();
		  
/*!]]>*/</script>
</head>
<body>
<div class="dokuwiki export">
<!-- TOC START -->
<div id="dw__toc">
<h3 class="toggle">Table of Contents</h3>
<div>

<ul class="toc">
<li class="level1"><div class="li"><a href="laborator-09.html#laborator_09_-_thread-uri_windows">Laborator 09 - Thread-uri Windows</a></div>
<ul class="toc">
<li class="level2"><div class="li"><a href="laborator-09.html#materiale_ajutatoare">Materiale ajutătoare</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="laborator-09.html#nice_to_read">Nice to read</a></div></li>
</ul>
</li>
<li class="level2"><div class="li"><a href="laborator-09.html#crearea_firelor_de_executie">Crearea firelor de execuție</a></div></li>
<li class="level2"><div class="li"><a href="laborator-09.html#handle_si_identificator">Handle și identificator</a></div></li>
<li class="level2"><div class="li"><a href="laborator-09.html#asteptarea_firelor_de_executie">Așteptarea firelor de execuție</a></div></li>
<li class="level2"><div class="li"><a href="laborator-09.html#terminarea_firelor_de_executie">Terminarea firelor de execuție</a></div></li>
<li class="level2"><div class="li"><a href="laborator-09.html#suspend_resume">Suspend, Resume</a></div></li>
<li class="level2"><div class="li"><a href="laborator-09.html#cedarea_procesorului">Cedarea procesorului</a></div></li>
<li class="level2"><div class="li"><a href="laborator-09.html#alte_functii_utile">Alte funcții utile</a></div></li>
<li class="level2"><div class="li"><a href="laborator-09.html#thread_local_storage">Thread Local Storage</a></div></li>
<li class="level2"><div class="li"><a href="laborator-09.html#exemplu">Exemplu</a></div></li>
<li class="level2"><div class="li"><a href="laborator-09.html#fibre_de_executie">Fibre de execuție</a></div></li>
<li class="level2"><div class="li"><a href="laborator-09.html#securitate_si_drepturi_de_acces">Securitate și drepturi de acces</a></div></li>
<li class="level2"><div class="li"><a href="laborator-09.html#sincronizarea_firelor_de_executie">Sincronizarea firelor de execuție</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="laborator-09.html#mutex_win32">Mutex Win32</a></div></li>
<li class="level3"><div class="li"><a href="laborator-09.html#semafor_win32">Semafor Win32</a></div></li>
<li class="level3"><div class="li"><a href="laborator-09.html#sectiune_critica">Secțiune critică</a></div>
<ul class="toc">
<li class="level4"><div class="li"><a href="laborator-09.html#initializareadistrugerea_unei_sectiuni_critice">Inițializarea/distrugerea unei secțiuni critice</a></div></li>
<li class="level4"><div class="li"><a href="laborator-09.html#utilizarea_sectiunilor_critice">Utilizarea secțiunilor critice</a></div></li>
<li class="level4"><div class="li"><a href="laborator-09.html#exemplu_sectiuni_critice">Exemplu secțiuni critice</a></div></li>
</ul>
</li>
<li class="level3"><div class="li"><a href="laborator-09.html#evenimente">Evenimente</a></div></li>
<li class="level3"><div class="li"><a href="laborator-09.html#operatii_atomice_cu_variabile_partajate_interlocked_variable_access">Operații atomice cu variabile partajate (Interlocked Variable Access)</a></div></li>
</ul>
</li>
<li class="level2"><div class="li"><a href="laborator-09.html#windows_thread_pooling">Windows Thread Pooling</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="laborator-09.html#adaugarea_de_taskuri_la_thread_pool">Adăugarea de taskuri la thread pool</a></div>
<ul class="toc">
<li class="level4"><div class="li"><a href="laborator-09.html#asteptarea_unei_operatii_de_intrareiesire_asincrone">Așteptarea unei operații de intrare/ieșire asincrone</a></div></li>
<li class="level4"><div class="li"><a href="laborator-09.html#adaugarea_unui_task_pentru_executie_imediata">Adăugarea unui task pentru execuție imediată</a></div></li>
</ul>
</li>
<li class="level3"><div class="li"><a href="laborator-09.html#timer_queues">Timer Queues</a></div>
<ul class="toc">
<li class="level4"><div class="li"><a href="laborator-09.html#creareadistrugerea_unei_cozi_de_timere">Crearea/distrugerea unei cozi de timere</a></div></li>
<li class="level4"><div class="li"><a href="laborator-09.html#crearea_unui_timer">Crearea unui timer</a></div></li>
</ul>
</li>
<li class="level3"><div class="li"><a href="laborator-09.html#registered_wait_functions">Registered Wait Functions</a></div>
<ul class="toc">
<li class="level4"><div class="li"><a href="laborator-09.html#inregistrarea_unei_functii_de_asteptare">Înregistrarea unei funcții de așteptare</a></div></li>
<li class="level4"><div class="li"><a href="laborator-09.html#deinregistrarea_unei_functii_de_asteptare">Deînregistrarea unei funcții de așteptare</a></div></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="level1"><div class="li"><a href="laborator-09.html#exercitii_de_laborator">Exerciții de laborator</a></div>
<ul class="toc">
<li class="level2"><div class="li"><a href="laborator-09.html#exercitiul_0_-_joc_interactiv_2p">Exercițiul 0 - Joc interactiv (2p)</a></div></li>
<li class="level2"><div class="li"><a href="laborator-09.html#windows_9p">Windows (9p)</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="laborator-09.html#exercitiul_1_-_threading_si_prioritati_1p">Exercițiul 1 - Threading și priorități (1p)</a></div></li>
<li class="level3"><div class="li"><a href="laborator-09.html#exercitiul_2_-_thread_debugging_1p">Exercițiul 2 - Thread debugging (1p)</a></div></li>
<li class="level3"><div class="li"><a href="laborator-09.html#exercitiul_3_-_interlocked_2p">Exercițiul 3 - Interlocked (2p)</a></div></li>
<li class="level3"><div class="li"><a href="laborator-09.html#exercitiul_4_-_tls_1p">Exercițiul 4 - TLS (1p)</a></div></li>
<li class="level3"><div class="li"><a href="laborator-09.html#exercitiul_5_-_timerqueue_2p">Exercițiul 5 - TimerQueue (2p)</a></div></li>
<li class="level3"><div class="li"><a href="laborator-09.html#exercitiul_6_-_barrier_2p">Exercițiul 6 - Barrier (2p)</a></div></li>
<li class="level3"><div class="li"><a href="laborator-09.html#bonus">BONUS</a></div>
<ul class="toc">
<li class="level4"><div class="li"><a href="laborator-09.html#so_karma_-_parallel_sort">2 so karma - Parallel Sort</a></div></li>
<li class="level4"><div class="li"><a href="laborator-09.html#so_karma_-_the_dorm_room_problem">2 so karma - The dorm room problem</a></div></li>
</ul>
</li>
</ul>
</li>
<li class="level2"><div class="li"><a href="laborator-09.html#solutii">Soluții</a></div></li>
</ul></li>
</ul>
</div>
</div>
<!-- TOC END -->

<h1 class="sectionedit1" id="laborator_09_-_thread-uri_windows">Laborator 09 - Thread-uri Windows</h1>
<div class="level1">

</div>
<!-- EDIT1 SECTION "Laborator 09 - Thread-uri Windows" [1-50] -->
<h2 class="sectionedit2" id="materiale_ajutatoare">Materiale ajutătoare</h2>
<div class="level2">
<ul>
<li class="level1"><div class="li"><a href="http://elf.cs.pub.ro/so/res/laboratoare/lab09-slides.pdf" class="urlextern" title="http://elf.cs.pub.ro/so/res/laboratoare/lab09-slides.pdf"  rel="nofollow"> lab09-slides.pdf</a></div>
</li>
<li class="level1"><div class="li"><a href="http://elf.cs.pub.ro/so/res/laboratoare/lab09-refcard.pdf" class="urlextern" title="http://elf.cs.pub.ro/so/res/laboratoare/lab09-refcard.pdf"  rel="nofollow"> lab09-refcard.pdf</a></div>
</li>
</ul>

</div>
<!-- EDIT2 SECTION "Materiale ajutătoare" [51-254] -->
<h3 class="sectionedit3" id="nice_to_read">Nice to read</h3>
<div class="level3">
<ul>
<li class="level1"><div class="li"> WSP4 - Chapter 7, Threads and Scheduling</div>
</li>
</ul>

</div>
<!-- EDIT3 SECTION "Nice to read" [255-323] -->
<h2 class="sectionedit4" id="crearea_firelor_de_executie">Crearea firelor de execuție</h2>
<div class="level2">

<p>
Pentru a lansa un nou fir de execuție, există funcțiile <a href="http://msdn.microsoft.com/en-us/library/ms682453%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms682453%28VS.85%29.aspx"  rel="nofollow">CreateThread</a> și <a href="http://msdn.microsoft.com/en-us/library/ms682437%28v=VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms682437%28v=VS.85%29.aspx"  rel="nofollow">CreateRemoteThread</a> (a doua fiind folosită pentru a crea un fir de execuție în cadrul altui proces decât cel curent).
</p>
<table class="columns-plugin" style="width:30%">
<tr><td class="columns-plugin first" style="width:30%;">
<pre class="code c">HANDLE CreateThread <span class="br0">&#40;</span>
	LPSECURITY_ATTRIBUTES  lpThreadAttributes<span class="sy0">,</span>
	SIZE_T dwStackSize<span class="sy0">,</span>
	LPTHREAD_START_ROUTINE lpStartAddress<span class="sy0">,</span>
	LPVOID lpParameter<span class="sy0">,</span>
	DWORD dwCreationFlags<span class="sy0">,</span>
	LPDWORD lpThreadId
<span class="br0">&#41;</span><span class="sy0">;</span></pre>
</td><td class="columns-plugin last" style="width:30%;">
<pre class="code c">hthread <span class="sy0">=</span> CreateThread<span class="br0">&#40;</span>
        NULL<span class="sy0">,</span>
        <span class="nu0">0</span><span class="sy0">,</span>
        ThreadFunc<span class="sy0">,</span>
        <span class="sy0">&amp;</span>dwThreadParam<span class="sy0">,</span>                        
        <span class="nu0">0</span><span class="sy0">,</span>
        <span class="sy0">&amp;</span>dwThreadId
<span class="br0">&#41;</span><span class="sy0">;</span></pre>
</td></tr></table>

<p>
Parametrul <code>dwStackSize</code> reprezintă mărimea inițială a stivei (în octeți). Sistemul rotunjește această valoare la cel mai apropiat multiplu de dimensiunea unei pagini. Dacă parametrul este 0, noul fir de execuție va folosi mărimea implicită (1 <abbr title="Megabyte">MB</abbr>). <code>lpStartAddress</code> este un pointer la funcția ce trebuie executată de către firul de execuție. Această funcție are următorul prototip:
</p>
<pre class="code c">DWORD WINAPI ThreadProc<span class="br0">&#40;</span>LPVOID lpParameter<span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>
unde <code>lpParameter</code> reprezintă datele care sunt pasate firului în momentul execuției. La fel ca pe Linux, se poate transmite un pointer la o structură, care conține toți parametrii necesari. Rezultatul întors poate fi obținut de un alt fir de execuție folosind funcția <a href="http://msdn.microsoft.com/en-us/library/ms683190%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms683190%28VS.85%29.aspx"  rel="nofollow">GetExitCodeThread</a>.
</p>

</div>
<!-- EDIT4 SECTION "Crearea firelor de execuție" [324-1973] -->
<h2 class="sectionedit5" id="handle_si_identificator">Handle și identificator</h2>
<div class="level2">

<p>
Firele de execuție pot fi identificate în sistem în 3 moduri:
</p>
<ul>
<li class="level1"><div class="li">printr-un <code>HANDLE</code>, obținut la crearea firului de execuție, sau folosind funcția <a href="http://msdn.microsoft.com/en-us/library/ms684335%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms684335%28VS.85%29.aspx"  rel="nofollow">OpenThread</a>, căreia i se dă ca parametru identificatorul firului de execuție:<pre class="code c">HANDLE OpenThread<span class="br0">&#40;</span>
	DWORD dwDesiredAccess<span class="sy0">,</span>
	BOOL bInheritHandle<span class="sy0">,</span>
	DWORD dwThreadId
<span class="br0">&#41;</span><span class="sy0">;</span></pre>
</div>
</li>
</ul>
<ul>
<li class="level1"><div class="li">printr-un <code>pseudo-HANDLE</code>, o valoare specială care indică funcțiilor de lucru cu <code>HANDLE</code>-uri că este vorba de <code>HANDLE</code>-ul asociat cu firul de execuție curent (obținut, de exemplu, apelând <a href="http://msdn.microsoft.com/en-us/library/ms683182%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms683182%28VS.85%29.aspx"  rel="nofollow">GetCurrentThread</a>). Pentru a converti un <code>pseudo-HANDLE</code> într-un <code>HANDLE</code> veritabil, trebuie folosită funcția <a href="http://msdn.microsoft.com/en-us/library/ms724251%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms724251%28VS.85%29.aspx"  rel="nofollow">DuplicateHandle</a>. De asemenea, nu are sens să facem <a href="http://msdn.microsoft.com/en-us/library/ms724211%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms724211%28VS.85%29.aspx"  rel="nofollow">CloseHandle</a> pe un <code>pseudo-HANDLE</code>. Pe de altă parte, handle-ul obținut cu <a href="http://msdn.microsoft.com/en-us/library/ms724251%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms724251%28VS.85%29.aspx"  rel="nofollow">DuplicateHandle</a> trebuie închis dacă nu mai este nevoie de el.</div>
</li>
</ul>
<ul>
<li class="level1"><div class="li">printr-un identificator al firului de execuție, de tipul <code>DWORD</code>, întors la crearea firului, sau obținut folosind <a href="http://msdn.microsoft.com/en-us/library/ms683183%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms683183%28VS.85%29.aspx"  rel="nofollow">GetCurrentThreadId</a>. O diferență dintre identificator și <code>HANDLE</code> este faptul că nu trebuie să ne preocupăm să închidem un identificator, pe când la <code>HANDLE</code>, pentru a evita <em>leak</em>-urile, trebuie să apelăm <a href="http://msdn.microsoft.com/en-us/library/ms724211%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms724211%28VS.85%29.aspx"  rel="nofollow">CloseHandle</a>.</div>
</li>
</ul>

<p>
Handle-ul obținut la crearea unui fir de execuție are implicit drepturi de acces nelimitate. El poate fi moștenit (sau nu) de procesele copil ale procesului curent, în funcție de flag-urile specificate la crearea lui. Prin funcția <a href="http://msdn.microsoft.com/en-us/library/ms724251%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms724251%28VS.85%29.aspx"  rel="nofollow">DuplicateHandle</a>, se poate crea un nou handle cu mai puține drepturi. Handle-ul este valid până când este închis, chiar dacă firul de execuție pe care îl reprezintă s-a terminat.
</p>

</div>
<!-- EDIT5 SECTION "Handle și identificator" [1974-4197] -->
<h2 class="sectionedit6" id="asteptarea_firelor_de_executie">Așteptarea firelor de execuție</h2>
<div class="level2">

<p>
Pe Windows, se poate aștepta terminarea unui fir de execuție folosind aceeași funcție ca pentru așteptarea oricărui obiect de sincronizare <a href="http://msdn.microsoft.com/en-us/library/ms687032%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms687032%28VS.85%29.aspx"  rel="nofollow">WaitForSingleObject</a>:
</p>
<pre class="code c">DWORD WINAPI WaitForSingleObject<span class="br0">&#40;</span>
	HANDLE hHandle<span class="sy0">,</span> 
	DWORD dwMilliseconds
<span class="br0">&#41;</span><span class="sy0">;</span></pre>

</div>
<!-- EDIT6 SECTION "Așteptarea firelor de execuție" [4198-4573] -->
<h2 class="sectionedit7" id="terminarea_firelor_de_executie">Terminarea firelor de execuție</h2>
<div class="level2">

<p>
Un fir de execuție se termină în unul din următoarele cazuri :
</p>
<ul>
<li class="level1"><div class="li">el însuși apelează funcția <a href="http://msdn.microsoft.com/en-us/library/ms682659%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms682659%28VS.85%29.aspx"  rel="nofollow">ExitThread</a> :<pre class="code c"><span class="kw4">void</span> ExitThread<span class="br0">&#40;</span>DWORD dwExitCode<span class="br0">&#41;</span><span class="sy0">;</span></pre>
</div>
</li>
</ul>
<ul>
<li class="level1"><div class="li">funcția asociată firului de execuție execută un <code>return</code>.</div>
</li>
</ul>
<ul>
<li class="level1"><div class="li">un fir de execuție ce deține un handle cu dreptul <code>THREAD_TERMINATE</code> asupra firului de execuție, execută un apel <a href="http://msdn.microsoft.com/en-us/library/ms686717%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms686717%28VS.85%29.aspx"  rel="nofollow">TerminateThread</a> pe acest handle : <pre class="code c">BOOL TerminateThread<span class="br0">&#40;</span>
	HANDLE hThread<span class="sy0">,</span> 
	DWORD dwExitCode
<span class="br0">&#41;</span><span class="sy0">;</span></pre>
</div>
</li>
</ul>
<ul>
<li class="level1"><div class="li">sau întregul proces se termină ca urmare a unui apel <a href="http://msdn.microsoft.com/en-us/library/ms682658%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms682658%28VS.85%29.aspx"  rel="nofollow">ExitProcess</a> sau <a href="http://msdn.microsoft.com/en-us/library/ms686714%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms686714%28VS.85%29.aspx"  rel="nofollow">TerminateProcess</a>.</div>
</li>
</ul>

<p>
La terminarea ultimului fir de execuție al unui proces se termină și procesul.
</p>

<p>
<p><div class="noteimportant"> Funcțiile <a href="http://msdn.microsoft.com/en-us/library/ms686717%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms686717%28VS.85%29.aspx"  rel="nofollow">TerminateThread</a> și <a href="http://msdn.microsoft.com/en-us/library/ms686714%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms686714%28VS.85%29.aspx"  rel="nofollow">TerminateProcess</a> nu trebuie folosite decât în cazuri extreme (pentru că nu eliberează resursele folosite de firul de execuție, iar unele resurse pot fi <strong>vitale</strong>). Metoda preferată de a termina un fir de execuție este <a href="http://msdn.microsoft.com/en-us/library/ms682659%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms682659%28VS.85%29.aspx"  rel="nofollow">ExitThread</a>, sau folosirea unui protocol de oprire între firul de execuție care dorește să închidă un alt fir de execuție și firul care trebuie oprit. 
</div></p>
</p>

<p>
Pentru aflarea codului de terminare a unui fir de execuție, folosim funcția <a href="http://msdn.microsoft.com/en-us/library/ms683190%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms683190%28VS.85%29.aspx"  rel="nofollow">GetExitCodeThread</a>.
</p>
<pre class="code c">BOOL GetExitCodeThread<span class="br0">&#40;</span>
	HANDLE hThread<span class="sy0">,</span> 
	LPDWORD lpExitCode
<span class="br0">&#41;</span><span class="sy0">;</span></pre>
<ul>
<li class="level1"><div class="li"><code>hThread</code> - handle al firului de execuție ce trebuie să aibă dreptul de acces <code>THREAD_QUERY_INFORMATION</code>.</div>
</li>
<li class="level1"><div class="li"><code>lpExitCode</code> - pointer la o variabilă în care va fi plasat codul de terminare al firului. Dacă firul nu și-a terminat execuția, această valoare va fi <code>STILL_ACTIVE</code>.</div>
</li>
</ul>

<p>
<p><div class="noteimportant"> Pot apărea probleme dacă firul de execuție returnează <code>STILL_ACTIVE</code> (259), și anume aplicația care testează valoarea poate intra într-o buclă infinită. 
</div></p>
</p>

</div>
<!-- EDIT7 SECTION "Terminarea firelor de execuție" [4574-6918] -->
<h2 class="sectionedit8" id="suspend_resume">Suspend, Resume</h2>
<div class="level2">
<div class="hiddenGlobal  hiddenActive"><div class="hiddenElements"></div><div class="hiddenHead  hiddenSinceBeginning"><div class="hiddenOnHidden">
<p>
Click to display ⇲
</p>
</div><div class="hiddenOnVisible">
<p>
Click to hide ⇱
</p>
</div></div> <!-- .hiddenHead --><div class="hiddenBody"><pre class="code c">DWORD SuspendThread<span class="br0">&#40;</span>HANDLE hThread<span class="br0">&#41;</span><span class="sy0">;</span>
DWORD ResumeThread<span class="br0">&#40;</span>HANDLE hThread<span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>
Prin intermediul acestor două funcții, un fir de execuție poate suspenda/relua execuția unui alt fir de execuție.
</p>

<p>
Un fir de execuție suspendat nu mai este planificat pentru a obține timp pe procesor.
</p>

<p>
Cele două funcții manipulează un <em class="u">contor de suspendare</em> (prin incrementare, respectiv decrementare - în limitele 0 - <code>MAXIMUM_SUSPEND_COUNT</code>).
</p>

<p>
În cazul în care contorul de suspendare este mai mare strict decât 0, firul de execuție este suspendat.
</p>

<p>
Un fir de execuție poate fi creat în starea suspendat folosind flag-ul <code>CREATE_SUSPENDED</code>.
</p>

<p>
Aceste funcții nu pot fi folosite pentru sincronizare (pentru că nu controlează punctul în care firul de execuție își va suspenda execuția), dar sunt utile pentru debug.
</p>
</div></div>
</div>
<!-- EDIT8 SECTION "Suspend, Resume" [6919-7807] -->
<h2 class="sectionedit9" id="cedarea_procesorului">Cedarea procesorului</h2>
<div class="level2">
<div class="hiddenGlobal  hiddenActive"><div class="hiddenElements"></div><div class="hiddenHead  hiddenSinceBeginning"><div class="hiddenOnHidden">
<p>
Click to display ⇲
</p>
</div><div class="hiddenOnVisible">
<p>
Click to hide ⇱
</p>
</div></div> <!-- .hiddenHead --><div class="hiddenBody">
<p>
Un fir de execuție poate renunța de bună voie la procesor.
</p>

<p>
În urma apelului funcției <a href="http://msdn.microsoft.com/en-us/library/ms686298%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms686298%28VS.85%29.aspx"  rel="nofollow">Sleep</a> un fir de execuție este suspendat pentru cel puțin o anumită perioadă de timp (<code>dwMilliseconds</code>).
</p>
<pre class="code c"><span class="kw4">void</span> Sleep<span class="br0">&#40;</span>DWORD dwMilliseconds<span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>
Există de asemenea funcția <a href="http://msdn.microsoft.com/en-us/library/ms686307%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms686307%28VS.85%29.aspx"  rel="nofollow">SleepEx</a> care este un <a href="http://msdn.microsoft.com/en-us/library/ms686298%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms686298%28VS.85%29.aspx"  rel="nofollow">Sleep</a> alertabil (ceea ce înseamnă că se pot prelucra APC-uri - Asynchronous Procedure Call - pe durata execuției lui <a href="http://msdn.microsoft.com/en-us/library/ms686307%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms686307%28VS.85%29.aspx"  rel="nofollow">SleepEx</a>).
</p>

<p>
Funcția <a href="http://msdn.microsoft.com/en-us/library/ms686352%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms686352%28VS.85%29.aspx"  rel="nofollow">SwitchToThread</a> este asemănătoare cu <a href="http://msdn.microsoft.com/en-us/library/ms686298%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms686298%28VS.85%29.aspx"  rel="nofollow">Sleep</a>, doar că nu este specificat intervalul de timp, astfel firul de execuție renunță doar la timpul pe care îl avea pe procesor în momentul respectiv (time-slice).
</p>
<pre class="code c">BOOL SwitchToThread<span class="br0">&#40;</span><span class="kw4">void</span><span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>
Funcția întoarce <code>TRUE</code> dacă procesorul este cedat unui alt fir de execuție și <code>FALSE</code> dacă nu există alte fire gata de execuție.
</p>
</div></div>
</div>
<!-- EDIT9 SECTION "Cedarea procesorului" [7808-9118] -->
<h2 class="sectionedit10" id="alte_functii_utile">Alte funcții utile</h2>
<div class="level2">
<pre class="code c">HANDLE GetCurrentThread<span class="br0">&#40;</span><span class="kw4">void</span><span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>
Rezultatul este un pseudo-handle pentru firul curent ce nu poate fi folosit decât de firul apelant. Acest handle are maximum de drepturi de acces asupra obiectului pe care îl reprezintă.
</p>
<pre class="code c">DWORD GetCurrentThreadId<span class="br0">&#40;</span><span class="kw4">void</span><span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>
Rezultatul este identificatorul firului de execuție.
</p>
<pre class="code c">DWORD GetThreadId<span class="br0">&#40;</span>HANDLE hThread<span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>
Rezultatul este identificatorul firului ce corespunde handle-ului <code>hThread</code>.
</p>

</div>
<!-- EDIT10 SECTION "Alte funcții utile" [9119-9623] -->
<h2 class="sectionedit11" id="thread_local_storage">Thread Local Storage</h2>
<div class="level2">

<p>
Ca și în Linux, în Windows există un mecanism prin care fiecare fir de execuție să aibă anumite date specifice. Acest mecanism poartă numele de <strong>Thread Local Storage</strong> (TLS). În Windows, pentru a accesa datele din TLS se folosesc indecșii asociați acestora (corespunzători cheilor din Linux).
</p>

<p>
Pentru a crea un nou TLS, se apelează funcția <a href="http://msdn.microsoft.com/en-us/library/ms686801%28v=VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms686801%28v=VS.85%29.aspx"  rel="nofollow">TlsAlloc</a>:
</p>
<pre class="code c">DWORD TlsAlloc<span class="br0">&#40;</span><span class="kw4">void</span><span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>
Funcția întoarce în caz de succes indexul asociat TLS-ului, prin intermediul căruia fiecare fir de execuție va putea accesa datele specifice. Valoarea stocată în TLS este inițializată cu 0. În caz de eșec, funcția întoarce valoarea <code>TLS_OUT_OF_INDEXES</code>.
</p>

<p>
Pentru a stoca o nouă valoare într-un TLS, se folosește funcția <a href="http://msdn.microsoft.com/en-us/library/ms686818%28v=VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms686818%28v=VS.85%29.aspx"  rel="nofollow">TlsSetValue</a>:
</p>
<pre class="code c">BOOL TlsSetValue<span class="br0">&#40;</span>
	DWORD dwTlsIndex<span class="sy0">,</span>
	LPVOID lpTlsValue
<span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>
Un fir de execuție poate afla valoarea specifică lui dintr-un TLS apelând funcția <a href="http://msdn.microsoft.com/en-us/library/ms686812%28v=VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms686812%28v=VS.85%29.aspx"  rel="nofollow">TlsGetValue</a>:
</p>
<pre class="code c"> LPVOID TlsGetValue<span class="br0">&#40;</span>DWORD dwTlsIndex<span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>
În caz de succes, funcția întoarce valoarea stocată în TLS, iar în caz de eșec, întoarce 0. Dacă data stocată în TLS are valoarea 0, atunci valoarea întoarsă este tot 0, dar <a href="http://msdn.microsoft.com/en-us/library/ms679360%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms679360%28VS.85%29.aspx"  rel="nofollow">GetLastError</a> va întoarce <code>NO_ERROR</code>. Deci trebuie verificată eroarea întoarsă de <a href="http://msdn.microsoft.com/en-us/library/ms679360%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms679360%28VS.85%29.aspx"  rel="nofollow">GetLastError</a>.
</p>

<p>
Pentru a elibera un index asociat unui TLS, se folosește funcția <a href="http://msdn.microsoft.com/en-us/library/ms686804%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms686804%28VS.85%29.aspx"  rel="nofollow">TlsFree</a>:
</p>
<pre class="code c"> BOOL TlsFree<span class="br0">&#40;</span>DWORD dwTlsIndex<span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>
Dacă firele de execuție au alocat memorie și au stocat în TLS un pointer la memoria alocată, această funcție nu va face dealocarea memoriei. Memoria trebuie dealocată de către fire înainte de apelul lui <a href="http://msdn.microsoft.com/en-us/library/ms686804%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms686804%28VS.85%29.aspx"  rel="nofollow">TlsFree</a>.
</p>

</div>
<!-- EDIT11 SECTION "Thread Local Storage" [9624-11773] -->
<h2 class="sectionedit12" id="exemplu">Exemplu</h2>
<div class="level2">

<p>
Exemplul prezintă crearea a 2 fire de execuție ce vor folosi un TLS.
</p>
<dl class="code">
<dt><a href="../../../code/so/laboratoare/laborator-09%3Fcodeblock=18" title="Download Snippet" class="mediafile mf_c">ThreadTLS.c</a></dt>
<dd><pre class="code c"><span class="co2">#include &lt;stdio.h&gt;</span>
<span class="co2">#include &lt;windows.h&gt;</span>
<span class="co2">#include &quot;utils.h&quot; </span>
&nbsp;
<span class="co2">#define NO_THREADS 2</span>
&nbsp;
DWORD dwTlsIndex<span class="sy0">;</span>
&nbsp;
&nbsp;
VOID TLSUse<span class="br0">&#40;</span>VOID<span class="br0">&#41;</span>
<span class="br0">&#123;</span>
	LPVOID lpvData<span class="sy0">;</span>
&nbsp;
	<span class="coMULTI">/* get the pointer from TLS for current thread */</span>
	lpvData <span class="sy0">=</span> TlsGetValue<span class="br0">&#40;</span>dwTlsIndex<span class="br0">&#41;</span><span class="sy0">;</span>
	DIE<span class="br0">&#40;</span><span class="br0">&#40;</span>lpvData <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">&#41;</span> <span class="sy0">&amp;&amp;</span> <span class="br0">&#40;</span>GetLastError<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="sy0">!=</span> <span class="nu0">0</span><span class="br0">&#41;</span><span class="sy0">,</span> <span class="st0">&quot;TlsGetValue&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
	<span class="coMULTI">/* use this data */</span>
	<a href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span class="kw3">printf</span></a><span class="br0">&#40;</span><span class="st0">&quot;thread %d: get lpvData=%p<span class="es1">\n</span>&quot;</span><span class="sy0">,</span> GetCurrentThreadId<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">,</span> lpvData<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
	Sleep<span class="br0">&#40;</span><span class="nu0">5000</span><span class="br0">&#41;</span><span class="sy0">;</span>
<span class="br0">&#125;</span>
&nbsp;
<span class="coMULTI">/* function executed by the threads */</span>
DWORD WINAPI ThreadFunc<span class="br0">&#40;</span>LPVOID lpParameter<span class="br0">&#41;</span>
<span class="br0">&#123;</span>
	LPVOID lpvData<span class="sy0">;</span>
	DWORD dwReturn<span class="sy0">;</span>
&nbsp;
	<span class="coMULTI">/* TLS init for the current thread */</span>
	lpvData <span class="sy0">=</span> <span class="br0">&#40;</span>LPVOID<span class="br0">&#41;</span> LocalAlloc<span class="br0">&#40;</span>LPTR<span class="sy0">,</span> <span class="nu0">256</span><span class="br0">&#41;</span><span class="sy0">;</span>
	DIE<span class="br0">&#40;</span>lpvData <span class="sy0">==</span> NULL<span class="sy0">,</span> <span class="st0">&quot;LocallAloc&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
	dwReturn <span class="sy0">=</span> TlsSetValue<span class="br0">&#40;</span>dwTlsIndex<span class="sy0">,</span> lpvData<span class="br0">&#41;</span><span class="sy0">;</span>
	DIE<span class="br0">&#40;</span>dwReturn <span class="sy0">==</span> FALSE<span class="sy0">,</span> <span class="st0">&quot;TlsSetValue&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
	<a href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span class="kw3">printf</span></a><span class="br0">&#40;</span><span class="st0">&quot;thread %d: set lpvData=%p<span class="es1">\n</span>&quot;</span><span class="sy0">,</span> GetCurrentThreadId<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">,</span> lpvData<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
	TLSUse<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
	<span class="coMULTI">/* free dinamic memory */</span>
	lpvData <span class="sy0">=</span> TlsGetValue<span class="br0">&#40;</span>dwTlsIndex<span class="br0">&#41;</span><span class="sy0">;</span>
	DIE<span class="br0">&#40;</span><span class="br0">&#40;</span>lpvData <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">&#41;</span> <span class="sy0">&amp;&amp;</span> <span class="br0">&#40;</span>GetLastError<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="sy0">!=</span> <span class="nu0">0</span><span class="br0">&#41;</span><span class="sy0">,</span> <span class="st0">&quot;TlsGetValue&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
	LocalFree<span class="br0">&#40;</span><span class="br0">&#40;</span>HLOCAL<span class="br0">&#41;</span> lpvData<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
	<span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">&#125;</span>
&nbsp;
DWORD main<span class="br0">&#40;</span>VOID<span class="br0">&#41;</span>
<span class="br0">&#123;</span>
	DWORD IDThread<span class="sy0">,</span> dwReturn<span class="sy0">;</span>
	HANDLE hThread<span class="br0">&#91;</span>NO_THREADS<span class="br0">&#93;</span><span class="sy0">;</span>
	<span class="kw4">int</span> i<span class="sy0">;</span>
&nbsp;
	<span class="coMULTI">/* allocate TLS index */</span>
	dwTlsIndex <span class="sy0">=</span> TlsAlloc<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
	DIE<span class="br0">&#40;</span>dwTlsIndex <span class="sy0">==</span> TLS_OUT_OF_INDEXES<span class="sy0">,</span> <span class="st0">&quot;Eroare la TlsAlloc&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
	<span class="coMULTI">/* create threads */</span>
	<span class="kw1">for</span> <span class="br0">&#40;</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> NO_THREADS<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
		hThread<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy0">=</span> CreateThread<span class="br0">&#40;</span>NULL<span class="sy0">,</span>                    <span class="coMULTI">/* default security attributes */</span>
			      <span class="nu0">0</span><span class="sy0">,</span>                                   <span class="coMULTI">/* default stack size */</span>
			      <span class="br0">&#40;</span>LPTHREAD_START_ROUTINE<span class="br0">&#41;</span> ThreadFunc<span class="sy0">,</span> <span class="coMULTI">/* routine to execute */</span>
			      NULL<span class="sy0">,</span>                                <span class="coMULTI">/* no thread parameter */</span>
			      <span class="nu0">0</span><span class="sy0">,</span>                                   <span class="coMULTI">/* immediately run the thread */</span>
			      <span class="sy0">&amp;</span>IDThread<span class="br0">&#41;</span><span class="sy0">;</span>                          <span class="coMULTI">/* thread id */</span>
		DIE<span class="br0">&#40;</span>hThread<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy0">==</span> NULL<span class="sy0">,</span> <span class="st0">&quot;CreateThread&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
	<span class="br0">&#125;</span>
&nbsp;
	<span class="coMULTI">/* wait for threads completion */</span>
	<span class="kw1">for</span> <span class="br0">&#40;</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> NO_THREADS<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
		dwReturn <span class="sy0">=</span> WaitForSingleObject<span class="br0">&#40;</span>hThread<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="sy0">,</span> INFINITE<span class="br0">&#41;</span><span class="sy0">;</span>
		DIE<span class="br0">&#40;</span>dwReturn <span class="sy0">==</span> WAIT_FAILED<span class="sy0">,</span> <span class="st0">&quot;WaitForSingleObject&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
	<span class="br0">&#125;</span>
&nbsp;
	<span class="coMULTI">/* free TLS index */</span>
	dwReturn <span class="sy0">=</span> TlsFree<span class="br0">&#40;</span>dwTlsIndex<span class="br0">&#41;</span><span class="sy0">;</span>
	DIE<span class="br0">&#40;</span>dwReturn <span class="sy0">==</span> FALSE<span class="sy0">,</span> <span class="st0">&quot;TlsFree&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
	<span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">&#125;</span></pre>
</dd></dl>

</div>
<!-- EDIT12 SECTION "Exemplu" [11774-13934] -->
<h2 class="sectionedit13" id="fibre_de_executie">Fibre de execuție</h2>
<div class="level2">

<p>
Windows pune la dispoziție și o implementare de User-space Threads, numite <strong>fibre</strong>. Kernel-ul planifică un singur Kernel Level Thread (KLT) asociat cu un set de fibre, iar fibrele colaborează pentru a partaja timpul de procesor oferit acestuia. Deși viteza de execuție este mai bună (pentru context-switch, nu mai este necesară interacțiunea cu kernel-ul), programele scrise folosind fibre pot deveni complexe. Mai multe informații puteți găsi în cadrul <a href="../../../../so/laboratoare-2013/resurse/threaduri_extra.html#fibre_de_executie" class="wikilink1" title="so:laboratoare-2013:resurse:threaduri_extra">secțiunii suplimentare dedicate</a>.
</p>

</div>
<!-- EDIT13 SECTION "Fibre de execuție" [13935-14536] -->
<h2 class="sectionedit14" id="securitate_si_drepturi_de_acces">Securitate și drepturi de acces</h2>
<div class="level2">
<div class="hiddenGlobal  hiddenActive"><div class="hiddenElements"></div><div class="hiddenHead  hiddenSinceBeginning"><div class="hiddenOnHidden">
<p>
Click to display ⇲
</p>
</div><div class="hiddenOnVisible">
<p>
Click to hide ⇱
</p>
</div></div> <!-- .hiddenHead --><div class="hiddenBody">
<p>
Modelul de securitate Windows NT ne permite să controlăm accesul la obiectele de tip fir de execuție.
</p>

<p>
Descriptorul de securitate pentru un fir de execuție se poate specifica la apelul uneia dintre funcțiile <a href="http://msdn.microsoft.com/en-us/library/ms682425%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms682425%28VS.85%29.aspx"  rel="nofollow">CreateProcess</a>, <a href="http://msdn.microsoft.com/en-us/library/ms682429%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms682429%28VS.85%29.aspx"  rel="nofollow">CreateProcessAsUser</a>, <a href="http://msdn.microsoft.com/en-us/library/ms682431%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms682431%28VS.85%29.aspx"  rel="nofollow">CreateProcessWithLogonW</a>, <a href="http://msdn.microsoft.com/en-us/library/ms682453%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms682453%28VS.85%29.aspx"  rel="nofollow">CreateThread</a> sau <a href="http://msdn.microsoft.com/en-us/library/ms682437%28v=VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms682437%28v=VS.85%29.aspx"  rel="nofollow">CreateRemoteThread</a>.
</p>

<p>
Dacă în locul acestui descriptor este pasată valoarea <code>NULL</code>, firul de execuție va avea un descriptor de securitate implicit.
</p>

<p>
Pentru a obține acest descriptor este folosită funcția <a href="http://msdn.microsoft.com/en-us/library/aa446654%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/aa446654%28VS.85%29.aspx"  rel="nofollow">GetSecurityInfo</a>, iar pentru a-l schimba funcția <a href="http://msdn.microsoft.com/en-us/library/aa379588%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/aa379588%28VS.85%29.aspx"  rel="nofollow">SetSecurityInfo</a>.
</p>
<pre class="code c">DWORD WINAPI GetSecurityInfo<span class="br0">&#40;</span>
	HANDLE handle<span class="sy0">,</span>
	SE_OBJECT_TYPE ObjectType<span class="sy0">,</span>
	SECURITY_INFORMATION SecurityInfo<span class="sy0">,</span>
	PSID <span class="sy0">*</span>ppsidOwner<span class="sy0">,</span>
	PSID <span class="sy0">*</span>ppsidGroup<span class="sy0">,</span>
	PACL <span class="sy0">*</span>ppDacl<span class="sy0">,</span>
	PACL <span class="sy0">*</span>ppSacl<span class="sy0">,</span>
	PSECURITY_DESCRIPTOR <span class="sy0">*</span>ppSecurityDescriptor
<span class="br0">&#41;</span><span class="sy0">;</span></pre>
<pre class="code c">DWORD WINAPI SetSecurityInfo<span class="br0">&#40;</span>
	HANDLE handle<span class="sy0">,</span>
	SE_OBJECT_TYPE ObjectType<span class="sy0">,</span>
	SECURITY_INFORMATION SecurityInfo<span class="sy0">,</span>
	PSID psidOwner<span class="sy0">,</span>
	PSID psidGroup<span class="sy0">,</span>
	PACL pDacl<span class="sy0">,</span>
	PACL pSacl
<span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>
Handle-ul întors de funcția <a href="http://msdn.microsoft.com/en-us/library/ms682453%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms682453%28VS.85%29.aspx"  rel="nofollow">CreateThread</a> are <code>THREAD_ALL_ACCESS</code>. La apelul <a href="http://msdn.microsoft.com/en-us/library/ms683182%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms683182%28VS.85%29.aspx"  rel="nofollow">GetCurrentThread</a>, sistemul întoarce un pseudo-handle cu maximul de drepturi de acces pe care descriptorul de securitate al firului de execuție îl permite apelantului.
</p>

<p>
Drepturile de acces pentru un obiect de tip fir de execuție includ drepturile de acces standard: <code>DELETE</code>, <code>READ_CONTROL</code>, <code>SYNCHRONIZE</code>, <code>WRITE_DAC</code> și <code>WRITE_OWNER</code> la care se adaugă drepturi specifice, pe care le puteți găsi pe <a href="http://msdn.microsoft.com/en-us/library/ms686769(VS.85).aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms686769(VS.85).aspx"  rel="nofollow">MSDN</a>.
</p>
</div></div>
</div>
<!-- EDIT14 SECTION "Securitate și drepturi de acces" [14537-16798] -->
<h2 class="sectionedit15" id="sincronizarea_firelor_de_executie">Sincronizarea firelor de execuție</h2>
<div class="level2">

<p>
Pentru sincronizarea firelor de execuție avem la dispoziție:
</p>
<ul>
<li class="level1"><div class="li"><strong>Mutex</strong>: <a href="../../../../so/laboratoare/laborator-08.html#mutex" class="wikilink1" title="so:laboratoare:laborator-08"> POSIX</a>, <a href="laborator-09.html#mutex-win32" title="so:laboratoare:laborator-09 ↵" class="wikilink1"> Win32</a></div>
</li>
<li class="level1"><div class="li"><strong>Semafor</strong>: <a href="../../../../so/laboratoare/laborator-08.html#semafor" class="wikilink1" title="so:laboratoare:laborator-08"> POSIX</a>, <a href="laborator-09.html#semafor-win32" title="so:laboratoare:laborator-09 ↵" class="wikilink1"> Win32</a></div>
</li>
<li class="level1"><div class="li"><strong>Secțiune critică</strong> (excludere mutuală în cadrul aceluiași proces): <a href="laborator-09.html#sectiune-critica" title="so:laboratoare:laborator-09 ↵" class="wikilink1"> Win32</a></div>
</li>
<li class="level1"><div class="li"><strong>Variabilă de condiție</strong>: <a href="../../../../so/laboratoare/laborator-08.html#variabile_conditie" class="wikilink1" title="so:laboratoare:laborator-08"> POSIX</a>, <a href="http://msdn.microsoft.com/en-us/library/ms682052(VS.85).aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms682052(VS.85).aspx"  rel="nofollow">Win32 (începând cu Vista)</a></div>
</li>
<li class="level1"><div class="li"><strong>Eveniment</strong>: <a href="http://msdn.microsoft.com/en-us/library/ms682655(VS.85).aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms682655(VS.85).aspx"  rel="nofollow">Win32</a></div>
</li>
<li class="level1"><div class="li"><strong>Timer</strong>: Win32. </div>
</li>
</ul>

<p>
Standardul POSIX specifică funcții de sincronizare pentru fiecare tip de obiect de sincronizare. <abbr title="Application Programming Interface">API</abbr>-ul Win32, fiind controlat de o singură entitate, permite ca toate obiectele de sincronizare să poată fi utilizate cu funcțiile standard de sincronizare: <a href="http://msdn.microsoft.com/en-us/library/ms687032%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms687032%28VS.85%29.aspx"  rel="nofollow">WaitForSingleObject</a>, <a href="http://msdn.microsoft.com/en-us/library/ms687025%28v=VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms687025%28v=VS.85%29.aspx"  rel="nofollow">WaitForMultipleObjects</a> sau <a href="http://msdn.microsoft.com/en-us/library/ms686293%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms686293%28VS.85%29.aspx"  rel="nofollow">SignalObjectAndWait</a>. 
</p>

<p>
Obiectele de sincronizare <a href="http://msdn.microsoft.com/en-us/library/ms685129%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms685129%28VS.85%29.aspx"  rel="nofollow">Semaphore</a>, <a href="http://msdn.microsoft.com/en-us/library/ms684266%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms684266%28VS.85%29.aspx"  rel="nofollow">Mutex</a>, <a href="http://msdn.microsoft.com/en-us/library/ms682655%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms682655%28VS.85%29.aspx"  rel="nofollow">Event</a> și <a href="http://msdn.microsoft.com/en-us/library/ms687012%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms687012%28VS.85%29.aspx"  rel="nofollow">WaitableTimer</a> pot fi folosite atât pentru sincronizarea proceselor, cât și a firelor de execuție.
</p>

<p>
În Windows mai există un mecanism de sincronizare care este disponibil doar pentru firele de execuție ale <strong>aceluiași proces</strong>, și anume <a href="http://msdn.microsoft.com/en-us/library/ms682530%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms682530%28VS.85%29.aspx"  rel="nofollow">CriticalSection</a>. Se recomandă folosirea <a href="http://msdn.microsoft.com/en-us/library/ms682530%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms682530%28VS.85%29.aspx"  rel="nofollow">CriticalSection</a> pentru excluderea mutuală a firelor de execuție ale aceluiași proces, fiind mai <strong>eficient</strong> decât <a href="http://msdn.microsoft.com/en-us/library/ms684266%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms684266%28VS.85%29.aspx"  rel="nofollow">Mutex</a> sau <a href="http://msdn.microsoft.com/en-us/library/ms685129%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms685129%28VS.85%29.aspx"  rel="nofollow">Semaphore</a>.
</p>

<p>
Win32 <abbr title="Application Programming Interface">API</abbr> pune la dispoziție un mecanism de acces sincronizat la variabile partajate între fire de execuție prin intermediul funcțiilor <strong>interlocked</strong> (<a href="http://msdn.microsoft.com/en-us/library/ms684122%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms684122%28VS.85%29.aspx"  rel="nofollow">Interlocked Variable Access</a>), precum și operații atomice de inserare și ștergere în liste simplu înlănțuite (<a href="http://msdn.microsoft.com/en-us/library/ms684121%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms684121%28VS.85%29.aspx"  rel="nofollow">Interlocked Singly Linked Lists</a>).
</p>

</div>
<!-- EDIT15 SECTION "Sincronizarea firelor de execuție" [16799-19510] -->
<h3 class="sectionedit16" id="mutex_win32">Mutex Win32</h3>
<div class="level3">

<p>
Pe scurt:
</p>
<pre class="code c"><span class="coMULTI">/* creează un mutex */</span>
HANDLE CreateMutex<span class="br0">&#40;</span>
	LPSECURITY_ATTRIBUTES lpMutexAttributes<span class="sy0">,</span> 
	BOOL bInitialOwner<span class="sy0">,</span> 
	LPCTSTR lpName
<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
<span class="coMULTI">/* deschide un mutex (identificat prin nume) */</span>
HANDLE OpenMutex<span class="br0">&#40;</span>
	DWORD dwDesiredAccess<span class="sy0">,</span> 
	BOOL bInheritHandle<span class="sy0">,</span> 
	LPCTSTR lpName
<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
<span class="coMULTI">/* eliberează un mutex ocupat */</span>
BOOL ReleaseMutex<span class="br0">&#40;</span>
	HANDLE hMutex
<span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>
Mai multe informaţii puteţi găsi în secţiunea dedicată  <a href="../../../../so/laboratoare-2013/laborator-05.html#mutex-uri" class="wikilink1" title="so:laboratoare-2013:laborator-05">comunicației inter-proces</a>.
</p>

</div>
<!-- EDIT16 SECTION "Mutex Win32" [19511-20036] -->
<h3 class="sectionedit17" id="semafor_win32">Semafor Win32</h3>
<div class="level3">

<p>
Avem următoarele funcţii:
</p>
<pre class="code c"><span class="coMULTI">/* creează un semafor */</span>
HANDLE CreateSemaphore<span class="br0">&#40;</span>
	LPSECURITY_ATTRIBUTES semattr<span class="sy0">,</span> 
	LONG initial_count<span class="sy0">,</span>
	LONG maximum_count<span class="sy0">,</span> 
	LPCTSTR name
<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
<span class="coMULTI">/* deschide un semafor existent */</span>
HANDLE OpenSemaphore<span class="br0">&#40;</span>
	DWORD dwDesiredAccess<span class="sy0">,</span> 
	BOOL bInheritHandle<span class="sy0">,</span> 
	LPCTSTR name
<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
<span class="coMULTI">/* incrementeare contor semafor cu 'lReleaseCount' */</span>
BOOL ReleaseSemaphore<span class="br0">&#40;</span>
	HANDLE hSemaphore<span class="sy0">,</span> 
	LONG lReleaseCount<span class="sy0">,</span> 
	LPLONG lpPreviousCount
<span class="br0">&#41;</span><span class="sy0">;</span></pre>

</div>
<!-- EDIT17 SECTION "Semafor Win32" [20037-20523] -->
<h3 class="sectionedit18" id="sectiune_critica">Secțiune critică</h3>
<div class="level3">

<p>
Obiectele <a href="http://msdn.microsoft.com/en-us/library/ms682530%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms682530%28VS.85%29.aspx"  rel="nofollow">CriticalSection</a> sunt echivalente mutex-urilor POSIX de tip <code>RECURSIVE</code>. Acestea sunt folosite pentru excluderea mutuală a accesului firelor de execuție ale <strong>aceluiași proces</strong> la o secțiune critică de cod care conține operații asupra unor date partajate. Un singur fir de execuție va fi activ la un moment dat în interiorul secțiunii critice. Dacă mai multe fire așteaptă să intre, nu este garantată ordinea lor de intrare, totuși sistemul va fi echitabil față de toate.
</p>

<p>
Operațiile care se pot efectua asupra unei secțiuni critice sunt: intrarea, intrarea neblocantă, ieșirea din secțiunea critică, inițializarea și distrugerea.
</p>

<p>
Pentru serializarea accesului la o secțiune critică, fiecare fir de execuție va trebui să intre într-un obiect <code>CriticalSection</code> la începutul secțiunii și să-l părăsească la sfârșitul ei. În acest fel, dacă două fire de execuție încearcă să intre în <code>CriticalSection</code> simultan, doar unul dintre ele va reuși, și își va continua execuția în interiorul secțiunii critice, iar celălalt se va bloca pînă când obiectul <code>CriticalSection</code> va fi părăsit de primul fir. Așadar, la sfârșitul secțiunii, primul fir trebuie să părăsească obiectul <code>CriticalSection</code>, permițându-i celuilalt intrarea.
</p>

<p>
Pentru excluderea mutuală se pot folosi atât obiecte <a href="http://msdn.microsoft.com/en-us/library/ms684266%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms684266%28VS.85%29.aspx"  rel="nofollow">Mutex</a>, cât și obiecte <a href="http://msdn.microsoft.com/en-us/library/ms682530%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms682530%28VS.85%29.aspx"  rel="nofollow">CriticalSection</a>; dacă sincronizarea trebuie făcută doar între firele de execuție ale aceluiași proces este recomandată folosirea <code>CriticalSection</code>, fiind un mecanism mai <strong>eficient</strong>. Operația de intrare în <code>CriticalSection</code> se traduce într-o singură instrucțiune de asamblare de tip <em>test-and-set-lock</em> (<code>TSL</code>). <code>CriticalSection</code> este <strong>echivalentul</strong> futex-ului din Linux.
</p>

</div>

<h4 id="initializareadistrugerea_unei_sectiuni_critice">Inițializarea/distrugerea unei secțiuni critice</h4>
<div class="level4">

<p>
Alocarea memoriei pentru o secțiune critică se face prin declararea unui obiect <code>CRITICAL_SECTION</code>. Acesta nu va putea fi folosit, totuși, înainte de a fi inițializat (<a href="http://msdn.microsoft.com/en-us/library/aa915072.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/aa915072.aspx"  rel="nofollow">InitializeCriticalSection</a>, <a href="http://msdn.microsoft.com/en-us/library/ms683476(v=vs.85).aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms683476(v=vs.85).aspx"  rel="nofollow">InitializeCriticalSectionAndSpinCount</a>, <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms686197(v=vs.85).aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/windows/desktop/ms686197(v=vs.85).aspx"  rel="nofollow">SetCriticalSectionSpinCount</a>, <a href="http://msdn.microsoft.com/en-us/library/aa909214.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/aa909214.aspx"  rel="nofollow">DeleteCriticalSection</a>) .
</p>
<pre class="code c"><span class="kw4">void</span> InitializeCriticalSection<span class="br0">&#40;</span>
	LPCRITICAL_SECTION pcrit_sect
<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
BOOL InitializeCriticalSectionAndSpinCount<span class="br0">&#40;</span>
	LPCRITICAL_SECTION pcrit_sect<span class="sy0">,</span> 
	DWORD dwSpinCount
<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
DWORD SetCriticalSectionSpinCount<span class="br0">&#40;</span>
	LPCRITICAL_SECTION pcrit_sect<span class="sy0">,</span> 
	DWORD dwSpinCount
<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
<span class="kw4">void</span> DeleteCriticalSection<span class="br0">&#40;</span>
	LPCRITICAL_SECTION pcrit_sect
<span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>
<p><div class="notewarning"> Un obiect <code>CRITICAL_SECTION</code> nu poate fi copiat sau modificat după inițializare. De asemenea, un obiect <code>CRITICAL_SECTION</code> nu trebuie inițializat de două ori, în caz contrar, comportamentul său fiind nedefinit. 
</div></p>
</p>

<p>
<strong>Contorul de spin</strong> (Spin Count) are sens doar pe sistemele <strong>multiprocesor</strong> (SMP) (este ignorat pe sisteme uniprocesor). Contorul de spin reprezintă numărul de cicli pe care îl petrece un fir de execuție pe un procesor în busy-waiting, înainte de a-și suspenda execuția la un semafor asociat secțiunii critice, în așteptarea eliberării acesteia. Scopul așteptării unui număr de cicli în busy-waiting este evitarea blocării la semafor în cazul în care secțiunea critică se eliberează în intervalul respectiv, deoarece blocarea la semafor are impact asupra performanțelor. Folosirea contorului de spin este recomandată mai ales în cazul unei secțiuni critice scurte, accesate foarte des.
</p>

</div>

<h4 id="utilizarea_sectiunilor_critice">Utilizarea secțiunilor critice</h4>
<div class="level4">

<p>
Secțiunile critice Windows au comportamentul mutex-urilor POSIX de tip <code>RECURSIVE</code>. Un fir de execuție care se află deja în secțiunea critică nu se va bloca dacă apelează din nou <a href="http://msdn.microsoft.com/en-us/library/ms682608%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms682608%28VS.85%29.aspx"  rel="nofollow">EnterCriticalSection</a>, însă va trebui să părăsească secțiunea critică de un număr de ori <strong>egal</strong> cu cel al ocupărilor, pentru a o elibera.
Pentru a încerca intrarea într-o secțiune critică fără a se bloca, un fir de execuție trebuie să apeleze <a href="http://msdn.microsoft.com/en-us/library/aa450959.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/aa450959.aspx"  rel="nofollow"> TryEnterCriticalSection</a>.
</p>
<pre class="code c"><span class="kw4">void</span> EnterCriticalSection<span class="br0">&#40;</span>
	LPCRITICAL_SECTION lpCriticalSection
<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
<span class="kw4">void</span> LeaveCriticalSection<span class="br0">&#40;</span>
	LPCRITICAL_SECTION lpCriticalSection
<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
<span class="coMULTI">/* pentru TryEnterCriticalSection _WIN32_WINNT &gt;= 0x0400 înainte de include &lt;windows.h&gt; */</span>
&nbsp;
<span class="co2">#define _WIN32_WINNT 0x0400</span>
<span class="co2">#include &lt;windows.h&gt;</span>
BOOL TryEnterCriticalSection<span class="br0">&#40;</span>
	LPCRITICAL_SECTION lpCriticalSection
<span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>
În cadrul unui fir de execuție, numărul apelurilor <a href="http://msdn.microsoft.com/en-us/library/ms684169%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms684169%28VS.85%29.aspx"  rel="nofollow">LeaveCriticalSection</a> trebuie să fie <strong>egal</strong> cu numărul apelurilor <a href="http://msdn.microsoft.com/en-us/library/ms682608%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms682608%28VS.85%29.aspx"  rel="nofollow">EnterCriticalSection</a>, pentru a elibera în final secțiunea critică. Dacă un fir de execuție care nu a intrat în secțiunea critică apelează <a href="http://msdn.microsoft.com/en-us/library/ms684169%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms684169%28VS.85%29.aspx"  rel="nofollow">LeaveCriticalSection</a>, se va produce o eroare care va face ca firele care au apelat <a href="http://msdn.microsoft.com/en-us/library/ms682608%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms682608%28VS.85%29.aspx"  rel="nofollow">EnterCriticalSection</a> să aștepte pentru o perioadă nedefinită de timp.
</p>

</div>

<h4 id="exemplu_sectiuni_critice">Exemplu secțiuni critice</h4>
<div class="level4">
<pre class="code c"><span class="coMULTI">/* global critical section */</span>
CRITICAL_SECTION CriticalSection<span class="sy0">;</span> 
&nbsp;
DWORD ThreadProc<span class="br0">&#40;</span>LPVOID <span class="sy0">*</span>param<span class="br0">&#41;</span>
<span class="br0">&#123;</span>
    <span class="coMULTI">/* only one thread enters the critical section, the rest are blocked */</span>
    EnterCriticalSection<span class="br0">&#40;</span><span class="sy0">&amp;</span>CriticalSection<span class="br0">&#41;</span><span class="sy0">;</span> 
&nbsp;
    <span class="coMULTI">/* use of protected data */</span>
&nbsp;
    <span class="coMULTI">/* leaves the critical section, allowing another thread to enter */</span>
    LeaveCriticalSection<span class="br0">&#40;</span><span class="sy0">&amp;</span>CriticalSection<span class="br0">&#41;</span><span class="sy0">;</span>
<span class="br0">&#125;</span>
&nbsp;
<span class="kw4">int</span> main<span class="br0">&#40;</span><span class="br0">&#41;</span>
<span class="br0">&#123;</span>
    <span class="coMULTI">/* initialize only one time */</span>
    InitializeCriticalSection<span class="br0">&#40;</span><span class="sy0">&amp;</span>CriticalSection<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
    <span class="coMULTI">/* the threads execution  ... */</span>
&nbsp;
    DeleteCriticalSection<span class="br0">&#40;</span><span class="sy0">&amp;</span>CriticalSection<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
    <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">&#125;</span></pre>

</div>
<!-- EDIT18 SECTION "Secțiune critică" [20524-26822] -->
<h3 class="sectionedit19" id="evenimente">Evenimente</h3>
<div class="level3">

<p>
Evenimentele reprezintă un mecanism prin care un fir de execuție poate semnaliza unul sau mai multe fire că o anumită condiție este îndeplintă. Ce e important este faptul că pot fi deblocate mai multe fire de execuție prin semnalarea unui singur eveniment. 
Evenimentele sunt de două tipuri, în funcție de modul în care sunt resetate:
</p>
<ul>
<li class="level1"><div class="li">resetare manuală - după alertarea mai multor fire de execuție, evenimentul trebuie resetat </div>
</li>
<li class="level1"><div class="li">resetare automată - dupa alertarea unui singur fir de execuție, evenimentul se resetează automat</div>
</li>
</ul>

<p>
Un eveniment este creat folosind funcția <a href="http://msdn.microsoft.com/en-us/library/ms682396%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms682396%28VS.85%29.aspx"  rel="nofollow"> CreateEvent</a>:
</p>
<table class="columns-plugin" style="width:30%">
<tr><td class="columns-plugin first" style="width:30%;">
<pre class="code c">HANDLE WINAPI CreateEvent<span class="br0">&#40;</span>
            LPSECURITY_ATTRIBUTES lpEventAttributes<span class="sy0">,</span>
            BOOL bManualReset<span class="sy0">,</span>
            BOOL bInitialState<span class="sy0">,</span>
            LPCTSTR lpName
<span class="br0">&#41;</span><span class="sy0">;</span></pre>
</td><td class="columns-plugin last" style="width:30%;">
<pre class="code c">hEvent <span class="sy0">=</span> CreateEvent<span class="br0">&#40;</span>
          NULL<span class="sy0">,</span>
          TRUE<span class="sy0">,</span>  <span class="coMULTI">/* Manual Reset */</span>
          FALSE<span class="sy0">,</span> <span class="coMULTI">/* Non-signaled state */</span>
          NULL   <span class="coMULTI">/* Private variable */</span>
<span class="br0">&#41;</span><span class="sy0">;</span></pre>
</td></tr></table>

<p>
Pentru a controla un eveniment se folosesc funcțiile: 
</p>
<ul>
<li class="level1"><div class="li"><a href="http://msdn.microsoft.com/en-us/library/ms686211%28VS.85%29.aspx#" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms686211%28VS.85%29.aspx#"  rel="nofollow"> SetEvent</a> - pentru semnalizarea evenimentului. Dacă evenimentul este de tip auto-reset, atunci <strong>un singur</strong> fir de execuție va fi trezit, iar evenimentul se resetează automat. Dacă evenimentul este de tip manual-reset, atunci evenimentul rămâne semnalizat până când un fir de execuție apelează  <a href="http://msdn.microsoft.com/en-us/library/ms685081%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms685081%28VS.85%29.aspx"  rel="nofollow"> ResetEvent</a>. Altfel, orice fir de execuție care încearcă să aștepte pe eveniment va fi automat deblocat.</div>
</li>
<li class="level1"><div class="li"><a href="http://msdn.microsoft.com/en-us/library/ms685081%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms685081%28VS.85%29.aspx"  rel="nofollow"> ResetEvent</a> - asigură trecerea evenimentului în starea non-signaled. Se utilizează împreună cu un eveniment de tip manual-reset.</div>
</li>
<li class="level1"><div class="li"><a href="http://msdn.microsoft.com/en-us/library/ms684914%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms684914%28VS.85%29.aspx"  rel="nofollow"> PulseEvent</a> - deblochează toate firele de execuție care așteaptă la un eveniment de tip manual-reset, iar evenimentul este apoi resetat. Dacă funcția este folosită în conjucție cu un eveniment auto-reset, atunci va debloca un singur fir de execuție.</div>
</li>
</ul>

<p>
<p><div class="noteimportant">
Obiectele eveniment de pe Windows sunt diferite de variabilele de conditie de pe Linux.<br/>

Daca se face signal pe un eveniment, si nu exista un thread care asteapta la acel eveniment, acest semnal nu va fi retinut.<br/>

In momentul in care vine un thread si asteapta la un eveniment DUPA ce s-a dat un semnal, acesta ramane blocat pana cand alt thread mai trimite inca un semnal.

</div></p>
</p>

</div>
<!-- EDIT19 SECTION "Evenimente" [26823-29500] -->
<h3 class="sectionedit20" id="operatii_atomice_cu_variabile_partajate_interlocked_variable_access">Operații atomice cu variabile partajate (Interlocked Variable Access)</h3>
<div class="level3">

<p>
Funcțiile <strong>interlocked</strong> pun la dispoziție un mecanism de sincronizare a accesului la variabile partajate între mai multe fire de execuție. Funcțiile pot fi apelate de fire de execuție ale unor procese diferite, pentru variabile aflate într-un spațiu de memorie partajată. Funcțiile interlocked reprezintă cel mai simplu mod de evitare a race-ului care apare când două fire de execuție modifică aceeași variabilă.
</p>

<p>
Operațiile atomice asupra variabilelor partajate:
</p>
<ul>
<li class="level1"><div class="li"><strong>incrementare</strong> / <strong>decrementare</strong> (ambele funcții întorc noua valoare)</div>
</li>
</ul>
<pre class="code c">LONG InterlockedIncrement<span class="br0">&#40;</span>
	LONG <span class="kw4">volatile</span> <span class="sy0">*</span>lpAddend
<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
LONG InterlockedDecrement<span class="br0">&#40;</span>
	LONG <span class="kw4">volatile</span> <span class="sy0">*</span>lpDecend
<span class="br0">&#41;</span><span class="sy0">;</span></pre>
<ul>
<li class="level1"><div class="li"><strong>atribuirea</strong> atomică a unei valori unei variabile partajate (primele două funcții întorc vechea valoare)</div>
</li>
</ul>
<pre class="code c">LONG InterlockedExchange<span class="br0">&#40;</span>
	LONG <span class="kw4">volatile</span> <span class="sy0">*</span>Target<span class="sy0">,</span> 
	LONG Value
<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
LONG InterlockedExchangeAdd<span class="br0">&#40;</span>
	LPLONG <span class="kw4">volatile</span> Addend<span class="sy0">,</span> 
	LONG Value
<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
PVOID InterlockedExchangePointer<span class="br0">&#40;</span>
	PVOID <span class="kw4">volatile</span> <span class="sy0">*</span>Target<span class="sy0">,</span> 
	PVOID Value
<span class="br0">&#41;</span><span class="sy0">;</span></pre>
<ul>
<li class="level1"><div class="li"><strong>atribuirea</strong> atomică după <strong>testarea</strong> valorii variabilei partajate </div>
</li>
</ul>
<pre class="code c">LONG InterlockedCompareExchange<span class="br0">&#40;</span>
	LONG <span class="kw4">volatile</span> <span class="sy0">*</span> dest<span class="sy0">,</span> 
	LONG exchange<span class="sy0">,</span> 
	LONG comp
<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
PVOID InterlockedCompareExchangePointer<span class="br0">&#40;</span>
	PVOID <span class="kw4">volatile</span> <span class="sy0">*</span> dest<span class="sy0">,</span> 
	PVOID exchange<span class="sy0">,</span> 
	PVOID comp
<span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>
<a href="http://msdn.microsoft.com/en-us/library/ms683560%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms683560%28VS.85%29.aspx"  rel="nofollow">InterlockedCompareExchange</a> va compara <code>dest</code> cu <code>comp</code>; dacă sunt egale, îi va atribui lui <code>dest</code> valoarea <code>exchange</code>. Testul și atribuirea vor fi executate într-o singură operație <strong>atomică</strong>. Pentru variabile de tip pointer se va folosi <a href="http://msdn.microsoft.com/en-us/library/ms683568%28v=VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms683568%28v=VS.85%29.aspx"  rel="nofollow">InterlockedCompareExchangePointer</a>. Comportamentul este echivalent cu:
</p>
<pre class="code c">atomicly_do <span class="br0">&#123;</span>                       <span class="co1">// execută atomic tot blocul următor</span>
    tmp <span class="sy0">=</span> <span class="sy0">*</span>dest<span class="sy0">;</span>                    <span class="co1">// copiază valoarea din *dest</span>
    <span class="kw1">if</span> <span class="br0">&#40;</span>tmp <span class="sy0">==</span> comp<span class="br0">&#41;</span> <span class="br0">&#123;</span>              <span class="co1">// dacă e egală cu valoarea lui 'comp'</span>
        <span class="sy0">*</span>dest <span class="sy0">=</span> exchange<span class="sy0">;</span>           <span class="co1">// atunci scrie valoarea 'exchange' în *dest</span>
    <span class="br0">&#125;</span>
<span class="br0">&#125;</span></pre>

</div>
<!-- EDIT20 SECTION "Operații atomice cu variabile partajate (Interlocked Variable Access)" [29501-31699] -->
<h2 class="sectionedit21" id="windows_thread_pooling">Windows Thread Pooling</h2>
<div class="level2">

<p>
Programele cu un număr mare de fire de execuție pot aduce probleme de performanță dincolo de cele de locking:
</p>
<ul>
<li class="level1"><div class="li">Fiecare fir de execuție are o stivă proprie (default 1MB). Astfel, 1000 de fire vor consuma 1GB de spațiu virtual.</div>
</li>
<li class="level1"><div class="li">Context-switch-urile între fire de execuție pot cauza page-fault-uri la accesarea stivei.</div>
</li>
<li class="level1"><div class="li">Crearea și terminarea firelor de execuție presupun calcule suplimentare.</div>
</li>
</ul>

<p>
Pentru a facilita dezvoltarea de aplicații eficiente bazate pe fire de execuție, sistemul de operare Windows pune la dispoziție mecanismul <strong>thread pooling</strong>. Utilizarea acestuia este benefică în cazul unei aplicații bazată pe fire de execuție care au de îndeplinit taskuri relativ scurte. Prin utilizarea thread pooling, fiecare task de efectuat va fi atribuit unui fir de execuție din pool (un task este o procedură executată de un fir de execuție din thread pool).
</p>

<p>
Există două modalități prin care o aplicație poate specifica task-urile pe care le dorește executate de fire de execuție din thread pool:
</p>
<ul>
<li class="level1"><div class="li">se pot adăuga taskuri ce vor fi executate <strong>imediat</strong> ce se eliberează un fir de execuție din thread pool</div>
</li>
<li class="level1"><div class="li">se pot adăuga operații de așteptare care au asociată o funcție callback ce urmează a fi executată la sfârșitul unui <strong>timeout</strong> de unul dintre firele de execuție din thread pool. Din această categorie fac parte operațiile de așteptare a terminării unei intrări/ieșiri asincrone, operațiile de așteptare a expirării unui <code>Timer-Queue Timer</code> și funcțiile de așteptare înregistrate. </div>
</li>
</ul>

<p>
Dacă vreuna dintre funcțiile executate într-un thread-pool apelează <code>TerminateThread</code>, comportamentul nu este definit.
</p>

<p>
Un exemplu practic pentru Windows ThreadPools, ce folosește noul <abbr title="Application Programming Interface">API</abbr>, se găsește <a href="http://msdn.microsoft.com/en-us/library/ms686980%28v=VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms686980%28v=VS.85%29.aspx"  rel="nofollow"> aici</a>.
</p>

</div>
<!-- EDIT21 SECTION "Windows Thread Pooling" [31700-33583] -->
<h3 class="sectionedit22" id="adaugarea_de_taskuri_la_thread_pool">Adăugarea de taskuri la thread pool</h3>
<div class="level3">

</div>

<h4 id="asteptarea_unei_operatii_de_intrareiesire_asincrone">Așteptarea unei operații de intrare/ieșire asincrone</h4>
<div class="level4">

<p>
Pentru a adăuga la <em>thread pool</em> un task care se va executa la finalul unei operații de intrare/ieșire asincrone pe un anumit <em>file handle</em>, se va apela funcția:
</p>
<pre class="code c"><span class="co1">// înregistrează o funcție ce va fi chemată când se încheie o </span>
<span class="co1">// operație de IO asincron pe fișierul identificat prin FileHandle.</span>
<span class="co1">// Pot fi înregistrate mai multe funcții și vor fi chemate toate</span>
<span class="co1">// când se încheie operația IO asincronă. Ordinea în care sunt apelate</span>
<span class="co1">// nu este specificată.</span>
BOOL BindIoCompletionCallback<span class="br0">&#40;</span>
	HANDLE FileHandle<span class="sy0">,</span>
	LPOVERLAPPED_COMPLETION_ROUTINE Function<span class="sy0">,</span>
	ULONG Flags
<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
<span class="co1">// semnătura funcției înregistrate să fie executată la încheierea operației AIO</span>
VOID CALLBACK FileIOCompletionRoutine<span class="br0">&#40;</span>
	DWORD dwErrorCode<span class="sy0">,</span>
	DWORD dwNumberOfBytesTransfered<span class="sy0">,</span>
	LPOVERLAPPED lpOverlapped
<span class="br0">&#41;</span><span class="sy0">;</span></pre>

</div>

<h4 id="adaugarea_unui_task_pentru_executie_imediata">Adăugarea unui task pentru execuție imediată</h4>
<div class="level4">

<p>
Pentru a adăuga la <em>thread pool</em> un task care să fie executat imediat se va apela funcția:
</p>
<pre class="code c">BOOL QueueUserWorkItem<span class="br0">&#40;</span>
	LPTHREAD_START_ROUTINE Function<span class="sy0">,</span>  <span class="co1">// funcția de executat</span>
	PVOID Context<span class="sy0">,</span> <span class="co1">// pointer ce va fi pasat funcției ca argument</span>
	ULONG Flags<span class="br0">&#41;</span><span class="sy0">;</span>  <span class="co1">// tipul rutinei (IO, NON-IO, funcția așteaptă mult, etc.)</span>
&nbsp;
<span class="co1">// Semnătura funcției e identică cu semnătura funcțiilor executate cu CreateThread</span>
DWORD WINAPI ThreadProc<span class="br0">&#40;</span>
	LPVOID param
<span class="br0">&#41;</span><span class="sy0">;</span></pre>

</div>
<!-- EDIT22 SECTION "Adăugarea de taskuri la thread pool" [33584-35043] -->
<h3 class="sectionedit23" id="timer_queues">Timer Queues</h3>
<div class="level3">

<p>
Obiectele <em>TimerQueue</em> reprezintă <strong>cozi de timere</strong>. Ele conțin obiecte <em>Timer-Queue Timer</em> care au asociată o funcție <em>callback</em>, ce va fi executată de un fir de execuție din <em>thread pool</em> la expirarea timerului.
</p>

</div>

<h4 id="creareadistrugerea_unei_cozi_de_timere">Crearea/distrugerea unei cozi de timere</h4>
<div class="level4">
<pre class="code c"><span class="co2">#define _WIN32_WINNT 0x0500</span>
<span class="co2">#include &lt;windows.h&gt;</span>
&nbsp;
HANDLE CreateTimerQueue<span class="br0">&#40;</span><span class="kw4">void</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
<span class="co1">// marchează coada pentru ștergere, dar *NU* așteaptă</span>
<span class="co1">// ca toate callbackurile asociate cozii să se termine</span>
BOOL DeleteTimerQueue<span class="br0">&#40;</span>
	HANDLE TimerQueue
<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
<span class="coMULTI">/**
  * CompletionEvent = NULL - marchează coada pentru ștergere și iese imediat (ca DeleteTimerQueue)
  * CompletionEvent = INVALID_HANDLE_VALUE - funcția așteaptă să se încheie toate callbackurile.
  * CompletionEvent = un handle de tip Event - un obiect Event care va fi 
  *                   trecut în starea SIGNALED când se încheie toate callbackurile.
  */</span>
BOOL DeleteTimerQueueEx<span class="br0">&#40;</span>
	HANDLE TimerQueue<span class="sy0">,</span> 
	HANDLE CompletionEvent
<span class="br0">&#41;</span><span class="sy0">;</span></pre>

</div>

<h4 id="crearea_unui_timer">Crearea unui timer</h4>
<div class="level4">

<p>
Pentru crearea unui timer se va apela funcția:
</p>
<pre class="code c">BOOL CreateTimerQueueTimer<span class="br0">&#40;</span>
	PHANDLE phNewTimer<span class="sy0">,</span> <span class="co1">// aici întoarce un HANDLE la timerul nou creat</span>
	HANDLE TimerQueue<span class="sy0">,</span>  <span class="co1">// coada la care este adăugat timerul. </span>
                            <span class="co1">// Dacă e NULL se folosește o coadă implicită.</span>
	WAITORTIMERCALLBACK Callback<span class="sy0">,</span> <span class="co1">// callback de executat</span>
	PVOID Parameter<span class="sy0">,</span>    <span class="co1">// parametru trimis callbackului</span>
	DWORD DueTime<span class="sy0">,</span>      <span class="co1">// timerul va expira prima dată după 'DueTime' milisec.</span>
	DWORD Period<span class="sy0">,</span>       <span class="co1">// apoi timerul va expira periodic după 'Period' milisec.</span>
	ULONG Flags         <span class="co1">// tipul callbackului: IO/NonIO, EXECUTEONLYONCE, ș.a.</span>
<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
<span class="co1">// semnătura unui callback</span>
VOID WaitOrTimerCallback<span class="br0">&#40;</span>
	PVOID lpParameter<span class="sy0">,</span> 
	BOOLEAN TimerOrWaitFired
<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
<span class="co1">// modificarea timpului de expirare al unui timer</span>
BOOL ChangeTimerQueueTimer<span class="br0">&#40;</span>
	HANDLE TimerQueue<span class="sy0">,</span> <span class="co1">// coada la care este adăugat timerul.</span>
                           <span class="co1">// Dacă e NULL se folosește o coadă implicită.</span>
	HANDLE Timer<span class="sy0">,</span>  <span class="co1">// HANDLE la timerul de modificat</span>
	ULONG DueTime<span class="sy0">,</span> <span class="co1">// timerul va expira prima dată după 'DueTime' milisec.</span>
	ULONG Period   <span class="co1">// apoi timerul va expira periodic după 'Period' milisec.</span>
<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
<span class="co1">// dezactivarea unui timer</span>
BOOL CancelTimerQueueTimer<span class="br0">&#40;</span>
	HANDLE TimerQueue<span class="sy0">,</span> 
	HANDLE Timer
<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
<span class="co1">// dezactivarea ȘI distrugerea unui timer.</span>
<span class="co1">// CompletionEvent e similar cu cel din DeleteTimerQueueEx.</span>
BOOL DeleteTimerQueueTimer<span class="br0">&#40;</span>
	HANDLE TimerQueue<span class="sy0">,</span> 
	HANDLE Timer<span class="sy0">,</span> 
	HANDLE CompletionEvent
<span class="br0">&#41;</span><span class="sy0">;</span></pre>

</div>
<!-- EDIT23 SECTION "Timer Queues" [35044-37558] -->
<h3 class="sectionedit24" id="registered_wait_functions">Registered Wait Functions</h3>
<div class="level3">

<p>
Funcțiile de așteptare înregistrate sunt funcții de așteptare executate de un fir de execuție din <em>thread pool</em>. În momentul în care obiectul de sincronizare după care se așteaptă trece în starea <em>signaled</em>, se va executa rutina <em>callback</em> asociată funcției de așteptare înregistrate, de un fir de execuție din <em>thread pool</em>. În mod implicit, funcțiile de așteptare înregistrate se <strong>rearmează automat</strong> și rutinele <em>callback</em> sunt executate de fiecare dată când obiectul de sincronizare după care se așteaptă trece în starea <strong><em>signaled</em></strong>, sau intervalul de timeout <strong>expiră</strong>. Acest lucru se repetă până când înregistrarea funcției de așteptare este anulată. Se poate seta, însă, ca funcția de așteptare înregistrată să se execute <strong>o singură dată</strong>.
</p>

</div>

<h4 id="inregistrarea_unei_functii_de_asteptare">Înregistrarea unei funcții de așteptare</h4>
<div class="level4">

<p>
Pentru înregistrarea în <em>thread pool</em> a unei funcții de așteptare se va apela funcția:
</p>
<pre class="code c">BOOL RegisterWaitForSingleObject<span class="br0">&#40;</span>
	PHANDLE phNewWaitObject<span class="sy0">,</span>
	HANDLE hObject<span class="sy0">,</span>
	WAITORTIMERCALLBACK Callback<span class="sy0">,</span>
	PVOID Context<span class="sy0">,</span>
	ULONG dwMilliseconds<span class="sy0">,</span>
	ULONG dwFlags
<span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>
De fiecare dată când <code>hObject</code> trece în starea <em>signaled</em>, și la fiecare <code>dwMilliseconds</code>, rutina <code>Callback</code> va fi executată cu parametrul <code>Context</code>, de un fir de execuție din <em>thread pool</em>. Rutina <code>Callback</code> trebuie să nu apeleze <code>TerminateThread</code> și să aibă următoarea signatură:
</p>
<pre class="code c">VOID CALLBACK WaitOrTimerCallback<span class="br0">&#40;</span>
	PVOID lpParameter<span class="sy0">,</span>
	BOOLEAN TimerOrWaitFired
<span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>
Parametrul <code>TimerOrWaitFired</code> va specifica dacă execuția rutinei <code>Callback</code> s-a declanșat în urma trecerii în starea <strong><em>signaled</em></strong> a obiectului de sincronizare, sau în urma <strong>expirării</strong> intervalului de timeout specificat.
</p>

<p>
Prin intermediul parametrului <code>dwFlags</code> se pot transmite caracteristici ale firului de execuție care va executa rutina <code>Callback</code>, precum și dacă funcția de așteptare trebuie să se execute doar o singură dată. Funcția va întoarce, prin parametrul <code>phNewWaitObject</code>, un <em>handle</em> ce va fi folosit pentru deînregistrarea funcției de așteptare.
</p>

</div>

<h4 id="deinregistrarea_unei_functii_de_asteptare">Deînregistrarea unei funcții de așteptare</h4>
<div class="level4">

<p>
Pentru a anula înregistrarea unei funcții de așteptare se va apela una dintre funcțiile:
</p>
<pre class="code c">BOOL UnregisterWait  <span class="br0">&#40;</span>HANDLE WaitHandle<span class="br0">&#41;</span><span class="sy0">;</span>
BOOL UnregisterWaitEx<span class="br0">&#40;</span>HANDLE WaitHandle<span class="sy0">,</span> HANDLE CompletionEvent<span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>
Orice funcție de așteptare înregistrată va trebui deînregistrată prin apelul uneia dintre funcțiile de mai sus.
</p>

<p>
Funcția <code>UnregisterWaitEx</code> va semnaliza <em>event</em>-ul <code>CompletionEvent</code> în cazul în care se termină cu succes și rutina de <em>callback</em> s-a terminat cu succes. Dacă valoarea lui <code>CompletionEvent</code> nu este <code>NULL</code>, atunci funcția va aștepta finalizarea operației de așteptare și terminarea rutinei asociate. 
</p>

</div>
<!-- EDIT24 SECTION "Registered Wait Functions" [37559-40472] -->
<h1 class="sectionedit25" id="exercitii_de_laborator">Exerciții de laborator</h1>
<div class="level1">

</div>
<!-- EDIT25 SECTION "Exerciții de laborator" [40473-40511] -->
<h2 class="sectionedit26" id="exercitiul_0_-_joc_interactiv_2p">Exercițiul 0 - Joc interactiv (2p)</h2>
<div class="level2">
<ul>
<li class="level1"><div class="li"> Detalii desfășurare <a href="../../../../so/meta/notare.html#joc_interactiv" class="urlextern" title="http://ocw.cs.pub.ro/courses/so/meta/notare#joc_interactiv"  rel="nofollow">joc</a>.</div>
</li>
</ul>

</div>
<!-- EDIT26 SECTION "Exercițiul 0 - Joc interactiv (2p)" [40512-40655] -->
<h2 class="sectionedit27" id="windows_9p">Windows (9p)</h2>
<div class="level2">

<p>
În rezolvarea laboratorului folosiți arhiva de sarcini <a href="http://elf.cs.pub.ro/so/res/laboratoare/lab09-tasks.zip" class="urlextern" title="http://elf.cs.pub.ro/so/res/laboratoare/lab09-tasks.zip"  rel="nofollow"> lab09-tasks.zip</a>
</p>

<p>
<p><div class="notetip"> Pentru a deschide proiectul Visual Studio conținând exercițiile, deschideți fișierul lab09.sln. 
</div></p>
</p>

</div>
<!-- EDIT27 SECTION "Windows (9p)" [40656-40939] -->
<h3 class="sectionedit28" id="exercitiul_1_-_threading_si_prioritati_1p">Exercițiul 1 - Threading și priorități (1p)</h3>
<div class="level3">

<p>
Încărcați proiectul <code>1-threading</code> și setați-l ca <em>StartUp Project</em>. Compilați și rulați programul. Aflați câte fire de execuție creează în total.
</p>

<p>
Lansați <code>ProcessExplorer</code> (check Desktop) și verificați răspunsul de la întrebarea de mai sus. (View → Select Columns → Process Performance → Threads)
</p>

<p>
Aflați prioritatea procesului <code>threading.exe</code>. (View → Select Columns → Process Performance → Base Priority)
</p>

<p>
Experimentați schimbând prioritatea procesului (click-dreapta pe numele procesului → Set Priority). Setați prioritatea astfel încât procesul <code>threading.exe</code> să primească mai mult timp pe procesor.
</p>

<p>
<p><div class="notetip">Dacă setați ca prioritate <code>real-time</code> și comentați linia cu <code>Sleep</code> din bucla <code>while</code>, cel mai probabil vi se va bloca mașina virtuală. Acest lucru s-ar întâmpla pentru că ar exista tot timpul un thread cu prioritate mai mare ca cele pentru interfața grafică, de exemplu, gata să ruleze pe procesor. Vezi și <a href="https://en.wikipedia.org/wiki/Starvation_(computer_science)" class="urlextern" title="https://en.wikipedia.org/wiki/Starvation_(computer_science)"  rel="nofollow"> link</a>.
</div></p>
</p>

</div>
<!-- EDIT28 SECTION "Exercițiul 1 - Threading și priorități (1p)" [40940-42063] -->
<h3 class="sectionedit29" id="exercitiul_2_-_thread_debugging_1p">Exercițiul 2 - Thread debugging (1p)</h3>
<div class="level3">

<p>
Deschideți sursa <code>2-debug.c</code> din proiectul <code>2-debug</code> și completați funcția <code>StartThread</code> pentru a implementa crearea unui fir de execuție (urmăriți în cod secțiunea marcată cu <em>TODO</em>).
</p>

<p>
Compilați și rulați sursa.  Aplicația trebuie pornită din consolă: <code>Tools → PowerShell Command Prompt</code>. Observați că programul se blochează. Identificați și rezolvați problema.
</p>

<p>
<p><div class="notetip">
Soluția nu implică comentarea funcției <code>Sleep</code>. Inspectați funcțiile <code>MakeCake</code>, <code>MakeTiramisu</code> și <code>MakeMarshmallows</code> și observați ordinea în care se face <code>WaitForSingleObject</code> pe ingrediente (semafoare). Amintiți-vă din laboratorul precedent care era problema de la <a href="../../../../so/laboratoare/laborator-08.html#exercitiul_5_-_blocked_15p" class="urlextern" title="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-08#exercitiul_5_-_blocked_15p"  rel="nofollow">Exercițiul 5</a>.

</div></p>
</p>

</div>
<!-- EDIT29 SECTION "Exercițiul 2 - Thread debugging (1p)" [42064-42919] -->
<h3 class="sectionedit30" id="exercitiul_3_-_interlocked_2p">Exercițiul 3 - Interlocked (2p)</h3>
<div class="level3">

<p>
În cadrul acestui exercițiu dorim să testăm diverse tipuri de incrementări atomice ale unei variabile, comparându-le timpul de execuție. Deschideți sursa <code>interlocked.c</code> din proiectul <code>3-interlocked</code>. Programul crează <code>NO_THREADS</code> fire de execuție, care incrementează circular o variabilă (când se ajunge la o limită se resetează la 0).
</p>

<p>
Asigurați accesul exclusiv la variabila incrementată folosind <a href="laborator-09.html#operatii_atomice_cu_variabile_partajate_interlocked_variable_access" title="so:laboratoare:laborator-09 ↵" class="wikilink1"> Interlocked Variables</a> deoarece mecanismul e mai rapid decât o incrementare normală protejată cu <code>Mutex</code> sau <code>CRITICAL_SECTION</code> (folosiți funcția <code>InterlockedCompareExchange</code>). Incrementarea circulară se va face în funcția <code>thread_function</code> (urmăriți comentariile cu <em> TODO 1 </em>). Veți avea nevoie de două operații interlocked (<code>InterlockedIncrement</code> și <code>InterlockedCompareExchange</code>).
</p>

<p>
Identificați o problemă cu folosirea <code>Interlocked Operations</code> pentru a incrementa circular o variabilă.
</p>

<p>
<p><div class="notetip">
Adăugați un apel <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms686352(v=vs.85).aspx" class="urlextern" title="https://msdn.microsoft.com/en-us/library/windows/desktop/ms686352(v=vs.85).aspx"  rel="nofollow">SwitchToThread()</a> (echivalent al <code>yield()</code> din Linux) <strong>între</strong> cele două operații interlocked. Compilați și rulați din nou programul. Observați că rezultatul nu mai este cel așteptat. Acest lucru s-a întâmplat pentru că am forțat schedulerul să schimbe firul de execuție imediat după incrementare. Chiar dacă fiecare operație în parte este atomică, succesiunea a două operații atomice <strong>NU</strong> este atomică.

</div></p>
</p>

<p>
Comparați timpul de execuție al programului precedent în cazul în care se folosește un mutex care să sincronizeze accesul la variabila <code>count</code>, completând funcția <code>thread_function_mutex</code> ( <em> TODO 2 </em> ). Nu uitați să modificați și parametrul funcției <code>CreateThread</code> din funcția <code>main</code>.
</p>

</div>
<!-- EDIT30 SECTION "Exercițiul 3 - Interlocked (2p)" [42920-44846] -->
<h3 class="sectionedit31" id="exercitiul_4_-_tls_1p">Exercițiul 4 - TLS (1p)</h3>
<div class="level3">

<p>
Dorim să simulăm o implementare a funcției <code>perror</code>. Pentru aceasta vom avea variabila globală <code>myErrno</code>, dar cu valori specifice (diferite) pentru fiecare fir de execuție. Deschideți sursa <code>tls.c</code> din proiectul <code>4-tls</code> și urmăriți comentariile marcate cu <em>TODO</em> (revedeți secțiunea despre <a href="laborator-09.html#thread_local_storage" title="so:laboratoare:laborator-09 ↵" class="wikilink1"> TLS</a>).
</p>

</div>
<!-- EDIT31 SECTION "Exercițiul 4 - TLS (1p)" [44847-45228] -->
<h3 class="sectionedit32" id="exercitiul_5_-_timerqueue_2p">Exercițiul 5 - TimerQueue (2p)</h3>
<div class="level3">

<p>
Deschideți sursa <code>timer.c</code> din proiectul <code>5-timer</code>. Creați un <code>Timer-Queue Timer</code>, a cărui rutină <em>callback</em> să fie declanșată de exact 3 ori, o dată la fiecare secundă. După 3 declanșări se va dezactiva timerul și se vor distruge toate resursele create. Trebuie să sincronizați rutina <em>timer</em>-ului cu funcția <code>main</code> care va dezactiva timer-ul; pentru aceasta puteți folosi orice mecanism de semnalizare: semafor, event
(revedeți secțiunea despre <a href="laborator-09.html#timer_queues" title="so:laboratoare:laborator-09 ↵" class="wikilink1"> Timer Queues</a>).
</p>

</div>
<!-- EDIT32 SECTION "Exercițiul 5 - TimerQueue (2p)" [45229-45785] -->
<h3 class="sectionedit33" id="exercitiul_6_-_barrier_2p">Exercițiul 6 - Barrier (2p)</h3>
<div class="level3">

<p>
Deschideți sursa <code>barrier.c</code> din proiectul <code>6-Barrier</code>. Implementați o barieră reutilizabilă folosind un mutex și o variabilă de tip eveniment. Completați funcțiile de lucru cu bariera pentru a obține funcționalitatea dorită (comentariile marcate cu <em>TODO</em>).
</p>

<p>
Pentru a putea semnaliza un obiect și a aștepta la un alt obiect de sincronizare în același timp, puteți folosi funcția <a href="http://msdn.microsoft.com/en-us/library/ms686293%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms686293%28VS.85%29.aspx"  rel="nofollow"> SignalObjectAndWait </a>. De asemenea, revedeți secțiunile despre lucrul cu <a href="laborator-09.html#mutex_win32" title="so:laboratoare:laborator-09 ↵" class="wikilink1"> mutex-uri</a> și <a href="laborator-09.html#evenimente" title="so:laboratoare:laborator-09 ↵" class="wikilink1"> evenimente</a>.
</p>

<p>
Bariera va fi reprezentată prin structura:
</p>
<pre class="code c"><span class="kw4">typedef</span> <span class="kw4">struct</span> <span class="br0">&#123;</span>
	HANDLE hGuard<span class="sy0">;</span>	    <span class="coMULTI">/* mutex to protect internal variable access */</span>
	HANDLE hEvent<span class="sy0">;</span>	    <span class="coMULTI">/* auto-resetable event */</span>
	DWORD dwCount<span class="sy0">;</span>	    <span class="coMULTI">/* number of threads to have reached the barrier */</span>
	DWORD dwThreshold<span class="sy0">;</span>  <span class="coMULTI">/* barrier limit */</span>
<span class="br0">&#125;</span>THRESHOLD_BARRIER<span class="sy0">,</span> <span class="sy0">*</span>THB_OBJECT<span class="sy0">;</span></pre>

<p>
Folosiți mutexul pentru a sincroniza execuția în cadrul funcției <code>WaitThresholdBarrier</code>. Folosiți eventul pentru a aștepta până când toate threadurile ajung să apeleze funcția <code>WaitThresholdBarrier</code>. Folosiți funcția <a href="http://msdn.microsoft.com/en-us/library/ms684914%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms684914%28VS.85%29.aspx"  rel="nofollow"> PulseEvent</a> pentru a semnala toate threadurile care așteaptă asupra eventului.
</p>

</div>
<!-- EDIT33 SECTION "Exercițiul 6 - Barrier (2p)" [45786-47161] -->
<h3 class="sectionedit34" id="bonus">BONUS</h3>
<div class="level3">

</div>

<h4 id="so_karma_-_parallel_sort">2 so karma - Parallel Sort</h4>
<div class="level4">

<p>
Deschideți sursa <code>sort.c</code> din proiectul <code>7-sort</code>. Se dorește realizarea sortării unui șir de numere aleatoare dintr-un fișier în următorul mod:
</p>
<ul>
<li class="level1"><div class="li"> Se împarte vectorul în bucăți către fiecare fir de execuție</div>
</li>
<li class="level3"><div class="li"> Un fir de execuție sortează bucata proprie folosind quicksort</div>
</li>
<li class="level3"><div class="li"> Se face merge la bucăți, în următorul fel: <a href="../../../../_detail/so/laboratoare-2013/parallel_sort.png%3Fid=so%253Alaboratoare%253Alaborator-09.html" class="media" title="so:laboratoare-2013:parallel_sort.png"><img src="../../../../_media/so/laboratoare-2013/parallel_sort.png%3Fw=450&amp;tok=be0e1b" class="media" alt="" width="450" /></a></div>
</li>
</ul>

<p>
Realizați partea de creare a firelor de execuție și împărțire a taskurilor în funcția <code>init_setup()</code>. După ce toate firele de execuție sortează chunk-ul static, unele vor incepe sa facă merge la chunk-urile sortate. Completați funcția <code>ThreadFunc</code> pentru ca, în funcție de id, un fir de execuție să apeleze funcția <code>MergeChunks</code> (care realizează interclasarea a doi vectori sortați)  (urmăriți comentariile cu <em>TODO</em>).
</p>

<p>
Șirul de numere este dat sub forma unui fișier binar care poate fi generat cu programul <code>generator.exe</code>. Citirea șirului într-un vector este deja realizată în funcția <code>init_setup</code>, iar fiecare fir de execuție primește o structură <code>CHUNK</code> care reprezintă dimensiunea unui vector de sortat, cât și adresa inițială a vectorului.  Interclasarea a două structuri CHUNK în care vectorii sunt deja sortați se realizează cu funcția <code>MergeChunks</code>.
</p>

</div>

<h4 id="so_karma_-_the_dorm_room_problem">2 so karma - The dorm room problem</h4>
<div class="level4">

<p>
Deschideți sursa <code>dorm_room.c</code> din proiectul <code>8-dean</code>. Se dorește simularea/modelarea următoarei probleme: decanul și studenții. Se dau următoarele constrângeri:
</p>
<ul>
<li class="level1"><div class="li"> Orice număr de studenți poate intra într-o cameră în același moment</div>
</li>
<li class="level3"><div class="li"> Decanul poate intra într-o cameră doar dacă nu sunt studenți acolo (pentru a realiza o percheziție) sau dacă sunt mai mult de 25 de studenți (pentru a sparge petrecerea)</div>
</li>
<li class="level3"><div class="li"> Cât timp Decanul este în cameră, studenții pot doar ieși, nu și intra</div>
</li>
<li class="level3"><div class="li"> Decanul nu poate părăsi camera până când nu au ieșit toți studenții (s-a terminat sigur petrecerea :P)</div>
</li>
<li class="level3"><div class="li"> Există un singur Decan.</div>
</li>
</ul>

<p>
Rezolvați problema scriind cod pentru entitățile respective: decan și student. Pentru firele de execuție <em>studenți</em> completați funcțiile “enter_room” și “party”, iar pentru firul de execuție <em>decan</em> completați funcția “break_party” (revedeți secțiunea despre <a href="laborator-09.html#mutex-win32" title="so:laboratoare:laborator-09 ↵" class="wikilink1"> mutex-uri </a> și <a href="laborator-09.html#semafor-win32" title="so:laboratoare:laborator-09 ↵" class="wikilink1"> semafoare </a>).
</p>

<p>
Folosiți funcțiile “dbg_student” și “dbg_decan” pentru a afișa mesaje corespunzătoare de fiecare dată când un fir de execuție își schimbă starea (ex: decanul intră în cameră, un student nu poate intra deoarece decanul e deja în cameră etc.)
</p>

</div>
<!-- EDIT34 SECTION "BONUS" [47162-50562] -->
<h2 class="sectionedit35" id="solutii">Soluții</h2>
<div class="level2">

<p>
 <a href="http://elf.cs.pub.ro/so/res/laboratoare/lab09-sol.zip" class="urlextern" title="http://elf.cs.pub.ro/so/res/laboratoare/lab09-sol.zip"  rel="nofollow"> Soluţii laborator 9</a>
</p>



</div>
<!-- EDIT35 SECTION "Soluții" [50563-] --></div>
</body>
</html>
