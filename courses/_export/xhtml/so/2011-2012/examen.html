    
    

<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
  <meta charset="utf-8" />
  <title>so:2011-2012:examen</title>
<meta name="generator" content="DokuWiki"/>
<meta name="robots" content="index,follow"/>
<meta name="date" content="2013-02-16T16:16:46+0200"/>
<meta name="keywords" content="so,2011-2012,examen"/>
<link rel="search" type="application/opensearchdescription+xml" href="../../../../lib/exe/opensearch.php" title="CS Open CourseWare"/>
<link rel="start" href="../../../../../courses.1.html"/>
<link rel="alternate" type="application/rss+xml" title="Recent Changes" href="../../../../feed.php"/>
<link rel="alternate" type="application/rss+xml" title="Current Namespace" href="../../../../feed.php%3Fmode=list&amp;ns=so:2011-2012"/>
<link rel="alternate" type="text/html" title="Plain HTML" href="examen.html"/>
<link rel="canonical" href="../../../../so/2011-2012/examen.html"/>
<link rel="stylesheet" type="text/css" href="../../../../lib/exe/css.php%3Ft=arctic&amp;tseed=1479898000.css"/>
<script type="text/javascript">/*<![CDATA[*/var NS='so:2011-2012';var JSINFO = {"id":"so:2011-2012:examen","namespace":"so:2011-2012","isadmin":0,"isauth":0};
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="../../../../lib/exe/js.php%3Ftseed=1479898000"></script>
<script type="text/x-mathjax-config">/*<![CDATA[*/MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ["$","$"], ["\\(","\\)"] ],
        displayMath: [ ["$$","$$"], ["\\[","\\]"] ],
        processEscapes: true
    }
});
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
<script type="text/javascript">/*<![CDATA[*/
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
		  
/*!]]>*/</script>
<script type="text/javascript">/*<![CDATA[*/
var pageTracker = _gat._getTracker("UA-38383934-1");
pageTracker._initData();
pageTracker._trackPageview();
		  
/*!]]>*/</script>
</head>
<body>
<div class="dokuwiki export">
<!-- TOC START -->
<div id="dw__toc">
<h3 class="toggle">Table of Contents</h3>
<div>

<ul class="toc">
<li class="level1"><div class="li"><a href="examen.html#examen">Examen</a></div>
<ul class="toc">
<li class="level2"><div class="li"><a href="examen.html#examen_final">Examen final</a></div></li>
<li class="level2"><div class="li"><a href="examen.html#lucrari">Lucrări</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="examen.html#lucrare_1">Lucrare 1</a></div></li>
<li class="level3"><div class="li"><a href="examen.html#ca_nr_1">3CA, nr. 1</a></div></li>
<li class="level3"><div class="li"><a href="examen.html#ca_nr_2">3CA, nr. 2</a></div></li>
<li class="level3"><div class="li"><a href="examen.html#cc_nr_1">3CC, nr. 1</a></div></li>
<li class="level3"><div class="li"><a href="examen.html#cc_nr_2">3CC, nr. 2</a></div></li>
</ul>
</li>
<li class="level2"><div class="li"><a href="examen.html#examene_anterioare">Examene anterioare</a></div></li>
</ul></li>
</ul>
</div>
</div>
<!-- TOC END -->

<h1 class="sectionedit1" id="examen">Examen</h1>
<div class="level1">
<ul>
<li class="level1"><div class="li">Urmăriți precizările din <a href="../../../../so/reguli-notare.html" class="wikilink2" title="so:reguli-notare" rel="nofollow">pagina de reguli</a>.</div>
</li>
</ul>

</div>
<!-- EDIT1 SECTION "Examen" [1-93] -->
<h2 class="sectionedit2" id="examen_final">Examen final</h2>
<div class="level2">
<ul>
<li class="level1"><div class="li">Examenele finale ale cursului de Sisteme de Operare se vor desfășura astfel:</div>
<ul>
<li class="level2"><div class="li">Miercuri, 16 mai 2012, ora 19:30, sala EC105 – studenții care pleacă la stagii și nu pot participa la examenele din sesiune</div>
</li>
<li class="level2"><div class="li">Joi, 24 mai 2012, ora 09:00, sala EG106 – studenții care au restanță</div>
</li>
<li class="level2"><div class="li">Sâmbătă, 26 mai 2012, ora 11, sala AN030 – 333CA, 334CA, 331CC, 335CC, studenți seria CB, studenți care au restanță</div>
</li>
<li class="level2"><div class="li">Vineri, 8 iunie 2012, ora 8, sala EC105 – 331CA, 332CA, 332CC, 333CC, 334CC</div>
</li>
</ul>
</li>
<li class="level1"><div class="li">Rugăm să veniți în intervalul stabilit grupei voastre. Dacă, din motive obiective, nu puteți participa în data repartizată, trimiteți-i un e-mail lui <a href="mailto:&#x74;&#x72;&#x61;&#x69;&#x61;&#x6e;&#x2e;&#x70;&#x6f;&#x70;&#x65;&#x65;&#x61;&#x40;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;" class="mail" title="&#x74;&#x72;&#x61;&#x69;&#x61;&#x6e;&#x2e;&#x70;&#x6f;&#x70;&#x65;&#x65;&#x61;&#x40;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;">Traian</a> cu subiectul <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/so_transfer_examen_-_prenume_nume_grupa" class="media mediafile mf_ wikilink2" title="so:2011-2012:so_transfer_examen_-_prenume_nume_grupa">so_transfer_examen_-_prenume_nume_grupa</a>}.</div>
</li>
<li class="level1"><div class="li">Puteți participa la <strong>un singur</strong> examen.</div>
</li>
</ul>
<ul>
<li class="level1"><div class="li">16 mai 2012 ( <a href="http://elf.cs.pub.ro/so/res/examen/2012/SO_2011-2012_examen_16_mai.pdf" class="urlextern" title="http://elf.cs.pub.ro/so/res/examen/2012/SO_2011-2012_examen_16_mai.pdf"  rel="nofollow"> foaie examen</a> )</div>
</li>
<li class="level1"><div class="li">24 mai 2012 ( <a href="http://elf.cs.pub.ro/so/res/examen/2012/SO_2011-2012_examen_24_mai.pdf" class="urlextern" title="http://elf.cs.pub.ro/so/res/examen/2012/SO_2011-2012_examen_24_mai.pdf"  rel="nofollow"> foaie examen</a> )</div>
</li>
<li class="level1"><div class="li">26 mai 2012 ( <a href="http://elf.cs.pub.ro/so/res/examen/2012/SO_2011-2012_examen_26_mai.pdf" class="urlextern" title="http://elf.cs.pub.ro/so/res/examen/2012/SO_2011-2012_examen_26_mai.pdf"  rel="nofollow"> foaie examen</a> )</div>
</li>
<li class="level1"><div class="li">8 iunie 2012 ( <a href="http://elf.cs.pub.ro/so/res/examen/2012/SO_2011-2012_examen_08_iunie.pdf" class="urlextern" title="http://elf.cs.pub.ro/so/res/examen/2012/SO_2011-2012_examen_08_iunie.pdf"  rel="nofollow"> foaie examen</a> )</div>
</li>
</ul>

</div>
<!-- EDIT2 SECTION "Examen final" [94-1373] -->
<h2 class="sectionedit3" id="lucrari">Lucrări</h2>
<div class="level2">
<ul>
<li class="level1"><div class="li">Nu există sesiune de contestații pentru lucrările de curs. În cazul în care considerați că au fost lipsuri la corectarea lucrării, trimiteți un e-mail lui <a href="mailto:&#x74;&#x72;&#x61;&#x69;&#x61;&#x6e;&#x2e;&#x70;&#x6f;&#x70;&#x65;&#x65;&#x61;&#x40;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;" class="mail" title="&#x74;&#x72;&#x61;&#x69;&#x61;&#x6e;&#x2e;&#x70;&#x6f;&#x70;&#x65;&#x65;&#x61;&#x40;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;">Traian</a>.</div>
<ul>
<li class="level2"><div class="li">Folosiți subiectul [SO][Lucrare X] Prenume Nume - grupa; de exemplu [SO][Lucrare 1] Andreea Popescu - 332CA.</div>
</li>
</ul>
</li>
</ul>

</div>
<!-- EDIT3 SECTION "Lucrări" [1374-1713] -->
<h3 class="sectionedit4" id="lucrare_1">Lucrare 1</h3>
<div class="level3">
<ul>
<li class="level1"><div class="li">6 martie, 09:05-09:15, EC004, seria CA</div>
</li>
<li class="level1"><div class="li">7 martie, 17:05-17:15, EC105, seria CC</div>
</li>
</ul>

</div>
<!-- EDIT4 SECTION "Lucrare 1" [1714-1819] -->
<h3 class="sectionedit5" id="ca_nr_1">3CA, nr. 1</h3>
<div class="level3">

<p>
# Fie procesul P1. Câte procese copil va avea P1 în urma rulării secvenței de pseudocod de mai jos? De ce?
</p>
<pre class="code c"><span class="kw1">while</span><span class="br0">&#40;</span>fork<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">&#41;</span>
    <span class="sy0">;</span></pre>

<p>
#* <strong>Răspuns</strong>: Apelul <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/fork" class="media mediafile mf_ wikilink2" title="so:2011-2012:fork">fork</a>} întoarce 0 în procesul copil și PID-ul procesului copil, diferit de 0, în părinte. De aceea, părintele va executa o singură dată <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/fork" class="media mediafile mf_ wikilink2" title="so:2011-2012:fork">fork</a>}, ieșind apoi din buclă. Copilul va mai executa o dată bucla, devenind la rândul lui părinte și ieșind din buclă. Fiecare proces va fi părinte pentru un singur copil. Astfel, P1 va avea un singur proces copil.
# De ce aduce un apel de sistem mai mult overhead decât un apel de funcție obișnuit?
#* <strong>Răspuns</strong>: Un apel de sistem aduce mai mult overhead datorită comutării în kernel-space, în timp ce un apel de funcție se execută în user-space.
# Unde este poziționat cursorul de fișier <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/fd1" class="media mediafile mf_ wikilink2" title="so:2011-2012:fd1">fd1</a>} în urma secvenței de mai jos? Presupuneți că toate apelurile se întorc cu succes.
</p>
<pre class="code c">fd1 <span class="sy0">=</span> open<span class="br0">&#40;</span><span class="st0">&quot;a.txt&quot;</span><span class="sy0">,</span> O_RDWR <span class="sy0">|</span> O_CREAT <span class="sy0">|</span> O_TRUNC<span class="sy0">,</span> <span class="nu8">0644</span><span class="br0">&#41;</span><span class="sy0">;</span>
fd2 <span class="sy0">=</span> open<span class="br0">&#40;</span><span class="st0">&quot;a.txt&quot;</span><span class="sy0">,</span> O_RDWR <span class="sy0">|</span> O_CREAT <span class="sy0">|</span> O_TRUNC<span class="sy0">,</span> <span class="nu8">0644</span><span class="br0">&#41;</span><span class="sy0">;</span>
write<span class="br0">&#40;</span>fd2<span class="sy0">,</span> <span class="st0">&quot;1&quot;</span><span class="sy0">,</span> <span class="nu0">1</span><span class="br0">&#41;</span><span class="sy0">;</span>
dup2<span class="br0">&#40;</span>fd2<span class="sy0">,</span> fd1<span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>
#* <strong>Răspuns</strong>: În urma apelului <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/open" class="media mediafile mf_ wikilink2" title="so:2011-2012:open">open</a>}, cursorul de fișier <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/fd2" class="media mediafile mf_ wikilink2" title="so:2011-2012:fd2">fd2</a>} va poziționat la început. După <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/write" class="media mediafile mf_ wikilink2" title="so:2011-2012:write">write</a>}, acesta va poziționat la 1 octet după începutul fișierului, iar după <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/dup2" class="media mediafile mf_ wikilink2" title="so:2011-2012:dup2">dup2</a>}, și cursorul de fișier <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/fd1" class="media mediafile mf_ wikilink2" title="so:2011-2012:fd1">fd1</a>} va poziționat la 1 octet după începutul fișierului.
</p>

</div>
<!-- EDIT5 SECTION "3CA, nr. 1" [1820-3241] -->
<h3 class="sectionedit6" id="ca_nr_2">3CA, nr. 2</h3>
<div class="level3">

<p>
# Fie secvența de pseudocod de mai jos:
</p>
<pre class="code c">fd1 <span class="sy0">=</span> open<span class="br0">&#40;</span><span class="st0">&quot;a.txt&quot;</span><span class="sy0">,</span> O_RDWR <span class="sy0">|</span> O_CREAT <span class="sy0">|</span> O_TRUNC<span class="sy0">,</span> <span class="nu8">0644</span><span class="br0">&#41;</span><span class="sy0">;</span>
pid <span class="sy0">=</span> fork<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
<span class="kw1">switch</span> <span class="br0">&#40;</span>pid<span class="br0">&#41;</span> <span class="br0">&#123;</span>
    <span class="kw1">case</span> <span class="nu0">0</span><span class="sy0">:</span>
        <span class="kw2">break</span><span class="sy0">;</span>
    <span class="kw1">default</span><span class="sy0">:</span>
        dup<span class="br0">&#40;</span>fd1<span class="br0">&#41;</span><span class="sy0">;</span>
<span class="br0">&#125;</span></pre>

<p>
Presupunând că toate apelurile se întorc cu succes, câți descriptori din fiecare proces vor referi fișierului <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/a.txt" class="media mediafile mf_txt wikilink2" title="so:2011-2012:a.txt">a.txt</a>}?
#* <strong>Răspuns</strong>: 3 descriptori; 2 descriptori în părinte (<a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/fd1" class="media mediafile mf_ wikilink2" title="so:2011-2012:fd1">fd1</a>} și descriptorul rezultat în urma <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/dup" class="media mediafile mf_ wikilink2" title="so:2011-2012:dup">dup</a>}) și 1 descriptor în copil (<a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/fd1" class="media mediafile mf_ wikilink2" title="so:2011-2012:fd1">fd1</a>}, moștenit de copil în urma <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/fork" class="media mediafile mf_ wikilink2" title="so:2011-2012:fork">fork</a>}).
# Care este numărul minim de descriptori de fișier ai unui proces pot referi, la un moment dat, <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/stderr" class="media mediafile mf_ wikilink2" title="so:2011-2012:stderr">stderr</a>} (standard error)? De ce?
#* <strong>Răspuns</strong>: Numărul minim este 0, deoarece <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/stderr" class="media mediafile mf_ wikilink2" title="so:2011-2012:stderr">stderr</a>} poate fi închis prin apel <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/close" class="media mediafile mf_ wikilink2" title="so:2011-2012:close">close</a>}.
# În ce zonă de memorie este plasată adresa de retur a unei funcții? De ce?
#* <strong>Răspuns</strong>: Adresa de retur a unei funcții este plasată pe stivă. La fiecare apel de funcție, un nou stack frame este creat pe stivă, care conține parametrii funcției, adresa de retur și variabile locale. La ieșirea din funcție, adresa de retur este preluată de pe stivă.
</p>

</div>
<!-- EDIT6 SECTION "3CA, nr. 2" [3242-4394] -->
<h3 class="sectionedit7" id="cc_nr_1">3CC, nr. 1</h3>
<div class="level3">

<p>
# Fie secvența de pseudocod de mai jos:
</p>
<pre class="code c">fd1 <span class="sy0">=</span> open<span class="br0">&#40;</span><span class="st0">&quot;a.txt&quot;</span><span class="sy0">,</span> O_RDONLY<span class="br0">&#41;</span><span class="sy0">;</span>
fd2 <span class="sy0">=</span> open<span class="br0">&#40;</span><span class="st0">&quot;b.txt&quot;</span><span class="sy0">,</span> O_RDWR<span class="br0">&#41;</span><span class="sy0">;</span>
dup2<span class="br0">&#40;</span>fd1<span class="sy0">,</span> fd2<span class="br0">&#41;</span><span class="sy0">;</span>
write<span class="br0">&#40;</span>fd2<span class="sy0">,</span> <span class="st0">&quot;X&quot;</span><span class="sy0">,</span> <span class="nu0">1</span><span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>
Care sunt valorile posibile ce pot fi intoarse de apelul <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/write" class="media mediafile mf_ wikilink2" title="so:2011-2012:write">write</a>}?
#* <strong>Răspuns</strong>:
#<strong> Dacă toate apelurile se întorc cu succes, în urma apelului <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/dup2" class="media mediafile mf_ wikilink2" title="so:2011-2012:dup2">dup2</a>}, <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/fd2" class="media mediafile mf_ wikilink2" title="so:2011-2012:fd2">fd2</a>} va puncta către <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/a.txt" class="media mediafile mf_txt wikilink2" title="so:2011-2012:a.txt">a.txt</a>} deschis <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/o_rdonly" class="media mediafile mf_ wikilink2" title="so:2011-2012:o_rdonly">o_rdonly</a>}, iar apelul <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/write" class="media mediafile mf_ wikilink2" title="so:2011-2012:write">write</a>} va întoarce -1 și va seta errno la valoarea <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/ebadf" class="media mediafile mf_ wikilink2" title="so:2011-2012:ebadf">ebadf</a>}, pentru a semnala eroarea.
#</strong> Dacă apelul <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/dup2" class="media mediafile mf_ wikilink2" title="so:2011-2012:dup2">dup2</a>} eșuează, <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/fd2" class="media mediafile mf_ wikilink2" title="so:2011-2012:fd2">fd2</a>} va puncta către <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/b.txt" class="media mediafile mf_txt wikilink2" title="so:2011-2012:b.txt">b.txt</a>} deschis <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/o_rdwr" class="media mediafile mf_ wikilink2" title="so:2011-2012:o_rdwr">o_rdwr</a>}, iar apelul <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/write" class="media mediafile mf_ wikilink2" title="so:2011-2012:write">write</a>} va întoarce 1, dacă a scris caracterul, sau 0, dacă nu a scris caracterul.
# De ce apelul <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/fopen" class="media mediafile mf_ wikilink2" title="so:2011-2012:fopen">fopen</a>} realizează în spate apel de sistem, dar apelul <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/memcpy" class="media mediafile mf_ wikilink2" title="so:2011-2012:memcpy">memcpy</a>} nu?
#* <strong>Răspuns</strong>:
#* <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/fopen" class="media mediafile mf_ wikilink2" title="so:2011-2012:fopen">fopen</a>} realizează apelul de sistem <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/open" class="media mediafile mf_ wikilink2" title="so:2011-2012:open">open</a>} pentru a putea deschide/crea un fișier sau dispozitiv, pentru acest lucru fiind necesară trecerea în kernel-space.
#* <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/memcpy" class="media mediafile mf_ wikilink2" title="so:2011-2012:memcpy">memcpy</a>} nu realizează apel de sistem deoarece scrie și citește memorie deja alocată în spațiul de adresă al procesului fără a trece în kernel-space.
# Dați două exemple în care:
#* a) un proces are mai multe procese părinte decât procese copil;
#* b) un proces are mai multe procese copil decât procese părinte.
#* <strong>Răspuns</strong>:
#* toate procesele, cu excepția procesului <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/init" class="media mediafile mf_ wikilink2" title="so:2011-2012:init">init</a>}, au un proces părinte;
#<strong> a) un proces care nu are procese copil (nu a executat <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/fork" class="media mediafile mf_ wikilink2" title="so:2011-2012:fork">fork</a>} niciodată);
#</strong> b) un proces care are cel puțin două procese copil (a executat <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/fork" class="media mediafile mf_ wikilink2" title="so:2011-2012:fork">fork</a>} de cel puțin două ori, cu succes) sau procesul <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/init" class="media mediafile mf_ wikilink2" title="so:2011-2012:init">init</a>} care nu are proces părinte.
</p>

</div>
<!-- EDIT7 SECTION "3CC, nr. 1" [4395-6071] -->
<h3 class="sectionedit8" id="cc_nr_2">3CC, nr. 2</h3>
<div class="level3">

<p>
# Fie un fișier <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/a.txt" class="media mediafile mf_txt wikilink2" title="so:2011-2012:a.txt">a.txt</a>} având dimensiunea de 1024 octeți și secvența de pseudocod de mai jos:
</p>
<pre class="code c">fd1 <span class="sy0">=</span> open<span class="br0">&#40;</span><span class="st0">&quot;a.txt&quot;</span><span class="sy0">,</span> O_RDWR <span class="sy0">|</span> O_TRUNC<span class="br0">&#41;</span><span class="sy0">;</span>
close<span class="br0">&#40;</span>fd1<span class="br0">&#41;</span><span class="sy0">;</span>
fd1 <span class="sy0">=</span> open<span class="br0">&#40;</span><span class="st0">&quot;a.txt&quot;</span><span class="sy0">,</span> O_RDWR <span class="sy0">|</span> O_APPEND<span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>
Unde va fi poziționat cursorul de fișier ale descriptorului <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/fd1" class="media mediafile mf_ wikilink2" title="so:2011-2012:fd1">fd1</a>}? De ce?
#* <strong>Răspuns</strong>: În urma primului apel <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/open" class="media mediafile mf_ wikilink2" title="so:2011-2012:open">open</a>}, flag-ul <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/o_trunc" class="media mediafile mf_ wikilink2" title="so:2011-2012:o_trunc">o_trunc</a>} reduce dimensiunea fișierului la 0. Al doilea apel <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/open" class="media mediafile mf_ wikilink2" title="so:2011-2012:open">open</a>} poziționează cursorul la sfârșitul unui fișier gol, adică pe poziția 0. Dacă fișierul <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/a.txt" class="media mediafile mf_txt wikilink2" title="so:2011-2012:a.txt">a.txt</a>} nu există, toate apelurile vor întoarce -1.
# De ce apelul <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/fork" class="media mediafile mf_ wikilink2" title="so:2011-2012:fork">fork</a>} întoarce 0 pentru succes în procesul copil și o valoare diferită de 0 pentru succes în procesul părinte?
#* <strong>Răspuns</strong>: În procesul copil întoarce 0 pentru că procesul poate folosi apelul <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/getppid" class="media mediafile mf_ wikilink2" title="so:2011-2012:getppid">getppid</a>} pentru a afla PID-ul procesul părinte. În procesul părinte, <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/fork" class="media mediafile mf_ wikilink2" title="so:2011-2012:fork">fork</a>} întoarce PID-ul procesului copil. Un proces poate avea mai multe procese copil și este comod ca <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/fork" class="media mediafile mf_ wikilink2" title="so:2011-2012:fork">fork</a>} să întoarcă PID-ul procesului copil proaspăt creat.
# Care dintre următoarele apeluri pot modifica numărul de procese dintr-un sistem UNIX: <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/open" class="media mediafile mf_ wikilink2" title="so:2011-2012:open">open</a>}, <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/fork" class="media mediafile mf_ wikilink2" title="so:2011-2012:fork">fork</a>}, <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/dup2" class="media mediafile mf_ wikilink2" title="so:2011-2012:dup2">dup2</a>}, <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/wait" class="media mediafile mf_ wikilink2" title="so:2011-2012:wait">wait</a>}, <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/exec" class="media mediafile mf_ wikilink2" title="so:2011-2012:exec">exec</a>}?
#* <strong>Răspuns</strong>:
#<strong> <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/open" class="media mediafile mf_ wikilink2" title="so:2011-2012:open">open</a>} deschide și, posibil, creează un nou fișier sau dispozitiv - </strong>NU<strong>
#</strong> <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/fork" class="media mediafile mf_ wikilink2" title="so:2011-2012:fork">fork</a>} creează un nou proces - <strong>DA</strong>
#<strong> <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/dup2" class="media mediafile mf_ wikilink2" title="so:2011-2012:dup2">dup2</a>} duplică un descriptor de fișier - </strong>NU<strong>
#</strong> <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/wait" class="media mediafile mf_ wikilink2" title="so:2011-2012:wait">wait</a>} așteaptă schimbarea stării unui proces, în cazul unui proces copil care și-a încheiat execuția, permite sistemului să elibereze resursele asociate cu copilul, ducând la scăderea numărului de procese din sistem - <strong>DA</strong>
#<strong> <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/exec" class="media mediafile mf_ wikilink2" title="so:2011-2012:exec">exec</a>} înlocuiește imaginea procesului curent cu o nouă imagine de proces - </strong>NU<strong>
==== Lucrare 2 ====

  *27 martie, 09:05-09:15, EC004, seria CA
  *28 martie, 17:05-17:15, EC105, seria CC

==== 3CA, nr. 1 ====

# Dați exemplu de acțiune ce conduce la trecerea unui proces din starea <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/running" class="media mediafile mf_ wikilink2" title="so:2011-2012:running">running</a>} în <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/waiting" class="media mediafile mf_ wikilink2" title="so:2011-2012:waiting">waiting</a>} și un exemplu de acțiune care conduce la o trecere inversă.
#* </strong>Răspuns<strong>
#</strong> Un proces trece din starea <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/running" class="media mediafile mf_ wikilink2" title="so:2011-2012:running">running</a>} în <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/waiting" class="media mediafile mf_ wikilink2" title="so:2011-2012:waiting">waiting</a>} atunci când execută o acțiune blocantă.
#<strong> Un proces nu poate trece direct din starea <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/waiting" class="media mediafile mf_ wikilink2" title="so:2011-2012:waiting">waiting</a>} în <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/running" class="media mediafile mf_ wikilink2" title="so:2011-2012:running">running</a>}. Procesul trece în starea <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/ready" class="media mediafile mf_ wikilink2" title="so:2011-2012:ready">ready</a>} atunci când a dispărut cauza blocării sale.
# Dați exemplu de avantaj, respectiv dezavantaj al sincronizării folosind semafoare binare în fața spinlock-urilor.
#* </strong>Răspuns<strong>:
#</strong> Avantaj: Deoarece semafoarele binare nu folosesc busy waiting, pot fi folosite pentru secțiuni critice de orice dimensiune.
#<strong> Dezavantaj: Un proces va ceda procesorul dacă nu poate lua semaforul. Operația de <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/down" class="media mediafile mf_ wikilink2" title="so:2011-2012:down">down</a>} are un overhead ridicat, datorită schimbării de context.
# În ce mod influențează dimensiunea TLB-ului numărul maxim de spații de adresă existente în sistem?
#* </strong>Răspuns<strong>: TLB-ul menține mapări de pagini fizice și pagini virtuale. Conține un subset al tabelei de pagini. Numărul maxim de spații de adresă existente în sistem depinde de numărul de procese existente în sistem. Acest număr nu este influențat de dimensiunea TLB-ului.

==== 3CA, nr. 2 ====

# Cum ar trebui aleasă cuanta de timp pentru procese pentru un sistem în care se dorește interactivitate mare? De ce?
#* </strong>Răspuns<strong>: Cuanta de timp trebuie să fie mică pentru ca procesele să fie preemptate mai des și să crească timpul de răspuns al sistemului.
# Dați exemplu de avantaj, respectiv dezavantaj al sincronizării folosind spinlock-uri în fața mutex-urilor.
#* </strong>Răspuns<strong>:
#</strong> Avantaj: Un proces nu va ceda procesorul dacă nu poate lua spinlock-ul. Operația de <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/lock" class="media mediafile mf_ wikilink2" title="so:2011-2012:lock">lock</a>} are un overhead scăzut.
#<strong> Dezavantaj: Deoarece spinlock-urile folosesc busy waiting, sunt recomandate doar pentru secțiuni critice mici, ce se execută rapid.
# Fie un utilizator fără drepturi de administrator. În ce mod poate acesta modifica numărul de pagini fizice din sistem? Dar numărul de pagini virtuale?
#* </strong>Răspuns<strong>:
#</strong> Numărul de pagini fizice din sistem poate fi modificat prin adăugarea/scoaterea de memorie fizică din sistem sau prin modificarea dimensiunii paginilor fizice, având suport hardware. Pentru aceste operații este necesar un administrator, deci un utilizator fără drepturi de administrator nu poate modifica numărul de pagini fizice din sistem.
#<strong> Un utilizator fără drepturi de administrator poate modifica numărul de pagini virtuale din sistem prin crearea/omorârea de procese, deoarece fiecare proces ale paginile virtuale proprii.

==== 3CC, nr. 1 ====

# În ce mod este determinat numărul de procese care se pot afla, la un moment dat, în starea <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/running" class="media mediafile mf_ wikilink2" title="so:2011-2012:running">running</a>} de următoarele componente fizice ale sistemului: număr de procesoare, arhitectură pe 32/64 biți, memorie fizică, capacitate de stocare?
#* </strong>Răspuns<strong>: Numărul de procese care se pot afla, la un moment dat, în starea <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/running" class="media mediafile mf_ wikilink2" title="so:2011-2012:running">running</a>} depinde doar de numărul de procesoare, deoarece pot exista maxim <em>n</em> procese în starea <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/running" class="media mediafile mf_ wikilink2" title="so:2011-2012:running">running</a>} pe un sistem cu <em>n</em> procesoare. Celelalte componente nu influențează acest număr.
# Care metodă de sincronizare (mutex sau spinlock) este mai avantajoasă pentru sincronizarea accesului la următoarea regiune critică și de ce? Prezentați cel puțin un motiv.&lt;code c&gt;…
<em> start regiune critica
c=a+b;
a=b;
b=c;
</em> stop regiune critica
…&lt;/code&gt;
#* </strong>Răspuns<strong>: Deoarece regiunea critică este mică, este mai avantajoasă folosirea unui spinlock pentru sincronizare, deoarece se evită overhead-ul unei schimbări de context.
# Dați exemplu de avantaj, respectiv dezavantaj al paginării simple (neierarhice) în fața paginării ierarhice.
#* </strong>Răspuns<strong>:
#</strong> Avantaje: 
#<strong>* Overhead de prelucrare mic (este parcursă o singură tabelă de pagini);
#</strong>* Complexitate mică de implementare.
#<strong> Dezavantaj: paginarea simplă ocupă mai mult spațiu, deoarece se ocupă spațiu și pentru zonele de memorie virtuale nevalide.

==== 3CC, nr. 2 ====

# În ce mod este determinat numărul de procese care se pot afla, la un moment dat, în starea <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/ready" class="media mediafile mf_ wikilink2" title="so:2011-2012:ready">ready</a>} de următoarele componente fizice ale sistemului: număr de procesoare, arhitectură pe 32/64 biți, memorie fizică, capacitate de stocare?
#* </strong>Răspuns<strong>: Numărul de procese care se pot afla, la un moment dat, în starea <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/ready" class="media mediafile mf_ wikilink2" title="so:2011-2012:ready">ready</a>} depinde de memoria fizică, deoarece coada/cozile <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/ready" class="media mediafile mf_ wikilink2" title="so:2011-2012:ready">ready</a>} sunt reținute în liste în memoria fizică, iar dimensiunea acesteia poate limita dimensiunile acestora. Celelalte componente nu influențează, în general, acest număr.
#</strong> Observație: Au fost considerate valide următoarele argumente:
#<strong>* pentru dimensiuni mari ale memoriei fizice (peste 4 <abbr title="Gigabyte">GB</abbr>) este relevantă arhitectura, pentru a putea adresa memoria disponibilă;
#</strong>* existența mai multor procesoare duce la creșterea numărului de procese aflate simultan în starea <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/running" class="media mediafile mf_ wikilink2" title="so:2011-2012:running">running</a>}, astfel că scade numărul de procese care ar fi fost în starea <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/ready" class="media mediafile mf_ wikilink2" title="so:2011-2012:ready">ready</a>}, diferența fiind egală cu diferența dintre numărul de procesoare;
# Care dintre următoarele operații pot genera schimbare de context cu o cauză diferită de expirarea cuantei? De ce? <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/lock_mutex" class="media mediafile mf_ wikilink2" title="so:2011-2012:lock_mutex">lock_mutex</a>}, <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/unlock_mutex" class="media mediafile mf_ wikilink2" title="so:2011-2012:unlock_mutex">unlock_mutex</a>}, <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/spin_lock_spinlock" class="media mediafile mf_ wikilink2" title="so:2011-2012:spin_lock_spinlock">spin_lock_spinlock</a>}, <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/spin_unlock_spinlock" class="media mediafile mf_ wikilink2" title="so:2011-2012:spin_unlock_spinlock">spin_unlock_spinlock</a>}, <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/down_semaphore" class="media mediafile mf_ wikilink2" title="so:2011-2012:down_semaphore">down_semaphore</a>}, <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/up_semaphore" class="media mediafile mf_ wikilink2" title="so:2011-2012:up_semaphore">up_semaphore</a>}.
#* <strong>Răspuns</strong>:
#<strong> <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/lock_mutex" class="media mediafile mf_ wikilink2" title="so:2011-2012:lock_mutex">lock_mutex</a>} - încercarea de a obține un mutex inaccesibil trece procesul în starea <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/waiting" class="media mediafile mf_ wikilink2" title="so:2011-2012:waiting">waiting</a>} - </strong>DA<strong>
#</strong> <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/unlock_mutex" class="media mediafile mf_ wikilink2" title="so:2011-2012:unlock_mutex">unlock_mutex</a>} - la ieșirea din zona critică, procesele care așteptau la mutex vor trece din starea <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/waiting" class="media mediafile mf_ wikilink2" title="so:2011-2012:waiting">waiting</a>} în starea <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/ready" class="media mediafile mf_ wikilink2" title="so:2011-2012:ready">ready</a>} - <strong>DA</strong>
#<strong> <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/spin_lock_spinlock" class="media mediafile mf_ wikilink2" title="so:2011-2012:spin_lock_spinlock">spin_lock_spinlock</a>} - încercarea de a obține un spinlock inaccesibil nu trece procesul în starea <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/waiting" class="media mediafile mf_ wikilink2" title="so:2011-2012:waiting">waiting</a>} - </strong>NU<strong>
#</strong> <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/spin_unlock_spinlock" class="media mediafile mf_ wikilink2" title="so:2011-2012:spin_unlock_spinlock">spin_unlock_spinlock</a>} - la ieșirea din zona critică, procesul care aștepta la spinlock se va debloca, dar va rămâne în starea <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/running" class="media mediafile mf_ wikilink2" title="so:2011-2012:running">running</a>} - <strong>NU</strong>
#<strong> <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/down_semaphore" class="media mediafile mf_ wikilink2" title="so:2011-2012:down_semaphore">down_semaphore</a>} - încercarea de a obține un semafor inaccesibil trece procesul în starea <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/waiting" class="media mediafile mf_ wikilink2" title="so:2011-2012:waiting">waiting</a>} - </strong>DA<strong>
#</strong> <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/up_semaphore" class="media mediafile mf_ wikilink2" title="so:2011-2012:up_semaphore">up_semaphore</a>} - la ieșirea din zona critică, procesele care așteptau la semafor vor trece din starea <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/waiting" class="media mediafile mf_ wikilink2" title="so:2011-2012:waiting">waiting</a>} în starea <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/ready" class="media mediafile mf_ wikilink2" title="so:2011-2012:ready">ready</a>} - <strong>DA</strong>
# Dați exemplu de avantaj, respectiv dezavantaj al folosirii TLB.
#* <strong>Răspuns</strong>:
#<strong> Avantaj: TLB-ul este un cache rapid care menține mapări de pagini fizice și pagini virtuale. În cazul TLB hit, scade timpul de acces la memorie.
#</strong> Dezavantaje:
#<strong>* În cazul TLB miss, timpul de acces la memorie este mai mare decât timpul de acces în absența TLB-ului.
#</strong>* La fiecare schimbare de context se face TLB flush, astfel că vor exista mai multe miss-uri imediat după schimbarea de context.
#<strong>* Dimensiune mică și cost ridicat.

==== Lucrare 3 ====

  *24 aprilie, 09:05-09:15, EC004, seria CA
  *25 aprilie, 17:05-17:15, EC105, seria CC


==== 3CA, nr. 1 ====

# Motivați utilizarea <em>copy-on-write</em> în cadrul apelului <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/fork" class="media mediafile mf_ wikilink2" title="so:2011-2012:fork">fork</a>}.
#* </strong>Răspuns<strong>: Este utilă folosirea mecanismului de <em>copy-on-write</em> deoarece crearea unui nou proces se face mai rapid, evitând operațiile de copiere a memoriei. Foarte probabil, după <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/fork" class="media mediafile mf_ wikilink2" title="so:2011-2012:fork">fork</a>} copilul va face un apel <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/exec" class="media mediafile mf_ wikilink2" title="so:2011-2012:exec">exec</a>} pentru a lansa un program diferit. Astfel, dacă nu s-ar folosi <em>copy-on-write</em>, s-ar copia degeaba paginile din spațiul de adresă al părintelui.
# Dați 2 exemple de resurse partajate între <em>thread-urile</em> aceluiași proces.
#* </strong>Răspuns<strong>: <em>Thread-urile</em> aceluiași proces partajează descriptorii de fișier, spațiul de adrese (memoria), masca de semnale, deoarece acestea sunt resurse la nivel de proces, nu de thread.
##* Ele folosesc aceleași segmente de memorie <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/heap" class="media mediafile mf_ wikilink2" title="so:2011-2012:heap">heap</a>}, <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/data" class="media mediafile mf_ wikilink2" title="so:2011-2012:data">data</a>} și <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/bss" class="media mediafile mf_ wikilink2" title="so:2011-2012:bss">bss</a>}. (deci și variabilele stocate în ele)
# Fie un program multithreaded cu <em>user-level threads</em> care efectuează multe operații I/O per thread. Este mai eficientă folosirea operațiilor I/O blocante sau non-blocante?
#* </strong>Răspuns<strong>: Efectuarea unei operații blocante în cadrul unei implementări cu <em>user-level threads</em> va bloca întreg procesul, nu doar thread-ul curent. De aceea este mai eficientă folosirea operațiilor I/O non-blocante.

==== 3CA, nr. 2 ====

# Prezentați un avantaj și un dezavantaj al mapării fișierelor în memorie.
#* </strong>Răspuns<strong>:
##* Avantaje:
###* Se evită apelurile de sistem <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/read" class="media mediafile mf_ wikilink2" title="so:2011-2012:read">read</a>} și <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/write" class="media mediafile mf_ wikilink2" title="so:2011-2012:write">write</a>}, deci și <em>double-buffering-ul</em>.
###* Permite partajarea fișierelor între procese.
###* Nu mai este necesar apelul <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/lseek" class="media mediafile mf_ wikilink2" title="so:2011-2012:lseek">lseek</a>}, căutarea se realizează prin manipularea pointer-ilor.
##* Dezavantaje:
###* Maparea fișierelor în memorie se face la nivel de pagină, astfel că apare fragmentare, mai ales în cazul fișierelor mici.
###* Maparea trebuie să se încadreze în spațiul de adresă al procesului. Pe sisteme pe 32 de biți, sunt dificil de mapat fișiere mari.
###* Accesul la memorie determină apariția page fault-urilor.
###* Trebuie apelat periodic <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/msync" class="media mediafile mf_ wikilink2" title="so:2011-2012:msync">msync</a>}, deoarece modificările în memorie nu sunt scrise imediat pe disc.
# Dați 2 exemple de resurse care </strong>NU<strong> sunt partajate între <em>thread-urile</em> aceluiași proces.
#* </strong>Răspuns<strong>: Fiecare <em>thread</em> al unui proces are un context de execuție propriu, format din stivă și set de regiștri (deci și un contor de program - registrul (E)IP). De asemenea, TLS/TSD reprezintă variabile specifice unui <em>thread</em>, invizibile pentru celelalte <em>thread-uri</em>.
# Fie afirmația “Întreruperile pot fi folosite la fel de bine și pentru dispozitive care folosesc <em>memory-mapped I/O</em> și pe sisteme care folosesc <em>port-mapped I/O</em>”. Precizați și justificați valoarea de adevăr a afirmației.
#* </strong>Răspuns<strong>: Întreruperile sunt semnale folosite de către dispozitive pentru a semnala procesorului finalizarea unei operații de I/O. Acesta va salva starea curentă și va rula rutina de tratare a întreruperii. Utilizarea <em>memory-mapped I/O</em> sau a <em>port-mapped I/O</em> determină doar modul de adresare a dispozitivelor în cadrul rutinei de tratare, fără a afecta eficiența utilizării întreruperilor. Astfel, afirmația este adevărată.

==== 3CC, nr. 1 ====

# În ce situație folosirea funcției <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/memcpy" class="media mediafile mf_ wikilink2" title="so:2011-2012:memcpy">memcpy</a>} generează <em>page fault</em> și în ce situație nu generează <em>page fault</em>?
#* </strong>Răspuns<strong>: Funcția <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/memcpy" class="media mediafile mf_ wikilink2" title="so:2011-2012:memcpy">memcpy</a>} folosește două buffere: sursă și destinație. Fie <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/s" class="media mediafile mf_ wikilink2" title="so:2011-2012:s">s</a>} mulțimea paginilor în care se află bufferul sursă și <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/d" class="media mediafile mf_ wikilink2" title="so:2011-2012:d">d</a>} mulțimea paginilor în care se află bufferul destinație.
##* Folosirea funcției <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/memcpy" class="media mediafile mf_ wikilink2" title="so:2011-2012:memcpy">memcpy</a>} generează <em>page fault</em> în următoarele situații:
###* Cel puțin o pagină din <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/s" class="media mediafile mf_ wikilink2" title="so:2011-2012:s">s</a>} sau <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/d" class="media mediafile mf_ wikilink2" title="so:2011-2012:d">d</a>} este nevalidă. (nu a fost alocată în RAM, este pe swap sau un acces nevalid din partea programatorului)
###* Cel puțin o pagină din <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/d" class="media mediafile mf_ wikilink2" title="so:2011-2012:d">d</a>} este validă, dar nu sunt drepturi de scriere. (copy-on-write, mapare PROT_READ)
###* Cel puțin o pagină din <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/s" class="media mediafile mf_ wikilink2" title="so:2011-2012:s">s</a>} este validă, dar nu sunt drepturi de citire. (mapare PROT_NONE)
##* Folosirea funcției <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/memcpy" class="media mediafile mf_ wikilink2" title="so:2011-2012:memcpy">memcpy</a>} nu generează <em>page fault</em> dacă toate paginile din <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/s" class="media mediafile mf_ wikilink2" title="so:2011-2012:s">s</a>} sunt valide, cu drept de citire și dacă toate paginile din <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/d" class="media mediafile mf_ wikilink2" title="so:2011-2012:d">d</a>} sunt valide, cu drept de scriere.
# Dați exemplu de situație/aplicație în care este mai avantajos să se folosească un număr <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/x" class="media mediafile mf_ wikilink2" title="so:2011-2012:x">x</a>} de <em>kernel-level threads</em> într-un proces și o situație/aplicație în care este mai avantajos să se folosească un număr <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/y" class="media mediafile mf_ wikilink2" title="so:2011-2012:y">y</a>} de <em>kernel-level threads</em>, cu <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/x_y" class="media mediafile mf_ wikilink2" title="so:2011-2012:x_y">x_y</a>}. Ambele situații se vor raporta la același sistem dat.
#* </strong>Răspuns<strong>:
##* Este mai avantajos să se folosească un număr <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/x" class="media mediafile mf_ wikilink2" title="so:2011-2012:x">x</a>} (mai mic) de <em>kernel-level threads</em> într-un proces care execută operații CPU-intensive care folosesc puține apeluri blocante, deoarece utilizarea mai multor <em>kernel-level threads</em> ar însemna mai multe schimbări de context, care ar scădea performanța.
##* Este mai avantajos să se folosească un număr <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/y" class="media mediafile mf_ wikilink2" title="so:2011-2012:y">y</a>} (mai mare) de <em>kernel-level threads</em> într-un proces care este I/O-intensive, având multe apeluri blocante, permițând unui număr mai mare de thread-uri să și continue execuția în cazul blocării unui thread.
# Care este principala caracteristică a unui dispozitiv de tip caracter? Dați 2 exemple de astfel de dispozitive.
#* </strong>Răspuns<strong>: Dispozitivele de tip caracter oferă acces secvențial și transfer de date la nivel de caracter, astfel au viteză redusă.
##* Exemple: tastatură, mouse, game controller, port serial, terminal,

==== 3CC, nr. 2 ====

# Pe un sistem pe 32 de biți, cu 512MB RAM și 512MB de swap, un proces execută secvența următoare de cod:&lt;code c&gt;int x = read_int_from_user();
void *a = malloc(x);
memset(a, 0, x);&lt;/code&gt;La un curs de Sisteme de Operare, profesorul întreabă “Care este valoarea minimă a lui <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/x" class="media mediafile mf_ wikilink2" title="so:2011-2012:x">x</a>} pentru care apelul <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/malloc" class="media mediafile mf_ wikilink2" title="so:2011-2012:malloc">malloc</a>} întoarce un pointer valid, dar apelul <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/memset" class="media mediafile mf_ wikilink2" title="so:2011-2012:memset">memset</a>} duce la blocarea sistemului?”. Un student răspunde “1GB + 1B”. Profesorul răspunde “Cam pe acolo, dar valoarea reală este ceva mai mică”. De ce a spus profesorul acest lucru?
#* </strong>Răspuns<strong>: Apelul <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/malloc" class="media mediafile mf_ wikilink2" title="so:2011-2012:malloc">malloc</a>} folosește demand paging, alocând memorie pur virtuală, fără suport în memoria fizică. Apelul <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/memset" class="media mediafile mf_ wikilink2" title="so:2011-2012:memset">memset</a>} necesită alocarea de pagini fizice, astfel că sistemul se va bloca în momentul în care nu mai are pagini fizice disponibile. Sistemul are disponibil 1 <abbr title="Gigabyte">GB</abbr> memorie fizică (512MB RAM și 512MB de swap) astfel că studentul a considerat că se va bloca la ocuparea întregii memorii fizice (1GB + 1B). În realitate, sistemul se va bloca la o valoare “ceva mai mică”, deoarece în memoria fizică se află pagini de memorie ale kernelului, cât și ale altor procese.
# Prezentați un avantaj și un dezavantaj al folosirii <em>user-level threads</em> față de <em>kernel-level threads</em>.
#* </strong>Răspuns<strong>:
##* Avantaje :
###* schimbarea de context nu implică kernelul, deci vom avea comutare rapidă
###* planificarea poate fi aleasă de aplicație; aplicația poate folosi acea planificare care favorizează creșterea performanțelor
###* firele de execuție pot rula pe orice sistem de operare, inclusiv pe sisteme de operare care nu suportă fire de execuție la nivel kernel.
##* Dezavantaje :
###* kernel-ul nu știe de fire de execuție, astfel că dacă un fir de execuție face un apel blocant toate firele de execuție planificate de aplicație vor fi blocate
###* nu se pot utiliza la maximum resursele hardware: kernelul va vedea un singur fir de execuție și va planifica procesul respectiv pe maximum un procesor, chiar dacă aplicația ar avea mai multe fire de execuție planificabile în același timp.
# Care sunt cele două caracteristici importante ale unui dispozitiv de tip bloc? Dați 2 exemple de astfel de dispozitive.
#* </strong>Răspuns<strong>: Dispozitivele de tip bloc oferă acces aleator și transfer de date la nivel de bloc, astfel au o viteză ridicată.
##* Exemple: discuri (hard-disk, floppy, unități optice, unități flash), sisteme de fișiere, memoria RAM.


==== Lucrare 4 ====

  *15 mai, 09:05-09:15, EC004, seria CA
  *16 mai, 17:05-17:15, EC105, seria CC


==== 3CA, nr. 1 ====

# Care sunt <em>dentry-urile</em> existente în orice director pe un sistem de fișiere <em>ext2/3</em> și ce reprezintă acestea?
#* </strong>Răspuns<strong>: Orice director are intrările <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012" class="media mediafile mf_ wikilink2" title="so:2011-2012">2011-2012</a>} și <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012" class="media mediafile mf_ wikilink2" title="so:2011-2012">2011-2012</a>} care sunt <em>dentry-uri</em> către directorul curent, respectiv directorul părinte.
# De ce nu este recomandată folosirea OpenVZ pentru kernel development?
#* </strong>Răspuns<strong>: Deoarece OpenVZ este o soluție de virtualizare la nivel de kernel, însemnând că mașinile virtuale (containerele) partajează același kernel. În kernel development avem nevoie de o soluție de virtualizare în care putem găzdui un kernel separat astfel încât atunci când acesta este instabil să nu afecteze kernelul ce controlează mașina fizică.
# Un dezvoltator rezolvă problema de signed/unsigned comparison din secvența de cod de mai jos:&lt;code c&gt;int i;
unsigned int j;
…
if (i &lt; j)
     …&lt;/code&gt;astfel&lt;code c&gt;int i;
unsigned int j;
unsigned int k;
…
k = (unsigned int) i;
if (k &lt; j)
   …&lt;/code&gt;De ce nu este aceasta o soluție corespunzătoare?
#* </strong>Răspuns<strong>: Soluția propusă de către dezvoltator include un cast de la <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/int" class="media mediafile mf_ wikilink2" title="so:2011-2012:int">int</a>} la <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/unsigned_int" class="media mediafile mf_ wikilink2" title="so:2011-2012:unsigned_int">unsigned_int</a>}, care constă în adunarea valorii <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/uint_max_1" class="media mediafile mf_ wikilink2" title="so:2011-2012:uint_max_1">uint_max_1</a>} la valoarea lui <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/i" class="media mediafile mf_ wikilink2" title="so:2011-2012:i">i</a>}. Cel mai probabil <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/k" class="media mediafile mf_ wikilink2" title="so:2011-2012:k">k</a>} va avea o valoare foarte mare, astfel că nu se va intra pe ramura <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/if" class="media mediafile mf_ wikilink2" title="so:2011-2012:if">if</a>} a codului, dar <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/k" class="media mediafile mf_ wikilink2" title="so:2011-2012:k">k</a>} nu va putea face overflow, deoarece va fi reprezentat pe același număr de biți ca și <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/i" class="media mediafile mf_ wikilink2" title="so:2011-2012:i">i</a>}. Pentru mai multe informații, puteți consulta <a href="http://www.open-std.org/jtc1/sc22/WG14/www/docs/n1256.pdf" class="urlextern" title="http://www.open-std.org/jtc1/sc22/WG14/www/docs/n1256.pdf"  rel="nofollow"> standardul C99</a>, secțiunile 6.2.5 (9), 6.3.1.3, 6.3.1.8, 

==== 3CA, nr. 2 ====

# Prezentați un avantaj și un dezavantaj al utilizării sistemelor de fișiere jurnalizate.
#* </strong>Răspuns<strong>:
#</strong> Avantaj: menținerea unui log al acțiunilor făcute asupra sistemului de fișiere, log ce poate fi consultat în cazul unei defecțiuni și poate ajuta la recuperarea datelor afectate în timpul defecțiunii.
#<strong> Dezavantaj: este overhead-ul adus în procesare și spațiul pe suportul fizic consumat pentru menținerea jurnalului
# Pe două sisteme identice sunt folosite soluții de virtualizare diferite: VMware Workstation, respectiv OpenVZ. Pe care din cele două sisteme gazdă vor exista mai multe procese în cazul pornirii unei mașini virtuale?
#* </strong>Răspuns<strong>: În cazul VMware, sistemul de operare gazdă va vedea procesele sale plus un proces VMware sub care se ascund procesele mașinilor guest. În cazul OpenVZ, sistemul gazdă vede arborele cu procesele sale plus arborii fiecărui contianer OpenVZ.
# Ce reprezintă conceptul de ”<em>salt</em>” în securitate și la ce este folosit?
#* </strong>Răspuns<strong>: Conceptul de ”<em>salt</em>” se referă la o valoare (șir de biți, caractere) ce ajută la generarea mai eficientă a unui hash. <em>Salt-ul</em> ajută la mărirea entropiei hash-ului generat.

==== 3CC, nr. 1 ====

# Fie o implementare de <em>inode</em> care reține următoarele valori: permisiuni, număr de link-uri, uid, gid, dimensiune și zone directe. Fie fișierul ”<a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/a" class="media mediafile mf_ wikilink2" title="so:2011-2012:a">a</a>}” și un hard link către acesta, ”<a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/b" class="media mediafile mf_ wikilink2" title="so:2011-2012:b">b</a>}”. Prin ce diferă <em>inode-urile</em> celor două fișiere?
#* </strong>Răspuns<strong>: Un hard link reprezintă un nou dentry care referă același <em>inode</em>, deci <em>inode-urile</em> celor două fișiere sunt identice.
# Pe un sistem gazdă rulează 10 mașini virtuale care realizează numeroase copieri de fișiere între ele. Care soluție de virtualizare (Xen, OpenVZ, VMware Workstation) este mai eficientă în această situație și de ce?
#* </strong>Răspuns<strong>: Deoarece OpenVZ este o soluție de virtualizare la nivel de kernel, containerele OpenVZ partajează același kernel și același sistem de fișiere astfel că, în OpenVZ, se pot copia ușor fișiere dintr-un container în altul. În cazul Xen sau VMware Workstation este necesară trecerea prin două spații kernel (al mașinilor virtuale sursă și destinație) și prin hipervizor. 
# De ce este considerată funcția <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/memcpy" class="media mediafile mf_ wikilink2" title="so:2011-2012:memcpy">memcpy</a>} mai “sigură” decât funcția <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/strcpy" class="media mediafile mf_ wikilink2" title="so:2011-2012:strcpy">strcpy</a>}?
#* </strong>Răspuns<strong>: Deoarece funcția <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/memcpy" class="media mediafile mf_ wikilink2" title="so:2011-2012:memcpy">memcpy</a>} specifică dimensiunea buffer-ului care trebuie copiat, în timp ce <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/strcpy" class="media mediafile mf_ wikilink2" title="so:2011-2012:strcpy">strcpy</a>} presupune că buffer-ele sunt alocate cum trebuie, astfel încât <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/strlen_sursa_sizeof_dest" class="media mediafile mf_ wikilink2" title="so:2011-2012:strlen_sursa_sizeof_dest">strlen_sursa_sizeof_dest</a>}.

==== 3CC, nr. 2 ====

# Pe un sistem se dorește conservarea numărului de <em>inode-uri</em>. Care din cele două tipuri de link-uri, <em>hard</em> sau <em>sym</em>, trebuie folosite în acest caz și de ce?
#* </strong>Răspuns<strong>: Un hard link nu generează <em>inode-uri</em> noi, pe când un sym link este un <em>inode</em> nou, astfel că trebuie folosite hard link-uri.
# Care dintre variantele VMware Workstation, respectiv OpenVZ oferă un grad mai mare de securitate și de ce?
#* </strong>Răspuns<strong>: VMware Workstation oferă un grad mai mare de securitate, deoarece este o soluție de full virtualization, însemnând o izolare completă între mașini. În OpenVZ se partajează nucleul și coruperea sa într-o mașină duce la compromiterea întregului sistem.
# Completați zona punctată a următoarei secvențe de cod cu un apel de bibliotecă, astfel încât:
#* a) programul să fie vulnerabil la stack smashing;
#* b) programul să nu fie vulnerabil la stack smashing.
#* Motivați alegerile făcute.&lt;code c&gt;#define INPUT “1234”
int main(void)
{
       char a[2];
       memcpy(a, INPUT, …);
       return 0;
}&lt;/code&gt;
#* </strong>Răspuns<strong>: Pentru ca programul să fie vulnerabil la stack smashing, trebuie să permită copierea unui număr de octeți independent de dimensiunea buffer-ului destinație. Pentru ca programul să nu fie vulnerabil, trebuie să permită copierea unui număr de octeți mai mare decât dimensiunea buffer-ului destinație.
#</strong> a) Apeluri de bibliotecă: <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/strlen_input" class="media mediafile mf_ wikilink2" title="so:2011-2012:strlen_input">strlen_input</a>}, <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/sizeof_input" class="media mediafile mf_ wikilink2" title="so:2011-2012:sizeof_input">sizeof_input</a>}, etc.
#** b) Apeluri de bibliotecă: <a href="http://ocw.cs.pub.ro/courses/_media/so/2011-2012/sizeof_a" class="media mediafile mf_ wikilink2" title="so:2011-2012:sizeof_a">sizeof_a</a>}, etc.
</p>

</div>
<!-- EDIT8 SECTION "3CC, nr. 2" [6072-28991] -->
<h2 class="sectionedit9" id="examene_anterioare">Examene anterioare</h2>
<div class="level2">

</div>
<!-- EDIT9 SECTION "Examene anterioare" [28992-] --></div>
</body>
</html>
