    
    

<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
  <meta charset="utf-8" />
  <title>so:examen:2010-2011</title>
<meta name="generator" content="DokuWiki"/>
<meta name="robots" content="index,follow"/>
<meta name="date" content="2013-01-31T21:57:00+0200"/>
<meta name="keywords" content="so,examen,2010-2011"/>
<link rel="search" type="application/opensearchdescription+xml" href="../../../../lib/exe/opensearch.php" title="CS Open CourseWare"/>
<link rel="start" href="../../../../../courses.1.html"/>
<link rel="alternate" type="application/rss+xml" title="Recent Changes" href="../../../../feed.php"/>
<link rel="alternate" type="application/rss+xml" title="Current Namespace" href="../../../../feed.php%3Fmode=list&amp;ns=so:examen"/>
<link rel="alternate" type="text/html" title="Plain HTML" href="2010-2011.html"/>
<link rel="canonical" href="../../../../so/examen/2010-2011.html"/>
<link rel="stylesheet" type="text/css" href="../../../../lib/exe/css.php%3Ft=arctic&amp;tseed=1479898000.css"/>
<script type="text/javascript">/*<![CDATA[*/var NS='so:examen';var JSINFO = {"id":"so:examen:2010-2011","namespace":"so:examen","isadmin":0,"isauth":0};
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="../../../../lib/exe/js.php%3Ftseed=1479898000"></script>
<script type="text/x-mathjax-config">/*<![CDATA[*/MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ["$","$"], ["\\(","\\)"] ],
        displayMath: [ ["$$","$$"], ["\\[","\\]"] ],
        processEscapes: true
    }
});
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
<script type="text/javascript">/*<![CDATA[*/
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
		  
/*!]]>*/</script>
<script type="text/javascript">/*<![CDATA[*/
var pageTracker = _gat._getTracker("UA-38383934-1");
pageTracker._initData();
pageTracker._trackPageview();
		  
/*!]]>*/</script>
</head>
<body>
<div class="dokuwiki export">
<!-- TOC START -->
<div id="dw__toc">
<h3 class="toggle">Table of Contents</h3>
<div>

<ul class="toc">
<li class="level1"><div class="li"><a href="2010-2011.html#examene_si_lucrari_2010-2011">Examene și lucrări 2010-2011</a></div>
<ul class="toc">
<li class="level2"><div class="li"><a href="2010-2011.html#examen_restanta">Examen restanță</a></div></li>
<li class="level2"><div class="li"><a href="2010-2011.html#examen_final">Examen final</a></div></li>
<li class="level2"><div class="li"><a href="2010-2011.html#lucrari">Lucrări</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="2010-2011.html#lucrare_1">Lucrare 1</a></div></li>
<li class="level3"><div class="li"><a href="2010-2011.html#ca_nr_1">3CA, nr. 1</a></div></li>
<li class="level3"><div class="li"><a href="2010-2011.html#ca_nr_2">3CA, nr. 2</a></div></li>
<li class="level3"><div class="li"><a href="2010-2011.html#cc_nr_2">3CC, nr. 2</a></div></li>
<li class="level3"><div class="li"><a href="2010-2011.html#lucrare_3">Lucrare 3</a></div></li>
<li class="level3"><div class="li"><a href="2010-2011.html#ca_nr_11">3CA, nr. 1</a></div></li>
<li class="level3"><div class="li"><a href="2010-2011.html#ca_nr_21">3CA, nr. 2</a></div></li>
<li class="level3"><div class="li"><a href="2010-2011.html#cc_nr_1">3CC, nr. 1</a></div></li>
<li class="level3"><div class="li"><a href="2010-2011.html#cc_nr_21">3CC, nr. 2</a></div></li>
<li class="level3"><div class="li"><a href="2010-2011.html#cc_nr_11">3CC, nr. 1</a></div></li>
<li class="level3"><div class="li"><a href="2010-2011.html#cc_nr_22">3CC, nr. 2</a></div></li>
</ul></li>
</ul></li>
</ul>
</div>
</div>
<!-- TOC END -->

<h1 class="sectionedit1" id="examene_si_lucrari_2010-2011">Examene și lucrări 2010-2011</h1>
<div class="level1">

</div>
<!-- EDIT1 SECTION "Examene și lucrări 2010-2011" [1-46] -->
<h2 class="sectionedit2" id="examen_restanta">Examen restanță</h2>
<div class="level2">
<ul>
<li class="level1"><div class="li">5 septembrie 2011 ( <a href="http://elf.cs.pub.ro/so/res/old-res/2010-2011/examen/2011/SO_2010-2011_examen_05_septembrie.pdf" class="urlextern" title="http://elf.cs.pub.ro/so/res/old-res/2010-2011/examen/2011/SO_2010-2011_examen_05_septembrie.pdf"  rel="nofollow"> foaie examen</a> )</div>
</li>
<li class="level1"><div class="li">12 septembrie 2011 ( <a href="http://elf.cs.pub.ro/so/res/old-res/2010-2011/examen/2011/SO_2010-2011_examen_12_septembrie.pdf" class="urlextern" title="http://elf.cs.pub.ro/so/res/old-res/2010-2011/examen/2011/SO_2010-2011_examen_12_septembrie.pdf"  rel="nofollow"> foaie examen</a> )</div>
</li>
</ul>

</div>
<!-- EDIT2 SECTION "Examen restanță" [47-359] -->
<h2 class="sectionedit3" id="examen_final">Examen final</h2>
<div class="level2">
<ul>
<li class="level1"><div class="li">27 mai 2011 ( <a href="http://elf.cs.pub.ro/so/res/old-res/2010-2011/examen/2011/SO_2010-2011_examen_27_mai.pdf" class="urlextern" title="http://elf.cs.pub.ro/so/res/old-res/2010-2011/examen/2011/SO_2010-2011_examen_27_mai.pdf"  rel="nofollow"> foaie examen</a> )</div>
</li>
<li class="level1"><div class="li">30 mai 2011 ( <a href="http://elf.cs.pub.ro/so/res/old-res/2010-2011/examen/2011/SO_2010-2011_examen_30_mai.pdf" class="urlextern" title="http://elf.cs.pub.ro/so/res/old-res/2010-2011/examen/2011/SO_2010-2011_examen_30_mai.pdf"  rel="nofollow"> foaie examen</a> )</div>
</li>
<li class="level1"><div class="li">9 iunie 2011 ( <a href="http://elf.cs.pub.ro/so/res/old-res/2010-2011/examen/2011/SO_2010-2011_examen_09_iunie.pdf" class="urlextern" title="http://elf.cs.pub.ro/so/res/old-res/2010-2011/examen/2011/SO_2010-2011_examen_09_iunie.pdf"  rel="nofollow"> foaie examen</a> )</div>
</li>
<li class="level1"><div class="li">10 iunie 2011 ( <a href="http://elf.cs.pub.ro/so/res/old-res/2010-2011/examen/2011/SO_2010-2011_examen_10_iunie.pdf" class="urlextern" title="http://elf.cs.pub.ro/so/res/old-res/2010-2011/examen/2011/SO_2010-2011_examen_10_iunie.pdf"  rel="nofollow"> foaie examen</a> )</div>
</li>
</ul>

</div>
<!-- EDIT3 SECTION "Examen final" [360-901] -->
<h2 class="sectionedit4" id="lucrari">Lucrări</h2>
<div class="level2">

</div>
<!-- EDIT4 SECTION "Lucrări" [902-923] -->
<h3 class="sectionedit5" id="lucrare_1">Lucrare 1</h3>
<div class="level3">
<ul>
<li class="level1"><div class="li">8 martie, 09:05-09:15, EC004, seria CA</div>
</li>
<li class="level1"><div class="li">9 martie, 17:05-17:15, EC105, seria CC</div>
</li>
</ul>

</div>
<!-- EDIT5 SECTION "Lucrare 1" [924-1029] -->
<h3 class="sectionedit6" id="ca_nr_1">3CA, nr. 1</h3>
<div class="level3">

<p>
# Dați exemplu de două apeluri care modifică valoarea cursorului de fișier (file pointer).
#* <strong>Răspuns</strong>:
#<strong> <a href="http://ocw.cs.pub.ro/courses/_media/so/examen/lseek" class="media mediafile mf_ wikilink2" title="so:examen:lseek">lseek</a>}/<a href="http://ocw.cs.pub.ro/courses/_media/so/examen/fseek" class="media mediafile mf_ wikilink2" title="so:examen:fseek">fseek</a>}, apeluri al căror rol este de modificare a cursorului de fișier;
#</strong> read/fread/fgets – la fiecare citire cursorul de fișier este incrementat cu numărul de octeți citiți;
#<strong> write/fwrite/fputs/fprints – la fiecare scriere cursorul de fișier este incrementat cu numărul de octeți scriși;
#</strong> ftruncate – trunchiază fișierul (cursorul este plasat pe 0);
#<strong> apelurile echivalante Windows.
# Care dintre următoarele apeluri durează cel mai mult: <a href="http://ocw.cs.pub.ro/courses/_media/so/examen/strcpy" class="media mediafile mf_ wikilink2" title="so:examen:strcpy">strcpy</a>}, <a href="http://ocw.cs.pub.ro/courses/_media/so/examen/strdup" class="media mediafile mf_ wikilink2" title="so:examen:strdup">strdup</a>}, <a href="http://ocw.cs.pub.ro/courses/_media/so/examen/strchr" class="media mediafile mf_ wikilink2" title="so:examen:strchr">strchr</a>}?
#* </strong>Răspuns<strong>: strcpy copiază șirul iar strchr caută un caracter în șir; strdup realizează operație similară strcpy dar, în plus, alocă spațiu pentru noul șir, operație costisitoare ce poate însemna și efectuarea unui apel de sistem. În concluzie, strdup durează, în general, cel mai mult.
# Care dintre următoarele apeluri au legătură directă cu procesele </strong>zombie<strong>: <a href="http://ocw.cs.pub.ro/courses/_media/so/examen/fork" class="media mediafile mf_ wikilink2" title="so:examen:fork">fork</a>}, <a href="http://ocw.cs.pub.ro/courses/_media/so/examen/dup" class="media mediafile mf_ wikilink2" title="so:examen:dup">dup</a>}, <a href="http://ocw.cs.pub.ro/courses/_media/so/examen/wait" class="media mediafile mf_ wikilink2" title="so:examen:wait">wait</a>}, <a href="http://ocw.cs.pub.ro/courses/_media/so/examen/exec" class="media mediafile mf_ wikilink2" title="so:examen:exec">exec</a>}, <a href="http://ocw.cs.pub.ro/courses/_media/so/examen/malloc" class="media mediafile mf_ wikilink2" title="so:examen:malloc">malloc</a>}?
#* </strong>Răspuns<strong>: Un proces zombie este un proces care a murit dar care nu a fost așteptat (wait) de procesul părinte; informațiile legate de încheiere ocupă spațiu în memorie până la un apel <a href="http://ocw.cs.pub.ro/courses/_media/so/examen/wait" class="media mediafile mf_ wikilink2" title="so:examen:wait">wait</a>}/<a href="http://ocw.cs.pub.ro/courses/_media/so/examen/waitpid" class="media mediafile mf_ wikilink2" title="so:examen:waitpid">waitpid</a>}/<a href="http://ocw.cs.pub.ro/courses/_media/so/examen/waitforsingleobject" class="media mediafile mf_ wikilink2" title="so:examen:waitforsingleobject">waitforsingleobject</a>} al procesului părinte. Apelul <a href="http://ocw.cs.pub.ro/courses/_media/so/examen/wait" class="media mediafile mf_ wikilink2" title="so:examen:wait">wait</a>} are, așadar, legătură directă cu procesele zombie.

==== 3CA, nr. 2 ====

# Ce valoare întoarce <a href="http://ocw.cs.pub.ro/courses/_media/so/examen/fork" class="media mediafile mf_ wikilink2" title="so:examen:fork">fork</a>} în procesul părinte? Dar în procesul copil? De ce?
#* </strong>Răspuns<strong>: În procesul copil întoarce 0 pentru că procesul poate folosi apelul <a href="http://ocw.cs.pub.ro/courses/_media/so/examen/getppid" class="media mediafile mf_ wikilink2" title="so:examen:getppid">getppid</a>} pentru a afla PID-ul procesul părinte. În procesul părinte, <a href="http://ocw.cs.pub.ro/courses/_media/so/examen/fork" class="media mediafile mf_ wikilink2" title="so:examen:fork">fork</a>} întoarce PID-ul procesului copil. Un proces poate avea mai multe procese copil și este comod ca <a href="http://ocw.cs.pub.ro/courses/_media/so/examen/fork" class="media mediafile mf_ wikilink2" title="so:examen:fork">fork</a>} să întoarcă PID-ul procesului copil proaspăt creat.
# Unde este poziționat cursorul de fișier în urma apelului:&lt;code c&gt;
   open(“a.txt”, O_CREAT | O_RDWR, 0644);
&lt;/code&gt;Dar în urma apelului:&lt;code&gt;
   open(“a.txt”, O_RDWR | O_TRUNC);
&lt;/code&gt;Se presupune că apelurile se întorc cu succes.
#* </strong>Răspuns<strong>: De fiecare dată cursorul este plasat la începutul fișierului: în prima situație se va începe citirea/scrierea de la începutul fișierului; în a doua situație fișierul este trunchiat și cursorul se află la început. Singura situație în care cursorul este plasat altundeva în momentul deschiderii acestuia este aceea în care se folosește flag-ul <a href="http://ocw.cs.pub.ro/courses/_media/so/examen/o_append" class="media mediafile mf_ wikilink2" title="so:examen:o_append">o_append</a>}.
# Câți descriptori de fișier ai unui proces pot referi, la un moment dat, ieșirea standard (standard output)?
#* </strong>Răspuns<strong>: Oricâți, în limita dimensiunii tabelei de descriptori de fișier a procesului, prin intermediul folosirii apelului <a href="http://ocw.cs.pub.ro/courses/_media/so/examen/dup" class="media mediafile mf_ wikilink2" title="so:examen:dup">dup</a>}/<a href="http://ocw.cs.pub.ro/courses/_media/so/examen/dup2" class="media mediafile mf_ wikilink2" title="so:examen:dup2">dup2</a>}:&lt;code&gt;
for (i = 3; i &lt; getdtablesize(); i++)
        dup2(1, i);
&lt;/code&gt;

==== 3CC, nr. 1 ====

# Care dintre următoarele apeluri întoarce un întreg: <a href="http://ocw.cs.pub.ro/courses/_media/so/examen/open" class="media mediafile mf_ wikilink2" title="so:examen:open">open</a>}, <a href="http://ocw.cs.pub.ro/courses/_media/so/examen/read" class="media mediafile mf_ wikilink2" title="so:examen:read">read</a>}, <a href="http://ocw.cs.pub.ro/courses/_media/so/examen/malloc" class="media mediafile mf_ wikilink2" title="so:examen:malloc">malloc</a>}, <a href="http://ocw.cs.pub.ro/courses/_media/so/examen/fopen" class="media mediafile mf_ wikilink2" title="so:examen:fopen">fopen</a>}?
#* </strong>Răspuns<strong>: 
#</strong> open întoarce un file descriptor (întreg) – <strong>DA</strong>
#<strong> read întoarce numărul de octeți citiți (întreg) – </strong>DA<strong>
#</strong> malloc întoarce adresa de memorie alocată (pointer) – <strong>NU</strong>
#<strong> fopen întoarce FILE * (un pointer) – </strong>NU<strong>
# În ce situație modificarea cursorului de fișier pentru un descriptor conduce la modificarea cursorului de fișier pentru alt descriptor?
#* </strong>Răspuns<strong>:  în cazul în care unul dintre descriptori este un duplicat al altui descriptor; amândoi vor partaja descriptorul de fișier
# Un descriptor de fișier pentru un proces dat poate referi între <a href="http://ocw.cs.pub.ro/courses/_media/so/examen/x" class="media mediafile mf_ wikilink2" title="so:examen:x">x</a>} și <a href="http://ocw.cs.pub.ro/courses/_media/so/examen/y" class="media mediafile mf_ wikilink2" title="so:examen:y">y</a>} fișiere. Ce valori au <a href="http://ocw.cs.pub.ro/courses/_media/so/examen/x" class="media mediafile mf_ wikilink2" title="so:examen:x">x</a>} și <a href="http://ocw.cs.pub.ro/courses/_media/so/examen/y" class="media mediafile mf_ wikilink2" title="so:examen:y">y</a>}?
#* </strong>Răspuns<strong>: X = 0 în cazul în care descriptorul este nevalid/nealocat; Y = 1 – un descriptor de fișier referă un singur fișier; nu poate să refere mai multe fișiere

==== 3CC, nr. 2 ====

# Un proces poate avea între <a href="http://ocw.cs.pub.ro/courses/_media/so/examen/a" class="media mediafile mf_ wikilink2" title="so:examen:a">a</a>} și <a href="http://ocw.cs.pub.ro/courses/_media/so/examen/b" class="media mediafile mf_ wikilink2" title="so:examen:b">b</a>} procese copil și între <a href="http://ocw.cs.pub.ro/courses/_media/so/examen/c" class="media mediafile mf_ wikilink2" title="so:examen:c">c</a>} și <a href="http://ocw.cs.pub.ro/courses/_media/so/examen/d" class="media mediafile mf_ wikilink2" title="so:examen:d">d</a>} procese părinte. Ce valori au (<a href="http://ocw.cs.pub.ro/courses/_media/so/examen/a" class="media mediafile mf_ wikilink2" title="so:examen:a">a</a>}, <a href="http://ocw.cs.pub.ro/courses/_media/so/examen/b" class="media mediafile mf_ wikilink2" title="so:examen:b">b</a>}) respectiv (<a href="http://ocw.cs.pub.ro/courses/_media/so/examen/c" class="media mediafile mf_ wikilink2" title="so:examen:c">c</a>}, <a href="http://ocw.cs.pub.ro/courses/_media/so/examen/d" class="media mediafile mf_ wikilink2" title="so:examen:d">d</a>})?
#* </strong>Răspuns<strong>:
#</strong> (A, B) = (0, inf) - un proces poate avea oricâte procese copil, în limita resurselor disponibile
#<strong> (C, D) = (1, 1) - orice proces copil are un proces părinte, se poate considera init ca proces fără proces părinte; se permite soluția (C, D) = (0, 1) (dacă se precizează init)
# Un apel de bibliotecă (libc) poate invoca între <a href="http://ocw.cs.pub.ro/courses/_media/so/examen/x" class="media mediafile mf_ wikilink2" title="so:examen:x">x</a>} și <a href="http://ocw.cs.pub.ro/courses/_media/so/examen/y" class="media mediafile mf_ wikilink2" title="so:examen:y">y</a>} apeluri de sistem. Ce valori au <a href="http://ocw.cs.pub.ro/courses/_media/so/examen/x" class="media mediafile mf_ wikilink2" title="so:examen:x">x</a>} și <a href="http://ocw.cs.pub.ro/courses/_media/so/examen/y" class="media mediafile mf_ wikilink2" title="so:examen:y">y</a>}?
#* </strong>Răspuns<strong>: (X, Y) = (0, inf) poate să nu invoce nici un apel de sistem (vezi strcpy) sau mai multe apeluri de sistem (teoretic infinite); nu există o limitare pentru ca un apel de bibliotecă să apeleze mai multe apeluri de sistem (sau foarte multe), doar că nu este ceva comun.
# Listați secvența de pseudocod prin care scrierea la descriptorul 1 al unui proces să realizeze afișarea la stderr iar scrierea la descriptorul 2 să realizeze afișarea la stdout.
#* </strong>Răspuns<strong>:&lt;code&gt;
dup2(1, 3);
dup2(2, 1);
dup2(3, 2);
&lt;/code&gt;

==== Lucrare 2 ====

  *29 martie, 09:05-09:15, EC004, seria CA
  *30 martie, 17:05-17:15, EC105, seria CC

==== 3CA, nr. 1 ====

# Câte procese se pot găsi, la un moment dat, într-un sistem de operare, în stările <a href="http://ocw.cs.pub.ro/courses/_media/so/examen/running" class="media mediafile mf_ wikilink2" title="so:examen:running">running</a>}, <a href="http://ocw.cs.pub.ro/courses/_media/so/examen/ready" class="media mediafile mf_ wikilink2" title="so:examen:ready">ready</a>} și <a href="http://ocw.cs.pub.ro/courses/_media/so/examen/waiting" class="media mediafile mf_ wikilink2" title="so:examen:waiting">waiting</a>}?
#* </strong>Răspuns<strong>:
#</strong> În starea <a href="http://ocw.cs.pub.ro/courses/_media/so/examen/running" class="media mediafile mf_ wikilink2" title="so:examen:running">running</a>} se găsesc procesele care execută cod pe procesor. Numărul maxim de procese în acea stare este dat de numărul de procesoare.
#<strong> În starea <a href="http://ocw.cs.pub.ro/courses/_media/so/examen/ready" class="media mediafile mf_ wikilink2" title="so:examen:ready">ready</a>}, respectiv <a href="http://ocw.cs.pub.ro/courses/_media/so/examen/waiting" class="media mediafile mf_ wikilink2" title="so:examen:waiting">waiting</a>} se pot găsi oricâte procese în limita resurselor sistemului. În <a href="http://ocw.cs.pub.ro/courses/_media/so/examen/ready" class="media mediafile mf_ wikilink2" title="so:examen:ready">ready</a>} se vor găsi procese gata de rulare, neblocate, care așteaptă acordarea de timp pe procesor; în starea <a href="http://ocw.cs.pub.ro/courses/_media/so/examen/waiting" class="media mediafile mf_ wikilink2" title="so:examen:waiting">waiting</a>} se vor găsi procese blocate în așteptarea unei acțiuni de blocare (dispozitiv de I/O, semafoare cozi de mesaje). Nu există o limitare dată pentru procesele din starea <a href="http://ocw.cs.pub.ro/courses/_media/so/examen/ready" class="media mediafile mf_ wikilink2" title="so:examen:ready">ready</a>} sau <a href="http://ocw.cs.pub.ro/courses/_media/so/examen/waiting" class="media mediafile mf_ wikilink2" title="so:examen:waiting">waiting</a>}.
# Se poate implementa un semafor folosind </strong>doar<strong> mutex-uri? Dar un mutex folosind </strong>doar<strong> semafoare?
#* </strong>Răspuns<strong>:
#</strong> Un mutex se poate implementa ca un semafor binar. Răspuns afirmativ la a doua întrebare.
#<strong> (Mulțumim lui Răzvan Pistolea pentru observație) Pentru implementarea unui semafor cu mutex-uri, este nevoie de un mutex care să îndeplinească rolul unei variabile condiție (pentru notificare). În acest caz, trebuie ca acel mutex să nu poată fi incrementat de două ori (adică să se apeleze release de două ori). În plus, trebuie asigurată sincronizarea corespunzătoare, pentru a preveni condițiile de cursă, precum două thread-uri care trec de semafor în momentul în care valoarea acestuia este 1.
#</strong>* Mai multe exemple sunt prezentate <a href="http://webhome.csc.uvic.ca/~mcheng/460/notes/gensem.pdf" class="urlextern" title="http://webhome.csc.uvic.ca/~mcheng/460/notes/gensem.pdf"  rel="nofollow"> aici</a>.
# Dați exemplu de avantaj, respectiv dezavantaj al paginării ierarhice în fața paginării simple (neierarhice).
#* <strong>Răspuns</strong>:
#<strong> Avantaj: paginarea ierarhică ocupă mai puțin spațiu; se ocupă spațiu doar pentru zonele de memorie virtuale valide. În cazul paginării simple, tabela de pagini ocupă același spațiu indiferent de numărul de pagini virtuale valide.
#</strong> Dezavataje:
#<strong>* overhead de prelucrare mai mare (trebuie parcurse mai multe tabele de pagini, mai multe referențieri);
#</strong>* complexitate mai mare de implementare (împărțire mai fină a unei adrese de memorie).
</p>

</div>
<!-- EDIT6 SECTION "3CA, nr. 1" [1030-8554] -->
<h3 class="sectionedit7" id="ca_nr_2">3CA, nr. 2</h3>
<div class="level3">

<p>
# Pentru un sistem se dorește productivitate (throughput) mare. De ce se preferă alegerea unei cuante de timp (timeslice) mare pentru procese?
#* <strong>Răspuns</strong>:
#<strong> Productivitate mare înseamnă un timp mare consumat pe lucru efectiv (rulare pe procesor) pe lângă timpi consumați pentru alte activități, cea mai importantă fiind schimabrea de context.
#</strong> În cazul unei cuante de timp mari, proceselor vor lucra timp îndelungat iar timpul consumat pe schimbarea de context (apărută la expirarea cuantei) va fi mai mic, relativ.
# Fie un sistem cu două procesoare. Câte procese pot <em>“aștepta”</em> simultan eliberarea unui spinlock? Dar a unui mutex?
#* <strong>Răspuns</strong>:
#<strong> La un mutex pot aștepta oricâte procese. Dacă mutexul este achiziționat, procesele se blochează și trec în starea <a href="http://ocw.cs.pub.ro/courses/_media/so/examen/waiting" class="media mediafile mf_ wikilink2" title="so:examen:waiting">waiting</a>}. Pot exista oricâte procese în starea <a href="http://ocw.cs.pub.ro/courses/_media/so/examen/waiting" class="media mediafile mf_ wikilink2" title="so:examen:waiting">waiting</a>}.
#</strong> Dacă un proces a achiziționat un spinlock, cel mult un alt proces poate <em>“aștepta”</em> (busy waiting) așteptarea acestuia pe un alt procesor. Dacă cele două procese (ce rulează pe procesor) au ajuns la un livelock (ambele așteaptă la spinlock) sistemul este “agățat”; ambele așteaptă în acel moment la spinlock.
#<strong>* Un proces care deține un spinlock nu va fi planificat pentru că atunci alte procese ar aștepta nedefinit și sistemul devine instabil. Un spinlock protejează o zonă scurtă și rapidă. De asemenea, un proces care <em>“așteaptă”</em> la un spinlock nu va fi preemptat pentru că așteptarea este că va aștepta puțin la procesor (prin busy waiting).
#</strong>* În concluzie, pe un sistem cu două procesoare, eliberarea unui spinlock poate fi așteptată de cel mult două procese.
# Fie un sistem cu paginare simplă (neierarhică). Pot două pagini de memorie virtuală referi aceeași pagină de memorie fizică? Dar invers?
#* <strong>Răspuns</strong>:
#<strong> Da, două pagini de memorie virtuală pot referi aceeași pagină.
#</strong>* În această situație, în cadrul unui proces, în tabela de pagini, unor intrări diferite (indexate de pagina virtuală A și pagina virtuală B) le corespunde aceeași pagină fizică.
#<strong>* În cazul a două procese este vorba de implementarea mecanismului de shared memory.
#</strong> Nu, două pagini de memorie fizică nu pot referi aceeași pagină virtuală. Adresa virtuală este cea folosită de proces. O astfel de adresă nu poate indica spre două adrese fizice diferite. Este similar cu a spune că <a href="http://ocw.cs.pub.ro/courses/_media/so/examen/f_x_a" class="media mediafile mf_ wikilink2" title="so:examen:f_x_a">f_x_a</a>} și <a href="http://ocw.cs.pub.ro/courses/_media/so/examen/f_x_b" class="media mediafile mf_ wikilink2" title="so:examen:f_x_b">f_x_b</a>}, unde <a href="http://ocw.cs.pub.ro/courses/_media/so/examen/a_b" class="media mediafile mf_ wikilink2" title="so:examen:a_b">a_b</a>}.
#<strong> Nu are relevanță folosirea paginării simple. Afirmațiile sunt valabile pentru orice tip de paginare: ierarhică, neierarhică, inversată.

==== 3CC, nr. 1 ====

# Dați exemplu de acțiune ce conduce la trecerea unui proces din starea <a href="http://ocw.cs.pub.ro/courses/_media/so/examen/ready" class="media mediafile mf_ wikilink2" title="so:examen:ready">ready</a>} în <a href="http://ocw.cs.pub.ro/courses/_media/so/examen/running" class="media mediafile mf_ wikilink2" title="so:examen:running">running</a>} și un exemplu care conduce la o trecere inversă.
#* </strong>Răspuns<strong>:
#</strong> Un proces trece din starea <a href="http://ocw.cs.pub.ro/courses/_media/so/examen/running" class="media mediafile mf_ wikilink2" title="so:examen:running">running</a>} în <a href="http://ocw.cs.pub.ro/courses/_media/so/examen/ready" class="media mediafile mf_ wikilink2" title="so:examen:ready">ready</a>} în momentul în care i-a expirat cuanta de timp sau când există un alt proces prioritar lui în coada <a href="http://ocw.cs.pub.ro/courses/_media/so/examen/ready" class="media mediafile mf_ wikilink2" title="so:examen:ready">ready</a>}.
#<strong>* Observație: Blocarea procesului conduce la trecerea acestuia în coada <a href="http://ocw.cs.pub.ro/courses/_media/so/examen/waiting" class="media mediafile mf_ wikilink2" title="so:examen:waiting">waiting</a>}, iar omorârea procesului înseamnă că acesta nu trece în nici o altă coadă.
#</strong> Un proces trece din <a href="http://ocw.cs.pub.ro/courses/_media/so/examen/ready" class="media mediafile mf_ wikilink2" title="so:examen:ready">ready</a>} în <a href="http://ocw.cs.pub.ro/courses/_media/so/examen/running" class="media mediafile mf_ wikilink2" title="so:examen:running">running</a>} în momentul în care se găsește în vârful cozii <a href="http://ocw.cs.pub.ro/courses/_media/so/examen/ready" class="media mediafile mf_ wikilink2" title="so:examen:ready">ready</a>} și procesului care rulează pe procesor (cel din starea <a href="http://ocw.cs.pub.ro/courses/_media/so/examen/running" class="media mediafile mf_ wikilink2" title="so:examen:running">running</a>}) îi expiră cuanta, sau are prioritate mai mică, sau acel proces se blochează sau acel proces moare.
# Este nevoie de folosirea unui mecanism de sincronizare la folosirea memoriei partajate? Dar la folosirea cozilor de mesaje?
#* <strong>Răspuns</strong>:
#<strong> Da, la memoria partajată. Două (sau mai multe procese) pot decide să scrie în memorie partajată și pot rezulta date incorecte. Este nevoie de protejarea prin folosirea unui mecanism de locking.
#</strong> În cazul folosirii cozilor de mesaje nu este nevoie de folosirea unui mecanism de sincronizare. Aceasta deoarece operațiile pe cozile de mesaje sunt atomice și serializate.
#<strong>* Scrierea unui mesaj se face după altă scriere, iar citirea unui mesaj se realizează în momentul în care un mesaj există deja în coadă (altfel se blochează în așteptare). Nu este necesară folosirea unei forme de utilizare de genul <a href="http://ocw.cs.pub.ro/courses/_media/so/examen/lock/send/unlock" class="media mediafile mf_ wikilink2" title="so:examen:lock:send:unlock">unlock</a>}.
# Fie <a href="http://ocw.cs.pub.ro/courses/_media/so/examen/struct_tlb_entry" class="media mediafile mf_ wikilink2" title="so:examen:struct_tlb_entry">struct_tlb_entry</a>} o structură aferentă unei intrări în TLB. Ce câmpuri conține o astfel de structură?
#* </strong>Răspuns<strong>:
#</strong> TLB-ul este folosit pentru translatarea rapidă a adreselor virtuale în adrese fizice. Structura conține adresa paginii virtuale și adresa paginii fizice aferente.
</p>

</div>
<!-- EDIT7 SECTION "3CA, nr. 2" [8555-13169] -->
<h3 class="sectionedit8" id="cc_nr_2">3CC, nr. 2</h3>
<div class="level3">

<p>
# Dați exemplu de acțiune ce conduce la trecerea unui proces din starea <a href="http://ocw.cs.pub.ro/courses/_media/so/examen/ready" class="media mediafile mf_ wikilink2" title="so:examen:ready">ready</a>} în <a href="http://ocw.cs.pub.ro/courses/_media/so/examen/waiting" class="media mediafile mf_ wikilink2" title="so:examen:waiting">waiting</a>} și un exemplu care conduce la o trecere inversă.
#* <strong>Răspuns</strong>:
#<strong> Un proces nu poate trece direct din starea <a href="http://ocw.cs.pub.ro/courses/_media/so/examen/ready" class="media mediafile mf_ wikilink2" title="so:examen:ready">ready</a>} în <a href="http://ocw.cs.pub.ro/courses/_media/so/examen/waiting" class="media mediafile mf_ wikilink2" title="so:examen:waiting">waiting</a>}. Pentru a ajunge în <a href="http://ocw.cs.pub.ro/courses/_media/so/examen/waiting" class="media mediafile mf_ wikilink2" title="so:examen:waiting">waiting</a>} trebuie să execute o acțiune blocantă, adică trebuie să ruleze, adică trebuie să se găsească în starea <a href="http://ocw.cs.pub.ro/courses/_media/so/examen/running" class="media mediafile mf_ wikilink2" title="so:examen:running">running</a>}.
#</strong> Un proces trece din starea <a href="http://ocw.cs.pub.ro/courses/_media/so/examen/waiting" class="media mediafile mf_ wikilink2" title="so:examen:waiting">waiting</a>} în <a href="http://ocw.cs.pub.ro/courses/_media/so/examen/ready" class="media mediafile mf_ wikilink2" title="so:examen:ready">ready</a>} atunci când a dispărut cauza blocării sale: a apărut un eveniment de I/O pe care îl aștepta, a fost notificat, a fost făcut unlock pe mutex-ul la care aștepta etc. Procesul este, atunci, pregătit pentru execuție.
# Dați exemplu de situație în care trei procese care interacționează ajung în deadlock.
#* <strong>Răspuns</strong>:
#<strong> Cea mai simplă situație este aceea a unei așteptări circulare a proceselor. Procesele, respectiv, <a href="http://ocw.cs.pub.ro/courses/_media/so/examen/p1" class="media mediafile mf_ wikilink2" title="so:examen:p1">p1</a>}, <a href="http://ocw.cs.pub.ro/courses/_media/so/examen/p2" class="media mediafile mf_ wikilink2" title="so:examen:p2">p2</a>}, <a href="http://ocw.cs.pub.ro/courses/_media/so/examen/p3" class="media mediafile mf_ wikilink2" title="so:examen:p3">p3</a>} dețin resursele <a href="http://ocw.cs.pub.ro/courses/_media/so/examen/r1" class="media mediafile mf_ wikilink2" title="so:examen:r1">r1</a>}, <a href="http://ocw.cs.pub.ro/courses/_media/so/examen/r2" class="media mediafile mf_ wikilink2" title="so:examen:r2">r2</a>}, <a href="http://ocw.cs.pub.ro/courses/_media/so/examen/r3" class="media mediafile mf_ wikilink2" title="so:examen:r3">r3</a>} fără a le elibera. Apoi procesul <a href="http://ocw.cs.pub.ro/courses/_media/so/examen/p1" class="media mediafile mf_ wikilink2" title="so:examen:p1">p1</a>} solicită accesul la resursa <a href="http://ocw.cs.pub.ro/courses/_media/so/examen/r2" class="media mediafile mf_ wikilink2" title="so:examen:r2">r2</a>}, <a href="http://ocw.cs.pub.ro/courses/_media/so/examen/p2" class="media mediafile mf_ wikilink2" title="so:examen:p2">p2</a>} la <a href="http://ocw.cs.pub.ro/courses/_media/so/examen/r3" class="media mediafile mf_ wikilink2" title="so:examen:r3">r3</a>} iar <a href="http://ocw.cs.pub.ro/courses/_media/so/examen/p3" class="media mediafile mf_ wikilink2" title="so:examen:p3">p3</a>} la <a href="http://ocw.cs.pub.ro/courses/_media/so/examen/r1" class="media mediafile mf_ wikilink2" title="so:examen:r1">r1</a>}. Fiecare proces așteaptă la o resursă deținută de alt proces, fără ca vreunul din ele să o fi eliberat. Toate sunt blocate – deadlock.
# De ce este golit (flushed) TLB-ul la o schimbare de context?
#* </strong>Răspuns<strong>:
#</strong> TLB-ul conține un subset de intrări din tabela de pagini pentru acces rapid din partea procesorului. Tabela de pagini este proprie fiecărui proces (spațiului de adresă al acestuia). La o shimbare de context, procesul este schimbat și la fel și tabela de pagini. Schimbarea tabelei de pagini înseamnă invalidarea TLB-ului și este necesară golirea acestuia.
</p>

</div>
<!-- EDIT8 SECTION "3CC, nr. 2" [13170-14905] -->
<h3 class="sectionedit9" id="lucrare_3">Lucrare 3</h3>
<div class="level3">
<ul>
<li class="level1"><div class="li">19 aprilie, 09:05-09:15, EC004, seria CA</div>
</li>
<li class="level1"><div class="li">20 aprilie, 17:05-17:15, EC105, seria CC</div>
</li>
</ul>

</div>
<!-- EDIT9 SECTION "Lucrare 3" [14906-15015] -->
<h3 class="sectionedit10" id="ca_nr_11">3CA, nr. 1</h3>
<div class="level3">

<p>
# Dați exemplu de situație în care se produce <em>page fault</em> (la nivelul subsistemului de gestiune a memoriei), fără a rezulta în <em>segmentation fault</em>/excepție la nivelul procesului care a cauzat <em>page fault</em>-ul.
## În cazul <em>demand paging</em>, se alocă o pagină virtuală (<em>page</em>) fără suport fizic (<em>frame</em>). La apariția unui <em>page fault</em> se va aloca o pagină fizică, fără a rezulta o excepție.
## În cazul <em>copy-on-write</em>, două pagini virtuale (<em>page</em>) (din două procese diferite) sunt marcate read-only și referă aceeași pagină fizică (<em>frame</em>). În momentul în care unul dintre cele două procese efectuează o operație de scriere, se obține <em>page fault</em>, se duplică pagina fizică și se continuă execuția.
## În cazul unei pagini virtuale (<em>page</em>) valide, al cărei conținut se găsește în <em>swap</em>, un acces generează <em>page fault</em>. Conținutul este <em>swapped in</em> într-o pagină fizică (<em>frame</em>) si procesul își continuă execuția.
# Fie un program multithreaded care efectuază multe operații I/O per thread. Este mai eficientă folosirea <em>user-level threads</em> sau <em>kernel-level threads</em>?
#* Operațiile I/O sunt, în general, operații blocante. Efectuarea unei operații de I/O în cadrul unei implementări de thread-uri <em>user-level</em> va bloca întreg procesul, nu doar thread-ul curent.
#* În cadrul unei implementări de thread-uri <em>kernel-level</em>, doar thread-ul care a efectuat operația I/O, celelalte thread-uri putând fi planificate pe procesor.
#* Implementarea <em>kernel-level threads</em> este, în acest caz mai eficientă, prin folosirea procesorului/procesoarelor de mai multe thread-uri ale proceselor.
# Cine/ce generează întreruperi și cine/ce le tratează?
#* Întreruperile sunt generate de dispozitivele hardware la apariția unui eveniment specific (primirea de date/eliberarea unui buffer local, caz de eroare).
#* Tratarea întreruperilor este realizează de procesor în cadrul unei rutine de tratare a întreruperii (<em>IRQ handler</em> sau <em>ISR – Interrupt Service Routine</em>).
</p>

</div>
<!-- EDIT10 SECTION "3CA, nr. 1" [15016-17122] -->
<h3 class="sectionedit11" id="ca_nr_21">3CA, nr. 2</h3>
<div class="level3">

<p>
# Care este rolul bitului <em>dirty</em> / <em>modified</em> pentru subsistemul de înlocuire a paginilor? Bitul este activat în momentul în care o pagină este modificată/scrisă.
#* Dacă o pagină este modificată atunci o eventuală alegere a acestei pagini pentru a fi evacuată (<em>swapped out</em>) va înseamnă scrierea acesteia pe disc.
#* Dacă o pagină nu este modificată (bitul <em>dirty</em> este dezactivat) nu va mai fi scrisă pe disc în momentul evacuării, rezultând într-un overhead redus al operației de înlocuire.
#* În general, algoritmii de înlocuire de pagini din cadrul subsistemelor aferente, vor ține cont de ultimul acces (fie de scriere, fie de citire al unei pagini) – LRU, NRU (<em>Least/Not Recently Used</em>). Se vor prefera paginile nereferite recent, iar dintre acestea, cele care nu au fost scrise (bitul <em>dirty</em> dezactivat) – vezi <a href="http://en.wikipedia.org/wiki/Page_replacement_algorithm#Not_recently_used" class="urlextern" title="http://en.wikipedia.org/wiki/Page_replacement_algorithm#Not_recently_used"  rel="nofollow"> NRU</a>.
# Fie un program multithreaded care rulează pe un sistem multiprocesor. Este mai eficientă folosirea <em>user-level threads</em> sau <em>kernel-level threads</em>?
#* În cadrul unei implementări <em>user-level</em>, un singur thread rulează pe procesor; planificatorul de la nivelul nucleului “vede” o singură entitate planificabilă – procesul corespunzător.
#* În cadrul unei implementări <em>kernel-level</em>, fiecare thread al procesului poate rula pe un procesor. Se poate întâmpla ca, pe un sistem cu număr suficient de procesoare, toate thread-urile unui proces să ruleze pe procesoare.
#* În concluzie, este mai eficientă folosirea unei implementări <em>kernel-level</em> prin utilizarea mai bună a procesoarelor, rezultând, astfel, într-o productivitate mai bună.
# Dați exemplu de funcție de <abbr title="Application Programming Interface">API</abbr> care efectuează operații I/O sincrone și o funcție care efectuează operații I/O asincrone.
#* Operații I/O sincrone: <a href="http://ocw.cs.pub.ro/courses/_media/so/examen/read" class="media mediafile mf_ wikilink2" title="so:examen:read">read</a>}, <a href="http://ocw.cs.pub.ro/courses/_media/so/examen/write" class="media mediafile mf_ wikilink2" title="so:examen:write">write</a>}. Sunt funcții la apelul cărora se execută operația de I/O.
#* Operații I/O asincrone: <a href="http://ocw.cs.pub.ro/courses/_media/so/examen/aio_read" class="media mediafile mf_ wikilink2" title="so:examen:aio_read">aio_read</a>}, <a href="http://ocw.cs.pub.ro/courses/_media/so/examen/aio_write" class="media mediafile mf_ wikilink2" title="so:examen:aio_write">aio_write</a>}, <a href="http://ocw.cs.pub.ro/courses/_media/overlapped_i/o" class="media mediafile mf_ wikilink2" title="overlapped_i:o">o</a>}, <a href="http://ocw.cs.pub.ro/courses/_media/so/examen/select" class="media mediafile mf_ wikilink2" title="so:examen:select">select</a>}.
#<strong> Primele 3 sunt operații asincrone, neblocante. Asincrone – declanșează o operația I/O fără a urmări “sincron” execuția acesteia; neblocante – nu se blochează în așteptarea încheierii operației.
#</strong> <a href="http://ocw.cs.pub.ro/courses/_media/so/examen/select" class="media mediafile mf_ wikilink2" title="so:examen:select">select</a>} – nu este cu adevărat o operație I/O, ci un apel de control a acestora. Poate fi considerată asincronă pentru că nu urmărește execuția unui set de operații; fie sincrone sau asincrone, <a href="http://ocw.cs.pub.ro/courses/_media/so/examen/select" class="media mediafile mf_ wikilink2" title="so:examen:select">select</a>} este un apel blocant care notifică încheierea unei operații I/O.
</p>

</div>
<!-- EDIT11 SECTION "3CA, nr. 2" [17123-19713] -->
<h3 class="sectionedit12" id="cc_nr_1">3CC, nr. 1</h3>
<div class="level3">

<p>
# Dați exemplu de situație/scenariu în care apariția unui <em>page fault</em> determină <em>swap out</em>.
#* În cazul apariției unui <em>page fault</em>, este posibil ca pagina fizică (<em>frame</em>) aferentă să nu fie alocată (<em>demand paging</em> sau <em>copy-on-write</em>) sau să fie pe disc (<em>swapped</em>). În acest caz pagina trebuie adusă în RAM.
#* Dacă memoria fizică (RAM) este ocupată, va trebui aleasă o pagină fizică pentru a fi înlocuită. Se aplică un algoritm de înlocuire a paginii.
#* În momentul aplicării algoritmului de înlocuire a paginii, pagina fizică este evacuată pe disc (<em>swapped out</em>); conținutul de pe disc aferent paginii ce a cauzat <em>page fault</em>-ul este adus în memorie (<em>swapped in</em>) în locul paginii fizice proaspăt evacuate.
# Fie următoarea secvență de cod:
</p>
<pre class="code">int main(void)
{
    int a = 0;
    pthread_create(...);
    a++;
}</pre>

<p>
 Care va fi valoarea lui <a href="http://ocw.cs.pub.ro/courses/_media/so/examen/a" class="media mediafile mf_ wikilink2" title="so:examen:a">a</a>} la finalul secvenței?
#* În urma apelului <a href="http://ocw.cs.pub.ro/courses/_media/so/examen/pthread_create" class="media mediafile mf_ wikilink2" title="so:examen:pthread_create">pthread_create</a>} thread-ul principal (<em>main thread</em>, <em>master thread</em>) își continuă execuția; thread-ul nou creat  execută funcția transmisă ca argument funcției <a href="http://ocw.cs.pub.ro/courses/_media/so/examen/pthread_create" class="media mediafile mf_ wikilink2" title="so:examen:pthread_create">pthread_create</a>}.
#* Variabila <a href="http://ocw.cs.pub.ro/courses/_media/so/examen/a" class="media mediafile mf_ wikilink2" title="so:examen:a">a</a>} va fi incrementată doar de thread-ul principal, astfel că valoarea finală a acesteia va fi 1.
#* O situație diferită este aceea în care <a href="http://ocw.cs.pub.ro/courses/_media/so/examen/a" class="media mediafile mf_ wikilink2" title="so:examen:a">a</a>} este transmisă într-o formă ca argument funcției aferente thread-ului nou creat și acesta o modifică; de asemenea, o valoare diferită rezultă în momentul în care thread-ul nou creat accesează variabila a pe stiva thread-ului principal (foarte puțin probabil, dar posibil).
# Care este scopul sortării cererilor de I/E pe care le face un sistem de operare atunci când lucrează cu discul?
#* Sortarea cererilor de I/E rezultă în organizarea acestora după sectorul de pe disc din care fac parte.
#* Prin sortarea acestora se minimizează timpul de căutare și poziționarea acului mecanic pe sector corespunzător. În loc să se rotească discul înainte și înapoi pentru poziționare pe capătul/sectorul/platanul corespunzător, se parcurg liniar/secvențial sectoarele descrise în cereri.
#* Rezultă, astfel, un overhead redus al căutării (<em>seek</em>) pe disc în cadrul cererilor de I/E – performanță îmbunătățită.
</p>

</div>
<!-- EDIT12 SECTION "3CC, nr. 1" [19714-22021] -->
<h3 class="sectionedit13" id="cc_nr_21">3CC, nr. 2</h3>
<div class="level3">

<p>
# Dați exemplu de situație/scenariu în care apariția unui <em>page fault</em> determină <em>swap in</em>.
#* Vezi explicația de la exercițiul 1 de la numărul 3CC, nr. 1.
# În ce situație pot două thread-uri din două procese diferite să partajeze o pagină de memorie?
#* Două thread-uri din două procese diferite nu pot partaja o pagină de memorie decât în cazul în care cele două procese o partajează la rândul lor.
#* Întrebarea se transformă, așadar, în “când pot două procese diferite să partajeze o pagină de memorie?”
#<strong> când cele două procese referă au mapată aceeași pagină fizică (folosint apeluri de forma <a href="http://ocw.cs.pub.ro/courses/_media/so/examen/mmap" class="media mediafile mf_ wikilink2" title="so:examen:mmap">mmap</a>});
#</strong> când cele două procese sunt înrudite și referă o pagină prin copy-on-write;
#<strong> când cele două procese au mapat același executabil/aceeași bibliotecă (codul acestora este read-only și paginile fizice aferente sunt partajate).
# Cu ce diferă o operație I/O asincronă de o operație I/O neblocantă?
#* O operație I/O asincronă este pornită dar nu se așteaptă încheierea acesteia. În momentul încheierii operației, se trimite o notificare.
#* O operație I/O neblocantă se întoarce imediat. Dacă este sincronă atunci va citi/scrie cât îi oferă dispozitivul. Dacă este asincronă, va primi notificare la încheierea operației.
#* Diferența constă, în general, în primirea sau nu a unei notificări, la sfârșitul încheierii operației de I/O. Acest lucru se întâmplă tot timpul la o operație I/O asincronă; la o operație I/O neblocantă se întâmplă doar dacă aceasta este asincronă – dacă este sincronă (<a href="http://ocw.cs.pub.ro/courses/_media/so/examen/read" class="media mediafile mf_ wikilink2" title="so:examen:read">read</a>} cu <a href="http://ocw.cs.pub.ro/courses/_media/so/examen/o_nonblock" class="media mediafile mf_ wikilink2" title="so:examen:o_nonblock">o_nonblock</a>}) atunci nu se primește notificare, doar se întoarce după ce a scris/citit cât i-a oferit dispozitivul.

==== Lucrare 4 ====

  *17 aprilie, 09:05-09:15, EC004, seria CA
  *18 aprilie, 17:05-17:15, EC105, seria CC

==== 3CA, nr. 1 ====

# Care este forma de asociere între <em>dentry</em> și <em>inode</em>? (unu la unu, mai multe la mai multe etc.)
#* Un dentry conține un nume și un inode number. Două sau mai multe dentry-uri pot referi același inode, prin intermediul inode number-ului (denumite și hard link-uri). Asocierea este </strong>mai multe dentry-uri la un inode<strong>.
# De ce nu poate rula un sistem de operare Windows într-un container OpenVZ?
#* OpenVZ este o soluție de virtualizare la nivelul sistemului de operare (<em>operating system-level virtualization</em>). În consecință, mașinile virtuale/containerele create partajează nucleul sistemului de operare.
#* Nu se poate crea/rula un container care folosește un kernel diferit de al sistemului de bază. Întrucât OpenVZ este o soluție specifică nucleului Linux doar soluții bazate pe acest nucleu vor putea rula (nu Windows, Mac <abbr title="Operating System">OS</abbr> X, Open Solaris, *BSD).
# Cum previne tehnica ASLR (<em>Address Space Layout Randomization</em>) atacuri de tipul <em>return-to-libc</em>?
#* Un atac de tipul <em>return-to-libc</em> presupune suprascrierea adresei de retur din cadrul stack frame-ului unei funcții cu o adresă din zona de cod a procesului (cel mai probabil codul aferent pentru <a href="http://ocw.cs.pub.ro/courses/_media/so/examen/system" class="media mediafile mf_ wikilink2" title="so:examen:system">system</a>} sau <a href="http://ocw.cs.pub.ro/courses/_media/so/examen/exec" class="media mediafile mf_ wikilink2" title="so:examen:exec">exec</a>}).
#* Tehnica ASLR împiedică atacatorul să cunoască adresa funcției dorite din cadrul zonei de cod prin maparea acestora în puncte aleatoare din spațiul de adresă. În cazul unui spațiu virtual suficient de mare (spre exemplu în cazul sistemelor pe 64 de biți), timpul de “căutare” a adresei dorite face impractice atacuri de tipul <em>return-to-libc</em>.

==== 3CA, nr. 2 ====

# De ce este mai eficientă folosirea unei tabele FAT în locul alocării cu liste pentru gestiunea blocurilor libere ale unui sistem de fișiere?
#* Alocarea cu liste presupune existența, la sfârșitul fiecărui bloc, a unui pointer către următorul bloc de date. Acest lucru înseamnă că, pentru a ajunge la al N-lea bloc de date, trebuie parcurse (citite de pe disc și aduse în memorie) N-1 blocuri de date.
#* În cazul tabelei FAT toți pointerii sunt ținuți localizat în cadrul tabelei. La o adresă specifică unui bloc se găsește un pointer către o altă adresă (specifică altui bloc). Overhead-ul/timpul de citire a unui bloc de date este, astfel, mult redus.
#* Tabela FAT, fiind localizată, poate fi stocată în cache-ul de memorie, mărind astfel viteza de acces la resursele aferente.
# De ce OpenVZ scalează mai bine decât VMware Workstation (scalează = se pot crea și pot rula simultan mai multe mașini virtuale)?
#* Fiind vorba de o soluție de virtualizare la nivelul sistemului de operare (<em>operating system-level virtualization</em>), aplicațiile din cadrul containerelor OpenVZ apelează direct nucleul sistemului de operare. Overhead-ul de rulare este minimal, dat de asigurarea separării între containere.
#* În cazul VMware Workstation, o soluție de virtualizare <em>hosted</em>, aplicațiile aferente apelează hypervisor-ul (VMM) care face legătura cu sistemul de operare al sistemului de bază. Overhead-ul este dat de trecerea prin niveluri suplimentare date de hypervisor. În plus, separația datelor este dată de fișiere specializate pentru disc (<a href="http://ocw.cs.pub.ro/courses/_media/so/examen/vmdk" class="media mediafile mf_ wikilink2" title="so:examen:vmdk">vmdk</a>}) ce înseamnă overhead suplimentar.
# Cum previne flag-ul NX (<em>No eXecute</em>) atacurile de tipul <em>stack buffer overflow</em>?
#* Atacurile de tipul <em>stack buffer overflow</em> presupun suprascrierea adresei de retur din cadrul stack frame-ului unei funcții prin trecerea peste limita unui buffer alocat pe stivă. În general, adresa este suprascrisă chiar cu o adresă de pe stivă din cadrul buffer-ului.
#</strong> Atacatorul completează în cadrul buffer-ului de pe stivă un shell code și apoi suprascrie adresa de retur cu adresa din cadrul buffer-ului unde începe shell code-ul.
#* Flag-ul NX este un flag/bit hardware ce marchează anumite pagini ca fiind neexecutabile. Exemple de zone care sunt candidați pentru acest bit sunt stiva, heap-ul și zonele de date. Marcarea stivei ca fiind neexecutabilă, prin folosirea flag-ului NX, înseamnă imposibilitatea realizării unui atac de tipul <em>stack buffer overflow</em>.
</p>

</div>
<!-- EDIT13 SECTION "3CC, nr. 2" [22022-28073] -->
<h3 class="sectionedit14" id="cc_nr_11">3CC, nr. 1</h3>
<div class="level3">

<p>
# De ce nu se poate crea un hard link către un inode de pe alt sistem de fișiere?
#* Un hard link este un dentry; conține un nume și un număr de inode.
#* Întrucât două sisteme de fișiere diferite pot avea alocat același inode, este ambiguă prezența unui număr de inode ce referă al sistem de fișiere. Numărul de inode din cadrul dentry-ul aferent va referi inode-ul de pe sistemul curent de fișiere.
# De ce este considerat VMware Workstation o soluție de tipul <em>hosted hypervisor</em>, pe când Xen nu?
#* VMware Workstation rulează ca o aplicație peste un sistem de operare existent. Sistemul de operare oferă o gamă largă de servicii utilizatorului, printre acestea numărându-se și posibilitatea rulării VMware Workstation.
#* Xen nu rulează peste un sistem de operare existent. În general, Xen este instalat în forma unui sistem de operare Linux cu suportul de virtualizare direct peste hardware (<em>bare metal hypervisor</em>).
# Cum sunt prevenite atacurile de tipul <em>stack buffer overflow</em> folosind soluții de tipul <em>stack smashing protection</em>?
#* Vezi descriere <em>stack buffer overflow</em> mai sus.
#* Soluțiile de tipul <em>stack smashing protection</em> presupun plasarea unei valori speciale (<em>canary value</em>) înaintea adresei de retur dintr-un stack frame.
#* Întrucât majoritatea atacurilor presupun operații pe șiruri, suprascrierea adresei de retur va însemna și suprascrierea valorii speciale. Înainte de revenirea de funcție se verifică această valoare. Dacă a fost modificată atunci se generează eroare.
</p>

</div>
<!-- EDIT14 SECTION "3CC, nr. 1" [28074-29657] -->
<h3 class="sectionedit15" id="cc_nr_22">3CC, nr. 2</h3>
<div class="level3">

<p>
# În cazul alocării indexate, inode-ul conține un număr limitat de pointeri către blocuri de date, limitând astfel dimensiunea maximă a unui fișier. Cum este rezolvată această problemă?
#* Problema este rezolvată prin indirectare. O parte din pointerii din cadrul inode-ului nu vor referi blocuri de date, ci vor referi blocuri cu pointeri către blocuri de date (indirectare simplă) sau blocuri cu pointeri către blocuri cu pointeri către blocuri de date (indirectare dublă) etc. Dezavantajul este o latență mai mare de acces pentru blocurile finale.
# De ce este considerat Xen o soluție de tipul <em>bare metal hypervisor</em>, pe când VMware Workstation nu?
#* Vezi răspunsul de la <strong>3CC, nr. 1, exercițiul 2</strong>.
# De ce executabilul aferent comenzii <em>su</em> (<em>/bin/su</em>) are bitul <em>setuid</em> activat?
#* Un proces care ia naștere din cadul executabilului <a href="http://ocw.cs.pub.ro/courses/_media/bin/su" class="media mediafile mf_ wikilink2" title="bin:su">su</a>} execută o serie de operații privilegiate precum:
#<strong> parcurgerea fișierului <a href="http://ocw.cs.pub.ro/courses/_media/etc/shadow" class="media mediafile mf_ wikilink2" title="etc:shadow">shadow</a>} pentru a citi parola;
#</strong> schimbarea user id-ului curent (practic schimbarea utilizatorului).
#* Pentru executarea operațiilor privilegiate este nevoie de drept de superuser. Prezența bitului <em>setuid</em> permite efectuarea acestora.
</p>

</div>
<!-- EDIT15 SECTION "3CC, nr. 2" [29658-] --></div>
</body>
</html>
