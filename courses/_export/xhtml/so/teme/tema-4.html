    
    

<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
  <meta charset="utf-8" />
  <title>so:teme:tema-4</title>
<meta name="generator" content="DokuWiki"/>
<meta name="robots" content="index,follow"/>
<meta name="date" content="2016-05-04T11:15:56+0300"/>
<meta name="keywords" content="so,teme,tema-4"/>
<link rel="search" type="application/opensearchdescription+xml" href="../../../../lib/exe/opensearch.php" title="CS Open CourseWare"/>
<link rel="start" href="../../../../../courses.1.html"/>
<link rel="alternate" type="application/rss+xml" title="Recent Changes" href="../../../../feed.php"/>
<link rel="alternate" type="application/rss+xml" title="Current Namespace" href="../../../../feed.php%3Fmode=list&amp;ns=so:teme"/>
<link rel="alternate" type="text/html" title="Plain HTML" href="tema-4.html"/>
<link rel="canonical" href="../../../../so/teme/tema-4.html"/>
<link rel="stylesheet" type="text/css" href="../../../../lib/exe/css.php%3Ft=arctic&amp;tseed=1476798676.css"/>
<script type="text/javascript">/*<![CDATA[*/var NS='so:teme';var JSINFO = {"id":"so:teme:tema-4","namespace":"so:teme","isadmin":0,"isauth":0};
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="../../../../lib/exe/js.php%3Ftseed=1476798676"></script>
<script type="text/x-mathjax-config">/*<![CDATA[*/MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ["$","$"], ["\\(","\\)"] ],
        displayMath: [ ["$$","$$"], ["\\[","\\]"] ],
        processEscapes: true
    }
});
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
<script type="text/javascript">/*<![CDATA[*/
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
		  
/*!]]>*/</script>
<script type="text/javascript">/*<![CDATA[*/
var pageTracker = _gat._getTracker("UA-38383934-1");
pageTracker._initData();
pageTracker._trackPageview();
		  
/*!]]>*/</script>
</head>
<body>
<div class="dokuwiki export">
<!-- TOC START -->
<div id="dw__toc">
<h3 class="toggle">Table of Contents</h3>
<div>

<ul class="toc">
<li class="level1"><div class="li"><a href="tema-4.html#tema_4_planificator_de_threaduri">Tema 4 Planificator de threaduri</a></div>
<ul class="toc">
<li class="level2"><div class="li"><a href="tema-4.html#obiectivele_temei">Obiectivele temei</a></div></li>
<li class="level2"><div class="li"><a href="tema-4.html#enunt">Enunț</a></div></li>
<li class="level2"><div class="li"><a href="tema-4.html#descriere_detaliata_a_functionarii_planificatorului">Descriere detaliată a funcționării planificatorului</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="tema-4.html#timp_executie">Timp execuție:</a></div></li>
<li class="level3"><div class="li"><a href="tema-4.html#evenimente_si_io">Evenimente și I/O</a></div></li>
<li class="level3"><div class="li"><a href="tema-4.html#round_robin_cu_prioritati">Round Robin cu priorități</a></div></li>
<li class="level3"><div class="li"><a href="tema-4.html#stari_threaduri">Stări threaduri:</a></div></li>
<li class="level3"><div class="li"><a href="tema-4.html#detalii_implementare_instructiuni">Detalii implementare instrucțiuni</a></div></li>
</ul>
</li>
<li class="level2"><div class="li"><a href="tema-4.html#exemplu_executie">Exemplu execuție</a></div></li>
<li class="level2"><div class="li"><a href="tema-4.html#precizari_linux">Precizări Linux</a></div></li>
<li class="level2"><div class="li"><a href="tema-4.html#precizari_windows">Precizări Windows</a></div></li>
<li class="level2"><div class="li"><a href="tema-4.html#utile">Utile</a></div></li>
<li class="level2"><div class="li"><a href="tema-4.html#testare">Testare</a></div></li>
<li class="level2"><div class="li"><a href="tema-4.html#notare">Notare</a></div></li>
<li class="level2"><div class="li"><a href="tema-4.html#materiale_ajutatoare">Materiale ajutătoare</a></div></li>
<li class="level2"><div class="li"><a href="tema-4.html#faq">FAQ</a></div></li>
<li class="level2"><div class="li"><a href="tema-4.html#suport_intrebari_si_clarificari">Suport, întrebări și clarificări</a></div></li>
</ul></li>
</ul>
</div>
</div>
<!-- TOC END -->

<h1 class="sectionedit1" id="tema_4_planificator_de_threaduri">Tema 4 Planificator de threaduri</h1>
<div class="level1">

<p>
<p><div class="noteimportant">
Dată publicare: <strong>21 Aprilie 2016</strong>
</p>

<p>
Deadline: <strong>9 Mai 2016, ora 23:55</strong>
</p>

<p>
<del>Deadline: <strong>6 Mai 2016, ora 23:55</strong></del>
</p>

<p>
Deadline hard: <strong>13 Mai 2016, ora 23:55</strong>

</div></p>
</p>

</div>
<!-- EDIT1 SECTION "Tema 4 Planificator de threaduri" [1-238] -->
<h2 class="sectionedit2" id="obiectivele_temei">Obiectivele temei</h2>
<div class="level2">
<ul>
<li class="level1"><div class="li">Aprofundarea următoarelor noțiuni:</div>
<ul>
<li class="level2"><div class="li">threaduri POSIX și WINDOWS</div>
</li>
<li class="level2"><div class="li">planificarea proceselor/threadurilor</div>
</li>
<li class="level2"><div class="li">mecanisme de sincronizare între threaduri</div>
</li>
</ul>
</li>
</ul>

</div>
<!-- EDIT2 SECTION "Obiectivele temei" [239-433] -->
<h2 class="sectionedit3" id="enunt">Enunț</h2>
<div class="level2">

<p>
Să se implementeze un planificator de threaduri care va controla execuția acestora în user-space. Acesta va simula un <strong>scheduler</strong> de procese preemptiv, într-un sistem uniprocesor, care utilizează un algoritm de planificare Round Robin cu priorități.
</p>

<p>
Implementarea planificatorului de threaduri se va face într-o bibliotecă partajată dinamică, pe care o vor încărca thread-urile ce urmează să fie planificate. Aceasta va trebui să exporte următoarele funcții:
</p>
<ul>
<li class="level1"><div class="li"><code>INIT</code> - inițializează structurile interne ale planificatorului.</div>
</li>
<li class="level1"><div class="li"><code>FORK</code> - pornește un nou thread.</div>
</li>
<li class="level1"><div class="li"><code>EXEC</code> - simulează execuția unei instrucțiuni.</div>
</li>
<li class="level1"><div class="li"><code>WAIT</code> - așteaptă un eveniment/operație I/O.</div>
</li>
<li class="level1"><div class="li"><code>SIGNAL</code> - semnalează threadurile care așteaptă un eveniment/operație I/O.</div>
</li>
<li class="level1"><div class="li"><code>END</code> - distruge planificatorul și eliberează structurile alocate.</div>
</li>
</ul>

<p>
Pe lângă implementarea propriu-zisă a funcțiilor de mai sus, va trebui să asigurați și planificarea/execuția corectă a threadurilor, conform algoritmului <span class="curid"><a href="../../../../so/teme/tema-4.html#round_robin_cu_prioritati" class="wikilink1" title="so:teme:tema-4">Round Robin cu priorități</a></span>. Fiecare thread trebuie să ruleze în contextul unui thread real din sistem. Fiind un planificator pentru sisteme uniprocesor, un singur thread va putea rula la un moment dat.
</p>

</div>
<!-- EDIT3 SECTION "Enunț" [434-1726] -->
<h2 class="sectionedit4" id="descriere_detaliata_a_functionarii_planificatorului">Descriere detaliată a funcționării planificatorului</h2>
<div class="level2">

</div>
<!-- EDIT4 SECTION "Descriere detaliată a funcționării planificatorului" [1727-1794] -->
<h3 class="sectionedit5" id="timp_executie">Timp execuție:</h3>
<div class="level3">

<p>
Într-un sistem real, pentru controlul execuției, contorizarea timpului de rulare a unui proces se realizează la fiecare întrerupere de ceas.
</p>

<p>
Pentru facilitarea implementării, modelul temei va simula un sistem real astfel:
</p>
<ol>
<li class="level1"><div class="li"> sistemul simulat va folosi un timp virtual (logic), independent de cel real pentru a contoriza timpul de rulare pe procesor.</div>
</li>
<li class="level1"><div class="li"> veți considera că o <code>instructiune</code> durează o <strong>singură</strong> perioadă de ceas (unitate de timp logic).</div>
</li>
<li class="level1"><div class="li"> fiecare din funcțiile prezentate mai sus reprezintă o <strong>singură</strong> <code>instructiune</code> ce poate fi executată de un thread la un moment dat.</div>
</li>
</ol>

</div>
<!-- EDIT5 SECTION "Timp execuție:" [1795-2432] -->
<h3 class="sectionedit6" id="evenimente_si_io">Evenimente și I/O</h3>
<div class="level3">

<p>
Threadurile din sistem se pot bloca în așteptarea unui eveniment sau a unei operații de I/O. Un astfel de eveniment va fi identificat printr-un id (0 - nr_events). Numărul total de evenimente (care pot apărea la un moment dat în sistem) va fi dat ca parametru la inițializarea planificatorului.
</p>

<p>
Un thread se blochează în urma apelului funcției <code>wait</code> (ce primește ca parametru id-ul/indexul evenimentului/dispozitivului) și este eliberat atunci când un alt thread apelează funcția <code>signal</code> pe același eveniment/dispozitiv. Signal trezește toate threadurile care așteapta un anumit eveniment.
</p>

<p>
Atenție, un thread care a apelat funcția <code>wait</code>, indiferent de prioritate, nu poate fi planificat decât după ce este trezit de un alt thread.
</p>

</div>
<!-- EDIT6 SECTION "Evenimente și I/O" [2433-3227] -->
<h3 class="sectionedit7" id="round_robin_cu_prioritati">Round Robin cu priorități</h3>
<div class="level3">
<ul>
<li class="level1"><div class="li">fiecare task are asociată o prioritate statică, care este specificată la pornirea threadului.</div>
</li>
<li class="level1"><div class="li">întotdeauna va fi planificat threadul cu cea mai mare prioritate.</div>
</li>
<li class="level1"><div class="li">la expirarea cuantei de timp, threadul care rulează este preemptat și se alege un nou task.</div>
</li>
<li class="level1"><div class="li">dacă un thread este preemptat și revine în starea READY (ex: cazul în care îi expiră cuanta), iar în sistem nu mai există un alt thread READY de prioritate mai mare sau egală cu a lui, va fi replanificat același thread.</div>
</li>
<li class="level1"><div class="li">threadurile cu aceeași prioritate vor fi planificate după modelul Round Robin (ex: puteți folosi cozi de priorități ce vor fi parcurse circular).</div>
</li>
<li class="level1"><div class="li">dacă un thread proaspăt creat (sau care doar ce a ieșit din starea de waiting) are prioritate mai mare decât threadul care rulează, cel din urmă va fi preemptat și va rula thread-ul cu prioritatea mai mare.</div>
</li>
<li class="level1"><div class="li">la replanificarea unui thread, cuanta acestuia de rulare pe procesor va fi resetată la valoarea maximă.</div>
</li>
<li class="level1"><div class="li"><strong>preempția</strong>: odată ce o funcție/instrucțiune a fost planificată, ea nu poate fi preemptată decât după ce și-a terminat treaba (“do work” în exemplul de mai jos). Pentru a simula preempția, puteți bloca funcția curentă folosind mecanisme de sincronizare. De exemplu, o instrucțiune se poate abstractiza astfel:</div>
</li>
</ul>
<pre class="code">instruction()
{
    do work
    check scheduler
    if (preempted)
        block();
    return;
}</pre>

<p>
Prin urmare, cazurile în care threadul curent este preemptat și un alt thread începe rularea sunt:
</p>
<ul>
<li class="level1"><div class="li">un task cu o prioritate mai mare intră în sistem.</div>
</li>
<li class="level1"><div class="li">un task cu o prioritate mai mare este semnalat printr-o operație de tipul <code>signal</code>.</div>
</li>
<li class="level1"><div class="li">task-ului curent i-a expirat cuanta de timp.</div>
</li>
<li class="level1"><div class="li">așteaptă la un eveniment cu ajutorul unei operații de tipul <code>wait</code>.</div>
</li>
<li class="level1"><div class="li">nu mai are instrucțiuni de executat.</div>
</li>
</ul>

<p>
Pentru mai multe detalii despre algoritmi de planificare puteți consulta <a href="../../../../so/cursuri/curs-04.html" class="wikilink1" title="so:cursuri:curs-04">cursul 4</a>.
</p>

</div>
<!-- EDIT7 SECTION "Round Robin cu priorități" [3228-5212] -->
<h3 class="sectionedit8" id="stari_threaduri">Stări threaduri:</h3>
<div class="level3">

<p>
Stările prin care poate trece un thread sunt:
</p>
<ul>
<li class="level1"><div class="li"><strong>New</strong> - thread nou creat în urma unui apel de tipul <code>fork</code>.</div>
</li>
<li class="level1"><div class="li"><strong>Ready</strong> - așteaptă să fie planificat.</div>
</li>
<li class="level1"><div class="li"><strong>Running</strong> - planificat - un singur thread poate rula la un moment dat.</div>
</li>
<li class="level1"><div class="li"><strong>Waiting</strong> - așteaptă după un eveniment sau o operație I/O. Un thread se va bloca în starea de wait în urma apelului <code>so_wait(event/io)</code>.</div>
</li>
<li class="level1"><div class="li"><strong>Terminated</strong> - și-a încheiat execuția.</div>
</li>
</ul>

<p>
Pentru o mai bună întelegere a algoritmilor de planificare, se recomandă urmărirea tranzițiilor dintre stări ca în desenul de mai jos.
</p>

<p>
<a href="../../../../_detail/so/teme/thr_states.png%3Fid=so%253Ateme%253Atema-4.html" class="media" title="so:teme:thr_states.png"><img src="../../../../_media/so/teme/thr_states.png" class="media" alt="" /></a>
</p>

</div>
<!-- EDIT8 SECTION "Stări threaduri:" [5213-5847] -->
<h3 class="sectionedit9" id="detalii_implementare_instructiuni">Detalii implementare instrucțiuni</h3>
<div class="level3">

<p>
Funcțiile care trebuie exportate de planificator, alături de parametrii fiecăruia, sunt detaliate mai jos:
</p>
<ul>
<li class="level1"><div class="li"><code>int so_init(cuantă, io)</code> - inițializează planificatorul. Primește ca argumente cuanta de timp după care un proces trebuie preemptat și numărul de evenimente (dispozitive I/O) suportate. Întoarce 0 dacă planificatorul a fost inițializat cu succes, sau negativ în caz de eroare. Numărul maxim de dispozitive I/O suportate este 256 iar indexarea acestora începe de la 0.</div>
</li>
</ul>
<ul>
<li class="level1"><div class="li"><code>void so_end()</code> - eliberează resursele planificatorului și așteaptă terminarea tuturor threadurilor înainte de părăsirea sistemului.</div>
</li>
</ul>
<ul>
<li class="level1"><div class="li"><code>void so_exec()</code> - simulează execuția unei instrucțiuni generice. Practic, doar consumă timp pe procesor.</div>
</li>
</ul>
<ul>
<li class="level1"><div class="li"><code>int so_wait(event/io)</code> - threadul curent se blochează în așteptarea unui eveniment sau a unei operații de I/O. Întoarce 0 dacă evenimentul există (id-ul acestuia este valid) sau negativ în caz de eroare.</div>
</li>
</ul>
<ul>
<li class="level1"><div class="li"><code>int so_signal(event/io)</code> - trezește unul sau mai multe threaduri care așteaptă un anumit eveniment. Întoarce numărul total de threaduri deblocate, sau negativ în caz de eroare (evenimentul nu este valid).</div>
</li>
</ul>
<ul>
<li class="level1"><div class="li"><code>tid_t so_fork(handler, prioritate)</code> - pornește și introduce în planificator un nou thread. Primește ca parametru o rutină pe care threadul o va executa după ce va fi planificat și prioritatea cu care acesta va rula și întoarce un id unic corespunzător threadului. Handlerul executat de thread va primi ca parametru prioritatea acestuia.</div>
</li>
</ul>

<p>
În mod normal, so_fork va fi apelată din contextul unui alt thread din sistem. Se garantează faptul că va exista întotdeauna cel puțin un thread ce poate fi planificat, pe întreg parcursul rulării planificatorului. Excepție face cazul primului so_fork ce va crea primul thread din sistem și va fi apelat din contextul testelor, neavând ca parinte un thread din sistemul simulat. 
</p>

<p>
Un exemplu de model de implementare a funcției fork, ar putea fi folosirea unei funcții suplimentare (ex start_thread) care să determine contextul în care se va executa noul thread (handlerul primit ca parametru) ca în descrierea de mai jos:
</p>
<pre class="code">
so_fork(handler, prio)
-&gt; initializare thread struct
-&gt; creare thread nou ce va executa functia start_thread
-&gt; asteaptă ca threadul să intre în starea READY/RUN
-&gt; returnează id-ul noului thread

start_thread(params)
-&gt; asteaptă să fie planificat
-&gt; call handler(prio)
-&gt; iesire thread
</pre>

<p>
<strong>Atenție:</strong> Funcția se va întoarce abia după ce noul thread creat fie a fost planificat fie a intrat în starea READY.
</p>

</div>
<!-- EDIT9 SECTION "Detalii implementare instrucțiuni" [5848-8524] -->
<h2 class="sectionedit10" id="exemplu_executie">Exemplu execuție</h2>
<div class="level2">
<div class="table sectionedit11"><table class="inline">
	<tr class="row0">
		<th class="col0 leftalign"> = Thread 0 =      </th><th class="col1 leftalign"> = Thread 1 =       </th><th class="col2 leftalign"> = Thread 2 =         </th><th class="col3 leftalign"> = Thread 3 =        </th>
	</tr>
	<tr class="row1">
		<td class="col0 leftalign"> exec    </td><td class="col1 leftalign"> exec     </td><td class="col2 leftalign"> exec        </td><td class="col3 centeralign">  exec    </td>
	</tr>
	<tr class="row2">
		<td class="col0 leftalign"> fork(thr2, 2)    </td><td class="col1 leftalign"> signal(3)    </td><td class="col2 leftalign"> wait(3)        </td><td class="col3 centeralign">  exec    </td>
	</tr>
	<tr class="row3">
		<td class="col0 leftalign"> fork(thr1, 1)    </td><td class="col1 leftalign"> fork(thr3, 1)    </td><td class="col2 leftalign"> exec        </td><td class="col3 leftalign">     </td>
	</tr>
	<tr class="row4">
		<td class="col0 leftalign"> exec    </td><td class="col1 leftalign"> exec    </td><td class="col2 leftalign">        </td><td class="col3 leftalign">     </td>
	</tr>
	<tr class="row5">
		<td class="col0 leftalign">     </td><td class="col1 leftalign"> exec    </td><td class="col2 leftalign">        </td><td class="col3 leftalign">     </td>
	</tr>
	<tr class="row6">
		<td class="col0 leftalign">     </td><td class="col1 leftalign"> exec    </td><td class="col2 leftalign">        </td><td class="col3 leftalign">     </td>
	</tr>
</table></div>
<!-- EDIT11 TABLE [8556-8919] -->
<p>
În exemplul de mai sus, threadul 0 are prioritatea 0. Acesta pornește threadurile 1 și 2 cu prioritățile asociate. Threadul 2 se blochează așteptând evenimentul cu id-ul 3, eveniment ce va fi semnalat de threadul 1. Cuanta de rulare pe procesor este 3. În final, instrucțiunile se vor executa în următoarea ordine:
</p>
<pre class="code">T0 exec
T0 forks T2, prio 2
--&gt; T2 preempts T0 (prio(T2) &gt; prio(T0))
T2 exec
T2 waits for event 3
--&gt; T2 blocks and is preempted
T0 forks T1, prio 1
--&gt; T1 preempts T0
T1 exec
T1 signals event 3
--&gt; T2 is woken up and preempts T1
T2 exec
--&gt; T2 finished
T1 forks T3, prio 1
T1 exec
T1 exec
--&gt; T1 is preempted, its CPU quantum expired
T3 exec
T3 exec
--&gt; T3 finished
T1 exec
--&gt; T1 finished
T0 exec
--&gt; T0 finished</pre>

</div>
<!-- EDIT10 SECTION "Exemplu execuție" [8525-9679] -->
<h2 class="sectionedit12" id="precizari_linux">Precizări Linux</h2>
<div class="level2">

<p>
Identificatorul întors de funcția <code>so_fork</code> trebuie să fie structura <code>pthread_t</code> populată de funcția POSIX <code>pthread_create()</code>.
</p>

<p>
Tema se va rezolva folosind doar funcții POSIX. Se pot folosi de asemenea și funcțiile de formatare printf, scanf, funcțiile de alocare de memorie malloc, free, și funcțiile de manipulare a șirurilor de caractere (strcat, strdup, etc.)
</p>

<p>
Tema se va rezolva folosind fire de execuție POSIX și exclusiv mecanisme de sincronizare a firelor de execuție POSIX (mutex, variabile de condiție).
</p>

</div>
<!-- EDIT12 SECTION "Precizări Linux" [9680-10246] -->
<h2 class="sectionedit13" id="precizari_windows">Precizări Windows</h2>
<div class="level2">

<p>
Pe lângă mecanismele de sincronizare învățate la laborator, aveți voie să folosiți și <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms682052(v=vs.85).aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/windows/desktop/ms682052(v=vs.85).aspx"  rel="nofollow">variabile de condiție</a>.
</p>

<p>
Identificatorul întors de funcția <code>so_fork</code> trebuie să fie cel întors de funcția <code>GetCurrentThreadId()</code> apelată în contextul threadului nou creat.
</p>

<p>
Tema se va rezolva folosind doar funcții Win32. Se pot folosi de asemenea și funcțiile de formatare printf, scanf, funcțiile de alocare de memorie malloc, free și funcțiile de manipulare a șirurilor de caractere (strcat, strcmp, etc.)
</p>

</div>
<!-- EDIT13 SECTION "Precizări Windows" [10247-10882] -->
<h2 class="sectionedit14" id="utile">Utile</h2>
<div class="level2">
<ul>
<li class="level1"><div class="li"><a href="http://elf.cs.pub.ro/so/res/teme/tema4-util/so_scheduler.h" class="urlextern" title="http://elf.cs.pub.ro/so/res/teme/tema4-util/so_scheduler.h"  rel="nofollow"> Header</a> - conține semnăturile funcțiilor exportate.</div>
</li>
</ul>

</div>
<!-- EDIT14 SECTION "Utile" [10883-11023] -->
<h2 class="sectionedit15" id="testare">Testare</h2>
<div class="level2">
<ul>
<li class="level1"><div class="li">Corectarea temelor se va realiza automat cu ajutorul unor suite de teste publice:</div>
<ul>
<li class="level2"><div class="li">teste Linux   – <a href="http://elf.cs.pub.ro/so/res/teme/tema4-checker-lin.zip" class="urlextern" title="http://elf.cs.pub.ro/so/res/teme/tema4-checker-lin.zip"  rel="nofollow"> tema4-checker-lin.zip</a></div>
</li>
<li class="level2"><div class="li">teste Windows – <a href="http://elf.cs.pub.ro/so/res/teme/tema4-checker-win.zip" class="urlextern" title="http://elf.cs.pub.ro/so/res/teme/tema4-checker-win.zip"  rel="nofollow"> tema4-checker-win.zip</a></div>
</li>
</ul>
</li>
<li class="level1"><div class="li">Pentru evaluare și corectare tema va fi uploadată folosind <a href="https://elf.cs.pub.ro/vmchecker/ui" class="urlextern" title="https://elf.cs.pub.ro/vmchecker/ui"  rel="nofollow"> interfața vmchecker</a>.</div>
</li>
<li class="level1"><div class="li">În urma compilării temei trebuie să rezulte o bibliotecă shared-object (Linux) denumită <code>libscheduler.so</code> sau o bibliotecă dinamică (Windows) denumită <code>libscheduler.dll</code>.</div>
</li>
<li class="level1"><div class="li">Suita de teste conține un set de teste. Trecerea unui test conduce la obținerea punctajului aferent acestuia.</div>
<ul>
<li class="level2"><div class="li">În urma rulării testelor, se va acorda, în mod automat, un punctaj total. Punctajul total maxim este de 90 de puncte, pentru o temă care trece toate testele. La acest punctaj se adaugă 10 puncte care reprezintă aprecierea temei de către asistentul care o corectează.</div>
</li>
<li class="level2"><div class="li">Cele 100 de puncte corespund la 10 puncte din cadrul notei finale.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li">Pot exista penalizări în caz de întârzieri sau pentru neajunsuri de implementare sau de stil. Ca excepție, pot apărea depunctări mai mari de 1 pct, în cazul în care tema trece teste prin “hackuri” în implementare (ex: sincronizări cu sleep, threadurile nu rulează peste threaduri reale din sistem, etc).</div>
</li>
<li class="level1"><div class="li"><strong>Testul 0</strong> din cadrul checker-ului temei verifică automat coding style-ul surselor voastre. Ca referință este folosit <a href="https://www.kernel.org/doc/Documentation/CodingStyle" class="urlextern" title="https://www.kernel.org/doc/Documentation/CodingStyle"  rel="nofollow"> stilul de coding din kernelul Linux</a>. Acest test nu oferă sau scade puncte, dar poate fi folosit orientativ de către echipa de corectare pentru a penaliza problemele grave de coding style. Important este să vă definiți un stil și să-l folosiți consecvent. Pentru mai multe informații despre un cod de calitate citiți <a href="../../../../so/laboratoare/resurse/c_tips.html" class="urlextern" title="http://ocw.cs.pub.ro/courses/so/laboratoare/resurse/c_tips"  rel="nofollow"> pagina de recomandări</a>.</div>
</li>
</ul>

</div>
<!-- EDIT15 SECTION "Testare" [11024-13037] -->
<h2 class="sectionedit16" id="notare">Notare</h2>
<div class="level2">

<p>
Nota maximă este de 100p.
</p>

<p>
Depunctări suplimentare:
</p>
<ul>
<li class="level1"><div class="li"> <code>&#039;-0.5</code>&#039;: alocare statică a unui vector de thread-uri</div>
</li>
<li class="level1"><div class="li"> <code>&#039;-0.6</code>&#039;: erori de sincronizare (deadlock, race condition, etc.)</div>
</li>
<li class="level1"><div class="li"> <code>&#039;-2</code>&#039;: sincronizare prin sleep-uri</div>
</li>
<li class="level1"><div class="li"> <code>&#039;-2</code>&#039;: sincronizare prin busy-waiting</div>
</li>
<li class="level1"><div class="li"> <code>&#039;-1</code>&#039;: nu sunt definite structuri pentru thread-uri, planificator, cozi de priorități; lipsa abstractizării și a încapsulării datelor</div>
</li>
<li class="level1"><div class="li"> nerespectarea regulilor de <a href="../../../../so/teme/general.html" class="wikilink1" title="so:teme:general">aici</a></div>
</li>
<li class="level1"><div class="li"> alte depunctări pentru implementări greșite, ce nu respectă cerința generală a temei</div>
</li>
</ul>

</div>
<!-- EDIT16 SECTION "Notare" [13038-13630] -->
<h2 class="sectionedit17" id="materiale_ajutatoare">Materiale ajutătoare</h2>
<div class="level2">

<p>
Cursuri:
</p>
<ul>
<li class="level1"><div class="li"><a href="../../../../so/cursuri/curs-04.html" class="wikilink1" title="so:cursuri:curs-04">Curs 4</a> - Planificarea execuției</div>
</li>
<li class="level1"><div class="li"><a href="../../../../so/cursuri/curs-08.html" class="wikilink1" title="so:cursuri:curs-08">Curs 8</a> - Fire de execuție</div>
</li>
<li class="level1"><div class="li"><a href="../../../../so/cursuri/curs-09.html" class="wikilink1" title="so:cursuri:curs-09">Curs 9</a> - Sincronizare</div>
</li>
</ul>

<p>
Laboratoare:
</p>
<ul>
<li class="level1"><div class="li"><a href="../../../../so/laboratoare/laborator-08.html" class="wikilink1" title="so:laboratoare:laborator-08">Laborator 8</a></div>
</li>
<li class="level1"><div class="li"><a href="../../../../so/laboratoare/laborator-09.html" class="wikilink1" title="so:laboratoare:laborator-09">Laborator 9</a></div>
</li>
</ul>

<p>
<p><div class="noteimportant">
Resursele temei se găsesc și în repo-ul <a href="https://github.com/systems-cs-pub-ro/so-assignments" class="urlextern" title="https://github.com/systems-cs-pub-ro/so-assignments"  rel="nofollow">so-assignments</a> de pe GitHub. Repo-ul conține și un script Bash care vă ajută să vă creați un repository privat pe instanța de <a href="https://gitlab.cs.pub.ro" class="urlextern" title="https://gitlab.cs.pub.ro"  rel="nofollow">GitLab</a> a facultății. Urmăriți indicațiile din README și de pe <a href="../../../../so/teme/folosire-gitlab.html" class="wikilink1" title="so:teme:folosire-gitlab"> pagina de Wiki dedicată pentru git</a>.
</p>

<p>
În plus, responsabilii de teme se pot uita mai rapid pe <a href="https://gitlab.cs.pub.ro" class="urlextern" title="https://gitlab.cs.pub.ro"  rel="nofollow">GitLab</a> la temele voastre în cazul în care aveți probleme/bug-uri. Este mai ușor să primiți suport în rezolvarea problemelor implementării voastre dacă le oferiți responsabililor de teme acces la codul sursă pe <a href="https://gitlab.cs.pub.ro" class="urlextern" title="https://gitlab.cs.pub.ro"  rel="nofollow">GitLab</a>.
</p>

<p>
<strong>Dacă ați folosit <a href="https://gitlab.cs.pub.ro" class="urlextern" title="https://gitlab.cs.pub.ro"  rel="nofollow">GitLab</a> pentru realizarea temei, indicați în README link-ul către repository. Asigurați-vă că responsabilii de teme au drepturi de citire asupra repo-ului vostru</strong>.

</div></p>
</p>

</div>
<!-- EDIT17 SECTION "Materiale ajutătoare" [13631-14931] -->
<h2 class="sectionedit18" id="faq">FAQ</h2>
<div class="level2">
<ul>
<li class="level1"><div class="li"><strong>Q:</strong> Tema se poate face în C++?</div>
<ul>
<li class="level2"><div class="li"><strong>A:</strong> Nu.</div>
</li>
</ul>
</li>
</ul>

</div>
<!-- EDIT18 SECTION "FAQ" [14932-15003] -->
<h2 class="sectionedit19" id="suport_intrebari_si_clarificari">Suport, întrebări și clarificări</h2>
<div class="level2">

<p>
Pentru întrebări sau nelămuriri legate de temă folosiți <a href="../../../../so/info/lista-discutii.html" class="wikilink1" title="so:info:lista-discutii">lista de discuții</a> sau <a href="../../../../so/info/documentatie.html#social_media" class="wikilink1" title="so:info:documentatie">canalul de IRC</a>.
</p>

</div>
<!-- EDIT19 SECTION "Suport, întrebări și clarificări" [15004-] --></div>
</body>
</html>
