    
    

<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
  <meta charset="utf-8" />
  <title>so:meta:examen:2014-2015</title>
<meta name="generator" content="DokuWiki"/>
<meta name="robots" content="index,follow"/>
<meta name="date" content="2016-06-03T18:00:38+0300"/>
<meta name="keywords" content="so,meta,examen,2014-2015"/>
<link rel="search" type="application/opensearchdescription+xml" href="../../../../../lib/exe/opensearch.php" title="CS Open CourseWare"/>
<link rel="start" href="../../../../../../courses.1.html"/>
<link rel="alternate" type="application/rss+xml" title="Recent Changes" href="../../../../../feed.php"/>
<link rel="alternate" type="application/rss+xml" title="Current Namespace" href="../../../../../feed.php%3Fmode=list&amp;ns=so:meta:examen"/>
<link rel="alternate" type="text/html" title="Plain HTML" href="2014-2015.html"/>
<link rel="canonical" href="../../../../../so/meta/examen/2014-2015.html"/>
<link rel="stylesheet" type="text/css" href="../../../../../lib/exe/css.php%3Ft=arctic&amp;tseed=1476798676.css"/>
<script type="text/javascript">/*<![CDATA[*/var NS='so:meta:examen';var JSINFO = {"id":"so:meta:examen:2014-2015","namespace":"so:meta:examen","isadmin":0,"isauth":0};
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="../../../../../lib/exe/js.php%3Ftseed=1476798676"></script>
<script type="text/x-mathjax-config">/*<![CDATA[*/MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ["$","$"], ["\\(","\\)"] ],
        displayMath: [ ["$$","$$"], ["\\[","\\]"] ],
        processEscapes: true
    }
});
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
<script type="text/javascript">/*<![CDATA[*/
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
		  
/*!]]>*/</script>
<script type="text/javascript">/*<![CDATA[*/
var pageTracker = _gat._getTracker("UA-38383934-1");
pageTracker._initData();
pageTracker._trackPageview();
		  
/*!]]>*/</script>
</head>
<body>
<div class="dokuwiki export">
<!-- TOC START -->
<div id="dw__toc">
<h3 class="toggle">Table of Contents</h3>
<div>

<ul class="toc">
<li class="level2"><div class="li"><a href="2014-2015.html#examen_cacc_2014-2015">Examen CA/CC 2014-2015</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="2014-2015.html#examen_final">Examen final</a></div>
<ul class="toc">
<li class="level4"><div class="li"><a href="2014-2015.html#foi_de_examen">Foi de examen</a></div></li>
</ul>
</li>
<li class="level3"><div class="li"><a href="2014-2015.html#lucrari">Lucrări</a></div>
<ul class="toc">
<li class="level4"><div class="li"><a href="2014-2015.html#lucrare_1">Lucrare 1</a></div></li>
<li class="level4"><div class="li"><a href="2014-2015.html#lucrare_2">Lucrare 2</a></div></li>
<li class="level4"><div class="li"><a href="2014-2015.html#lucrare_3">Lucrare 3</a></div></li>
<li class="level4"><div class="li"><a href="2014-2015.html#lucrare_4">Lucrare 4</a></div></li>
</ul>
</li>
<li class="level3"><div class="li"><a href="2014-2015.html#examene_anterioare">Examene anterioare</a></div></li>
</ul></li>
</ul>
</div>
</div>
<!-- TOC END -->

<h2 class="sectionedit1" id="examen_cacc_2014-2015">Examen CA/CC 2014-2015</h2>
<div class="level2">

<p>
Urmăriți precizările din <a href="../../../../../so/meta/notare/reguli-notare-ca-cc.html" class="wikilink1" title="so:meta:notare:reguli-notare-ca-cc">pagina de reguli</a>.
</p>

</div>
<!-- EDIT1 SECTION "Examen CA/CC 2014-2015" [1-123] -->
<h3 class="sectionedit2" id="examen_final">Examen final</h3>
<div class="level3">

<p>
Puteți participa la o singură sesiune de examen final.
</p>

</div>

<h4 id="foi_de_examen">Foi de examen</h4>
<div class="level4">
<ul>
<li class="level1"><div class="li"> 11 iunie 2015 ( <a href="http://elf.cs.pub.ro/so/res/examen/2014-2015/SO_2014-2015_Examen_2015-06-11.pdf" class="urlextern" title="http://elf.cs.pub.ro/so/res/examen/2014-2015/SO_2014-2015_Examen_2015-06-11.pdf"  rel="nofollow">foaie examen</a> )</div>
</li>
<li class="level1"><div class="li"> 15 iunie 2015 ( <a href="http://elf.cs.pub.ro/so/res/examen/2014-2015/SO_2014-2015_Examen_2015-06-15.pdf" class="urlextern" title="http://elf.cs.pub.ro/so/res/examen/2014-2015/SO_2014-2015_Examen_2015-06-15.pdf"  rel="nofollow">foaie examen</a> )</div>
</li>
<li class="level1"><div class="li"> 1 septembrie 2015 ( <a href="http://elf.cs.pub.ro/so/res/examen/2014-2015/SO_2014-2015_Examen_2015-09-01.pdf" class="urlextern" title="http://elf.cs.pub.ro/so/res/examen/2014-2015/SO_2014-2015_Examen_2015-09-01.pdf"  rel="nofollow">foaie examen</a> )</div>
</li>
<li class="level1"><div class="li"> 10 septembrie 2015 ( <a href="http://elf.cs.pub.ro/so/res/examen/2014-2015/SO_2014-2015_Examen_2015-09-10.pdf" class="urlextern" title="http://elf.cs.pub.ro/so/res/examen/2014-2015/SO_2014-2015_Examen_2015-09-10.pdf"  rel="nofollow">foaie examen</a> )</div>
</li>
</ul>

</div>
<!-- EDIT2 SECTION "Examen final" [124-714] -->
<h3 class="sectionedit3" id="lucrari">Lucrări</h3>
<div class="level3">
<ul>
<li class="level1"><div class="li"> Dacă nu puteți participa la seria fiecăruia, puteți veni la cealaltă serie. Pentru aceasta trimiteți un e-mail catre <a href="mailto:&#x72;&#x61;&#x7a;&#x76;&#x61;&#x6e;&#x2e;&#x64;&#x65;&#x61;&#x63;&#x6f;&#x6e;&#x65;&#x73;&#x63;&#x75;&#x40;&#x63;&#x73;&#x2e;&#x70;&#x75;&#x62;&#x2e;&#x72;&#x6f;" class="mail" title="&#x72;&#x61;&#x7a;&#x76;&#x61;&#x6e;&#x2e;&#x64;&#x65;&#x61;&#x63;&#x6f;&#x6e;&#x65;&#x73;&#x63;&#x75;&#x40;&#x63;&#x73;&#x2e;&#x70;&#x75;&#x62;&#x2e;&#x72;&#x6f;">Răzvan</a> cu subiectul <code>[SO][Lucrare X] Transfer Prenume Nume, Grupa</code> unde:</div>
<ul>
<li class="level2"><div class="li"> <code>X</code> este indexul lucrării (1, 2, 3 sau 4)</div>
</li>
<li class="level2"><div class="li"> <code>Prenume</code> este prenumele.</div>
</li>
<li class="level2"><div class="li"> <code>Nume</code> este numa.</div>
</li>
<li class="level2"><div class="li"> <code>Grupa</code> este grupa.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Nu există sesiune de contestații pentru lucrările de curs. În cazul în care considerați că au fost lipsuri la corectarea lucrării, trimiteți un e-mail catre <a href="mailto:&#x72;&#x61;&#x7a;&#x76;&#x61;&#x6e;&#x2e;&#x64;&#x65;&#x61;&#x63;&#x6f;&#x6e;&#x65;&#x73;&#x63;&#x75;&#x40;&#x63;&#x73;&#x2e;&#x70;&#x75;&#x62;&#x2e;&#x72;&#x6f;" class="mail" title="&#x72;&#x61;&#x7a;&#x76;&#x61;&#x6e;&#x2e;&#x64;&#x65;&#x61;&#x63;&#x6f;&#x6e;&#x65;&#x73;&#x63;&#x75;&#x40;&#x63;&#x73;&#x2e;&#x70;&#x75;&#x62;&#x2e;&#x72;&#x6f;">Răzvan</a>.</div>
<ul>
<li class="level2"><div class="li"> Folosiți subiectul <code>[SO][Lucrare X] Prenume Nume, Grupa</code>; de exemplu <code>[SO][Lucrare 1] Andreea Popescu, 332CA</code>.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Pentru a fi punctat, răspunsul la o întrebare trebuie să fie <strong>justificat</strong>.</div>
</li>
</ul>

</div>

<h4 id="lucrare_1">Lucrare 1</h4>
<div class="level4">
<ul>
<li class="level1"><div class="li"> La începutul cursului 4:</div>
<ul>
<li class="level2"><div class="li"> marți, 17 martie 2015, 09:05-09:15, EC004, seria CA</div>
</li>
<li class="level2"><div class="li"> miercuri, 18 martie 2015, 17:05-17:15, EC004, seria CC</div>
</li>
</ul>
</li>
</ul>

</div>

<h5 id="ca_varianta_1">3CA, varianta 1</h5>
<div class="level5">
<ol>
<li class="level1"><div class="li"> În ce situație practică este folosit apelul <code>dup()</code>?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: Apelul <code>dup()</code> este folosit practic pentru redirectarea ieșirii, intrării sau erorii standard în fișier. Altă situație practică este pentru operatorul <code>|</code> (<em>pipe</em>) de comunicare între procese.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Ce conține tabela de descriptori de fișier a unui proces?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: Tabela de descriptori de fișier a unui proces conține pointeri; ca structură de date este un vector de pointeri. Acești pointeri referă structuri de fișier deschis de proces. Când un proces deschide un fișier, se alocă o structură de fișier deschis, iar adresa acestei structuri este stocată într-un loc liber (indicat de descriptorul de fișier) din tabela de descriptori de fișier.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Apelul <code>wait()</code> este un apel blocant. Când are loc deblocarea procesului blocat în <code>wait()</code>?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: Un proces este deblocat din apelul <code>wait()</code> atunci când unul dintre procesele sale copil își încheie execuția. În acel moment, apelul <code>wait()</code> se deblochează și întoarce informații despre modul în care și-a încheiat procesul copil execuția.</div>
</li>
</ul>
</li>
</ol>

</div>

<h5 id="ca_varianta_2">3CA, varianta 2</h5>
<div class="level5">
<ol>
<li class="level1"><div class="li"> De ce nucleul sistemului de operare rulează, în general, într-un spațiu dedicat, numit <em>kernel space</em>?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: Pentru că în <em>kernel space</em> au loc operații privilegiate. Spațiul kernel este un spațiu privilegiat la care doar nucleul sistemului de operare are acces. În felul acesta se păstrează securitatea sistemului, orice operație privilegiată necesitând trecerea în spațiul kernel și acordul nucleului sistemului de operare pentru execuție.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Care este un avantaj al apelurilor de tipul <em>buffered I/O</em> (precum <code>fread</code>, <code>fwrite</code>) și care este un avantaj al celor de tipul <em>system I/O</em> (precum <code>read</code>, <code>write</code>)?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: Apelurile de tipul <em>buffered I/O</em> fac mai puține apeluri de sistem, deci overhead mai redus, întrucât informația este ținută în buffere până la nevoia de flush. Sunt, de asemenea, portabile. Apelurile de tipul <em>system I/O</em> au o latența mai redusă, informațiile ajung repede pe dispozitiv. De asemenea, apelurile de tipul <code>system I/O</code> nu alocă memorie suplimentară pentru buffering, sunt mai economice din acest punct de vedere.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> De ce spunem despre apelul <code>fork()</code> că este invocat o dată dar se întoarce de două ori?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: Apelul <em>fork()</em> este invocat o dată de procesul părinte și se întoarce de două ori: o dată în procesul părinte pentru continuarea execuției acestuia și altă dată în procesul copil de unde va rula acesta.</div>
</li>
</ul>
</li>
</ol>

</div>

<h5 id="cc_varianta_1">3CC, varianta 1</h5>
<div class="level5">
<ol>
<li class="level1"><div class="li"> Un descriptor de fișier gestionează/referă, în general, un fișier obișnuit (<em>regular file</em>). Ce altceva mai poate referi?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: Un descriptor de fișier mai poate referi un director, un link simbolic, un pipe, un socket, un dispozitiv bloc sau caracter. Toate aceste entități sunt gestionate de un proces prin intermediul unui descriptor de fișier.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Dați exemplu de apel care modifică dimensiunea unui fișier.</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: Apeluri care pot modifica dimensiunea unui fișier sunt <code>write</code> (poate scrie dincolo de limita unui fișier), <code>ftruncate</code> (modifică chiar câmpul dimensiune) sau <code>open</code> cu argumentul <code>O_TRUNC</code> care reduce dimensiunea fișierului la 0.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Ce este un proces zombie?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: Un proces zombie este un proces care și-a încheiat execuția dar care nu a fost încă așteptat de procesul său părinte.</div>
</li>
</ul>
</li>
</ol>

</div>

<h5 id="cc_varianta_2">3CC, varianta 2</h5>
<div class="level5">
<ol>
<li class="level1"><div class="li"> Câte tabele de descriptori de fișier există la nivelul sistemului de operare?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: Fiecare proces are o tabelă de descriptori de fișier, deci vor exista, la nivelul sistemului de operare, atâtea tabele de descriptori de fișier câte procese există în acel moment în sistem.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Dați un exemplu de informație care se găsește în structura de fișier deschis și un exemplu de informație care se găsește în structura de fișier pe disc (<em>inode</em>).</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: În structura de fișier deschis se găsesc cursorul de fișier, permisiunile de deschidere a fișierului, pointer către structura de fișier pe disc. În structura de fișier pe disc se găsesc permisiuni de acces, informații despre utilizatorul deținător, grupul deținător, dimensiunea fișierului, timpi de acces, tipul fișierului, pointeri către blocurile de date.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Dați exemplu de situație care duce la trecerea unui proces din starea <code>RUNNING</code> în starea <code>READY</code>.</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: Un proces trece din starea <code>RUNNING</code> în starea <code>READY</code> atunci când îi expiră cuanta de rulare sau când există un proces cu prioritate mai mare în coada <code>READY</code> (care să îi ia locul).</div>
</li>
</ul>
</li>
</ol>

</div>

<h4 id="lucrare_2">Lucrare 2</h4>
<div class="level4">
<ul>
<li class="level1"><div class="li"> La începutul cursului 7:</div>
<ul>
<li class="level2"><div class="li"> marți, 7 aprilie 2015, 08:05-08:15, EC004, seria CA</div>
</li>
<li class="level2"><div class="li"> miercuri, 8 aprilie 2015, 17:05-17:15, EC004, seria CC</div>
</li>
</ul>
</li>
</ul>

</div>

<h5 id="ca_varianta_11">3CA, varianta 1</h5>
<div class="level5">
<ol>
<li class="level1"><div class="li"> Numiți o sursă de overhead care apare atunci când sistemul de operare schimbă contextul de execuție între două procese.</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: Surse de overhead pentru schimbarea de context între procese sunt schimbarea tabelei de pagini, care conduce la flush la TLB, algoritmul de alegere a următorului proces și schimbarea efectivă de context, cu salvarea registrelor procesului curent și restaurarea procesului ales.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> De ce este uzual și avantajos ca spațiul virtual de adrese al proceselor să cuprindă o zonă dedicată pentru kernel?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: Prezența zonei dedicate pentru kernel în spațiul de adresă al fiecărui proces înseamnă că la fiecare apel de sistem, adică la trecerea din user space în kernel space, tabela de pagini rămâne aceeași și nu se face flush la TLB. În cazul în care kernel-ul ar avea o zonă dedicată, atunci ar avea și o tabelă de pagini dedicată și ar trebui schimbată tabela de pagini la fiecare apel de sistem și la fiecare revenire din apel de sistem.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Procesul P1 folosește <code>100MB</code> de memorie fizică (RAM) rezidentă. P1 execută <code>fork()</code> și rezultă procesul P2. Câtă memorie fizică (RAM) rezidentă folosesc împreună P1 și P2 imediat dupa <code>fork()</code>? De ce?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: Apelul <code>fork()</code> folosește <em>copy-on-write</em> ceea ce înseamnă că nu se alocă memorie rezidentă nouă pentru noul proces. Se alocă, într-adevăr, o nouă tabelă de pagini, dar spațiul rezident al procesului P1 este acum partajat cu procesul P2 până la prima operație de scriere, când pagina aferentă va fi duplicată.</div>
</li>
</ul>
</li>
</ol>

</div>

<h5 id="ca_varianta_21">3CA, varianta 2</h5>
<div class="level5">
<ol>
<li class="level1"><div class="li"> Descrieți o problemă posibilă care poate apărea dacă un sistem de operare implementează un algoritm de planificare de tipul <em>Shortest Job First</em>.</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: În cazul unei planificări <em>Shortest Job First</em>, dacă sunt adăugate în sistem, în mod constant, procese noi și de durată scurtă, procesele de durată mai lungă nu vor apuca să ruleze. Va rezulta într-un timp de așteptare foarte mare pentru procesele de lungă durată sau chiar în <code>starvation</code> (așteptare nedefinită pentru ca un proces să poată rula pe procesor).</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Care este utilitatea conceptului de <em>demand paging</em>?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: Atunci când sistemul de operare folosește <em>demand paging</em> alocarea de memorie fizică este amânată până în momentul în care nevoie (adică la primul acces). Sistemul de operare doar rezervă memorie virtuală și nu alocă memorie fizică în spate, economisind memorie fizică. La primul acces se alocă și memorie fizică, la cerere (adică <em>on demand</em>) și se face maparea acesteia la spațiul virtual (<em>paging</em>).</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> De ce zonele <code>.text</code> și <code>.rodata</code> din cadrul bibiliotecilor partajate (<code>shared libraries</code>) pot fi partajate între mai multe procese?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: Zonele <code>.text</code> și <code>.rodata</code> sunt zone <em>read only</em>. Acest lucru înseamna că pot fi partajate în siguranță pentru că nici un proces care accesează zona nu o va putea modifica. Zonele conțin permanent aceleași informații indiferent de numărul de procese care le folosesc și pot fi, deci, partajate.</div>
</li>
</ul>
</li>
</ol>

</div>

<h5 id="cc_varianta_11">3CC, varianta 1</h5>
<div class="level5">
<ol>
<li class="level1"><div class="li"> La ce se referă noțiunea de timp de așteptare (<em>waiting time</em>) în contextul planificării proceselor (<em>process scheduling</em>)?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: Noțiunea de <em>waiting time</em> se referă la timpul de așteptare al unui proces în coada <code>READY</code> a planificatorului. Pentru un sistem interactiv/responsiv este de dorit ca timpul de așteptare să fie cât mai scurt.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> De ce este utilă paginarea ierarhică?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: Dacă nu am folosi paginare ierarhică tabelele de pagini ar ocupa foarte mult spațiu; ar fi neovie de o intrare pentru fiecare pagină virtuală a unui proces. Paginarea ierarhică conduce la reducerea spațiului ocupat de tabela de pagini, profitând de faptul că o bună parte din spațiul virtual de adrese al procesului nu este folosit.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Care este o cauză sursă pentru evacuarea unei pagini din memoria fizică (RAM) pe disc (<em>swap out</em>)?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: Cauze sursă pentru evacuarea unei pagini din RAM sunt:</div>
<ul>
<li class="level3"><div class="li"> operația de <em>swap in</em>, care necesită o pagină liberă în RAM, conducând la o operația de <em>swap out</em></div>
</li>
<li class="level3"><div class="li"> alocarea unei pagini fizice noi; nu există pagini libere, se execută <em>swap out</em></div>
</li>
<li class="level3"><div class="li"> <em>demand paging</em>, la fel ca mai sus</div>
</li>
<li class="level3"><div class="li"> <em>copy on write</em> care necesită alocarea unei noi pagini fizice, posibil inexistente</div>
</li>
</ul>
</li>
</ul>
</li>
</ol>

</div>

<h5 id="cc_varianta_21">3CC, varianta 2</h5>
<div class="level5">
<ol>
<li class="level1"><div class="li"> Care este un avantaj și un dezavantaj al folosirii unei cuante de timp scurte în planificarea proceselor (<em>process scheduling</em>)?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: Folosirea unei cuante de timp scurte înseamnă un sistem interactiv și responsiv. Dar înseamnă și schimbări dese de context adică un randament mai scăzut al sistemului în a rula procese, deci o productivitate (<em>throughput</em>) redusă.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Ce conține tabela de pagini a unui proces?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: Tabela de pagini a unui proces conține pointeri de pagini fizice. Indexul în tabelă este pagina virtuală. În general tabela de pagini mai conține și informații legate de permisiuni, validatate, dacă pagina a fost sau nu modificată.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Dați exemplu de situație care cauzează <em>page fault</em> <strong>fără</strong> a rezulta în trimiterea unei excepții de acces la memorie (de tipul <code>SIGSEGV</code>, <em>Segmentation fault</em>) către procesul care a generat <em>page fault</em>-ul.</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: Dacă un proces are rezervat un spațiu virtual în modul <em>demand paging</em> atunci accesarea unei pagini virtuale din acel spațiu va conduce la <em>page fault</em>. În urma <em>page fault</em>-ului, se va aloca și mapa o pagină fizică, iar procesul își va continua execuția. Nu va fi generată excepție de acces la memorie. La fel se întâmplă și în cazul <em>copy-on-write</em>.</div>
</li>
</ul>
</li>
</ol>

</div>

<h4 id="lucrare_3">Lucrare 3</h4>
<div class="level4">
<ul>
<li class="level1"><div class="li"> La începutul cursului 10:</div>
<ul>
<li class="level2"><div class="li"> marți, 5 mai 2015, 09:05-09:15, EC004, seria CA</div>
</li>
<li class="level2"><div class="li"> miercuri, 6 mai 2015, 17:05-17:15, EC004, seria CC</div>
</li>
</ul>
</li>
</ul>

</div>

<h5 id="ca_varianta_12">3CA, varianta 1</h5>
<div class="level5">
<ol>
<li class="level1"><div class="li"> De ce este relevant, în contextul securității memoriei, faptul că adresa de retur a unei funcții se reține pe stivă?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: Adresa de retur stocată în memorie oferă unui atacator posibilitatea suprascrierii acesteia și alterarea fluxului normal de execuție al programului. Pentru aceasta este nevoie de o vulnerabilitate într-un buffer la nivelul stivei. În general folosirea de adrese pe stive oferă această posibilitate si e de evitat, dar nu putem face asta în privința adresei de retur; este nevoie de stocarea pe stivă pentru a putea reveni în stack frame-ul anterior.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Care este un avantaj și un dezavantaj al folosirii unei implementări de thread-uri în user space (<em>user-level threads</em>)?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>:</div>
<ul>
<li class="level3"><div class="li"> Avantaje pot fi:</div>
<ul>
<li class="level4"><div class="li"> timp de creare mai mic decât thread-urile kernel level</div>
</li>
<li class="level4"><div class="li"> schimbări de context mai rapide</div>
</li>
<li class="level4"><div class="li"> control mai bun asupra aspectelor de planificare (totul se întâmplă în user space, sub controlul programatorului)</div>
</li>
</ul>
</li>
<li class="level3"><div class="li"> Dezavantaje pot fi:</div>
<ul>
<li class="level4"><div class="li"> blocarea unui thread duce la blocarea întregului proces</div>
</li>
<li class="level4"><div class="li"> nu poate fi folosit suportul multiprocesor</div>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="level1"><div class="li"> De ce este importantă o instrucțiune de tip <code>TSL</code> (<em>test and set lock</em>) la nivelul procesorului?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: Implementările de mecanisme de sincronizare se bazează pe instrucțiuni hardware. Fără suportul procesorului pentru operații atomice (precum <code>TSL</code> sau <code>cmpxchg</code>) nu ar fi posibilă implementarea unor mecanisme precum spinlock-uri. Astfel de instrucțiuni vor fi disponibile pentru orice procesor pentru a permite implementarea mecanismelor de sincronizare.</div>
</li>
</ul>
</li>
</ol>

</div>

<h5 id="ca_varianta_22">3CA, varianta 2</h5>
<div class="level5">
<ol>
<li class="level1"><div class="li"> De ce folosirea DEP (<em>Data Execution Prevention</em>) <strong>nu</strong> previne atacurile de tipul <em>return-to-libc</em>?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: DEP previne existența simultană a permisiunilor de scriere și execuție. Adică nu se poate scrie într-o zonă un shellcode (sau ceva similar) care apoi să se execute. Un atac de tipul <em>return-to-libc</em> presupune suprascrierea unei adrese (de retur, pointer de funcție) ca să pointeze către o funcție din biblioteca standard C. Întrucât un atac de tipul <em>return-to-libc</em> nu presupune scriere și execuție a aceleiași zone, nu poate fi prevenit de DEP.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Care este un avantaj și un dezavantaj al folosirii unei implementări de thread-uri cu suport în kernel (<em>kernel-level threads</em>)?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>:</div>
<ul>
<li class="level3"><div class="li"> Avantaje pot fi:</div>
<ul>
<li class="level4"><div class="li"> dacă un thread se blochează celelalte thread-uri pot rula</div>
</li>
<li class="level4"><div class="li"> se folosește suportul multiprocesor al sistemului</div>
</li>
<li class="level4"><div class="li"> planificator robust asigurat de sistemul de operare, preemptiv</div>
</li>
</ul>
</li>
<li class="level3"><div class="li"> Dezavantaje pot fi:</div>
<ul>
<li class="level4"><div class="li"> timp de creare mai mare (necesită apel de sistem)</div>
</li>
<li class="level4"><div class="li"> schimbare de context mai lentă (overhead datorat trecerii în kernel space pentru invocarea planificatorului)</div>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Precizați un dezavantaj al folosirii primitivelor de sincronizare.</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: Dezavantaje sunt:</div>
<ul>
<li class="level3"><div class="li"> lock contention: mai multe thread-uri așteaptă la un lock (un singur thread poate accesa regiunea critică protejată de lock) → ineficiență</div>
</li>
<li class="level3"><div class="li"> lock overhead: apelul de lock/unlock produce overhead, de multe ori însemnând apel de sistem</div>
</li>
<li class="level3"><div class="li"> serializarea codului: codul protejat de un lock este cod serial, accesibil unui singur thread; nu avem paralelism</div>
</li>
<li class="level3"><div class="li"> deadlock: o folosire necorespunzătoare a primitivelor de sincronizare duce la deadlock sau livelock</div>
</li>
</ul>
</li>
</ul>
</li>
</ol>

</div>

<h5 id="cc_varianta_12">3CC, varianta 1</h5>
<div class="level5">
<ol>
<li class="level1"><div class="li"> De ce trebuie avut grijă la construcțiile precum cea de mai jos în cadrul unei funcții?<pre class="code">        int (*fn_ptr)(int, int);  /* fn_ptr is a function pointer */
        char buffer[128];    /* buffer for storing strings */</pre>
</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: În construcția din exercițiu dacă nu se ține cont de dimensiunea buffer-ului se poate obține un <em>buffer overflow</em>. În urma overflow-ului, se suprascrie pointer-ul de funcție <code>fn_ptr</code>. Probabil acest pointer va fi folosit la un moment dat rezultând în execuția arbitrară și alterând fluxul normal de execuție al programului.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> De ce dimensiunea spațiului virtual de adresă al unui proces crește în momentul creării unui thread (chiar dacă thread-ul nu ajuns încă să se execute)?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: În momentul creării unui thread se alocă o stivă nouă acelui thread. În mod implicit, pe sistemele Linux, dimensiunea stivei este de 8 <abbr title="Megabyte">MB</abbr> de memorie, observând o creștere semnificativă a spațiului virtual de adresă al procesului.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Când este recomandat să folosim un spinlock în locul unui mutex?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: Spinlock-ul folosește busy-waiting și are operații de <code>lock()</code> și <code>unlock()</code> ieftine prin comparație cu mutex-ul. Operațiilor de <code>lock()</code> și <code>unlock()</code> pe mutex sunt de obicei costisitoare întrucât pot ajunge să invoce planificatorul. Având operații rapide, spinlock-ul este potrivit pe secțiuni critice de mici dimensiuni în care nu se fac operații blocante; în aceste cazuri faptul că face busy-waiting nu contează așa de mult pentru că va intra rapid în regiunea critică. Dacă am folosi un mutex pentru o regiune critică mică, atunci overhead-ul cauzat de operațiile pe mutex ar fi relativ semnificativ față de timpul scurt petrecut în regiunea critică, rezultând în ineficiența folosirii timpului pe procesor.</div>
</li>
</ul>
</li>
</ol>

</div>

<h5 id="cc_varianta_22">3CC, varianta 2</h5>
<div class="level5">
<ol>
<li class="level1"><div class="li"> De ce, în general, un shellcode se încheie cu invocarea apelului de sistem <code>execve</code>?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: Un shellcode încearcă, în general, rularea unui program nou, de exemplu a unui shell în forma echivalentă a unui apel <code>execve(”/bin/sh”)</code>. Întrucât un apel de bibliotecă este mai dificil de realizat, se preferă o instrucțiune simplă de apel de sistem (precum <code>int 0x80</code>. Se face un apel de sistem <code>execve</code> cu un argument de forma unui șir <code>/bin/sh</code> într-un registru rezultând în crearea unui shell nou.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> De ce schimbarea de context între două thread-uri ale aceluiași proces este, în general, mai rapidă decât schimbarea de context între două procese?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: Schimbarea între două thread-uri ale aceluiași proces este mai rapidă decât schimbarea de context între două procese pentru că nu este nevoie de schimbarea spațiului de adresă. Schimbarea spațiului de adresă este relativ costisitoare pentrucă presupune schimbarea tabelei de pagini și golirea multor intrări din TLB.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Care sunt cele două tipuri de operații aferente mecanismelor de sincronizare prin secvențiere/ordonare?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: Cele două operații aferente mecanismelor de sincronizare prin secvențiere/ordonare sunt:</div>
<ul>
<li class="level3"><div class="li"> <code>wait()</code> pentru așteptarea îndeplinirii unei condiții după care thread-ul curent va rula;</div>
</li>
<li class="level3"><div class="li"> <code>notify()</code> sau <code>signal()</code> pentru a anunța thread-ul/thread-urile blocate în operația <code>wait()</code> de îndeplinirea condiției.</div>
</li>
</ul>
</li>
</ul>
</li>
</ol>

</div>

<h4 id="lucrare_4">Lucrare 4</h4>
<div class="level4">
<ul>
<li class="level1"><div class="li"> La începutul cursului 13:</div>
<ul>
<li class="level2"><div class="li"> marți, 26 mai 2015, 09:05-09:15, EC004, seria CA</div>
</li>
<li class="level2"><div class="li"> miercuri, 27 mai 2015, 17:05-17:15, EC004, seria CC</div>
</li>
</ul>
</li>
</ul>

</div>

<h5 id="ca_varianta_13">3CA, varianta 1</h5>
<div class="level5">
<ol>
<li class="level1"><div class="li"> O aplicație execută un apel <code>send()</code> cu <code>1024</code> de octeți de date, iar apelul <code>send</code> întoarce <code>1024</code>. Alegeți varianta corectă de mai jos și argumentați: În acest moment, aplicația sender poate fi sigură că datele au fost livrate cu succes către</div>
<ul>
<li class="level2"><div class="li"> nucleul SO de pe sistemul destinație</div>
</li>
<li class="level2"><div class="li"> aplicația destinație</div>
</li>
<li class="level2"><div class="li"> datele au fost salvate în send-buffer-ul de pe sistemul transmițătorului</div>
</li>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: Datele au fost salvate în buffer-ul de send al transmițătorului. În momentul în care datele au fost scrise acolo, apelul se întoarce. Este posibil ca datele să nu fi părăsit sistemul, dar apelul se va întoarce. Stiva TCP se va ocupa de transmiterea datelor din buffer-ul de send către destinație.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Indicați două obiective ale algoritmilor de planificare a cererilor pentru hard disk, și dați un exemplu de algoritm care le îndeplinește.</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: Un obiectiv este performanță ridicată. Un alt obiectiv este fairness: asigurarea că toate procesele au acces echitabil la resurse și că un proces nu așteaptă mai mult ca altul accesul la disc. Un algoritm care colectează mai multe cereri și apoi le sortează și agregă, independent de procesul care le cauzează va atinge obiectivele. Algoritmi precum C-SCAN sau C-LOOK sau altele satisfac aceste obiective.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Precizați două diferențe între un <em>symbolic link</em> și un <em>hard link</em>.</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: Un symbolic link are un inode al său, pe când un hard link este un dentry (un nume și un index de inode). Un symbolic link poate referi directoare în timp ce un hard link nu; un symbolic link poate fereri un fișier de pe altă partiție/alt sistem de fișiere, în timp ce un hard link nu.</div>
</li>
</ul>
</li>
</ol>

</div>

<h5 id="ca_varianta_23">3CA, varianta 2</h5>
<div class="level5">
<ol>
<li class="level1"><div class="li"> Explicați motivul pentru care este indicat să folosim pentru apelurile <code>send()</code> și <code>recv()</code> buffere de dimensiuni mari (de exemplu mai mari decât <code>100KB</code>).</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: Ca să transmitem mai multe date o dată si să evităm apelurile de sistem generate de apelul send și recv. Un apel de sistem va însemna overhead de timp (intare în kernel mode și apoi revenire în user mode) și overhead de copiere (transfer de date din buffer-ul din user space în buffer-ul din kernel space sau invers).</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Ce limitează performanța hard disk-ului în cazul accesului aleator la date din diverse zone ale discului?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: Mutarea capului de citire pe sectoarele/zonele necesare. Dacă există acces aleator, atunci datele vor fi plasate în diverse zone iar o operație va consta în două suboperații:</div>
<ol>
<li class="level3"><div class="li"> plasarea capului de citire</div>
</li>
<li class="level3"><div class="li"> citirea sau scrierea datelor respective</div>
</li>
</ol>
<ul>
<li class="level3"><div class="li"> Dacă datele sunt plasate aleator, operația de plasare va dura mult și va limita performanța; putem optimiza prin ordonarea cererilor și limitarea timpului de accesare. Operația de citire și scriere este standard, ține de mecanica discului, nu o putem optimiza.</div>
</li>
</ul>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Un director conține <code>N</code> subdirectoare. Câte hard link-uri pointează la acest director?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: Directorul va avea <code>N+2</code> hard link-uri. <code>N</code> hard link-uri sunt date de intrarea <code>..</code> (<em>dot dot</em>) a fiecărui subdirector (link către directorul părinte). Celelalte două hard link-uri sunt numele directorului și intrarea <code>.</code> (<em>dot</em>) care referă directorul însuși.</div>
</li>
</ul>
</li>
</ol>

</div>

<h5 id="cc_varianta_13">3CC, varianta 1</h5>
<div class="level5">
<ol>
<li class="level1"><div class="li"> De ce la plăcile de rețea de mare viteză are sens folosirea polling în locul întreruperilor pentru partea de intrare/ieșire?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: Având viteze mari, vor veni pachete foarte des și vor fi generate întreruperi foarte des. În această situație, procesorul va fi ocupat foarte mult timp rulând rutine de tratare a întreruperilor. Prin trecere la polling, procesorul interoghează placa de rețea și, dacă are date, le citesțe repede, fără întreruperi. În restul timpului face și alte lucruri, fără a mai consuma timp în rutina de tratare a întreruperilor.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> În ce situație operația <code>send()</code> pe un socket se blochează?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: Apelul <code>send()</code> pe socket se blochează în situația în care buffer-ul din kernel (<em>send buffer</em>) nu dispune de loc pentru copierea datelor din buffer-ul de user space. Sau, în anumite cazuri, precum în cazul sockeților non-blocanți, dacă nu există nici măcar 1 octet liber în buffer-ul de kernel (<em>send buffer</em>).</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Care este un avantaj și un dezavantaj al alocării indexate (cu <em>i-node</em>) pentru blocuri de date pentru fișiere?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: Principalul dezavantaj al alocării indexate este limitarea dimensiunii fișierului la numărul de intrări din lista de indecși (pointeri către blocuri). Avantajele este accesul rapid la blocuri (se citește indexul) și absența fragmentării externe: blocurile se pot găsi oriunde și pot fi referite din lista de indecși. Dezavantajul este compensat prin folosirea indirectării (simple, duble, triple) ducând la o mai mare dimensiune a fișierului, dar introducând un alt dezavantaj: timp mai mare de acces pentru blocurile din partea finală a fișierului; întrucât se trece prin blocurile de indirectare. Un dezavantaj aici poate fi și ocuparea de blocuri doar cu indecși, în loc să conțină date efective.</div>
</li>
</ul>
</li>
</ol>

</div>

<h5 id="cc_varianta_23">3CC, varianta 2</h5>
<div class="level5">
<ol>
<li class="level1"><div class="li"> De ce operația <code>lseek()</code> nu are sens pe dispozitive de tip caracter, ci doar pe dispozitive de tip bloc?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: Pentru că pe dispozitivele de tip caracter datele vin și sunt citite/scrise octet cu octet, ca într-o țeavă. Nu putem anticipa date și ne putem plasa mai sus sau mai jos pe banda de date. În cazul dispozitivelor de tip bloc însă, datele se găsesc pe un spațiu de stocare pe care ne putem plimba/glisa; putem &quot;căuta&quot; date prin plasarea pe un sector/bloc al dispozitivului de stocare și atunci operația <code>lseek()</code> are sens.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> În cazul unui apel <code>recv()</code> comandat pentru citirea a <code>789</code> de octeți, se citesc <code>123</code> de octeți. Cum se explică citirea unui număr mai mic de octeți decât cel comandat?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: În momentul citirii datelor, doar <code>123</code> de octeți erau disponibili în buffer-ul din kernel aferent socket-ului (<em>receive buffer</em>). În această situație apelul <code>recv()</code> se întoarce cu numărul de octeți disponibili (<code>123</code>) deși exista spațiu mai mare (<code>789</code>) în buffer-ul din user space.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Ce conțin blocurile de date aferente unui inode de tip director?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: Conțin un vector de <em>dentry</em>-uri. Un <em>dentry</em> este o structură ce conține numele fișierului și indexul inode-ului aferent. Fiecare intrare din director (indiferent de tipul acesteia: fișier, director, link symbolic) are un <em>dentry</em>.</div>
</li>
</ul>
</li>
</ol>

</div>
<!-- EDIT3 SECTION "Lucrări" [715-26615] -->
<h3 class="sectionedit4" id="examene_anterioare">Examene anterioare</h3>
<div class="level3">
<ul>
<li class="level1"><div class="li"> <a href="../../../../../so/meta/examen/2013-2014.html" class="wikilink1" title="so:meta:examen:2013-2014"> Examene și lucrări 2013-2014</a></div>
</li>
<li class="level1"><div class="li"> <a href="../../../../../so/meta/examen/2012-2013.html" class="wikilink1" title="so:meta:examen:2012-2013"> Examene și lucrări 2012-2013</a></div>
</li>
<li class="level1"><div class="li"> <a href="http://elf.cs.pub.ro/so/wiki/examen" class="urlextern" title="http://elf.cs.pub.ro/so/wiki/examen"  rel="nofollow"> Examene și lucrări 2011-2012</a></div>
</li>
<li class="level1"><div class="li"> <a href="http://elf.cs.pub.ro/so/wiki/examen/2010-2011" class="urlextern" title="http://elf.cs.pub.ro/so/wiki/examen/2010-2011"  rel="nofollow"> Examene și lucrări 2010-2011</a></div>
</li>
<li class="level1"><div class="li"> <a href="http://elf.cs.pub.ro/so/wiki/examen/2009-2010" class="urlextern" title="http://elf.cs.pub.ro/so/wiki/examen/2009-2010"  rel="nofollow"> Examene și lucrări 2009-2010</a></div>
</li>
<li class="level1"><div class="li"> <a href="http://elf.cs.pub.ro/so/wiki/examen/2008-2009" class="urlextern" title="http://elf.cs.pub.ro/so/wiki/examen/2008-2009"  rel="nofollow"> Examene și lucrări 2008-2009</a></div>
</li>
</ul>

</div>
<!-- EDIT4 SECTION "Examene anterioare" [26616-] --></div>
</body>
</html>
