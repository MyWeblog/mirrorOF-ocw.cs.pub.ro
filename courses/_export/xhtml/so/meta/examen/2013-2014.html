    
    

<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
  <meta charset="utf-8" />
  <title>so:meta:examen:2013-2014</title>
<meta name="generator" content="DokuWiki"/>
<meta name="robots" content="index,follow"/>
<meta name="date" content="2016-06-03T17:38:14+0300"/>
<meta name="keywords" content="so,meta,examen,2013-2014"/>
<link rel="search" type="application/opensearchdescription+xml" href="../../../../../lib/exe/opensearch.php" title="CS Open CourseWare"/>
<link rel="start" href="../../../../../../courses.1.html"/>
<link rel="alternate" type="application/rss+xml" title="Recent Changes" href="../../../../../feed.php"/>
<link rel="alternate" type="application/rss+xml" title="Current Namespace" href="../../../../../feed.php%3Fmode=list&amp;ns=so:meta:examen"/>
<link rel="alternate" type="text/html" title="Plain HTML" href="2013-2014.html"/>
<link rel="canonical" href="../../../../../so/meta/examen/2013-2014.html"/>
<link rel="stylesheet" type="text/css" href="../../../../../lib/exe/css.php%3Ft=arctic&amp;tseed=1476798676.css"/>
<script type="text/javascript">/*<![CDATA[*/var NS='so:meta:examen';var JSINFO = {"id":"so:meta:examen:2013-2014","namespace":"so:meta:examen","isadmin":0,"isauth":0};
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="../../../../../lib/exe/js.php%3Ftseed=1476798676"></script>
<script type="text/x-mathjax-config">/*<![CDATA[*/MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ["$","$"], ["\\(","\\)"] ],
        displayMath: [ ["$$","$$"], ["\\[","\\]"] ],
        processEscapes: true
    }
});
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
<script type="text/javascript">/*<![CDATA[*/
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
		  
/*!]]>*/</script>
<script type="text/javascript">/*<![CDATA[*/
var pageTracker = _gat._getTracker("UA-38383934-1");
pageTracker._initData();
pageTracker._trackPageview();
		  
/*!]]>*/</script>
</head>
<body>
<div class="dokuwiki export">
<!-- TOC START -->
<div id="dw__toc">
<h3 class="toggle">Table of Contents</h3>
<div>

<ul class="toc">
<li class="level2"><div class="li"><a href="2013-2014.html#examen_cacc_2013-2014">Examen CA/CC 2013-2014</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="2013-2014.html#examen_final">Examen final</a></div>
<ul class="toc">
<li class="level4"><div class="li"><a href="2013-2014.html#seriile_cacc">Seriile CA/CC</a></div></li>
<li class="level4"><div class="li"><a href="2013-2014.html#seria_cb">Seria CB</a></div></li>
</ul>
</li>
<li class="level3"><div class="li"><a href="2013-2014.html#lucrari">Lucrări</a></div>
<ul class="toc">
<li class="level4"><div class="li"><a href="2013-2014.html#lucrare_1">Lucrare 1</a></div></li>
<li class="level4"><div class="li"><a href="2013-2014.html#lucrare_2">Lucrare 2</a></div></li>
<li class="level4"><div class="li"><a href="2013-2014.html#lucrare_3">Lucrare 3</a></div></li>
<li class="level4"><div class="li"><a href="2013-2014.html#lucrare_4">Lucrare 4</a></div></li>
</ul></li>
</ul></li>
</ul>
</div>
</div>
<!-- TOC END -->

<h2 class="sectionedit1" id="examen_cacc_2013-2014">Examen CA/CC 2013-2014</h2>
<div class="level2">

</div>
<!-- EDIT1 SECTION "Examen CA/CC 2013-2014" [1-36] -->
<h3 class="sectionedit2" id="examen_final">Examen final</h3>
<div class="level3">

</div>

<h4 id="seriile_cacc">Seriile CA/CC</h4>
<div class="level4">
<ul>
<li class="level1"><div class="li"> Pentru seriile CA și CC, examenele finale ale cursului de Sisteme de Operare se vor desfășura astfel:</div>
<ul>
<li class="level2"><div class="li"> 25 mai 2014, ora 8:00, sala EC101 - 334CC</div>
</li>
<li class="level2"><div class="li"> 3 iunie 2014, ora 11:00, sala EC004 - 331CC, 332CC, 333CC</div>
</li>
<li class="level2"><div class="li"> 5 iunie 2014 ora 8:00, sala AN034 - 332CA, 333CA</div>
</li>
<li class="level2"><div class="li"> 8 iunie 2014, ora 8:00, sala A02 - 331CA, 334CA</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Sesiunea specială de restanțe (studenți anul 4) are loc în perioada 24 mai - 6 iunie 2014. Studenții de anul 4 pot veni într-una din cele două date de mai jos:</div>
<ul>
<li class="level2"><div class="li"> 25 mai 2014, ora 8:00, sala EC101</div>
</li>
<li class="level2"><div class="li"> 3 iunie 2014, ora 11:00, sala EC004</div>
</li>
<li class="level2"><div class="li"> 5 iunie 2014, ora 08:00, sala AN034</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Datele de mai sus sunt afișate și la avizierul facultății.</div>
</li>
<li class="level1"><div class="li"> Rugăm să veniți în intervalul stabilit grupei voastre. Dacă, din motive obiective, nu puteți participa în data repartizată, trimiteți-i un e-mail <a href="mailto:&#x6c;&#x61;&#x75;&#x72;&#x61;&#x2e;&#x67;&#x68;&#x65;&#x6f;&#x72;&#x67;&#x68;&#x65;&#x40;&#x63;&#x73;&#x2e;&#x70;&#x75;&#x62;&#x2e;&#x72;&#x6f;" class="mail" title="&#x6c;&#x61;&#x75;&#x72;&#x61;&#x2e;&#x67;&#x68;&#x65;&#x6f;&#x72;&#x67;&#x68;&#x65;&#x40;&#x63;&#x73;&#x2e;&#x70;&#x75;&#x62;&#x2e;&#x72;&#x6f;">Laurei</a> cu subiectul ”[SO] Transfer examen - Prenume Nume, Grupa”.</div>
</li>
<li class="level1"><div class="li"> Puteți participa la <strong>un singur</strong> examen.</div>
</li>
<li class="level1"><div class="li"> Pentru sesiunea septembrie 2014, examenele finale se vor desfășura astfel:</div>
<ul>
<li class="level2"><div class="li"> 4 septembrie 2014, ora 11:00, sala EC004</div>
</li>
<li class="level2"><div class="li"> 13 septembrie 2014, ora 09:00, sala EC101</div>
</li>
</ul>
</li>
</ul>
<ul>
<li class="level1"><div class="li"> 25 mai 2014 ( <a href="http://elf.cs.pub.ro/so/res/examen/2013-2014/SO_2013-2014_Examen_2014-05-24.pdf" class="urlextern" title="http://elf.cs.pub.ro/so/res/examen/2013-2014/SO_2013-2014_Examen_2014-05-24.pdf"  rel="nofollow">foaie examen</a> )</div>
</li>
<li class="level1"><div class="li"> 3 iunie 2014 ( <a href="http://elf.cs.pub.ro/so/res/examen/2013-2014/SO_2013-2014_Examen_2014-06-03.pdf" class="urlextern" title="http://elf.cs.pub.ro/so/res/examen/2013-2014/SO_2013-2014_Examen_2014-06-03.pdf"  rel="nofollow">foaie examen</a> )</div>
</li>
<li class="level1"><div class="li"> 5 iunie 2014 ( <a href="http://elf.cs.pub.ro/so/res/examen/2013-2014/SO_2013-2014_Examen_2014-06-05.pdf" class="urlextern" title="http://elf.cs.pub.ro/so/res/examen/2013-2014/SO_2013-2014_Examen_2014-06-05.pdf"  rel="nofollow">foaie examen</a> )</div>
</li>
<li class="level1"><div class="li"> 8 iunie 2014 ( <a href="http://elf.cs.pub.ro/so/res/examen/2013-2014/SO_2013-2014_Examen_2014-06-08.pdf" class="urlextern" title="http://elf.cs.pub.ro/so/res/examen/2013-2014/SO_2013-2014_Examen_2014-06-08.pdf"  rel="nofollow">foaie examen</a> )</div>
</li>
<li class="level1"><div class="li"> 4 septembrie 2014 ( <a href="http://elf.cs.pub.ro/so/res/examen/2013-2014/SO_2013-2014_Examen_2014-09-04.pdf" class="urlextern" title="http://elf.cs.pub.ro/so/res/examen/2013-2014/SO_2013-2014_Examen_2014-09-04.pdf"  rel="nofollow">foaie examen</a> )</div>
</li>
<li class="level1"><div class="li"> 13 septembrie 2014 ( <a href="http://elf.cs.pub.ro/so/res/examen/2013-2014/SO_2013-2014_Examen_2014-09-13.pdf" class="urlextern" title="http://elf.cs.pub.ro/so/res/examen/2013-2014/SO_2013-2014_Examen_2014-09-13.pdf"  rel="nofollow">foaie examen</a> )</div>
</li>
</ul>

</div>

<h4 id="seria_cb">Seria CB</h4>
<div class="level4">
<ul>
<li class="level1"><div class="li"> Pentru seria CB examenele finale se vor desfășura astfel:</div>
<ul>
<li class="level2"><div class="li"> 8 iunie 2014, ora 8:00, sala EC002 - 334CB</div>
</li>
<li class="level2"><div class="li"> 9 iunie 2014, ora 8:00, sala EC002 - 333CB</div>
</li>
<li class="level2"><div class="li"> 10 iunie 2014, ora 11:00, sala EC004 - 332CB</div>
</li>
<li class="level2"><div class="li"> 11 iunie 2014, ora 8:00, sala EC002 - 331CB</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Datele de mai sus sunt afișate și la avizierul facultății.</div>
</li>
<li class="level1"><div class="li"> Puteți participa la <strong>un singur</strong> examen.</div>
</li>
</ul>

</div>
<!-- EDIT2 SECTION "Examen final" [37-2368] -->
<h3 class="sectionedit3" id="lucrari">Lucrări</h3>
<div class="level3">
<ul>
<li class="level1"><div class="li"> Dacă nu puteți participa la seria fiecăruia, puteți veni la cealaltă serie. Pentru aceasta trimiteți un e-mail catre <a href="mailto:&#x6c;&#x61;&#x75;&#x72;&#x61;&#x2e;&#x67;&#x68;&#x65;&#x6f;&#x72;&#x67;&#x68;&#x65;&#x40;&#x63;&#x73;&#x2e;&#x70;&#x75;&#x62;&#x2e;&#x72;&#x6f;" class="mail" title="&#x6c;&#x61;&#x75;&#x72;&#x61;&#x2e;&#x67;&#x68;&#x65;&#x6f;&#x72;&#x67;&#x68;&#x65;&#x40;&#x63;&#x73;&#x2e;&#x70;&#x75;&#x62;&#x2e;&#x72;&#x6f;">Laura</a> cu subiectul <code>[SO][Lucrare X] Transfer Prenume Nume, Grupa</code> unde:</div>
<ul>
<li class="level2"><div class="li"> <code>X</code> este indexul lucrării (1, 2, 3 sau 4)</div>
</li>
<li class="level2"><div class="li"> <code>Prenume</code> este prenumele.</div>
</li>
<li class="level2"><div class="li"> <code>Nume</code> este numa.</div>
</li>
<li class="level2"><div class="li"> <code>Grupa</code> este grupa.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Nu există sesiune de contestații pentru lucrările de curs. În cazul în care considerați că au fost lipsuri la corectarea lucrării, trimiteți un e-mail catre <a href="mailto:&#x6c;&#x61;&#x75;&#x72;&#x61;&#x2e;&#x67;&#x68;&#x65;&#x6f;&#x72;&#x67;&#x68;&#x65;&#x40;&#x63;&#x73;&#x2e;&#x70;&#x75;&#x62;&#x2e;&#x72;&#x6f;" class="mail" title="&#x6c;&#x61;&#x75;&#x72;&#x61;&#x2e;&#x67;&#x68;&#x65;&#x6f;&#x72;&#x67;&#x68;&#x65;&#x40;&#x63;&#x73;&#x2e;&#x70;&#x75;&#x62;&#x2e;&#x72;&#x6f;">Laura</a>.</div>
<ul>
<li class="level2"><div class="li"> Folosiți subiectul <code>[SO][Lucrare X] Prenume Nume, Grupa</code>; de exemplu <code>[SO][Lucrare 1] Andreea Popescu, 332CA</code>.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Pentru a fi punctat, răspunsul la o întrebare trebuie să fie <strong>justificat</strong>.</div>
</li>
</ul>

</div>

<h4 id="lucrare_1">Lucrare 1</h4>
<div class="level4">
<pre class="code">* La începutul cursului 4:
  * marți, 11 martie 2014, 09:05-09:15, EC004, seria CA
  * miercuri, 12 martie 2014, 17:05-17:15, EC004, seria CC</pre>

</div>

<h5 id="ca_varianta_1">3CA, varianta 1</h5>
<div class="level5">
<ol>
<li class="level1"><div class="li"> Ce este un apel de sistem?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: Mecanism care asigură trecerea din user space în kernel space la solicitarea user space. Este folosit atunci când user space-ul nu are privilegiile de a realiza o operație și apelează la kernel space pentru acest lucru.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Ce conține și când este populată o intrare din tabela de descriptori de fișier a unui proces?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: Este un pointer la o structură de fișier deschis. Când se deschide un fișier (folosind fopen, open, CreateFile) se creează o nouă structură de fișier deschis iar adresa acesteia este reținută în cadrul intrării din tabela de descriptori de fișier.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> În ce situație are loc tranziția din starea WAITING în starea READY a unui proces?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: În cazul în care operația care a cauzat așteptarea (de exemplu, citirea de pe disc) s-a încheiat și acum procesul poate rula.</div>
</li>
</ul>
</li>
</ol>

</div>

<h5 id="ca_varianta_2">3CA, varianta 2</h5>
<div class="level5">
<ol>
<li class="level1"><div class="li"> De ce este utilă separația user space / kernel space?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: Spațiul kernel are privilegii complete la nivelul sistemului. Operațiile privilegiate nu pot fi realizate în user space din motive de securitate a sistemului. În aceste situații user space-ul apelează la kernel space prin intermediul unui apel de sistem.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Ce este un descriptor de fișier? Ce fel de operații folosesc descriptori de fișier?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: Este un număr (întreg) ce referă o intrare în tabela de descriptori de fișier. Este folosit în operații de lucru cu fișiere, pentru a identifica un fișier deschis.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> În ce situație are loc tranziția din starea RUNNING în starea WAITING a unui proces?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: În momentul în care procesul execută o operație blocantă (operație de I/O, sleep), acesta trece din starea RUNNING în starea WAITING.</div>
</li>
</ul>
</li>
</ol>

</div>

<h5 id="cc_varianta_1">3CC, varianta 1</h5>
<div class="level5">
<ol>
<li class="level1"><div class="li"> De ce apelul de bibliotecă strcpy nu generează apeluri de sistem?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: Un apel de sistem are loc în momentul în care este nevoie ca o operație privilegiată să fie realizată de kernel. Întrucât strcpy copiază octeți dintr-o zonă de memorie în altă zonă de memorie nu realizează operație privilegiată și, deci, nu necesită apel de sistem.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Ce rol are cursorul de fișier al unui fișier deschis? Când se modifică?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: Stabilește care este poziția curentă de la care vor avea loc operații la nivelul fișierului. Dacă valoarea sa este 100 și un apel read citește 30 de octeți, valoarea sa va ajunge la 130 de octeți. Se modifică și la apeluri de scriere sau la apeluri specifice de poziționare (seek).</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Ce este o schimbare de context? De ce este necesară?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: Se referă la schimbarea unui proces care rulează pe un procesor (este în starea RUNNING) cu un alt proces (aflat în starea READY). Este necesară pentru a asigura folosirea optimă a procesorului (dacă un proces se blochează îi ia altul locul) și pentru asigurarea echității (fairness) a sistemului (procesele se schimbă cu altele pentru a permite câtor mai multe să ruleze în sistem).</div>
</li>
</ul>
</li>
</ol>

</div>

<h5 id="cc_varianta_2">3CC, varianta 2</h5>
<div class="level5">
<ol>
<li class="level1"><div class="li"> Precizați un rol al nucleului sistemului de operare.</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: Nucleul de operare gestionează memoria sistemului. Asigură separația între procesele sistemului la nivel de memorie pentru a preveni unul să scrie în spațiul de adresă al altuia.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Care intrare din tabela de descriptori de fișier este modificată în cazul apelului cu redirectare ”./run &gt; out.txt” față de cazul rulării simple ”./run”?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: Se modifică intrarea aferentă ieșirii standard a procesului (standard output), în general cea cu indexul 1. Aceasta întrucât operatorul &gt; este redirectarea ieșirii standard. Acum intrarea de la indexul 1 din tabela de descriptori de fișier va referi fișierul out.txt, nu ieșirea standard a sistemului.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Ce reprezintă spațiul de adrese al unui proces? De ce este util?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: Spațiul de adrese al unui proces este spațiul de lucru cu memoria a unui proces. Procesul lucrează cu adrese de memorie iar spațiul de adresă îi definește zonele accesibile. Spațiul de adresă asigură separația, la nivelul memoriei, între un proces și alt proces</div>
</li>
</ul>
</li>
</ol>

</div>

<h4 id="lucrare_2">Lucrare 2</h4>
<div class="level4">
<ul>
<li class="level1"><div class="li"> La începutul cursului 7:</div>
<ul>
<li class="level2"><div class="li"> marți, 1 aprilie 2014, 09:05-09:15, EC004, seria CA</div>
</li>
<li class="level2"><div class="li"> miercuri, 2 aprilie 2014, 17:05-17:15, EC004, seria CC</div>
</li>
</ul>
</li>
</ul>

</div>

<h5 id="ca_varianta_11">3CA, varianta 1</h5>
<div class="level5">
<ol>
<li class="level1"><div class="li"> De ce sistemele cu planificare preemptivă au un nivel de interactivitate mai bun decât sistemele cu planificare cooperativă?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: Planificarea preemptivă introduce noțiunea de cuantă de timp alocată unui proces. Când acestuia îi expiră cuanta, este preemptat și înlocuit pe procesor. În acest fel, fiecare proces va ajunge mai repede pe procesor; nu apare riscul ca un proces să ruleze mult timp pe procesor. Fiecare proces rulând destul de rapid pe procesor, vom avea un sistem mai responsiv și mai interactiv.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> De ce NU avem fragmentare externă în cazul folosirii paginării?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: Întreg spațiul fizic este împărțit în pagini de dimensiune fixă. Atunci când este nevoie de spațiu nou se alocă pagini noi indiferent de poziția lor în spațiul inițial. Dacă o pagină este liberă, este eligibilă pentru alocare. Nu ajungem să avem fragmentare externă, adică spațiu liber nealocabil între spații deja alocate.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Ce reprezintă “demand paging”? Ce rol are?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: Demand paging este o formă de amânare a alocării de pagini fizice până în momentul în care este nevoie. Prin demand paging se alocă doar pagini virtuale iar paginile fizice aferente se vor aloca în momentul accesului la acele pagini. Rolul său este de a eficientiza consumul de memorie și de timpul de alocare. În momentul alocării se alocă doar memorie virtuală, nu și fizică, lucru care durează mai puțin. De asemenea, consumul de memorie fizică (RAM) la un moment dat este redus la strictul necesar în acel moment.</div>
</li>
</ul>
</li>
</ol>

</div>

<h5 id="ca_varianta_21">3CA, varianta 2</h5>
<div class="level5">
<ol>
<li class="level1"><div class="li"> Dați exemplu de situație în care un proces este scos de pe procesor deși NU a efectuat o operație blocantă.</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: În momentul în care unui proces îi expiră cuanta, aceasta este scos de pe procesor și un alt proces aflat în starea READY este planificat. Același lucru se întâmplă dacă există un proces în coada READY cu prioriate mai bună decât cel ce rulează pe procesor.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Precizați un avantaj al folosirii mecanismului de memorie virtuală.</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: Un avantaj este faptul că spațiul (virtual) de adrese al unui proces este continuu, independent de forma în care este realizată maparea pe spațiul fizic. Orice alocare se face în continuare spațiului virtual existent, iar mecanismul de memorie virtuală face maparea cu spațiul fizic. Un alt avantaj este posibilitatea folosirea spațiului de swap: mod prin care putem folosi discul pentru a reține pagini care nu încap în spațiul fizic (memoria RAM). Un alt avantaj este posibilitatea partajării memoriei, pagini virtuale din procese diferite (sau chiar din același proces) putând fi mapate peste aceleași pagini fizice.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Ce este spațiul de swap? Ce rol are?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: Spațiul de swap este spațiul localizat pe disc folosit ca depozitar temporar al informațiilor din memorie RAM. În momentul în care spațiul fizic (memoria RAM) devine insuficient, se evacuează (swap out) anumite pagini fizice. În momentul în care aceste pagini sunt necesare sunt readuse în memoria RAM (swap in).</div>
</li>
</ul>
</li>
</ol>

</div>

<h5 id="cc_varianta_11">3CC, varianta 1</h5>
<div class="level5">
<ol>
<li class="level1"><div class="li"> De ce, în general, procesele I/O bound au prioritate mai bună decât procesele CPU bound?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: În general, procesele I/O bound vor executa o operație de I/O rapid, adică se vor bloca. În acest caz, aceste procese vor trece în starea WAITING și vor elibera procesorul unui alt proces. Acordându-le prioritate mai bună, acestea vor rula mai repede dar vor elibera rapid procesorul lăsând loc altor procese. Un proces CPU bound va elibera mai târziu procesorul, motiv pentru care va avea o prioritate mai puțin bună. Preferăm să planificăm procesele I/O bound.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Care este avantajul folosirii paginării ierarhice?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: Prin folosirea paginării ierarhice, spațiul ocupat de tabelele de pagini ale proceselor este diminuat. În loc să existe o intrare pentru fiecare pagină, vor exista intrări doar pentru paginile valide din spațiul virtual de adrese al proceselor.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Corespondența între pagini virtuale și pagini fizice este “mai multe la una”. De ce se întâmplă și la ce este util acest lucru?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: Tabela de pagini conține o mapare între pagini virtuale și pagini fizice. În acest fel mai multe pagini virtuale pot avea corespondent aceeași pagină fizică. Acest lucru este util pentru mecanismul de memorie partajată în care procese diferite au pagini virtuale din propriu spațiu de adresă mapate peste aceleași pagini fizice.</div>
</li>
</ul>
</li>
</ol>

</div>

<h5 id="cc_varianta_21">3CC, varianta 2</h5>
<div class="level5">
<ol>
<li class="level1"><div class="li"> De ce sistemele care doresc productivitate ridicată au alocată o cuantă de timp mai mare alocată fiecărui proces?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: Un sistem este productiv dacă cea mai mare parte din timp acesta execută acțiune utilă. Pentru aceasta trebuie ca procesele să ruleze cât mai mult timp și să existe cât mai puține schimbări de context. Prea multe schimbări de context înseamnă un overhead semnificativ asupra timpului util de lucru. De aceea, pentru a diminua numărul de schimbări de context un sistem productiv va aloca o cuantă de timp mare proceselor sale, procesele petrecând cât mai mult timp rulând.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Ce este TLB? Ce rol are?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: TLB (Translation Lookaside Buffer) este o memorie cache la nivelul sistemului care cache-uiește intrările din tabelele de pagini ale proceselor. Întrucât fiecare acces la memorie necesită de fapt două accese (unul la tabela de pagini, alta la datele efective), TLB-ul micșorează timpul de acces simplificând primul acces (la tabela de pagini). TLB îndeplinește astfel rolul eficientizării accesului la memorie.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Care este avantajul principal al folosirii mecanismului copy-on-write la crearea proceselor folosind fork()?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: Prin folosirea mecanismului de copy-on-write la crearea proceselor folosind fork(), un proces nou este creat foarte rapid. Un proces nou nu va trebui să aloce spațiu fizic nou/separat ci va partaja spațiul fizic aferent procesului părinte. Acel spațiu este marcat read-only și va fi duplicat doar în momentul în care unul dintre procese va scrie (copy-on-write).</div>
</li>
</ul>
</li>
</ol>

</div>

<h4 id="lucrare_3">Lucrare 3</h4>
<div class="level4">
<ul>
<li class="level1"><div class="li"> La începutul cursului 10:</div>
<ul>
<li class="level2"><div class="li"> marți, 22 aprilie 2014, 09:05-09:15, EC004, seria CA</div>
</li>
<li class="level2"><div class="li"> miercuri, 23 aprilie 2014, 17:05-17:15, EC004, seria CC</div>
</li>
</ul>
</li>
</ul>

</div>

<h5 id="ca_varianta_12">3CA, varianta 1</h5>
<div class="level5">
<ol>
<li class="level1"><div class="li"> Care este utilitatea ASLR (Address Space Layout Randomization) din perspectiva securității memoriei?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: În cazul unui atac ce exploatează o vulnerabilitate de securitate a memoriei, atacatorul dorește să deturneze fluxul normal de execuție spre o funcție/adresă injectată de el (shellcode) sau către una existentă (return to libc). Pentru aceasta are nevoie de adresa precisă a acelei funcții; dacă procesul folosește ASLR este foarte dificil (în special pe sistemele pe 64 de biți) de identificat adresa funcției.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Precizați un avantaj al folosirii thread-urilor în locul proceselor</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: Avantaje pot fi:</div>
<ul>
<li class="level3"><div class="li"> timp de creare mai mic</div>
</li>
<li class="level3"><div class="li"> timp de schimbare de context mai rapid pentru thread-urile aceluiași proces</div>
</li>
<li class="level3"><div class="li"> partajare facilă a datelor între thread-urile aceluiași proces</div>
</li>
<li class="level3"><div class="li"> în cazul implementărilor cu suport la nivelul nucleului (kernel-level threads), blocarea unui thread nu blochează întregul proces, ducând la o productivitate sporită</div>
</li>
</ul>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Ce înseamnă “lock contention”?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: Lock contention se referă la accesul concurent la un lock/mutex din partea multor thread-uri. În cazul în care multe thread-uri așteaptă la un lock, eficiența este scăzută, doar un singur thread putând accesa la un moment dat regiunea critică protejată de lock.</div>
</li>
</ul>
</li>
</ol>

</div>

<h5 id="ca_varianta_22">3CA, varianta 2</h5>
<div class="level5">
<ol>
<li class="level1"><div class="li"> Ce înseamnă “stack buffer overflow”?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: Stack buffer overflow este depăsirea unui buffer local unei funcții (alocat pe stivă). Adică în cazul unui buffer cu 10 elemente, accesăm al 15-lea sau al 20-lea element. Putem suprascrie pointeri sau adresa de retur a funcției și dând naștere, astfel, unor atacuri de securitate.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Ce efect are apelul exit() în cadrul unei codului rulat de un thread?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: Apelul exit() încheie execuția procesului curent, indiferent de punctul în care este apelat. Dacă în cadrul funcției unui thread se apelează exit() atunci procesul aferent thread-ului își încheie execuția (împreună cu toate thread-urile procesului).</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Indicați un dezavantaj/neajuns al primitivelor de acces exclusiv chiar și în cazul folosirii corespunzătoare (în care se asigură coerența datelor).</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: Dezavantaje sunt:</div>
<ul>
<li class="level3"><div class="li"> lock contention: mai multe thread-uri așteaptă la un lock (un singur thread poate accesa regiunea critică protejată de lock) → ineficiență</div>
</li>
<li class="level3"><div class="li"> lock overhead: apelul de lock/unlock produce overhead, de multe ori însemnând apel de sistem</div>
</li>
<li class="level3"><div class="li"> serializarea codului: codul protejat de un lock este cod serial, accesibil unui singur thread; nu avem paralelism</div>
</li>
</ul>
</li>
</ul>
</li>
</ol>

</div>

<h5 id="cc_varianta_12">3CC, varianta 1</h5>
<div class="level5">
<ol>
<li class="level1"><div class="li"> Ce este un shellcode?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: Un shellcode este o secvență de cod binar care se dorește a fi injectat, prin intermediul unei vulnerabilități de securitate, în codul unui proces care rulează. Apoi procesului îi este deturnat fluxul de execuție pentru a executa shellcode-ul. De regulă shellcode-ul urmărește obținerea unui shell prin execuția unei instrucțiuni de forma exec(“/bin/bash”).</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Ce se întâmplă în cazul unui acces nevalid la memorie în cadrul codului rulat de un thread?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: În cazul unui acces nevalid la memorie, sistemul de operare generează o excepție (semnalul SIGSEGV pe Linux) al cărei efect este încheierea execuției procesului curent. Indiferent de modul în care este generat accesul (din cadrul funcției unui thread), procesul își încheie execuția, împreună cu toate thread-urile aferente.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Care este dezavantajul folosirii de regiuni critice de mici dimensiuni (granularitate fină)?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: Într-o regiune critică mică, overhead-ul cauzat de apelurile lock și unlock este semnificativ față de acțiunea efectivă realizată în regiunea critică. Dacă regiunea critică este accesată foarte des atunci acest overhead devine semnificativ la nivelul întregului set de acțiuni executate de thread.</div>
</li>
</ul>
</li>
</ol>

</div>

<h5 id="cc_varianta_22">3CC, varianta 2</h5>
<div class="level5">
<ol>
<li class="level1"><div class="li"> Ce înseamnă un atac de tipul “return-to-libc”?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: Un atac de tipul “return-to-libc” presupune suprascrierea unui pointer sau a adresei de retur a unei funcții cu adresa unei funcții din biblioteca standard C (de obicei funcția system). În acest fel se deturnează fluxul normal de execuție al programului către o altă adresă încercându-se obținerea unui shell.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Precizați un dezavantaj al folosirii thread-urilor în locul proceselor.</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: Dezavantaje sunt:</div>
<ul>
<li class="level3"><div class="li"> dacă un thread execută un apel nevalid la memorie atunci se generează excepție și întreg procesul își încheie execuția</div>
</li>
<li class="level3"><div class="li"> zonele de memorie folosite la comun impun folosirea mecanismelor de sincronizare care pot produce probleme dificil de depanat</div>
</li>
<li class="level3"><div class="li"> un număr semnificativ de thread-uri duce la penalizări de performanță față de alte abordări care nu folosesc mai multe thread-uri sau procese (de exemplu event-based I/O sau operații neblocante/asincrone)</div>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<ol>
<li class="level1"><div class="li"> Două thread-uri folosesc două mutex-uri. Cum se poate ajunge la deadlock?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: Fie T1, T2 cele două thread-uri și mutex_a și mutex_b cele două mutex-uri. Situația în care se poate ajunge la deadlock presupune ca thread-ul T1 să execute un cod de forma lock(mutex_a); lock(mutex_b); iar thread-ul T2 să execute un cod de forma lock(mutex_b); lock(mutex_a); Dacă thread-ul T2 rulează între cele două apeluri lock ale thread-ului T1 atunci acesta va achiziționat mutex-ul mutex_b. În acea situație T1 va avea achiziționat mutex-ul mutex_a și va aștepta după eliberarea mutex-ului mutex_b, iar T2 invers. În această situație nici un thread nu poate trece mai departe, ambele rămânând blocate: deadlock.</div>
</li>
</ul>
</li>
</ol>

</div>

<h4 id="lucrare_4">Lucrare 4</h4>
<div class="level4">
<ul>
<li class="level1"><div class="li"> La începutul cursului 13:</div>
<ul>
<li class="level2"><div class="li"> marți, 13 mai 2014, 09:05-09:15, EC004, seria CA</div>
</li>
<li class="level2"><div class="li"> miercuri, 14 mai 2014, 17:05-17:15, EC004, seria CC</div>
</li>
</ul>
</li>
</ul>

</div>

<h5 id="ca_varianta_13">3CA, varianta 1</h5>
<div class="level5">
<ol>
<li class="level1"><div class="li"> La ce este util buffer/page cache-ul?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: Datele accesate recent de pe disc/sistemul de fișiere sunt reținute în memorie pentru acces rapid. Șansele sunt mari ca acele date să fie reaccesate în viitor. Memoria fiind mult mai rapidă ca discul, se mărește viteza de lucru a sistemului.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> În ce situație se poate bloca un apel send pe un socket?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: Apelul send pe socket se blochează dacă buffer-ul de send (transmit, TX) al socketului este plin, adică dacă nu are nici un slot de un octet disponibil. Buffer-ul este plin pentru că nu au apucat să fie transmise pachetele pe rețea (placă de rețea lentă, congestie sau receiver-ul are și el buffer-ul plin).</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Care este un avantaj al alocării indexate față de alocarea contiguă la nivelul sistemului de fișiere?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: Alocarea indexată reduce fragmentarea externă: un fișier poate folosi blocuri din poziții aleatoare de pe disc.</div>
</li>
</ul>
</li>
</ol>

</div>

<h5 id="ca_varianta_23">3CA, varianta 2</h5>
<div class="level5">
<ol>
<li class="level1"><div class="li"> De ce în cadrul unei plăci de rețea de mare viteză (10Gbit) este problematic să se folosească un model bazat DOAR pe întreruperi? (în general se folosește un model hibrid de întreruperi și polling)</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: Pentru că pachetele vin cu vitează foarte mare și generează multe întreruperi. În cazul în care s-ar folosi doar un sistem bazat pe întreruperi, ar exista riscul ca procesorul să fie ocupat doar de rularea de rutine de tratare a întreruperilor.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> De ce este considerat sendfile un mecanism de tip zero-copy?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: sendfile transmite un fișier (sau parte a unui fișier) pe un socket. Întrucât nu există copieri între user space și kernel space, așa cum ar fi cazul unor operații de tipul read și send, sendfile este un mecanism de tip zero-copy.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Ce este un hard link?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: Un hard link se referă la situația în care avem mai multe intrari in directoare (dentry-uri) care pointeaza catre acelasi fișier pe disc (inode). Un nume sau un dentry denotă un hard link.</div>
</li>
</ul>
</li>
</ol>

</div>

<h5 id="cc_varianta_13">3CC, varianta 1</h5>
<div class="level5">
<ol>
<li class="level1"><div class="li"> Care este o caracteristică a unui dispozitiv de tip bloc?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: Un dispozitiv de tip bloc permite acces aleator la date, nu secvențial ca în cazul unui dispozitiv de tip caracter. De asemenea, un dispozitiv de tip bloc lucrează cu blocuri de date, nu cu câte un caracter/byte așa cum este cazul unui dispozitiv de tip caracter.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Ce valoare (numărul de octeți transmiși) poate întoarce un apel de forma send(s, buffer, 1000, 0)? Apelul urmărește transmiterea unui buffer de 1000 de octeți pe socketul s.</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: Apelul send poate întoarce între 1 și 1000 de octeți. Întoarce numărul de octeți disponibili (între 1 și 1000) când are date disponibile. Dacă nu are date disponibile și celălalt capăt nu a închis conexiunea, se blochează. La eroare sau când celălalt capăt a închis conexiunea, se întoarce cu eroare (-1).</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> De ce este importantă ordonarea cererilor în cadrul unui planificator de disk (disk scheduler)?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: Dacă cererile nu sunt ordonate, se fac multe operații de căutare (seek) pe disk pentru fiecare cerere, ceea ce înseamnă timp consumat. Prin ordonarea cererilor timpul de căutare (seek) este minimizat: se trece, în ordine, de la un bloc la alt bloc.</div>
</li>
</ul>
</li>
</ol>

</div>

<h5 id="cc_varianta_23">3CC, varianta 2</h5>
<div class="level5">
<ol>
<li class="level1"><div class="li"> Care este un avantaj al folosirii operațiilor I/O asincrone?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: După momentul lansării unei operații I/O asincrone, sistemul/procesul poate executa alte operații, nu trebuie să se blocheze în așteptarea încheierii acesteia. Acest lucru conduce la o eficiență sporită a sistemului.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> accept este un apel blocant pe partea server-ului. Ce apel din partea clientului deblochează apelul accept? De ce?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: Apelul connect din partea clientul este cel care stabilește o conexiune la server. În acest caz apelul accept se întoarce și creează un nou socket care va fi folosit pentru transmisia datelor.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Ce este un inode? Ce informații conține (în linii mari)?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: Este o structură/tip de date care identifică un fișier pe disc. Un inode identifică orice fișier (fișier obișnuit, director, link simbolic) și conține metadate despre un fișier: permisiune de acces, deținător, timestamp-uri, dimensiune, contor de link-uri, pointeri la blocurile de date etc.</div>
</li>
</ul>
</li>
</ol>

</div>
<!-- EDIT3 SECTION "Lucrări" [2369-] --></div>
</body>
</html>
