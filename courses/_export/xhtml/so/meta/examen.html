    
    

<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
  <meta charset="utf-8" />
  <title>so:meta:examen</title>
<meta name="generator" content="DokuWiki"/>
<meta name="robots" content="index,follow"/>
<meta name="date" content="2016-06-03T17:46:04+0300"/>
<meta name="keywords" content="so,meta,examen"/>
<link rel="search" type="application/opensearchdescription+xml" href="../../../../lib/exe/opensearch.php" title="CS Open CourseWare"/>
<link rel="start" href="../../../../../courses.1.html"/>
<link rel="alternate" type="application/rss+xml" title="Recent Changes" href="../../../../feed.php"/>
<link rel="alternate" type="application/rss+xml" title="Current Namespace" href="../../../../feed.php%3Fmode=list&amp;ns=so:meta"/>
<link rel="alternate" type="text/html" title="Plain HTML" href="examen.html"/>
<link rel="canonical" href="../../../../so/meta/examen.html"/>
<link rel="stylesheet" type="text/css" href="../../../../lib/exe/css.php%3Ft=arctic&amp;tseed=1476798676.css"/>
<script type="text/javascript">/*<![CDATA[*/var NS='so:meta';var JSINFO = {"id":"so:meta:examen","namespace":"so:meta","isadmin":0,"isauth":0};
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="../../../../lib/exe/js.php%3Ftseed=1476798676"></script>
<script type="text/x-mathjax-config">/*<![CDATA[*/MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ["$","$"], ["\\(","\\)"] ],
        displayMath: [ ["$$","$$"], ["\\[","\\]"] ],
        processEscapes: true
    }
});
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
<script type="text/javascript">/*<![CDATA[*/
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
		  
/*!]]>*/</script>
<script type="text/javascript">/*<![CDATA[*/
var pageTracker = _gat._getTracker("UA-38383934-1");
pageTracker._initData();
pageTracker._trackPageview();
		  
/*!]]>*/</script>
</head>
<body>
<div class="dokuwiki export">
<!-- TOC START -->
<div id="dw__toc">
<h3 class="toggle">Table of Contents</h3>
<div>

<ul class="toc">
<li class="level1"><div class="li"><a href="examen.html#examen_cacc">Examen CA/CC</a></div>
<ul class="toc">
<li class="level2"><div class="li"><a href="examen.html#examen_final">Examen final</a></div></li>
<li class="level2"><div class="li"><a href="examen.html#lucrari">Lucrări</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="examen.html#lucrare_1">Lucrare 1</a></div>
<ul class="toc">
<li class="level4"><div class="li"><a href="examen.html#ca_varianta_1">3CA, varianta 1</a></div></li>
<li class="level4"><div class="li"><a href="examen.html#ca_varianta_2">3CA, varianta 2</a></div></li>
<li class="level4"><div class="li"><a href="examen.html#cc_varianta_1">3CC, varianta 1</a></div></li>
<li class="level4"><div class="li"><a href="examen.html#cc_varianta_2">3CC, varianta 2</a></div></li>
<li class="level4"><div class="li"><a href="examen.html#greseli_frecvente">Greșeli frecvente</a></div></li>
<li class="level4"><div class="li"><a href="examen.html#lucrari_foarte_bune">Lucrări foarte bune</a></div></li>
</ul>
</li>
<li class="level3"><div class="li"><a href="examen.html#lucrare_2">Lucrare 2</a></div>
<ul class="toc">
<li class="level4"><div class="li"><a href="examen.html#ca_varianta_11">3CA, varianta 1</a></div></li>
<li class="level4"><div class="li"><a href="examen.html#ca_varianta_21">3CA, varianta 2</a></div></li>
<li class="level4"><div class="li"><a href="examen.html#cc_varianta_11">3CC, varianta 1</a></div></li>
<li class="level4"><div class="li"><a href="examen.html#cc_varianta_21">3CC, varianta 2</a></div></li>
<li class="level4"><div class="li"><a href="examen.html#greseli_frecvente1">Greșeli frecvente</a></div></li>
<li class="level4"><div class="li"><a href="examen.html#lucrari_foarte_bune1">Lucrări foarte bune</a></div></li>
</ul>
</li>
<li class="level3"><div class="li"><a href="examen.html#lucrare_3">Lucrare 3</a></div>
<ul class="toc">
<li class="level4"><div class="li"><a href="examen.html#ca_varianta_12">3CA, varianta 1</a></div></li>
<li class="level4"><div class="li"><a href="examen.html#ca_varianta_22">3CA, varianta 2</a></div></li>
<li class="level4"><div class="li"><a href="examen.html#cc_varianta_12">3CC, varianta 1</a></div></li>
<li class="level4"><div class="li"><a href="examen.html#cc_varianta_22">3CC, varianta 2</a></div></li>
<li class="level4"><div class="li"><a href="examen.html#greseli_frecvente2">Greșeli frecvente</a></div></li>
<li class="level4"><div class="li"><a href="examen.html#lucrari_foarte_bune2">Lucrări foarte bune</a></div></li>
</ul>
</li>
<li class="level3"><div class="li"><a href="examen.html#lucrare_4">Lucrare 4</a></div>
<ul class="toc">
<li class="level4"><div class="li"><a href="examen.html#ca_varianta_13">3CA, varianta 1</a></div></li>
<li class="level4"><div class="li"><a href="examen.html#ca_varianta_23">3CA, varianta 2</a></div></li>
<li class="level4"><div class="li"><a href="examen.html#cc_varianta_13">3CC, varianta 1</a></div></li>
<li class="level4"><div class="li"><a href="examen.html#cc_varianta_23">3CC, varianta 2</a></div></li>
<li class="level4"><div class="li"><a href="examen.html#greseli_frecvente3">Greșeli frecvente</a></div></li>
<li class="level4"><div class="li"><a href="examen.html#lucrari_foarte_bune3">Lucrări foarte bune</a></div></li>
</ul>
</li>
</ul>
</li>
<li class="level2"><div class="li"><a href="examen.html#examene_anterioare">Examene anterioare</a></div></li>
</ul></li>
</ul>
</div>
</div>
<!-- TOC END -->

<h1 class="sectionedit1" id="examen_cacc">Examen CA/CC</h1>
<div class="level1">

<p>
Urmăriți precizările din <a href="../../../../so/meta/notare/reguli-notare-ca-cc.html" class="wikilink1" title="so:meta:notare:reguli-notare-ca-cc">pagina de reguli</a>.
</p>

</div>
<!-- EDIT1 SECTION "Examen CA/CC" [1-115] -->
<h2 class="sectionedit2" id="examen_final">Examen final</h2>
<div class="level2">

<p>
Puteți participa la <strong>un singur</strong> examen final.
</p>

<p>
Datele de examen de SO sunt:
</p>
<ul>
<li class="level1"><div class="li"> sâmbătă, 4 iunie 2016, ora 08:00, sala EC101, examen restanță seria CB</div>
</li>
<li class="level1"><div class="li"> marți, 7 iunie 2016, ora 11:00, sala EC101, 331CB, 333CB</div>
</li>
<li class="level1"><div class="li"> miercuri, 8 iunie 2016, ora 08:00, sala EC002, 332CB</div>
</li>
<li class="level1"><div class="li"> miercuri, 8 iunie 2016, ora 14:00, sala EC004, examen restanță seriile CA și CC</div>
</li>
<li class="level1"><div class="li"> vineri, 10 iunie 2016, ora 09:00, sala EC002, examen restanță seriile CA și CC</div>
</li>
<li class="level1"><div class="li"> joi, 16 iunie 2016, ora 08:00, sala A02, seria CC</div>
</li>
<li class="level1"><div class="li"> vineri, 17 iunie 2016, ora 08:00, EC004, 334CB, 335CB</div>
</li>
<li class="level1"><div class="li"> vineri, 17 iunie 2016, ora 08:00, amfiteatrul PRECIS, seria CA</div>
</li>
</ul>

<p>
Sesiunea iunie 2016 are loc în perioada 28 mai 2016 - 17 iunie 2016. Sesiunea specială de restanțe (studenți anul 4) are loc în perioada 28 mai - 10 iunie 2016.
</p>

<p>
Datele de mai sus sunt afișate și la avizierul facultății.
</p>

<p>
Rugăm să veniți în intervalul stabilit grupei voastre. Dacă, din motive obiective, nu puteți participa în data repartizată, trimiteți-i un e-mail <a href="mailto:&#x6c;&#x61;&#x75;&#x72;&#x61;&#x2e;&#x67;&#x68;&#x65;&#x6f;&#x72;&#x67;&#x68;&#x65;&#x40;&#x63;&#x73;&#x2e;&#x70;&#x75;&#x62;&#x2e;&#x72;&#x6f;" class="mail" title="&#x6c;&#x61;&#x75;&#x72;&#x61;&#x2e;&#x67;&#x68;&#x65;&#x6f;&#x72;&#x67;&#x68;&#x65;&#x40;&#x63;&#x73;&#x2e;&#x70;&#x75;&#x62;&#x2e;&#x72;&#x6f;">Laurei</a> cu subiectul <code>&quot;[SO] Transfer examen - Prenume Nume, Grupa&quot;</code>.
</p>

<p>
Detalii despre examen găsiți în secțiunile aferente: <a href="../../../../so/meta/notare/reguli-notare-ca-cc.html#examen_3_puncte" class="wikilink1" title="so:meta:notare:reguli-notare-ca-cc">examen seriile CA și CC</a>, <a href="../../../../so/meta/notare/reguli-notare-cb.html#curs_4_puncte" class="wikilink1" title="so:meta:notare:reguli-notare-cb">examen seria CB</a>.
</p>

</div>
<!-- EDIT2 SECTION "Examen final" [116-1470] -->
<h2 class="sectionedit3" id="lucrari">Lucrări</h2>
<div class="level2">
<ul>
<li class="level1"><div class="li"> Dacă nu puteți participa la seria fiecăruia, puteți veni la cealaltă serie. Pentru aceasta trimiteți un e-mail catre <a href="mailto:&#x72;&#x61;&#x7a;&#x76;&#x61;&#x6e;&#x2e;&#x64;&#x65;&#x61;&#x63;&#x6f;&#x6e;&#x65;&#x73;&#x63;&#x75;&#x40;&#x63;&#x73;&#x2e;&#x70;&#x75;&#x62;&#x2e;&#x72;&#x6f;" class="mail" title="&#x72;&#x61;&#x7a;&#x76;&#x61;&#x6e;&#x2e;&#x64;&#x65;&#x61;&#x63;&#x6f;&#x6e;&#x65;&#x73;&#x63;&#x75;&#x40;&#x63;&#x73;&#x2e;&#x70;&#x75;&#x62;&#x2e;&#x72;&#x6f;">Răzvan</a> cu subiectul <code>[SO][Lucrare X] Transfer Prenume Nume, Grupa</code> unde:</div>
<ul>
<li class="level2"><div class="li"> <code>X</code> este indexul lucrării (1, 2, 3 sau 4)</div>
</li>
<li class="level2"><div class="li"> <code>Prenume</code> este prenumele.</div>
</li>
<li class="level2"><div class="li"> <code>Nume</code> este numa.</div>
</li>
<li class="level2"><div class="li"> <code>Grupa</code> este grupa.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Nu există sesiune de contestații pentru lucrările de curs. În cazul în care considerați că au fost lipsuri la corectarea lucrării, trimiteți un e-mail catre <a href="mailto:&#x72;&#x61;&#x7a;&#x76;&#x61;&#x6e;&#x2e;&#x64;&#x65;&#x61;&#x63;&#x6f;&#x6e;&#x65;&#x73;&#x63;&#x75;&#x40;&#x63;&#x73;&#x2e;&#x70;&#x75;&#x62;&#x2e;&#x72;&#x6f;" class="mail" title="&#x72;&#x61;&#x7a;&#x76;&#x61;&#x6e;&#x2e;&#x64;&#x65;&#x61;&#x63;&#x6f;&#x6e;&#x65;&#x73;&#x63;&#x75;&#x40;&#x63;&#x73;&#x2e;&#x70;&#x75;&#x62;&#x2e;&#x72;&#x6f;">Răzvan</a>.</div>
<ul>
<li class="level2"><div class="li"> Folosiți subiectul <code>[SO][Lucrare X] Prenume Nume, Grupa</code>; de exemplu <code>[SO][Lucrare 1] Andreea Popescu, 332CA</code>.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Pentru a fi punctat, răspunsul la o întrebare trebuie să fie <strong>justificat</strong>.</div>
</li>
</ul>

</div>
<!-- EDIT3 SECTION "Lucrări" [1471-2284] -->
<h3 class="sectionedit4" id="lucrare_1">Lucrare 1</h3>
<div class="level3">
<ul>
<li class="level1"><div class="li"> La începutul cursului 4:</div>
<ul>
<li class="level2"><div class="li"> marți, 15 martie 2016, 08:00-08:15, EC004, seria CA</div>
</li>
<li class="level2"><div class="li"> miercuri, 16 martie 2016, 17:00-17:15, EC004, seria CC</div>
</li>
</ul>
</li>
</ul>

</div>

<h4 id="ca_varianta_1">3CA, varianta 1</h4>
<div class="level4">
<ol>
<li class="level1"><div class="li"> De ce este importantă separația user mode - kernel mode?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: Separația kernel mode - user mode este importantă pentru că asigură un mod privilegiat de execuție (kernel mode) pentru operații critice. Un mod privilegiat în care rulează sistemul de operare înseamnă că operațiile critice (IPC, lucrul cu I/O, lucrul cu memoria) vor fi validate de sistemul de operare și un proces (aplicație user space) nu poate face pagube sistemului. Pentru operații privilegiate va fi necesară trecerea în kernel mode prin intermediul unui apel de sistem, și astfel invocarea sistemului de operare care acționează ca un gardian al operațiilor, garantând securitatea și integritatea sistemului.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> <code>fd1</code> este un descriptor de fișier, iar <code>fd2 = dup(fd1)</code>. Precizați ce se întamplă cu cursorul de fișier al <code>fd1</code> atunci când scriem în <code>fd2</code>.</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: Apelul <code>dup()</code> duplică un descriptor de fișier în alt descriptor de fișier, astfel încât ambii descriptori referă aceeași structură de fișier deschis. Referind aceeași structură de fișier deschis, descriptorii partajează cursorul de fișier (aflat în structura de fișier deschis). Atunci când scriem folosind descriptorul de fișier <code>fd2</code>, modificăm (creștem) cursorul de fișier lucru vizibil și în cadrul descriptorului <code>fd1</code>. Este, practic, vorba de același cursor de fișier.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> În Bash, executăm comanda <code>sleep 10</code>. Precizați pașii pe care îi va realiza procesul Bash pentru a rula această comandă.</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: Procesul Bash folosește <code>fork()</code> pentru a crea un proces copil identic sieși (clonă a sa) și apoi <code>exec(&quot;sleep&quot;)</code> în procesul copil pentru rularea codului din executabilul <code>sleep</code>. În procesul părinte se apelează <code>wait()</code> pentru a aștepta încheierea execuției procesului copil (<code>sleep</code>), procesul Bash apărând blocat utilizatorului până la încheierea comenzii (nu se pot introduce comenzi noi în Bash).</div>
</li>
</ul>
</li>
</ol>

</div>

<h4 id="ca_varianta_2">3CA, varianta 2</h4>
<div class="level4">
<ol>
<li class="level1"><div class="li"> Apelurile <code>printf(...)</code> și <code>write(1,...)</code> pot fi folosite pentru a afișa text la consolă. Care este diferența principală dintre ele?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: Diferența principală este că cele două apeluri este că <code>printf()</code> este un apel de tipul <em>buffered</em>, adică scrie într-un buffer de memorie în user space. Doar când buffer-ul este plin sau când se apelează <code>fflush()</code> sau când se întâlnește <em>newline</em> (<code>\n</code>) se face apel de sistem. <code>write()</code> realizează mereu apel de sistem. <code>printf()</code> oferă potențial avantaj de overhead (nefăcând apel de sistem de fiecare dată) cu nevoia alocării unui buffer de memorie în user space.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Un proces scrie în fiecare secundă PID-ul și timpul curent în fișierul <code>f.txt</code> cu ajutorul descriptorului <code>fd</code>. Procesul execută <code>fork()</code>. După <code>fork()</code> ambele procese scriu PID-ul și timpul curent în <code>fd</code>. Care dintre procese va reuși să scrie în <code>f.txt</code>?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: După <code>fork()</code> procesul copil moștenește tabela de descriptori de fișiere a procesului părinte astfel încât și acesta are acces la fișierele folosite până atunci de procesul părinte. Ambele procese vor putea scrie în fișierul <code>f.txt</code>. După <code>fork()</code> procesele partajează structura de fișier deschis astfel încât o modificare făcută de un proces (a cursorului de fișier) va fi vizibilă și în celălalt proces.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> În Bash, executăm comanda <code>sleep 10 &amp;</code>. Precizați pașii pe care îi va realiza procesul Bash pentru a rula această comandă.</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: Procesul Bash folosește <code>fork()</code> pentru a crea un proces copil identic sieși (clonă a sa) și apoi <code>exec(&quot;sleep&quot;)</code> în procesul copil pentru rularea codului din executabilul <code>sleep</code>. În procesul părinte <strong>nu</strong> se apelează <code>wait()</code>, procesul Bash <strong>nu</strong> așteaptă încheierea procesului sleep astfel încât utilizatorul poate introduce comenzi noi în Bash.</div>
</li>
</ul>
</li>
</ol>

</div>

<h4 id="cc_varianta_1">3CC, varianta 1</h4>
<div class="level4">
<ol>
<li class="level1"><div class="li"> Indicați un avantaj și un dezavantaj al unui kernel monolitic față de un microkernel.</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: Avantaj pentru un nucleu monolitic sunt viteza de execuție (overhead-ul redus). Dezavantaje pentru un nucleu monolitic sunt securitatea potențal mai slabă (întrucât kernel-ul este mai mare și are suprafață de atac mai mare, spunem că are TCB (<em>Trusted Computing Base</em>) mai mare); este mai puțin modular decât un microkernel însemnând o toleranță la defecte mai redusă și o proiectare mai greu extensibilă.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Indicați două funcții de lucru cu fișiere care alterează cursorul de fișier.</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: Funcții care alterează cursorul de fișier sunt <code>write()</code> și <code>read()</code> (care modifică cursorul de fișier în momentul în care se citește un buffer); modificarea se face în sens pozitiv cu numărul de octeți citiți/scriși. Modificare se poate face la orice punct din fișier folosind funcția <code>lseek()</code>. Funcția <code>open()</code> plasează cursorul de fișier la începutul sau sfârșitul fișierului funcție de prezența opțiunii <code>O_APPEND</code>.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Câte procese se pot găsi la un moment dat în fiecare dintre cele trei stări ale unui proces: <code>READY</code>, <code>RUNNING</code> și <code>WAITING</code>?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: În starea <code>RUNNING</code> se pot găsi între <code>0</code> și <code>N</code> procese unde <code>N</code> este numărul de procesoare. Un proces are nevoie de un procesor pentru a putea rula. În stările <code>READY</code> și <code>WAITING</code> se pot găsi oricâte procese, limitarea fiind dată de resursele sistemului (memorie). Nu există constrângeri puternice pentru stările <code>READY</code> și <code>WAITING</code>.</div>
</li>
</ul>
</li>
</ol>

</div>

<h4 id="cc_varianta_2">3CC, varianta 2</h4>
<div class="level4">
<ol>
<li class="level1"><div class="li"> Care este un avantaj și un dezavantaj al folosirii apelurilor de sistem?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: Apelurile de sistem au avantajul că oferă acces la serviciile nucleului (privilegiate) și tot prin intermediul acestuia obține acces la resursele hardware ale sistemului. Au ca dezavantaj overhead-ul; trecerea din user mode în kernel mode induce overhead de execuție.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Indicați două informații din metadatele unui fișier (excluzând numele fișierului).</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: Metadatele fișierului conțin informații despre utilizarea fișierului. Metadate sunt: dimensiunea fișierului, timpii de acces, user, group, permisiuni de acces, indecși către blocurile de date, tipul fișierului.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Ce se întâmplă cu un proces zombie rămas orfan?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: Un proces rămas orfan este adoptat de <code>init</code>. Și un proces zombie rămas orfan este adoptat de <code>init</code>; doar că, spre deosebire de un proces non-zombie, procesul zombie este apoi &quot;terminat&quot; de <code>init</code> (<em>zombie reaping</em>) și informațiile rezidente legate de modul în care și-a încheiat execuția sunt șterse.</div>
</li>
</ul>
</li>
</ol>

</div>

<h4 id="greseli_frecvente">Greșeli frecvente</h4>
<div class="level4">
<ul>
<li class="level1"><div class="li"> Verbul <code>a crea</code> are formele: <code>a crea</code>, <code>creează</code>, <code>a creat</code>, <code>creare</code>. Vedeți și articolul de la adresa <a href="https://diacritica.wordpress.com/tag/a-crea-sau-a-creea/" class="urlextern" title="https://diacritica.wordpress.com/tag/a-crea-sau-a-creea/"  rel="nofollow">https://diacritica.wordpress.com/tag/a-crea-sau-a-creea/</a></div>
</li>
<li class="level1"><div class="li"> <code>&amp;</code> înseamnă rulare în background, dar când vorbim de internele lucrului cu procese semnificația sa este că procesul părinte nu așteaptă (nu apelează <code>wait()</code> sau <code>WaitForSingleProcess()</code>) după procesul copil. Rularea în background este o denumire de comportament în shell; internele shell-ului (pașii urmați de shell) se referă la faptul că <strong>nu</strong> se apelează <code>wait()</code> de procesul părinte.</div>
</li>
<li class="level1"><div class="li"> Rularea în background-ul shell-ului nu înseamnă proces daemon. Procesul daemon este <strong>detașat</strong> de terminal; un proces care rulează în background poate fi adus în foreground-ul shell-ului. Spunem că un proces daemon rulează în background-ul sistemului, complet detașat de un terminal sau de un shell. Background-ul shell-ului diferă de noțiunea de background al sistemului pentru procese deamon (decuplate de terminal).</div>
</li>
<li class="level1"><div class="li"> Afirmația <em><code>printf()</code> scrie mereu la stdin, pe când <code>write()</code> poate scrie la un descriptor  de fișier ce poate fi redirectat.</em> este falsă. Redirectarea se face la nivelul descriptorului de fișier, nu ține de apelul folosit. Și <code>printf()</code> folosește un descriptor de fișier (descriptorul <code>1</code>) care poate redirectat, caz în care ce scriem folosind <code>printf()</code> va ajunge în fișierul în care am realizat redirectarea.</div>
</li>
<li class="level1"><div class="li"> Afirmația <em><code>fd1</code> pointează către fișier</em> nu este complet corectă. Corect este <em>pointează către o structură de fișier deschis</em>; este vorba de o structură în memorie creată după deschiderea fișierului. Fișierul stă pe disc indiferent dacă este deschis sau nu de un proces, structura de fișier deschis stă în memorie și este creată în momentul deschiderii fișierului de pe disc de un proces.</div>
</li>
<li class="level1"><div class="li"> Când vorbim despre pașii pe care îi realizează procesul Bash (sau orice alt proces) ne referim la internele operațiilor (<abbr title="Application Programming Interface">API</abbr>-ului) realizate de Bash. Stările prin care trece procesul Bash (sau orice alt proces) (<code>RUNNING</code>, <code>READY</code>, <code>WAITING</code>) țin de modul în care acest proces este planificat de planificatorul/scheduler-ul sistemului de operare. Nu sunt pași pe care procesul îi realizează.</div>
</li>
<li class="level1"><div class="li"> Există o confuzie între modurile de operare și utilizatori; de la exprimări de genul <em>pentru că un utilizator să nu strice kernel-ul</em>, până la afirmația <em>utilizatorul root operează în kernel mode</em>. Cel mai bine este să privim user mode/user space ca fiind <strong>application mode</strong>; nu are legătură cu utilizatorul/permisiunile utilizatorului ci cu procesele/aplicațiile; se referă la nivelul de privilegiu al proceselor/aplicațiilor. Procesele/Aplicațiile pornite de utilizatorul <code>root</code> rulează, de asemenea, în user space. Diferența este că la trecerea în kernel mode (prin apel de sistem) acestea au privilegii superiorare; un apel <code>kill()</code> de trimitere a unui semnal către un proces va fi tratat de kernel în mod diferit dacă procesul/aplicația care l-a inițiat a fost rulată de root sau de un utilizator obișnuit.</div>
</li>
<li class="level1"><div class="li"> Afirmația <em>În starea <code>WAITING</code> există un singur proces.</em> este nevalidă. Starea <code>WAITING</code> este starea în care sunt procese blocate în așteptarea unui eveniment care să le deblocheze. Pot fi oricât de multe procese în starea <code>WAITING</code> în limita resurselor sistemului.</div>
</li>
<li class="level1"><div class="li"> Ca avantaj pentru apeluri de sistem a fost precizat <em>Apelurile de sistem sunt mai rapide.</em> Apelurile de sistem au overhead, nu sunt neapărat rapide. Prin comparație cu apeluri de bibliotecă, apelurile de sistem sunt mai lente.</div>
</li>
<li class="level1"><div class="li"> Afirmația <em>Cursorul de fișier e metadată a fișierului.</em> este falsă. Fișierul rezidă pe disc, structura de fișier deschis rezidă în memorie și este creată când este deschis un fișier de proces; structura de fișier deschis conține cursorul de fișier. Metadatele fișierului se referă la fișierul de pe disc, iar aceste metadate nu conțin cursorul de fișier.</div>
</li>
<li class="level1"><div class="li"> Afimația <em>Cursorul de fișier e afectat de apelul <code>close()</code>.</em> nu este validă. Apelul <code>close()</code> invalidează un cursor de fișier și eventual dezalocă structura de fișier deschis ce conține cursorul de fișier; dar nu schimbă valoarea cursorului de fișier.</div>
</li>
<li class="level1"><div class="li"> Afirmația <em>Un proces zombie nu poate fi orfan.</em> este falsă. Un proces devine zombie când își încheie execuția dar nu este încă așteptat de procesul său părinte. Un proces zombie devine orfan când procesul său părinte își încheie execuția, fără să îl aștepte.</div>
</li>
</ul>

</div>

<h4 id="lucrari_foarte_bune">Lucrări foarte bune</h4>
<div class="level4">
<ul>
<li class="level1"><div class="li"> DUMITRU Mihai-Valentin, 335CB</div>
</li>
<li class="level1"><div class="li"> MURARU George-Cristian, 333CB</div>
</li>
<li class="level1"><div class="li"> IONESCU Bianca-Raluca, 331CC</div>
</li>
<li class="level1"><div class="li"> MIHAI Darius, 331CC</div>
</li>
<li class="level1"><div class="li"> BĂLAN Alexandru, 332CC</div>
</li>
<li class="level1"><div class="li"> DIMOS Alexandros, 332CC</div>
</li>
<li class="level1"><div class="li"> POȘTOACĂ Andrei Vlad, 332CC</div>
</li>
<li class="level1"><div class="li"> OPREA George Bogdan, 333CC</div>
</li>
<li class="level1"><div class="li"> MARINUȘ Alexandru, 334CC</div>
</li>
<li class="level1"><div class="li"> RACU Roxana, 335CC</div>
</li>
<li class="level1"><div class="li"> ROTARU Alexandru Andrei, 335CC</div>
</li>
<li class="level1"><div class="li"> ONOSE Cristian, 342C3</div>
</li>
<li class="level1"><div class="li"> PAVEL Nicolae Teodor, 333CA</div>
</li>
<li class="level1"><div class="li"> TUFĂ Adriana 333CA</div>
</li>
<li class="level1"><div class="li"> COSTEA Dragos Florin 334CA</div>
</li>
</ul>

</div>
<!-- EDIT4 SECTION "Lucrare 1" [2285-14403] -->
<h3 class="sectionedit5" id="lucrare_2">Lucrare 2</h3>
<div class="level3">
<ul>
<li class="level1"><div class="li"> La începutul cursului 7:</div>
<ul>
<li class="level2"><div class="li"> marți, 5 aprilie 2016, 08:00-08:15, EC004, seria CA</div>
</li>
<li class="level2"><div class="li"> miercuri, 6 aprilie 2016, 17:00-17:15, EC004, seria CC</div>
</li>
</ul>
</li>
</ul>

</div>

<h4 id="ca_varianta_11">3CA, varianta 1</h4>
<div class="level4">
<ol>
<li class="level1"><div class="li"> Precizați un avantaj și un dezavantaj al multitasking-ului preemptiv pe sisteme cu un singur procesor.</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: Multitasking-ul preemptiv pe un singur procesor mărește interactivitatea sistemului, planificând rând pe rând procesele pe procesor, dând șansa fiecăruia să ruleze. Este avantajos pentru că limitează <em>process starvation</em>. Are dezavantajul lipsei de <em>throughput</em> întrucât un proces va fi întrerupt când îi expiră cuanta de timp alocată. De asemenea, e dezavantajos pentru că nu mai avem determinism la nivelul rulării și nu putem estima cu precizie când un proces care știm cât ar trebui să ruleze își va încheia execuția.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Explicați cum folosește sistemul de operare <em>Translation Lookaside Buffer</em> (TLB).</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: În momentul în care este accesată o adresă virtuală, trebuie realizată translatarea acesteia în adresă fizică, informație care se găsește în tabela de pagini, dar cached în TLB. Se caută prima oară in TLB dacă există intrarea pentru pagina virtuală corespunzătoare adresei și se extrage de acolo pagina fizică. Dacă există (<em>TLB hit</em>), se extrage adresa paginii fizice și se calculează adresa fizică și se accesează. În caz contrar (<em>TLB miss</em>) se parcurge tabela de pagini a procesului și, în caz de intrare validă, se populează o intrare în TLB cu valoarea în cauză.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Procesul A folosește <code>3MB</code> de memorie fizică. A execută <code>fork()</code> și creează procesul B. Înainte ca A sau B să își continue execuția, care va fi consumul total de memorie fizică al celor două procese?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: Întrucât <code>fork()</code> folosește <em>copy-on-write</em>, imediat după <code>fork()</code> procesul părinte și procesul copil, deși cu spațiii virtuale diferite, vor partaja spațiul fizic de memorie al procesului părinte. Consumul total de memorie va rămâne de <code>3MB</code>.</div>
</li>
</ul>
</li>
</ol>

</div>

<h4 id="ca_varianta_21">3CA, varianta 2</h4>
<div class="level4">
<ol>
<li class="level1"><div class="li"> Precizați două dezavantaje ale algoritmului de planificare <em>Shortest Job First</em> (SJF).</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: Un dezavantaj este faptul că poate duce la process starvation. Dacă în sistem apar în continuu procese noi și care durează puțin, procesele care durează mult nu vor fi planificate. Acest dezavantaj poate fi exprimat și prin timp mare de așteptare pentru procesele cu durată mare. Sau poate fi exprimat și prin interactivitate redusă. Un alt dezavantaj este că nu putem estima cu precizie durata unui proces ca să putem face o planificare de tip <em>Shortest Job First</em>. Nu există dezavantaje legate de priorități sau de cuante de timp pentru că este un sistem de planificare nepreemptiv.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Detaliați pașii pe care îi execută <em>Memory Management Unit</em> (MMU) pentru a rezolva o adresă virtuală într-o adresă fizică.</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: MMU primește o adresă virtuală și are un pointer (de exemplu registrul <code>CR3</code> pe x86) la tabela de pagini a procesului care a făcut acces la acea adresă. Calculează adresa pagini virtuale aferente adresei și, în primă fază, caută existența intrării în TLB. Dacă există, extrage adresa paginii fizice aferente. Dacă nu există, accesează tabela de pagini a procesului în memoria RAM și caută acolo corespondența. Dacă există în TLB sau în tabela de pagini calculează adresa fizică corespunzătoare adresei virtuale inițiale și accesează memoria RAM. Dacă nu există în TLB și nici în tabela de pagini generează un <em>page fault</em>.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Explicați de ce <strong>nu</strong> este nevoie de <em>TLB flush</em> în cadrul unui apel de sistem.</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: În sistemele de operare moderne, spațiul virtual de adrese al tuturor proceselor are rezervată zonă pentru nucleul sistemului de operare. În acest fel, în momentul unui apel de sistem și al schimbării din user mode în kernel mode, spațiul virtual de adrese nu se schmbă iar intrările din TLB sunt valide. La apelarea și la revenirea din apel de sistem nu are loc schimbare de context și nu este nevoie de <em>TLB flush</em>.</div>
</li>
</ul>
</li>
</ol>

</div>

<h4 id="cc_varianta_11">3CC, varianta 1</h4>
<div class="level4">
<ol>
<li class="level1"><div class="li"> De ce este problematică folosirea unui planificator care folosește <strong>doar</strong> priorități statice?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: Dacă un planificator folosește doar priorități statice atunci procesele care au priorități superioare vor fi preferate în fața celor cu priorități inferioare. Acest lucru rezultă într-un sistem mai puțin interactiv, cu timp mediu de așteptare mare și riscul de process starvation pentru procesele cu priorități inferioare. Singurul moment în care procesele cu priorități inferioare vor putea rula este atunci când procesele cu priorități superioare sunt toate blocate sau când nu mai există astfel de procese în sistem.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Cum se realizează partajarea memoriei între două procese pe un sistem care folosește paginare și memorie virtuală?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: Pe un sistem cu paginare și memorie virtuală, fiecare proces dispune de o tabelă de pagini care face asocierea între pagini virtuale și pagini fizice. Două procese diferite pot avea astfel corespondențe de corespondențe la aceeași pagină fizică; paginile virtuale sunt diferite dar vor corespunde aceleiași pagini fizice.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> De ce dereferențierea unei adrese virtuale peste <code>3GB</code> cauzează terminarea/omorârea procesului pe un sistem Linux pe 32 de biți?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: Un sistem Linux pe 32 de biți rezervă pentru spațiul virtual de adrese al fiecărui proces zona <code>[3GB,4GB]</code> pentru sistemul de operare. Această zonă este protejată și accesibilă doar din kernel mode. Dacă un proces accesează o astfel de zonă (prin dereferențierea unei adrese virtuale mai mari de <code>3GB</code>), va primi un <em>page fault</em> și va fi omorât, nefiind validă accesarea acestei adrese din user mode.</div>
</li>
</ul>
</li>
</ol>

</div>

<h4 id="cc_varianta_21">3CC, varianta 2</h4>
<div class="level4">
<ol>
<li class="level1"><div class="li"> De ce preferăm să oferim o cuantă de timp de planificare (<em>scheduling time slice</em>) mai mare proceselor I/O intensive (<em>I/O bound</em>)?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: Preferăm o cuantă de timp mai mare proceselor I/O intensive pentru că acestea au probabilitate mare de a se bloca și de a elibera astfel procesorul, lăsând locul altor procese. Un proces I/O intensiv va părăsi astfel mai rar procesorul din cauză exprirării cuantei, mărind productivitatea (<em>throughput-ul</em>) sistemului (o schimbare de context suplimentară cauzează overhead).</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Un sistem x86 poate folosi pagini de <code>4KB</code> sau de <code>4MB</code> (numite și <em>huge pages</em>). Care este un avantaj al folosirii paginilor de <code>4KB</code> și un avantaj al folosirii paginilor de <code>4MB</code>?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: Avantajul folosirii unei pagini mai mici, de <code>4KB</code>, este că vom avea fragmentară internă redusă (la nivelul unei pagini). Alocarea a <code>10</code> octeți de date într-o pagină nouă lasă nefolosiți <code>4KB-10 octeți</code>, relativ puțin față de același lucru întâmplându-se pentru o pagină de <code>4MB</code>. Un alt avantaj este acela al granularității alocării, în cazul în care acest lucru ne interesează (corelează cu reducerea fragmentării interne). Avantajul folosirii unei pagini mai mare, de <code>4MB</code>, este dimensiunea redusă a tabelei de pagini. Spațiul ocupat de tabela de pagini va fi de <code>1024</code> de ori mai mic decât în cazul folosirii de pagini de <code>4KB</code>. Viteza de căutare în tabela de pagini va fi, de asemenea, redusă.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Dați exemplu de două situații în care apariția unui <em>page fault</em> nu cauzează terminarea/omorârea procesului care a generat <em>page fault</em>-ul.</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: Situații în care un <em>page fault</em> <strong>nu</strong> cauzează terminarea procesului sunt:</div>
<ul>
<li class="level3"><div class="li"> pagina fizică aferentă este în swap și trebuie făcut swap in pentru folosirea acesteia;</div>
</li>
<li class="level3"><div class="li"> pagina fizică nu a fost încă alocată și mapată, pentru că folosim mecanismul de <em>demand paging</em>;</div>
</li>
<li class="level3"><div class="li"> pagina virtuală este <em>read-only</em> și marcată <em>copy-on-write</em>; rezultă un <em>page fault</em> care conduce la duplicarea paginii fizice aferente și marcarea paginii aferente <em>read-write</em>.</div>
</li>
</ul>
</li>
</ul>
</li>
</ol>

</div>

<h4 id="greseli_frecvente1">Greșeli frecvente</h4>
<div class="level4">
<ul>
<li class="level1"><div class="li"> Prioritățile <strong>statice</strong> au problema că unele procese pot fi etern prioritare și pot să producă <em>starvation</em> pentru alte procese. Orice alte explicații sau precizări riscă să </div>
</li>
<li class="level1"><div class="li"> Răspunsuri presupuse sau încercări de a nimeri un răspuns la o întrebare vor conduce de multe ori la un răspuns greșit. Dacă nu știți răspunsul la o întrebare, cel mai bine este să nu răspundeți la acea întrebare. Colecționăm perle și probabil le vom publica (anonime) pentru viitorii studenți.</div>
</li>
</ul>

</div>

<h4 id="lucrari_foarte_bune1">Lucrări foarte bune</h4>
<div class="level4">
<ul>
<li class="level1"><div class="li"> FLOREA Cătălin, 334CC</div>
</li>
<li class="level1"><div class="li"> POȘTOACĂ Andrei Vlad, 332CC</div>
</li>
</ul>

</div>
<!-- EDIT5 SECTION "Lucrare 2" [14404-23231] -->
<h3 class="sectionedit6" id="lucrare_3">Lucrare 3</h3>
<div class="level3">
<ul>
<li class="level1"><div class="li"> La începutul cursului 10:</div>
<ul>
<li class="level2"><div class="li"> marți, 26 aprilie 2016, 08:00-08:15, EC004, seria CA</div>
</li>
<li class="level2"><div class="li"> miercuri, 27 aprilie 2016, 17:00-17:15, EC004, seria CC</div>
</li>
</ul>
</li>
</ul>

</div>

<h4 id="ca_varianta_12">3CA, varianta 1</h4>
<div class="level4">
<ol>
<li class="level1"><div class="li"> Compilatorul folosește <em>canary values</em> pentru a proteja împotriva vulnerabilităților de tip <em>stack buffer overflow</em>, iar toate celelalte mecanisme de protecție sunt dezactivate. Explicați cum poate fi exploatat acest sistem.</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: Cu ajutorul <em>canary values</em> putem proteja spațiul dintre un buffer și adresa de retur. Dacă însă în urma unui <em>stack buffer overflow</em> ajungem să suprascriem un pointer de funcție și sărim astfel la acea funcție, sau dacă suprascriem o variabilă care este apoi folosită într-o comparație și alterăm astfel fluxul de execuție, atunci vom reuși să exploatăm programul. Alternativ, printr-o anumită formă de atac de tip <em>information leak</em> putem extrage valoarea <em>canary value</em> și apoi să suprascriem zona de <em>canary value</em> cu valoarea extrasă (adică valoarea inițială) și să suprascriem și adresa de retur a funcției și să executăm cod din altă zonă din spațiul de adresă. Întrucât <em>canary value</em> nu apare modificat, nu se va detecta o problemă.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Precizați un avantaj și un dezavantaj al folosirii unei implementări de thread-uri user level față de o implementare de thread-uri kernel level.</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: O implementare de thread-uri user level are avantajul unor timpi de creare, schimbare de context și încheiere mult mai rapide. De asemenea, o implementare de thread-uri user level are avantajul că nu necesită suport la nivelul sistemului de operare. Totodată, implementatorul decide funcționarea planificatorului de thread-uri. Pe partea de dezavantaje o bibliotecă cu implementare de thread-uri user level blochează întreg procesul atunci când un thread se blochează, nu poate rula în format multicore (un thread pe un cor) dacă sistemul are așa ceva (sistemul de operare nu este conștient de existența mai multor thread-uri), iar implementaraea planificatorului este în general una colaborativă (nepreemptivă).</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Care este diferența dintre un deadlock și o condiție de cursă (<em>race condition</em>)?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: Un deadlock blochează instanțele de execuție care sunt blocate în deadlock (thread-uri sau procese). O condiție de cursă înseamnă o ordonare necorespunzătoare a instanțelor de execuție astfel încât o instanță folosește date incoerente/corupte, ducând la un comportament arbitrar al programului.</div>
</li>
</ul>
</li>
</ol>

</div>

<h4 id="ca_varianta_22">3CA, varianta 2</h4>
<div class="level4">
<ol>
<li class="level1"><div class="li"> Un sistem are activat DEP (<em>Data Execution Prevention</em>) și ASLR (<em>Address Space Layout Randomization</em>). Într-un program care rulează pe acest sistem un hacker a descoperit o vulnerabilitate de tip <em>stack buffer overflow</em>. Ce poate face atacatorul ca să altereze execuția normală a programului?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: Un atacator poate ajunge să suprascrie o variabilă care este apoi folosită într-o comparație pentru a altera astfel fluxul de execuție. Dacă un atacator suprascrie o adresă de funcție (pointer de funcție sau adresa de retur) atunci acesta poate sări undeva în codul programului (codul existent al programului, nu o bibliotecă al cărei cod este randomizat - ASLR); dacă în acest cod se găsesc elemente care pot fi folosite de atacator (probabil da), acesta va altera execuția programului pentru a îl exploata.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Pe un sistem pe 32 de biți, un programator testează care este limita de procese pe care le poate crea (folosind <code>fork()</code> într-o buclă <code>for</code> într-un program) și care este limita de thread-uri pe care le poate crea (folosind <code>pthread_create()</code> într-o buclă <code>for</code> într-un program). De ce va putea crea mai multe procese decât thread-uri?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: Când creăm thread-uri fiecare thread ocupă în spațiul virtual de adrese al procesului spațiu pentru stivă (în mod tipic <code>8MB</code> pe Linux). Limita de thread-uri care poate fi creată este dată de limita de <code>4GB</code> (pe 32 de biți, de fapt mai puțin pentru că există spațiu ocupat de kernel) pentru spațiul virtual de adrese al procesului. În cazul proceselor, se partajează memoria procesului, doar se creează structurile pentru noul proces. Limita este dată de spațiul fizic de memorie pe care îl are sistemul, în mod tipic suficient pentru a crea mai multe procese în sistem decât thread-uri într-un proces.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Precizați două diferențe între spinlock-uri și mutex-uri.</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: Spinlock-urile folosesc <em>busy waiting</em> în timp ce mutex-urile folosesc blocare. Un spinlock nu reține informații despre thread-urile/procesele care îl folosesc, pe când un mutex menține coada de thread-uri/procese blocate. Un spinlock este util de folosit în regiuni critice de mici dimensiuni în vreme ce un mutex este folosit în regiuni critice de dimensiuni mai mari, eventual și în care thread-urile/procesele fac acțiuni blocante.</div>
</li>
</ul>
</li>
</ol>

</div>

<h4 id="cc_varianta_12">3CC, varianta 1</h4>
<div class="level4">
<ol>
<li class="level1"><div class="li"> De ce este ASLR (<em>Address Space Layout Randomization</em>) un mecanism de protecție mai puternic pe un sistem x86_64 (64 de biți) decât pe un sistem i386 (32 de biți)?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: ASLR este un sistem care plasează la adrese aleatoare zone din spațiul de adresă al procesului (precum heap, stivă, biblioteci partajate). Întrucât este mai mult spațiu disponibili pentru de randomizare pe 64 de biți (de fapt 48 de biți de adrese virtuale) atunci va fi mult mai dificil de “șuntat” ASLR printr-un atac de tipul brute force (încercări repetate). Adică ASLR este mai puternic pe 64 de biți decât pe 32 de biți.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Precizați două avantaje ale folosirii unei implementări de thread-uri kernel level față de o implementare de thread-uri user level.</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: Thread-urile cu implementare kernel level au avantajul că pot folosi suportul de multicore al sistemului fizic, putând fi planificate câte un thread per core și mărind nivelul de paralelism; thread-urile cu implementare user level nu pot folosi suportul de multicore. De asemenea, un într-o implementare kernel level, un thread care se blochează nu blochează întreg procesul, spre deosebire de thread-urile user level.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Pentru sincronizarea accesului la o variabilă, un programator folosește într-un program multithreaded secvența de cod de mai jos. De ce este problematică această secvență în contextul sincronizării accesului?<pre class="code">/* a is initially 0 */
atomic_inc(&amp;a);  /* increment a atomically */
atomic_cmp_xchg(&amp;a, 16, 0); /* atomically do: if (a == 16) a = 0; */</pre>
</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: În secvența de mai sus este posibilă preemptarea unui thread (sau rularea simultană a unui alt thread pe un alt procesor) între cele două instrucțiuni. În acel caz, dacă valoarea variabilei este <code>15</code>, va ajunge la <code>17</code> (două incrementări) iar comparația va eșua, contorul <strong>nu</strong> va fi resetat la <code>0</code>. Operațiile în sine sunt atomice, dar ansamblul nu este atomic.</div>
</li>
</ul>
</li>
</ol>

</div>

<h4 id="cc_varianta_22">3CC, varianta 2</h4>
<div class="level4">
<ol>
<li class="level1"><div class="li"> Pentru exploatarea unei vulnerabilități de tip <em>stack buffer overflow</em> urmărim suprascrierea adresei de retur a unei funcții. Cu ce vom suprascrie adresa de retur în cazul unui atac de tipul <em>return-to-libc</em>?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: În cazul unui atac de tipul <em>return-to-libc</em> vom suprascrie adresa de retur cu adresa unei funcții din biblioteca standard C. De exemplu, adresa funcției system() urmărind apelul <code>system(&quot;/bin/bash&quot;)</code>.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Un programator implementează o aplicație de tip server astfel încât la fiecare conexiune către server se creează un thread nou care se ocupă de gestiunea conexiunii. Care este dezavantajul acestei abordări și care este o alternativă?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: Dezavantajul acestei abordări este că se creează un thread nou la fiecare conexiune (și care apoi este închis la sfârșitul tratării conexiunii). Se consumă foarte multe resurse și timp de creare/închidere a thread-ului. Alternativa este să folosim un pool de thread-uri care să servească la nevoie cereri sosite, fără nevoia de creare a unui thread la fiecare pas. Pornind de la ideea că thread-urile au dezavantajul că pot omorî întreg serverul la o eroare, putem considera și o alternativă de creare a unui proces, dar este mult prea “heavy” această abordare pentru o situație practică.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Pentru comunicarea și pentru sincronizarea accesului într-un mediu multithreaded, un programator are de ales între folosirea unui vector sau a unei liste. Precizați un avantaj al folosirii vectorului în locul listei din punct de vedere al sincronizării.</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: Un vector este o structură de date ușor partiționabilă; dacă un thread dorește să modifice anumite elemente din vector va folosi câte un lock pentru o anumită secțiune/partiție a vectorului. În cazul unei liste este problematică partiționarea întrucât listele își pot modifica pointerii între elemente și duce la date incoerente; soluția la liste este un singur lock pe întreaga listă, rezultând în cod puternic serial.</div>
</li>
</ul>
</li>
</ol>

</div>

<h4 id="greseli_frecvente2">Greșeli frecvente</h4>
<div class="level4">

<p>
Răspunsuri cu definiții despre buffer overflow, DEP, ASLR și nu răspuns la întrebare. Învârtit în jurul întrebării, scris ca să fie scris, dar fără răspuns la întrebare. Un soi de învârtit în jurul cozii.
</p>

<p>
Nu s-a înțeles că dacă ASLR este activat nu se pot face atacuri pe stivă sau în codul din biblioteci. Pentru că stiva și codul din alte biblioteci sunt plasate la adrese aleatoare.
</p>

<p>
Suprascrierea unei adrese nu este un atac. Trebuie să fie suprascrisă adresa cu o adresă validă care pointează către o zonă de cod executabil; suprascrierea cu o valoare neadecvată va duce la Segmentation fault dar nu exploatarea programului.
</p>

<p>
Într-un sistem cu DEP și ASLR, <strong>nu</strong> se poate sări la un cod injectat de atacator. Codul nu poate fi injectat pe un sistem cu DEP, pentru că nu se poate executa ceea ce a scris cineva.
</p>

<p>
Exprimarea “Limita de thread-uri este dată de numărul de core-uri” (sau alte exprimări echivalente) este nevalidă. Thread-urile care <strong>rulează</strong> sunt limitate de numărul de core-uri, dar nu cele care există la nivelul sistemului.
</p>

<p>
“Avantaj kernel level threads față de user level threads: omorârea unui thread nu omoară întreg procesul”. Și variante pe această temă: “Dacă se blochează un thread nu moare întreg procesul.” În ambele cazuri omorârea unui thread duce la încheierea procesului.
</p>

<p>
Legat de kernel level threads: “Dacă moare un thread în kernel, celelalte încă rulează. În user space dacă moare un thread, acesta generează o excepție care duce la oprirea întregului proces.” În ambele cazuri omorârea unui thread duce la încheierea procesului.
</p>

</div>

<h4 id="lucrari_foarte_bune2">Lucrări foarte bune</h4>
<div class="level4">
<ul>
<li class="level1"><div class="li"> CIOCÎRLAN Ștefan-Dan, 331CA</div>
</li>
<li class="level1"><div class="li"> ȘTEFU Teodor, 332CC</div>
</li>
<li class="level1"><div class="li"> CRUCERU Călin, 335CB</div>
</li>
<li class="level1"><div class="li"> COMAN Tudor Emil, 333CC</div>
</li>
<li class="level1"><div class="li"> RIȚĂ Cristian, 335CC</div>
</li>
<li class="level1"><div class="li"> DINU Andrei Mario, 335CC</div>
</li>
<li class="level1"><div class="li"> MURARU George, 333CB</div>
</li>
<li class="level1"><div class="li"> POPA Maria Cătălina, 331CC</div>
</li>
<li class="level1"><div class="li"> MATEȘICĂ Iulian-Răzvan, 331CC</div>
</li>
</ul>

</div>
<!-- EDIT6 SECTION "Lucrare 3" [23232-34343] -->
<h3 class="sectionedit7" id="lucrare_4">Lucrare 4</h3>
<div class="level3">
<ul>
<li class="level1"><div class="li"> La începutul cursului 13:</div>
<ul>
<li class="level2"><div class="li"> marți, 24 mai 2016, 08:00-08:15, EC004, seria CA</div>
</li>
<li class="level2"><div class="li"> miercuri, 25 mai 2016, 17:00-17:15, EC004, seria CC</div>
</li>
</ul>
</li>
</ul>

</div>

<h4 id="ca_varianta_13">3CA, varianta 1</h4>
<div class="level4">
<ol>
<li class="level1"><div class="li"> Descrieți cum ajung datele din buffer-ul <code>buf</code> la dispozitivul de I/O în cazul apelului <code>write(fd, buf, 100)</code>.</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: Datele din buffer sunt pentru început copiate în memorie în kernel space în urma unui apel de sistem. Apoi datele ajung în registrele dispozitivului cu ajutorul driverului de dispozitiv din kernel folosind, în general, întreruperi.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Un transmițător efectuează un apel <code>send(s,buf,10000,0)</code> pe un socket TCP conectat. La receptor se apelează <code>recv(s,buf,10000,0)</code>. Câți octeți se vor primi la receptor?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: Datele pot ajunge în partiții (chunk-uri de date) diferite între transmitățor și receptor din cauza buffer-ului transmițătorului, modului de funcționare a rețelei și buffer-ul receptorului. Receptorul poate primi de la <code>1</code> octet până la toți cei <code>10000</code> de octeți și aceasta este valoarea întoarsă de apelul <code>recv()</code>: câți octeți sunt disponibili atunci în buffer-ul receptorului.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Comanda <code>rm f.txt</code> rulează cu succes. În ce situație rularea acestei comenzi va duce la ștergerea fișierului <code>f.txt</code> pe un sistem de fișiere cu inode-uri?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: Comanda <code>rm</code> desface un link (un hard link, un nume) de la un inode. Dacă numele/link-ul <code>f.txt</code> este singurul link la inode-ul aferent fișierului, atunci fișierul va fi șters de pe disc. Dacă există mai multe nume/link-uri la fișier, atunci desfacerea link-ului <code>f.txt</code> nu va conduce la ștergerea fișierului de pe disc.</div>
</li>
</ul>
</li>
</ol>

</div>

<h4 id="ca_varianta_23">3CA, varianta 2</h4>
<div class="level4">
<ol>
<li class="level1"><div class="li"> Dați un exemplu de situație în care folosirea polling este de preferat folosirii întreruperilor pentru comunicarea cu un dispozitiv I/O.</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: Polling este preferat întreruperilor dacă ar veni foarte multe întreruperi, adică dacă procesorul ar sta ocupat în întreruperi în loc să facă acțiuni de procesare. Astfel în cazul dispozitivelor care efectuează transferuri rapide de date și care, astfel, ar genera foarte multe întreruperi, este de preferat să folosim polling. Este cazul plăcii de rețea, care atinge viteze foarte mari (de exemplu plăci de rețea de <code>10Gbit</code>).</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Când se întoarce cu succes apelul <code>accept()</code> în cadrul 3-way handshake-ul TCP? <strong>Justificați.</strong></div>
<ol>
<li class="level2"><div class="li"> după primirea primului pachet (conținând flag-ul SYN)</div>
</li>
<li class="level2"><div class="li"> după primirea celui de-al treilea pachet (conținând flag-ul ACK)</div>
</li>
</ol>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: Apelul <code>accept()</code> se întoarce în momentul în care conexiunea a fost realizată și socket-ul TCP întors poate fi folosit pentru transmitere și recepție de date. Pentru aceasta, trebuie ca întreg handshake-ul să aibă loc pentru a confirma că receptorul și transmitățorul sunt conectați și că numerele de secvență inițiale (ISN: <em>Initial Sequence Number</em>) au fost negociate.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Precizați un avantaj și un dezavantaj al folosirii FAT (<em>file allocation table</em>) pentru gestiunea spațiului într-un sistem de fișiere.</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: FAT are ca avantaje simplitatea (implementare ușoară) și eficiența stocării, având doar pointeri către indecși. Dezavantajul este că folosim un spațiu proporțional cu dimensiunea partiției care poate ajunge destul de mare pentru partiții mari. De asemenea, nu există suport implicit pentru metadate legate de securitate.</div>
</li>
</ul>
</li>
</ol>

</div>

<h4 id="cc_varianta_13">3CC, varianta 1</h4>
<div class="level4">
<ol>
<li class="level1"><div class="li"> Care este un avantaj și un dezavantaj al folosirii operațiilor I/O asincrone?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: Operațiile asincrone au avantajul că nu sunt blocante și că se pot planifica mai multe acțiuni asincrone simultan fără a trebui să așteptăm încheierea acestora. Dezavantajele țin de dificultatea în implementare: e nevoie de o structură care să rețină starea operațiile asincrone realizate și de un mecanism de notificare și sincronizare în cazul încheierii operațiilor.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> În ce situație apelul <code>send(s,buf,100,0)</code> pe un socket se blochează?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: Apelul <code>send()</code> se blochează în cazul în care buffer-ul de <code>send</code> al socketului TCP este plin. În acel moment kernel-ul nu poate copia nici măcar un octet din datele din user space în kernel space și blochează apelul. Acest lucru poate fi cauzat de o congestie în rețea care a prevenit ca datele să fie trimise prin rețea din buffer-ul de <code>send</code>.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Cu ce diferă un director de un fișier obișnuit (<em>regular file</em>) din punctul de vedere al implementării sistemului de fișiere?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: Un fișier obișnuit conține date nestructurate (<em>byte stream</em>). Un director conține date structurate, adică un vector de <em>directory entries</em> (dentry-uri): nume de fișier și index de inode.</div>
</li>
</ul>
</li>
</ol>

</div>

<h4 id="cc_varianta_23">3CC, varianta 2</h4>
<div class="level4">
<ol>
<li class="level1"><div class="li"> De ce, în lucrul cu discul, apelul <code>write()</code> în general <strong>NU</strong> se blochează?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: În urma unui apel <code>write()</code> datele sunt, în cazul discului, copiate din user space în buffer cache de unde vor fi la un moment dat scrise pe disc. Apelul de sistem <code>write()</code> nu interacționează efectiv cu discul, ci doar copiază datele în <em>buffer cache</em>, operație care nu este blocantă (nu interacționează cu un dispozitiv de I/O).</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Ce apel de funcție pe socket declanșează handshake-ul TCP de inițiere de conexiune?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: Funcția <code>connect()</code> este cea care, apelată din client conduce la realizarea conexiunii TCP (se creează <em>3-way handshake</em>). Funcția creează un socket pe partea clientului care este unul dintre capetele conexiunii. În partea de server celălalt capăt este creat cu ajutorul apelului <code>accept()</code>.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> De ce numele unui fișier <strong>NU</strong> este parte a inode-ului?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>: Numele unui fișier nu este parte a inode-ului din rațiuni de eficiență (multe acțiuni se fac doar pe nume și nu dorim să citim tot inode-ul pentru acest lucru) și pentru a permite hard link-uri, adică mai multe nume care să refere același fișier.</div>
</li>
</ul>
</li>
</ol>

</div>

<h4 id="greseli_frecvente3">Greșeli frecvente</h4>
<div class="level4">
<ul>
<li class="level1"><div class="li"> Apelul <code>send()</code> se blochează atunci când buffer-ul de <code>receive</code> este plin.</div>
</li>
<li class="level1"><div class="li"> Apelul <code>send()</code> se blochează dacă nu există 100 de octeți liberi în buffer-ul de <code>send</code>.</div>
</li>
</ul>

</div>

<h4 id="lucrari_foarte_bune3">Lucrări foarte bune</h4>
<div class="level4">
<ul>
<li class="level1"><div class="li"> GHEORGHE Liviu-Adrian, 335CC</div>
</li>
</ul>

</div>
<!-- EDIT7 SECTION "Lucrare 4" [34344-40715] -->
<h2 class="sectionedit8" id="examene_anterioare">Examene anterioare</h2>
<div class="level2">
<ul>
<li class="level1"><div class="li"> <a href="../../../../so/meta/examen/2014-2015.html" class="wikilink1" title="so:meta:examen:2014-2015"> Examene și lucrări 2014-2015</a></div>
</li>
<li class="level1"><div class="li"> <a href="../../../../so/meta/examen/2013-2014.html" class="wikilink1" title="so:meta:examen:2013-2014"> Examene și lucrări 2013-2014</a></div>
</li>
<li class="level1"><div class="li"> <a href="../../../../so/meta/examen/2012-2013.html" class="wikilink1" title="so:meta:examen:2012-2013"> Examene și lucrări 2012-2013</a></div>
</li>
<li class="level1"><div class="li"> <a href="http://elf.cs.pub.ro/so/wiki/examen" class="urlextern" title="http://elf.cs.pub.ro/so/wiki/examen"  rel="nofollow"> Examene și lucrări 2011-2012</a></div>
</li>
<li class="level1"><div class="li"> <a href="http://elf.cs.pub.ro/so/wiki/examen/2010-2011" class="urlextern" title="http://elf.cs.pub.ro/so/wiki/examen/2010-2011"  rel="nofollow"> Examene și lucrări 2010-2011</a></div>
</li>
<li class="level1"><div class="li"> <a href="http://elf.cs.pub.ro/so/wiki/examen/2009-2010" class="urlextern" title="http://elf.cs.pub.ro/so/wiki/examen/2009-2010"  rel="nofollow"> Examene și lucrări 2009-2010</a></div>
</li>
<li class="level1"><div class="li"> <a href="http://elf.cs.pub.ro/so/wiki/examen/2008-2009" class="urlextern" title="http://elf.cs.pub.ro/so/wiki/examen/2008-2009"  rel="nofollow"> Examene și lucrări 2008-2009</a></div>
</li>
</ul>

</div>
<!-- EDIT8 SECTION "Examene anterioare" [40716-] --></div>
</body>
</html>
