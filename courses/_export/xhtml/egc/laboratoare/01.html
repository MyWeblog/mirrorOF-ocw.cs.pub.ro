    
    

<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
  <meta charset="utf-8" />
  <title>egc:laboratoare:01</title>
<meta name="generator" content="DokuWiki"/>
<meta name="robots" content="index,follow"/>
<meta name="date" content="2016-10-16T20:34:08+0300"/>
<meta name="keywords" content="egc,laboratoare,01"/>
<link rel="search" type="application/opensearchdescription+xml" href="../../../../lib/exe/opensearch.php" title="CS Open CourseWare"/>
<link rel="start" href="../../../../../courses.1.html"/>
<link rel="alternate" type="application/rss+xml" title="Recent Changes" href="../../../../feed.php"/>
<link rel="alternate" type="application/rss+xml" title="Current Namespace" href="../../../../feed.php%3Fmode=list&amp;ns=egc:laboratoare"/>
<link rel="alternate" type="text/html" title="Plain HTML" href="01.html"/>
<link rel="canonical" href="../../../../egc/laboratoare/01.html"/>
<link rel="stylesheet" type="text/css" href="../../../../lib/exe/css.php%3Ft=arctic&amp;tseed=1476798676.css"/>
<script type="text/javascript">/*<![CDATA[*/var NS='egc:laboratoare';var JSINFO = {"id":"egc:laboratoare:01","namespace":"egc:laboratoare","isadmin":0,"isauth":0};
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="../../../../lib/exe/js.php%3Ftseed=1476798676"></script>
<script type="text/x-mathjax-config">/*<![CDATA[*/MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ["$","$"], ["\\(","\\)"] ],
        displayMath: [ ["$$","$$"], ["\\[","\\]"] ],
        processEscapes: true
    }
});
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
<script type="text/javascript">/*<![CDATA[*/
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
		  
/*!]]>*/</script>
<script type="text/javascript">/*<![CDATA[*/
var pageTracker = _gat._getTracker("UA-38383934-1");
pageTracker._initData();
pageTracker._trackPageview();
		  
/*!]]>*/</script>
</head>
<body>
<div class="dokuwiki export">
<!-- TOC START -->
<div id="dw__toc">
<h3 class="toggle">Table of Contents</h3>
<div>

<ul class="toc">
<li class="level1"><div class="li"><a href="01.html#laboratorul_01">Laboratorul 01</a></div>
<ul class="toc">
<li class="clear">
<ul class="toc">
<li class="level3"><div class="li"><a href="01.html#introducere">Introducere</a></div></li>
<li class="level3"><div class="li"><a href="01.html#framework_laborator">Framework laborator</a></div></li>
<li class="level3"><div class="li"><a href="01.html#structura_framework-ului">Structura framework-ului</a></div></li>
<li class="level3"><div class="li"><a href="01.html#functionarea_unei_aplicatii_grafice_opengl">Functionarea unei aplicatii grafice (OpenGL)</a></div>
<ul class="toc">
<li class="level4"><div class="li"><a href="01.html#multi-buffering">Multi-buffering</a></div></li>
</ul>
</li>
<li class="level3"><div class="li"><a href="01.html#modelul_de_functionare_al_aplicatiei_de_laborator">Modelul de functionare al aplicatiei de laborator</a></div>
<ul class="toc">
<li class="level4"><div class="li"><a href="01.html#etapele_rularii_aplicatiei">Etapele rularii aplicatiei</a></div></li>
</ul>
</li>
<li class="level3"><div class="li"><a href="01.html#standardul_opengl">Standardul OpenGL</a></div>
<ul class="toc">
<li class="level4"><div class="li"><a href="01.html#utilizarea_api">Utilizarea API</a></div></li>
</ul>
</li>
<li class="level3"><div class="li"><a href="01.html#cerinte_generale_de_laborator">Cerinte generale de laborator</a></div></li>
<li class="level3"><div class="li"><a href="01.html#laboratorul_1">Laboratorul 1</a></div>
<ul class="toc">
<li class="level4"><div class="li"><a href="01.html#framework">Framework</a></div></li>
<li class="level4"><div class="li"><a href="01.html#informatii_laborator">Informatii laborator</a></div></li>
<li class="level4"><div class="li"><a href="01.html#cerinte_laborator">Cerinte laborator</a></div></li>
</ul>
</li>
<li class="level3"><div class="li"><a href="01.html#glm">GLM</a></div></li>
</ul></li>
</ul></li>
</ul>
</div>
</div>
<!-- TOC END -->

<h1 class="sectionedit1" id="laboratorul_01">Laboratorul 01</h1>
<div class="level1">

</div>
<!-- EDIT1 SECTION "Laboratorul 01" [1-31] -->
<h3 class="sectionedit2" id="introducere">Introducere</h3>
<div class="level3">

<p>
Grafica pe calculator este un subiect amblu utilizat intr-un numar din ce in ce mai mare de domenii. In acest laborator se vor prezenta conceptele ce stau la baza graficii cat si a utilizarii placii video pentru acest scop. Domeniul graficii computerizate necesita cunostiinte variate: matematica, fizica, algoritmica, grafica digitala 2D &amp; 3D, user experience design, etc. 
</p>

</div>
<!-- EDIT2 SECTION "Introducere" [32-430] -->
<h3 class="sectionedit3" id="framework_laborator">Framework laborator</h3>
<div class="level3">

<p>
Intrucat scrierea unei aplicatii simple OpenGL nu se poate realiza foarte usor intr-un timp scurt, dar si pentru a putea prezenta mai simplu conceptele de baza ale graficii computerizate moderne, in cadrul laboratoarelor se va lucra pe un framework ce ofera o serie de functionalitati gata implementate. Framework-ul utilizat ofera toate functionalitatile de baza ale unui mini Engine grafic precum:
</p>
<ul>
<li class="level1"><div class="li"> Fereastra de desenare avand la baza un context <strong>OpenGL 3.3+</strong></div>
</li>
<li class="level1"><div class="li"> Suport pentru incarcarea de meshe 3D</div>
</li>
<li class="level1"><div class="li"> Suport pentru incarcarea de texturi 2D pentru texturarea meshelor 3D</div>
</li>
<li class="level1"><div class="li"> Suport pentru definirea si incarcarea de shadere OpenGL</div>
</li>
</ul>

<p>
De asemenea pe langa functionalitatile de baza framework-ul implementeaza un model generic pentru scrierea de aplicatii OpenGL. Astfel sunt oferite urmatoarele aspecte:
</p>
<ul>
<li class="level1"><div class="li"> Control pentru fereastra de afisare</div>
</li>
<li class="level1"><div class="li"> Management pentru input de la tastatura si mouse</div>
</li>
<li class="level1"><div class="li"> Camera de vizualizare cu input predefinit pentru a usura deplasarea si visualizarea scenei</div>
</li>
<li class="level1"><div class="li"> Model arhitectural a unei aplicatii simple OpenGL bazat pe toate aspectele prezentate</div>
</li>
</ul>

<p>
Functionalitatea framework-ului este oferita prin intermediul mai multor biblioteci (libraries):
</p>
<ul>
<li class="level1"><div class="li"> <strong>GLFW</strong> - <a href="http://www.glfw.org/" class="urlextern" title="http://www.glfw.org/"  rel="nofollow">http://www.glfw.org/</a> </div>
<ul>
<li class="level3"><div class="li"> oferta supportul de baza pentru <abbr title="Application Programming Interface">API</abbr> OpenGL precum context, fereastra, input, etc</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> <strong>GLEW</strong> - <a href="http://glew.sourceforge.net/" class="urlextern" title="http://glew.sourceforge.net/"  rel="nofollow">http://glew.sourceforge.net/</a></div>
<ul>
<li class="level2"><div class="li"> Asigura suportul pentru extensiile de OpenGL suportate de placa video</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> <strong>GLM</strong> - <a href="http://glm.g-truc.net" class="urlextern" title="http://glm.g-truc.net"  rel="nofollow">http://glm.g-truc.net</a></div>
<ul>
<li class="level2"><div class="li"> Functionalitati matematice bazate pe specificatiile limbajului GLSL (shadere OpenGL)</div>
</li>
<li class="level2"><div class="li"> Asigura interoperabilitate simpla cu <abbr title="Application Programming Interface">API</abbr> OpenGL</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> <strong>ASSIMP</strong> - <a href="http://www.assimp.org/" class="urlextern" title="http://www.assimp.org/"  rel="nofollow">http://www.assimp.org/</a></div>
<ul>
<li class="level2"><div class="li"> Open Asset Import Library</div>
</li>
<li class="level2"><div class="li"> Ofera suport pentru incarcarea de meshe si scene 3D </div>
</li>
<li class="level2"><div class="li"> Suporta majoritatea formatele de stocarea 3D utilizate in industrie</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> <strong>STB</strong> - <a href="https://github.com/nothings/stb" class="urlextern" title="https://github.com/nothings/stb"  rel="nofollow">https://github.com/nothings/stb</a></div>
<ul>
<li class="level2"><div class="li"> Ofera support pentru incarcare/decodare de imagini JPG, PNG, TGA, BMP, PSD,  etc.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> <strong>EGC-Components</strong> – closed source</div>
<ul>
<li class="level2"><div class="li"> Ofera o serie de functionalitati ce vor fi utilizate incepand din primul laborator dar care vor fi implementate si de catre studenti pe parcursul laboratoarelor</div>
</li>
</ul>
</li>
</ul>

</div>
<!-- EDIT3 SECTION "Framework laborator" [431-2625] -->
<h3 class="sectionedit4" id="structura_framework-ului">Structura framework-ului</h3>
<div class="level3">
<ul>
<li class="level1"><div class="li"> <strong>/libs</strong></div>
<ul>
<li class="level2"><div class="li"> Bibliotecile utilizate in cadrul framework-ului</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> <strong>/Visual Studio</strong></div>
<ul>
<li class="level2"><div class="li"> Proiect Visual Studio 2013/2015 preconfigurat</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> <strong>/Resources</strong></div>
<ul>
<li class="level2"><div class="li"> Resurse necesare rularii proiecutului</div>
</li>
<li class="level2"><div class="li"> <strong>/Textures</strong></div>
<ul>
<li class="level3"><div class="li"> diverse imagini ce pot fi incarcate si utilizate ca texturi</div>
</li>
</ul>
</li>
<li class="level2"><div class="li"> <strong>/Shaders</strong></div>
<ul>
<li class="level3"><div class="li"> exemple de programe shader, Vertex Shader si Fragment Shader</div>
</li>
</ul>
</li>
<li class="level2"><div class="li"> <strong>/Models</strong></div>
<ul>
<li class="level3"><div class="li"> meshe 3D ce pot fi incarcate in cadrul framework-ului</div>
</li>
</ul>
</li>
</ul>
</li>
<li class="level1"><div class="li"> <strong>/Source</strong></div>
<ul>
<li class="level2"><div class="li"> Surse C++</div>
</li>
<li class="level2"><div class="li"> <strong>/include</strong></div>
<ul>
<li class="level3"><div class="li"> o serie de headere predefinite pentru facilitarea acesului la librarii</div>
</li>
<li class="level3"><div class="li"> <em class="u">gl.h</em></div>
<ul>
<li class="level4"><div class="li"> adauga supportul pentru <abbr title="Application Programming Interface">API</abbr>-ul OpenGL</div>
</li>
</ul>
</li>
<li class="level3"><div class="li"> <em class="u">glm.h</em></div>
<ul>
<li class="level4"><div class="li"> adauga majoritatea headerelor glm ce vor fi utilizate</div>
</li>
<li class="level4"><div class="li"> printare usoara pentru <code>glm::vec2, glm::vec3, glm::vec4</code> prin intermediul operatorului C++ supraincarcat: <code>operator«</code></div>
</li>
</ul>
</li>
<li class="level3"><div class="li"> <em class="u">math.h</em></div>
<ul>
<li class="level4"><div class="li"> simple definitii preprocesor  pentru MIN, MAX, conversie radiani ⇔ grade</div>
</li>
</ul>
</li>
<li class="level3"><div class="li"> <em class="u">utils.h</em></div>
<ul>
<li class="level4"><div class="li"> simple definitii preprocesor pentru lucrul cu memoria si pe biti</div>
</li>
</ul>
</li>
</ul>
</li>
<li class="level2"><div class="li"> <strong>/Components</strong></div>
<ul>
<li class="level3"><div class="li"> diverse implementari ce facilitareaza lucrul in cadrul laboratoarelor</div>
</li>
<li class="level3"><div class="li"> <em class="u">SimpleScene.cpp</em></div>
<ul>
<li class="level4"><div class="li"> model de baza al unei scene 3D utilizata ca baza a tuturor laboratoarelor</div>
</li>
</ul>
</li>
<li class="level3"><div class="li"> <em class="u">CameraInput.cpp</em></div>
<ul>
<li class="level4"><div class="li"> Imlpementare unul model simplu de control FPS al camerei de vizualizare oferite de libraria EGC-Components</div>
</li>
</ul>
</li>
</ul>
</li>
<li class="level2"><div class="li"> <strong>/Core</strong></div>
<ul>
<li class="level3"><div class="li"> <abbr title="Application Programming Interface">API</abbr>-ul de baza al framwork-ul EGC</div>
</li>
<li class="level3"><div class="li"> <strong>/GPU</strong></div>
<ul>
<li class="level4"><div class="li"> <em class="u">GPUBuffers.cpp</em></div>
<ul>
<li class="level5"><div class="li"> Asigura supportul pentru definirea de buffere de date si incarcarea de date (tip mesh) pe GPU</div>
</li>
</ul>
</li>
<li class="level4"><div class="li"> <em class="u">Mesh.cpp</em></div>
<ul>
<li class="level5"><div class="li"> Loader de meshe 3D atat din fisier cat si din memorie</div>
</li>
</ul>
</li>
<li class="level4"><div class="li"> <em class="u">Shader.cpp</em></div>
<ul>
<li class="level5"><div class="li"> Loader de programe Shader pentru placa video</div>
</li>
</ul>
</li>
<li class="level4"><div class="li"> <em class="u">Texture2D.cpp</em></div>
<ul>
<li class="level5"><div class="li"> Loader de texturi 2D pe GPU</div>
</li>
</ul>
</li>
</ul>
</li>
<li class="level3"><div class="li"> <strong>/Managers</strong></div>
<ul>
<li class="level4"><div class="li"> <em class="u">ResourcePath.h</em></div>
<ul>
<li class="level5"><div class="li"> Locatii predefinite pentru utilizarea la incarcarea resurselor</div>
</li>
</ul>
</li>
<li class="level4"><div class="li"> <em class="u">TextureManager.cpp</em></div>
<ul>
<li class="level5"><div class="li"> Asigura incarcare si management pentru texturile Texture2D</div>
</li>
<li class="level5"><div class="li"> Incarca o serie de texturi simple predefinite </div>
</li>
</ul>
</li>
</ul>
</li>
<li class="level3"><div class="li"> <strong>/Window</strong></div>
<ul>
<li class="level4"><div class="li"> <em class="u">WindowCallbacks.cpp</em></div>
<ul>
<li class="level5"><div class="li"> Asigura implementarea functiilor de callback necesare de GLFW pentru un context OpenGL oarecare</div>
</li>
<li class="level5"><div class="li"> Evenimentele GLFW sunt redirectionate catre fereastra definita de Engine</div>
</li>
</ul>
</li>
<li class="level4"><div class="li"> <em class="u">WindowObject.cpp</em></div>
<ul>
<li class="level5"><div class="li"> Ofera implementarea de fereastra de lucru, support predefinite definire pentru callbacks, dar si un model de buffering pentru evenimente de input tastatura si mouse</div>
</li>
</ul>
</li>
<li class="level4"><div class="li"> <em class="u">InputController.cpp</em></div>
<ul>
<li class="level5"><div class="li"> Prin mostenire ofera support pentru implementarea callback-urilor de input/tastatura. O data instantiat obiectul se va atasa automat pe ferestara de lucru (pe care o obtine de la Engine) si va primi automat evenimentele de input pe care le va executa conform implementarii</div>
</li>
<li class="level5"><div class="li"> In cadrul unui program pot exista oricate astefel de obiecte. Toate vor fi apelate in ordinea atasarii lor dar si a producerii evenimentelor</div>
</li>
</ul>
</li>
<li class="level4"><div class="li"> <em class="u">Engine.cpp</em></div>
<ul>
<li class="level5"><div class="li"> Asigura initializarea contextului OpenGL si a ferestrei de lucru</div>
</li>
</ul>
</li>
<li class="level4"><div class="li"> <em class="u">World.cpp</em></div>
<ul>
<li class="level5"><div class="li"> Asigura implementarea modelul de functionare al unei aplicatii OpenGL pe baza <abbr title="Application Programming Interface">API</abbr>-ului oferit de Framework</div>
</li>
</ul>
</li>
</ul>
</li>
<li class="level3"><div class="li"> <strong>/Laboratoare</strong></div>
<ul>
<li class="level4"><div class="li"> Implementarile pentru fiecare laborator EGC</div>
</li>
<li class="level4"><div class="li"> Fiecare laborator va pleca de la baza oferita de SimpleScene</div>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

</div>
<!-- EDIT4 SECTION "Structura framework-ului" [2626-6150] -->
<h3 class="sectionedit5" id="functionarea_unei_aplicatii_grafice_opengl">Functionarea unei aplicatii grafice (OpenGL)</h3>
<div class="level3">

<p>
Orice aplicatie trebuie sa asigure functionalitatea pe o anumita perioada de timp. In functie de cerinte aceasta perioada poate fi :
</p>
<ul>
<li class="level1"><div class="li"> determinista, programul va executa un anumit task iar apoi se va inchide (majoritatea programelor create in cadrul facultatii pana in acest moment respecta acest model)</div>
</li>
<li class="level1"><div class="li"> ruleaza o serie de task-uri pe o perioada indefinita (sau cel putin pana in momentul in care utilizatorul sau un eveniment extern inchide aplicatia)</div>
</li>
</ul>

<p>
Aplicatiile grafice cu suport de vizualizare real-time (de exemplu jocuri, sau ce vom face noi la EGC) se regasesc in cel de-al doilea model si au la baza functionarea pe baza unui loop de procesare.<br/>

In cadrul framework-ulu EGC acest loop arata astfel (vezi World::LoopUpdate())
</p>
<ol>
<li class="level1"><div class="li"> Se interogheaza evenimentele ferestrei OpenGL (input, resize, etc.)</div>
<ul>
<li class="level2"><div class="li"> Evenimentele sunt salvate pentru a fi procesate mai tarziu</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Se estimeaza timpul de executie pentru iteratia actuala (timpul de executie al interatiei precedente)</div>
</li>
<li class="level1"><div class="li"> Se proceseaza evenimentele salvate anterior</div>
</li>
<li class="level1"><div class="li"> Se proceseaza frame-ul actual (este indicat sa se ia in considerare timpul de executie in cadrul modificarilor pentru a oferi actualizare independenta de timp)</div>
</li>
<li class="level1"><div class="li"> <em>Optional</em>: In cazul double sau triple buffering se interschimba bufferele de imagine</div>
</li>
<li class="level1"><div class="li"> Se trece la urmatorul frame (se revine la pasul 1)</div>
</li>
</ol>

<p>
<p><div class="noteclassic">
Cel mai simplu model de aplicatie OpenGL va trata evenimentele de input (mouse, tastatura) la momentul producerii lor. Acest model nu  este indicat deoarece are numeroase dezavantaje:
</p>
<ul>
<li class="level1"><div class="li"> nu ofera posibilitatea de a trata combinatii de taste (Exemplu: utilizatorul apasa W si A pentru a misca caracterul in diagonala)</div>
</li>
<li class="level1"><div class="li"> nu ofera infrmatii ce tin de starea continua a unui eveniment</div>
<ul>
<li class="level2"><div class="li"> <strong>Exemplu</strong>: Un caracter de joc trebuie sa se miste in fata atat timp cat utilizatorul tine apasata tasta <strong>W</strong>.</div>
<ul>
<li class="level3"><div class="li"> Pentru a trata corespunzator o astfel de logica este necesar sa mentinem starea tastei <strong>W</strong> iar atunci cand dorim sa miscam caracterul sa il miscam direct proportional cu timpul trecut de la ultimul frame procesat</div>
</li>
<li class="level3"><div class="li"> Acelasi lucru se aplica si in cazul butoanelor de la mouse</div>
</li>
</ul>
</li>
</ul>
</li>
</ul>

<p>
De asemenea, un model bazat pe buffering al evenimentelor de input ofera posibilitatea de a interoga starea input-ului in orice moment al unui frame, deci ofera si o flexibilitatea generala mai mare pentru a implementa noi comportamente/logici. Clasa <code>WindowObject</code> asigura supportul pentru buffering dar si pentru procesarea ulterioara a evenimentelor prin intermediul obiectelor de tipul <code>InputController</code>.
</p>

<p>
Recomandam sa cititi documentatia GLFW despre tratarea evenimentelor de input pentru a intelege mai bine conceptele prezentate: <a href="http://www.glfw.org/docs/latest/input_guide.html" class="urlextern" title="http://www.glfw.org/docs/latest/input_guide.html"  rel="nofollow">http://www.glfw.org/docs/latest/input_guide.html</a>
</p>

<p>

</div></p>
</p>

</div>

<h4 id="multi-buffering">Multi-buffering</h4>
<div class="level4">

<p>
In general aplicatiile grafice folosesc mai multe buffere de imagini separate pentru a evita aparitia artefactelor grafice prin modificarea directa a imaginii randate pe ecran. Astfel imaginea afisata la momentul T a fost procesata la momentul T-1, sau T-2 in functie de dimensiunea bufferului)<br/>

</p>

<p>
Informatii aditionale despre aceasta tehnica multi-buffering pot fi obtiunute de pe wiki:
</p>
<ul>
<li class="level1"><div class="li"> <a href="https://en.wikipedia.org/wiki/Multiple_buffering" class="urlextern" title="https://en.wikipedia.org/wiki/Multiple_buffering"  rel="nofollow">https://en.wikipedia.org/wiki/Multiple_buffering</a></div>
</li>
<li class="level1"><div class="li"> <a href="https://en.wikipedia.org/wiki/Multiple_buffering#Double_buffering_in_computer_graphics" class="urlextern" title="https://en.wikipedia.org/wiki/Multiple_buffering#Double_buffering_in_computer_graphics"  rel="nofollow">https://en.wikipedia.org/wiki/Multiple_buffering#Double_buffering_in_computer_graphics</a></div>
</li>
<li class="level1"><div class="li"> <a href="https://en.wikipedia.org/wiki/Multiple_buffering#Triple_buffering" class="urlextern" title="https://en.wikipedia.org/wiki/Multiple_buffering#Triple_buffering"  rel="nofollow">https://en.wikipedia.org/wiki/Multiple_buffering#Triple_buffering</a></div>
</li>
</ul>

</div>
<!-- EDIT5 SECTION "Functionarea unei aplicatii grafice (OpenGL)" [6151-9579] -->
<h3 class="sectionedit6" id="modelul_de_functionare_al_aplicatiei_de_laborator">Modelul de functionare al aplicatiei de laborator</h3>
<div class="level3">

<p>
In cadrul unui laborator modelul aplicatiei grafice prezentat mai sus este implementat de catre clasa <code>World</code>.<br/>
Pasul 2 este tratat de catre instantele InputController in timp ce pasul 4 este asigurat de functiile <code>FrameStart()</code>, <code>Update(float deltaTime)</code>, si <code>FrameEnd()</code> mostenite de la clasa <code>World</code>. Clasa <code>World</code> extinde deja <code>InputController</code> pentru a usura munca in cadrul laboratorului.<br/>

Toate laboratoarele EGC vor fi implementate pe baza <code>SimpleScene</code> ce ofera urmatoarele facilitati:
</p>
<ul>
<li class="level1"><div class="li"> scena 3D cu randarea sistem de referinta in coodronate OpenGL</div>
<ul>
<li class="level2"><div class="li"> plan orizontal XOZ</div>
</li>
<li class="level2"><div class="li"> evidentiarea spatiului pozitiv OX, OY, OZ)</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> camera predefinita pentru explorarea scenei</div>
</li>
<li class="level1"><div class="li"> shadere predefinite pentru lucrul in primele laboratoare</div>
</li>
<li class="level1"><div class="li"> management penstru stocarea shaderelor si meshelor nou create prin nume</div>
</li>
</ul>

</div>

<h4 id="etapele_rularii_aplicatiei">Etapele rularii aplicatiei</h4>
<div class="level4">
<ol>
<li class="level1"><div class="li"> Se definesc proprietatile pentru fereastra de lucru (Main.cpp)</div>
</li>
<li class="level1"><div class="li"> Se intializeaza Engine-ul astfel - <code>Engine::Init()</code></div>
<ol>
<li class="level2"><div class="li"> Se initializeaza <abbr title="Application Programming Interface">API</abbr>-ul OpenGL (<code>glfwInit()</code>)</div>
</li>
<li class="level2"><div class="li"> Se creaza fereastra de lucru cu un context OpenGL 3.3+ ()</div>
<ol>
<li class="level3"><div class="li"> Se ataseaza evenimentele de fereastra prin intermediul <em class="u">WindowsCallbacks.cpp</em></div>
</li>
</ol>
</li>
<li class="level2"><div class="li"> Se initializeaza managerul de texturi</div>
</li>
</ol>
</li>
<li class="level1"><div class="li"> Se creaza si initializeaza o noua scena 3D de lucru avand la baza modelul de update prezentat anterior (<em class="u">Main.cpp</em>)</div>
</li>
<li class="level1"><div class="li"> Se porneste rularea scenei incarcate (<code>LoopUpdate()</code>)</div>
</li>
</ol>

</div>
<!-- EDIT6 SECTION "Modelul de functionare al aplicatiei de laborator" [9580-11076] -->
<h3 class="sectionedit7" id="standardul_opengl">Standardul OpenGL</h3>
<div class="level3">

<p>
OpenGL este un standard(<abbr title="Application Programming Interface">API</abbr>) pe care il putem folosi pentru a crea aplicatii grafice real-time. Este aproape identic cu Direct3D, ambele avand o influenta reciproca de-a lungul anilor.
</p>
<ul>
<li class="level1"><div class="li"> Mai multe informatii despre istoricul OpenGL gasi la adresa: <a href="https://en.wikipedia.org/wiki/OpenGL" class="urlextern" title="https://en.wikipedia.org/wiki/OpenGL"  rel="nofollow">https://en.wikipedia.org/wiki/OpenGL</a></div>
</li>
<li class="level1"><div class="li"> Explicatii complete prinvind <abbr title="Application Programming Interface">API</abbr>-ul OpenGL cat si utilizarea acestuia se pot gasi pe pagina oficiala a standardului: <a href="https://www.opengl.org/sdk/docs/man/" class="urlextern" title="https://www.opengl.org/sdk/docs/man/"  rel="nofollow">https://www.opengl.org/sdk/docs/man/</a></div>
</li>
</ul>

<p>
<p><div class="notetip">Atunci cand nu sunteti siguri ce face o anumita comanda sau ce reprezinta paramaterii functiilor este recomandat sa consultati documentatia: <a href="https://www.opengl.org/sdk/docs/man/" class="urlextern" title="https://www.opengl.org/sdk/docs/man/"  rel="nofollow">https://www.opengl.org/sdk/docs/man/</a>

</div></p>
Versiunea curenta a acestui standard este 4.5. Pentru cursul de EGC vom folosi standardul 3.0/3.3, care este in acelasi timp si versiunea actuala pentru varianta pentru mobile a OpenGL, numita OpenGL ES <a href="https://en.wikipedia.org/wiki/OpenGL_ES" class="urlextern" title="https://en.wikipedia.org/wiki/OpenGL_ES"  rel="nofollow">https://en.wikipedia.org/wiki/OpenGL_ES</a>.<br/>

<br/>

Incepand cu 2016 a fost lansat si <abbr title="Application Programming Interface">API</abbr>-ul Vulkan ce ofera access avansat low-level la capababilitatile grafice moderne ale placilor video. Standardul Vulkan este orientat dezvoltarii aplicatiilor de inalta performanta iar complexitatea acestuia depaseste cu mult aspectele de baza ce vor fi prezentate in cadrul cusului/laboratorului.   
</p>

</div>

<h4 id="utilizarea_api">Utilizarea API</h4>
<div class="level4">

<p>
Pe parcursul laboratoarelor (dar si a cursului) se va trece prin toate etapele importante ce stau la baza redarii grafice. Astfel vor fi invatate concepte precum:
</p>
<ul>
<li class="level1"><div class="li"> incarcare si randare de obiecte 3D simple</div>
</li>
<li class="level1"><div class="li"> functionarea pipeline-ului grafic</div>
</li>
<li class="level1"><div class="li"> vizualizarea, proiectie, control camera</div>
</li>
<li class="level1"><div class="li"> utilizare shadere (vertex si fragment shader)</div>
</li>
<li class="level1"><div class="li"> iluminare</div>
</li>
<li class="level1"><div class="li"> texturare</div>
</li>
</ul>

</div>
<!-- EDIT7 SECTION "Standardul OpenGL" [11077-12729] -->
<h3 class="sectionedit8" id="cerinte_generale_de_laborator">Cerinte generale de laborator</h3>
<div class="level3">
<ul>
<li class="level1"><div class="li"> Cititi cu foarte mare atentie Framwork-ul de laborator intrucat il veti utiliza pe tot parcursul cursului de EGC inclusiv si la temele de casa</div>
</li>
<li class="level1"><div class="li"> Cititi comentariile din cod – ar trebui sa raspunda la majoritatea intrebarilor pe care le aveti</div>
</li>
<li class="level1"><div class="li"> Cititi documentatia de la <a href="https://github.com/UPB-Graphics/Framework-EGC/blob/master/Source/Core/Window/InputController.h" class="urlextern" title="https://github.com/UPB-Graphics/Framework-EGC/blob/master/Source/Core/Window/InputController.h"  rel="nofollow"> __InputController.h__</a> intrucat veti utiliza constant functiile din cadrul acestei clase (prin suprascriere) pentru definirea de interactiuni si comportament personalizat</div>
</li>
<li class="level1"><div class="li"> Daca nu intelegeti modelul de functionare al aplicatiei rugati asistentul sa explice inca o data cum functioneaza toata aplicatia</div>
</li>
</ul>

</div>

<h5 id="c">C++</h5>
<div class="level5">

<p>
Framework-ul este scris in limbajul C++, ce va fi utilizat pe tot parcursul laboratoarelor
Conceptele utilizate in cadrul laboratorului si importante de stiu sunt:
</p>
<ul>
<li class="level1"><div class="li"> concepte de baza de OOP - obiecte, mostenire, metode virtuale, etc</div>
</li>
<li class="level1"><div class="li"> utilizarea standard libraries: in special <a href="http://www.cplusplus.com/reference/vector/vector/" class="urlextern" title="http://www.cplusplus.com/reference/vector/vector/"  rel="nofollow"> std::vector</a>, <a href="http://www.cplusplus.com/reference/list/list/" class="urlextern" title="http://www.cplusplus.com/reference/list/list/"  rel="nofollow"> std::list </a> si <a href="http://www.cplusplus.com/reference/unordered_map/unordered_map/" class="urlextern" title="http://www.cplusplus.com/reference/unordered_map/unordered_map/"  rel="nofollow"> std::unorderd_map </a></div>
</li>
</ul>

<p>
<p><div class="notetip">
Pentru cei mai putini familiarizati cu limbajul C++ recomandam sa parcurgeti tutoriale: <a href="http://www.learncpp.com/" class="urlextern" title="http://www.learncpp.com/"  rel="nofollow"> Learn C++ </a>

</div></p>
</p>

</div>

<h5 id="visual_studio_2015">Visual Studio 2015</h5>
<div class="level5">
<ul>
<li class="level1"><div class="li"> In cadrul laboratorului vom utiliza <a href="https://www.visualstudio.com/vs/community/" class="urlextern" title="https://www.visualstudio.com/vs/community/"  rel="nofollow">Visual Studio 2015 Community Edition</a></div>
</li>
<li class="level1"><div class="li"> Installer-ul de Visual Studio 2015 nu instaleaza automat si compilatorul C++. La setup asigurati-va ca bifati corespunzator acest lucru selectand modulul <strong>Common Tools for Visual C++ 2015</strong> din sectiunea <strong>Custom</strong> install</div>
<ul>
<li class="level2"><div class="li"> <a href="https://blogs.msdn.microsoft.com/vcblog/2015/07/24/setup-changes-in-visual-studio-2015-affecting-c-developers/" class="urlextern" title="https://blogs.msdn.microsoft.com/vcblog/2015/07/24/setup-changes-in-visual-studio-2015-affecting-c-developers/"  rel="nofollow"> Instalare C++ pentru Visual Studio 2015</a></div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Framework-ul contine deja un proiect preconfigurat pentru Visual Studio 2015 <em class="u">Framework_EGC.sln</em> (folderul <a href="https://github.com/UPB-Graphics/Framework-EGC/tree/master/Visual%20Studio" class="urlextern" title="https://github.com/UPB-Graphics/Framework-EGC/tree/master/Visual%20Studio"  rel="nofollow"> /Visual Studio</a>)</div>
</li>
<li class="level1"><div class="li"> Deschideti solutia in Visual Studio 2015</div>
</li>
</ul>

<p>
<p><div class="notetip">
Cei care nu au mai utilizat IDE-ul <strong>Visual Studio</strong> pentru scrierea de aplicatii C++ sunt rugati sa citeasca toturialul <a href="https://msdn.microsoft.com/en-us/library/jj620919.aspx#BKMK_CreateApp" class="urlextern" title="https://msdn.microsoft.com/en-us/library/jj620919.aspx#BKMK_CreateApp"  rel="nofollow"> Getting Started with C++ in Visual Studio</a>

</div></p>
</p>

</div>
<!-- EDIT8 SECTION "Cerinte generale de laborator" [12730-15179] -->
<h3 class="sectionedit9" id="laboratorul_1">Laboratorul 1</h3>
<div class="level3">

</div>

<h4 id="framework">Framework</h4>
<div class="level4">

<p>
Framework-ul de laborator se gaseste pe <a href="https://github.com/UPB-Graphics/Framework-EGC" class="urlextern" title="https://github.com/UPB-Graphics/Framework-EGC"  rel="nofollow"> Github</a> <br/>

Puteti sa descarcati direct arhiva accesand <a href="https://github.com/UPB-Graphics/Framework-EGC/archive/master.zip" class="urlextern" title="https://github.com/UPB-Graphics/Framework-EGC/archive/master.zip"  rel="nofollow"> acest link </a>
</p>

</div>

<h4 id="informatii_laborator">Informatii laborator</h4>
<div class="level4">

<p>
<p><div class="noteimportant"> Sursele ce stau la baza fiecarui laborator se afla in directorul: <em class="u">/Source/Laboratoare/Laborator<strong>N</strong>/</em>, <strong>N</strong> reprezintand numarul laboratorului.

</div></p>
</p>

<p>
In cadrul laboratorului 1 puteti incarca modele 3D si randa in cadrul scenei utilizand functia
</p>
<pre class="code cpp">RenderMesh<span class="br0">&#40;</span>Mesh <span class="sy2">*</span> mesh, glm<span class="sy4">::</span><span class="me2">vec3</span> position, glm<span class="sy4">::</span><span class="me2">vec3</span> scale<span class="br0">&#41;</span></pre>

<p>
Pentru a desena trebuie sa salvam culorile generate intr-un buffer, numit Framebuffer. Contextul definit ofera automat un astfel de buffer si este configurat sa ruleze cu double-buffering
</p>

<p>
<abbr title="Application Programming Interface">API</abbr>-ul OpenGL utilizat in cadrul laboratorului:
</p>
<pre class="code cpp"><span class="co1">// defineste un spatiu de desenare in spatiul ferestrei de vizualizare</span>
<span class="co1">// x, y reprezinta coordonatele coltului stanga jos</span>
<span class="co1">// width, height reprezinta dimensiunea spatiului de desenare.</span>
<span class="kw4">void</span> glViewport<span class="br0">&#40;</span>GLint x,  GLint y,  GLsizei width,  GLsizei height<span class="br0">&#41;</span><span class="sy4">;</span> 
&nbsp;
<span class="co1">// seteaza culoarea cu care va fi colorat tot ecranul la operatia de clear</span>
<span class="kw4">void</span> glClearColor<span class="br0">&#40;</span><span class="kw4">float</span> r, <span class="kw4">float</span> g, <span class="kw4">float</span> b, <span class="kw4">float</span> a<span class="br0">&#41;</span><span class="sy4">;</span>
&nbsp;
 <span class="co1">// implementeaza operatia de clear</span>
<span class="kw4">void</span> glClear<span class="br0">&#40;</span>GL_COLOR_BUFFER_BIT<span class="br0">&#41;</span><span class="sy4">;</span></pre>

<p>
<p><div class="noteimportant">
Culorile in OpenGL sunt specificate ca float in intervalul 0 - 1
</p>

<p>
Bufferul de culoare utilizat (atat in cadrul laboratorului dar si in mod uzual datorita limitarilor impuse de afisarea pe monitore) este in format RGBA32. Fiecare componenta (red, green, blue, alpha) ocupa 8 biti, deci intervalul 0 – 255. Astfel: <br/>

</p>
<ul>
<li class="level1"><div class="li"> rosu (255, 0, 0) este reprezentata ca (1, 0, 0) pe placa video<br/>
</div>
</li>
<li class="level1"><div class="li"> galben este (1, 1, 0) si tot asa</div>
</li>
</ul>

<p>

</div></p>
</p>

</div>

<h5 id="control_aplicatie">Control aplicatie</h5>
<div class="level5">

<p>
Programul rulat ofera posibilitatea visualizarii scenei create prin intermediul unei camere predefinite.
</p>

<p>
<p><div class="notetip">
Taste de control pentru camera
</p>
<ul>
<li class="level1"><div class="li"> <strong>W, A, S, D, Q, E</strong> - miscare fata, stanga, spate, dreapta, jos, sus</div>
</li>
<li class="level1"><div class="li"> <strong>MOUSE RIGHT + MOUSE MOVE</strong> - rotatie camera</div>
</li>
</ul>

<p>

</div></p>
</p>

</div>

<h4 id="cerinte_laborator">Cerinte laborator</h4>
<div class="level4">
<ol>
<li class="level1"><div class="li"> Descarcati framework-ul, compilati si rulati proiectul</div>
<ul>
<li class="level2"><div class="li"> Trebuie sa deschideti proiectul Framework_EGC.sln (folderul /Visual Studio) in Visual Studio 2015</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Incarcati un alt model 3D si randati-l in scena la o pozitie diferita fata de cele 2 cuburi</div>
<ul>
<li class="level2"><div class="li"> <em class="u">/Resources/Models</em> contine o serie de meshe 3D ce pot fi incarcate</div>
</li>
<li class="level2"><div class="li"> In <code>Laborator1::Init()</code> gasiti modul in care puteti sa declarati (si incarcati) un nou obiect de tip <code>Mesh</code></div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Rezolvati task-urile propuse de asistent</div>
</li>
</ol>

<p>
<p><div class="noteimportant">Cititi cu atentie documentatia evenimentelor de input din fisierul <code><a href="https://github.com/UPB-Graphics/Framework-EGC/blob/master/Source/Core/Window/InputController.h" class="urlextern" title="https://github.com/UPB-Graphics/Framework-EGC/blob/master/Source/Core/Window/InputController.h"  rel="nofollow"> InputController.h</a></code> intrucat le veti utiliza in cadrul fiecarui laborator
</div></p>
</p>

</div>
<!-- EDIT9 SECTION "Laboratorul 1" [15180-19022] -->
<h3 class="sectionedit10" id="glm">GLM</h3>
<div class="level3">

<p>
In grafica, matematica este folosita peste tot, de la simple matrici pentru rotatii pana la integrale infinit dimensionale pentru algoritmii folositi in industria filmului, de aceea ne dorim sa avem un suport de matematica robust, bine documentat si nu il ultimul rand cat  mai apropiat de formatul OpenGL. In loc sa scriem noi o librarie de matematica vom folosi libraria GLM. GLM ne ofera rotatii, translatii, vectori de dimensiune 2/3/4, matrici si multe alte functionalitati avansate (e.g. modele de zgomot). Vom folosi doar cele mai simple functionalitati in laboratoarele de la aceasta materie. 
</p>
<pre class="code cpp">glm<span class="sy4">::</span><span class="me2">mat4</span> identity <span class="sy1">=</span> glm<span class="sy4">::</span><span class="me2">mat4</span> <span class="br0">&#40;</span><span class="nu0">1</span>, <span class="nu0">0</span>, <span class="nu0">0</span>, <span class="nu0">0</span>, 
                                <span class="nu0">0</span>, <span class="nu0">1</span>, <span class="nu0">0</span>, <span class="nu0">0</span>,
                                <span class="nu0">0</span>, <span class="nu0">0</span>, <span class="nu0">1</span>, <span class="nu0">0</span>,
                                <span class="nu0">0</span>, <span class="nu0">0</span>, <span class="nu0">0</span>, <span class="nu0">1</span><span class="br0">&#41;</span><span class="sy4">;</span> 
glm<span class="sy4">::</span><span class="me2">mat4</span> identity2 <span class="sy1">=</span> glm<span class="sy4">::</span><span class="me2">mat4</span><span class="br0">&#40;</span><span class="nu0">1</span><span class="br0">&#41;</span><span class="sy4">;</span> <span class="co1">// short form for writing identity matrices           </span>
glm<span class="sy4">::</span><span class="me2">vec3</span> culoare <span class="sy1">=</span> glm<span class="sy4">::</span><span class="me2">vec3</span><span class="br0">&#40;</span><span class="nu0">1</span>, <span class="nu16">0.5</span>, <span class="nu0">1</span><span class="br0">&#41;</span><span class="sy4">;</span>
glm<span class="sy4">::</span><span class="me2">vec2</span> directie <span class="sy1">=</span> glm<span class="sy4">::</span><span class="me2">vec3</span><span class="br0">&#40;</span><span class="sy2">-</span><span class="nu0">1</span>, <span class="nu0">1</span><span class="br0">&#41;</span><span class="sy4">;</span>
glm<span class="sy4">::</span><span class="me2">vec3</span> pozitie <span class="sy1">=</span> glm<span class="sy4">::</span><span class="me2">vec3</span><span class="br0">&#40;</span><span class="nu0">100</span>, <span class="nu0">10</span>, <span class="sy2">-</span><span class="nu0">20</span><span class="br0">&#41;</span><span class="sy4">;</span>
pozitie.<span class="me1">x</span> <span class="sy1">=</span> <span class="nu0">2</span><span class="sy4">;</span> <span class="co1">// you can select components like so: .x .y .z .t .r .g. b. a</span></pre>

</div>
<!-- EDIT10 SECTION "GLM" [19023-] --></div>
</body>
</html>
