    
    

<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
  <meta charset="utf-8" />
  <title>iot2015:courses:03</title>
<meta name="generator" content="DokuWiki"/>
<meta name="robots" content="index,follow"/>
<meta name="date" content="2016-06-17T15:45:22+0300"/>
<meta name="keywords" content="iot2015,courses,03"/>
<link rel="search" type="application/opensearchdescription+xml" href="../../../../lib/exe/opensearch.php" title="CS Open CourseWare"/>
<link rel="start" href="../../../../../courses.1.html"/>
<link rel="alternate" type="application/rss+xml" title="Recent Changes" href="../../../../feed.php"/>
<link rel="alternate" type="application/rss+xml" title="Current Namespace" href="../../../../feed.php%3Fmode=list&amp;ns=iot2015:courses"/>
<link rel="alternate" type="text/html" title="Plain HTML" href="03.html"/>
<link rel="canonical" href="../../../../iot2015/courses/03.html"/>
<link rel="stylesheet" type="text/css" href="../../../../lib/exe/css.php%3Ft=arctic&amp;tseed=1479898000.css"/>
<script type="text/javascript">/*<![CDATA[*/var NS='iot2015:courses';var JSINFO = {"id":"iot2015:courses:03","namespace":"iot2015:courses","isadmin":0,"isauth":0};
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="../../../../lib/exe/js.php%3Ftseed=1479898000"></script>
<script type="text/x-mathjax-config">/*<![CDATA[*/MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ["$","$"], ["\\(","\\)"] ],
        displayMath: [ ["$$","$$"], ["\\[","\\]"] ],
        processEscapes: true
    }
});
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
<script type="text/javascript">/*<![CDATA[*/
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
		  
/*!]]>*/</script>
<script type="text/javascript">/*<![CDATA[*/
var pageTracker = _gat._getTracker("UA-38383934-1");
pageTracker._initData();
pageTracker._trackPageview();
		  
/*!]]>*/</script>
</head>
<body>
<div class="dokuwiki export">
<!-- TOC START -->
<div id="dw__toc">
<h3 class="toggle">Table of Contents</h3>
<div>

<ul class="toc">
<li class="level1"><div class="li"><a href="03.html#lecture_3software_for_the_internet_of_things">Lecture 3: Software for the Internet of Things</a></div>
<ul class="toc">
<li class="level2"><div class="li"><a href="03.html#software_for_iot_-_wyliodrin">Software for IoT - Wyliodrin</a></div></li>
<li class="level2"><div class="li"><a href="03.html#languages">Languages</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="03.html#visual_programming">Visual Programming</a></div></li>
<li class="level3"><div class="li"><a href="03.html#streams_programming">Streams Programming</a></div>
<ul class="toc">
<li class="level4"><div class="li"><a href="03.html#run_node_function_and_digital_write">Run node, Function and Digital Write</a></div></li>
<li class="level4"><div class="li"><a href="03.html#analogwrite">AnalogWrite</a></div></li>
<li class="level4"><div class="li"><a href="03.html#print_and_analog_read">Print and Analog Read</a></div></li>
<li class="level4"><div class="li"><a href="03.html#switch_and_trigger">Switch and Trigger</a></div></li>
<li class="level4"><div class="li"><a href="03.html#buffer_and_send_signal">Buffer and Send Signal</a></div></li>
<li class="level4"><div class="li"><a href="03.html#delay_node">Delay Node</a></div></li>
</ul>
</li>
</ul>
</li>
<li class="level2"><div class="li"><a href="03.html#signal_processing">Signal processing</a></div></li>
</ul></li>
</ul>
</div>
</div>
<!-- TOC END -->

<h1 class="sectionedit1" id="lecture_3software_for_the_internet_of_things">Lecture 3: Software for the Internet of Things</h1>
<div class="level1">

<p>

<center>
<iframe width="640" height="360" src="https://www.youtube-nocookie.com/embed/rtUBobu223E" frameborder="0" allowfullscreen></iframe>
</center>

Slides are available from the <a href="http://www.slideshare.net/alexandruradovici/software-for-the-internet-of-things" class="urlextern" title="http://www.slideshare.net/alexandruradovici/software-for-the-internet-of-things"  rel="nofollow">link</a>
</p>

<p>
This particular course will make a sum up of the software used in the IoT field and describe in detail such programming languages as Streams or Visual programming. In addition, it will introduce the student into signal processing. 
</p>

</div>
<!-- EDIT1 SECTION "Lecture 3: Software for the Internet of Things" [1-1245] -->
<h2 class="sectionedit2" id="software_for_iot_-_wyliodrin">Software for IoT - Wyliodrin</h2>
<div class="level2">

<p>
Wyliodrin is an online platform for programming different IoT projects while all the created applications are stored in the Cloud. 
In case you want to build simple or complicated applications on embedded boards, Wyliodrin is a programming solution with a large palette of languages and functions.  
There are many features of Wyliodrin that make programming way easier and enjoyable.
You need a board that runs Linux and has an Internet connection in order to be able to use it with this service. As the embedded boards, such as the Intel Edison, that are supported by Wyliodrin are basically computers, you can run several projects at the same time on a single board as long as they do not interfere with each other. It is important that the projects do not write on the same GPIOs.
</p>

<p>
Some of Wyliodrin&#039;s features are the following:
</p>

<p>
* <strong>Dashboard</strong>: you can add charts to your projects. These have a debugging function. You can watch the progress of your application, the graphic representation of the values sent by the sensors and check for mistakes. However, it is not designed for long time usage or for deploying software. 
</p>

<p>
To use it, you simply click on the chart you prefer and drag and drop it around the dashboard. 
Another great feature is the fact that you can export the values from the chart to plot them in other types of  software.
</p>

<p>
* Wyliodrin has an <strong>open source library</strong>, which means that the projects can be used even if you decide not to use Wyliodrin anymore. 
Initially Wyliodrin started from the Arduino library, which was cloned and later adapted to suit embedded boards. 
The specifications are those of the Arduino library, but Wyliodrin adapted the <abbr title="Application Programming Interface">API</abbr> for each type of board supported on the platform. 
</p>

<p>
* The <strong>languages</strong> that you can use in Wyliodrin to build a project are varied. If you want to code, you can start doing it in either <strong>C</strong>, <strong>C++</strong>, <strong>JavaScript</strong>, <strong>Python</strong> and <strong>others</strong>, but also you can decide to use <strong>Visual programming</strong> or <strong>Streams</strong>.
A very important aspect is that it is completely hardware independent, so ,if you decide to change the board at some time, you will be able to run the same code on it, with very small changes like the pin numbering, because each board has different pins, but the <abbr title="Application Programming Interface">API</abbr> should be the same.
</p>

<p>
The functions most used from the Arduino-like library, libwyliodrin, are:
</p>
<ul>
<li class="level1"><div class="li"> <strong>pinMode</strong> will give to the pin the characteristic of input or output</div>
</li>
<li class="level1"><div class="li"> <strong>digitalWrite</strong> and <strong>analogWrite</strong> do exactly what&#039;s expected: they write values on digital or <em>PWM pins</em>. </div>
</li>
<li class="level1"><div class="li"> <strong>digitalRead</strong> and <strong>analogRead</strong> will consequently read values from digital or analog pins. For the latter, you can have 10 bit, 12 bit or other ADCs, thus the values received are scaled so they stay between 0 and 1024.</div>
</li>
</ul>

</div>
<!-- EDIT2 SECTION "Software for IoT - Wyliodrin" [1246-4068] -->
<h2 class="sectionedit3" id="languages">Languages</h2>
<div class="level2">

<p>
As mentioned before,there are many languages available to program a project.
</p>

<p>
C is mostly important for micro controllers. For small, simple projects (prototyping) <em>Visual programming</em> is the best option. On the other hand, for more complex applications writing code is more practical. Visual can still help, by generating the Python and Java Script code you will simply copy paste in your project. 
</p>

</div>
<!-- EDIT3 SECTION "Languages" [4069-4494] -->
<h3 class="sectionedit4" id="visual_programming">Visual Programming</h3>
<div class="level3">

<p>
<strong>Visual Programming</strong> is adapted for hardware, having as starting point Google Blockly.
You also can use this for documentation, drag some blocks and see the code for them in Python or JavaScript, that will help you if you do not know how some function work or what parameters they use.
</p>

</div>
<!-- EDIT4 SECTION "Visual Programming" [4495-4812] -->
<h3 class="sectionedit5" id="streams_programming">Streams Programming</h3>
<div class="level3">

<p>
<strong>Streams programming language</strong> is inspired from node-RED developed by IBM. This language is a data driven one, as opposed to imperative programming languages.  It is based on events, so an action occurs at the moment when data arrives in a certain point.
</p>

<p>
Streams language works by sending messages from one node to the other. This message will be stored in the payload, which is a necessary property of a node. Another property is the topic. It contains information about the payload, but it is optional. A node has only one input, but possibly multiple outputs. 
</p>

<p>
Apart from nodes, another type of components are the data routes. They are routing rules for sending data among nodes. 
</p>

<p>
After a Streams program is built and run, it is converted to imperative language, as this is the only way a computer can understand and execute it. The code can&#039;t be shown for the nodes, as it is for Visual blocks, because it is way more complicated, making possible the conversion. 
</p>

<p>
Most of the nodes are: 
</p>

</div>

<h4 id="run_node_function_and_digital_write">Run node, Function and Digital Write</h4>
<div class="level4">

<p>
<strong>Run</strong> node is the block which will start the payload. This is practically the first data flow sent towards the rest of the nodes you use in an application. In its settings you have three fields. If no payload is specified the payload is set to the current time in milliseconds since 1970. This allows subsequent functions to perform time based actions. You can write it yourself if you chose for it to be a string. The topic field can hold data to be used later, in other functions. The repeat option does what it says and continuously sends the payload every x seconds.The <em>Fire once at start</em> option actually waits 50mS before firing to give other nodes a chance to instantiate properly.
</p>

<p>
The <strong>function</strong> node is a block where you can write code to do many other interesting things.
By convention, it will have a “msg.payload” property containing the body of the message.
If you double click on it, you will find the name field, the second field, where you write the code and the last one, where you specify how many outputs the node has.
</p>

<p>
<strong>Digital Write</strong> node will write 0 or 1 on a digital pin, the one that you choose in the settings.
<strong>Digital Read</strong> is  the node that reads the digital value on the corresponding pin. You specify this pin in its settings.
</p>

<p>
<a href="../../../../_detail/iot2015/courses/excurs3.png%3Fid=iot2015%253Acourses%253A03.html" class="media" title="iot2015:courses:excurs3.png"><img src="../../../../_media/iot2015/courses/excurs3.png%3Fw=300&amp;tok=dc4731" class="media" alt="" width="300" /></a>
<a href="../../../../_detail/iot2015/courses/excurs3f.png%3Fid=iot2015%253Acourses%253A03.html" class="media" title="iot2015:courses:excurs3f.png"><img src="../../../../_media/iot2015/courses/excurs3f.png%3Fw=400&amp;tok=b1daae" class="media" alt="" width="400" /></a>
</p>

<p>
In the example above, two LEDs will take turns at being alight while the other one is off, at the press of one button. More specifically, when you press the button one LED is on, the other off, whereas when the button is not pressed, the LEDs behave in the opposite manner.  
</p>

<p>
Theoretically, the <em> run </em> node sends a message every one second, thus the value from the digital pin is read once a second. The direct value will go to one LED, the one on in 1. The function block will reverse this value and send it to pin 2. 
</p>

</div>

<h4 id="analogwrite">AnalogWrite</h4>
<div class="level4">

<p>
<strong>Analog Write</strong> node writes a value to an analog/PWN pin. It works similarly to Digital Write in terms of what you can do: specify the pin and the value in its configuration or use the message object to set it up. <strong>Pay attention</strong> that although you can write a signal with the root mean square of, for example 2.5 V, the pick value is still 5V. So if you need to power a device at a voltage of 2.5 V DC (!) you might damage it.
</p>

<p>
<a href="../../../../_detail/iot2015/courses/analog_write.jpg%3Fid=iot2015%253Acourses%253A03.html" class="media" title="iot2015:courses:analog_write.jpg"><img src="../../../../_media/iot2015/courses/analog_write.jpg%3Fw=400&amp;tok=b2722a" class="media" alt="" width="400" /></a>
</p>

<p>
In this example use the PWM pins to light up an LED gradually. As you might remember from the previous course, the PWM pins generate signals with variable duty cycle. In the case of Intel Edison you can control the duty by writing a number between 0 and 255 on the pin. Where 0 corresponds to 0% duty and 255 to 100%. The effect will be that the LED will turn on and off so fast that your eyes will see it as if the LED is not fully on.
</p>

<p>
You use the run node again with the times option at an interval of 0.1 seconds. In the function you compute the modulo 256 of the counter generating this way sequences of numbers from 0 to 255. It will look as is the LED gradually lights, then goes off and so on.
</p>

</div>

<h4 id="print_and_analog_read">Print and Analog Read</h4>
<div class="level4">

<p>
<strong>Analog Read</strong> node reads the value from the analog pin mentioned in the settings. 
</p>

<p>
The <strong>print</strong> node can be connected to the output of any node. It will display msg.payload field of any messages it receives.
</p>

<p>
<a href="../../../../_detail/iot2015/courses/11733243_923893331006333_225288174_n.jpg%3Fid=iot2015%253Acourses%253A03.html" class="media" title="iot2015:courses:11733243_923893331006333_225288174_n.jpg"><img src="../../../../_media/iot2015/courses/11733243_923893331006333_225288174_n.jpg%3Fw=400&amp;tok=06f387" class="media" alt="" width="400" /></a>
</p>

<p>
In the example, you connect a light sensor on analog input pin A0, read its value, that is stored in msg.payload property, then print it in the console.
</p>

</div>

<h4 id="switch_and_trigger">Switch and Trigger</h4>
<div class="level4">

<p>
<strong>Switch</strong> node is a function which will evaluate the message received and pass it on after filtering it through a set of rules. You can create the rules in the node&#039;s settings.
</p>

<p>
The <strong>trigger</strong> is the node which will send a value as soon as it receives a message, It will then wait for a certain amount of time and send another message. The trigger can be extended to send the first value as long as it gets a message and the next value when the message stops.
</p>

<p>
<a href="../../../../_detail/iot2015/courses/11720301_923893341006332_395811528_o.jpg%3Fid=iot2015%253Acourses%253A03.html" class="media" title="iot2015:courses:11720301_923893341006332_395811528_o.jpg"><img src="../../../../_media/iot2015/courses/11720301_923893341006332_395811528_o.jpg%3Fw=400&amp;tok=59532d" class="media" alt="" width="400" /></a>
<a href="../../../../_detail/iot2015/courses/trigger_settings.jpg%3Fid=iot2015%253Acourses%253A03.html" class="media" title="iot2015:courses:trigger_settings.jpg"><img src="../../../../_media/iot2015/courses/trigger_settings.jpg%3Fw=400&amp;tok=829569" class="media" alt="" width="400" /></a>
</p>

<p>
In this example you connect a button to GPIO pin number 2, pass its value to a switch that only forwards the message when it has a value of 1 (button is pressed). This will make the trigger send a message with payload 1 to the following node, Digital Write, wait for 3 seconds then send another message with payload 0. Having in mind the previous examples, can you guess what the effect is? When the button is pressed the LED will light up for 3 seconds.
</p>

</div>

<h4 id="buffer_and_send_signal">Buffer and Send Signal</h4>
<div class="level4">

<p>
The <strong>buffer</strong> node is similar to a <strong>value</strong> node, the difference here is that what a buffer stores is an array. It works like this: every time a new message comes, it will be saved in the array. From the moment the array is full, there are more proceeding methods. One, the array will be sent forward in the payload. Another, it will erase the first element and add a new one or it will store the array , drop whichever message comes, while waiting for a certain event to send out the array. 
</p>

<p>
<strong>Send Signal</strong> sends the value of the payload to the signal with the same name in the dashboard or to a certain number of boards.
</p>

<p>
In this example you collect data from a sensor, using Analog Read, store it in an array of 100 elements and send it to a plot on the dashboard.
</p>

<p>
<a href="../../../../_detail/iot2015/courses/11715867_923893314339668_222651253_n.jpg%3Fid=iot2015%253Acourses%253A03.html" class="media" title="iot2015:courses:11715867_923893314339668_222651253_n.jpg"><img src="../../../../_media/iot2015/courses/11715867_923893314339668_222651253_n.jpg%3Fw=400&amp;tok=582718" class="media" alt="" width="400" /></a><br/>

<a href="../../../../_detail/iot2015/courses/11715900_923893321006334_1532342540_n.jpg%3Fid=iot2015%253Acourses%253A03.html" class="media" title="iot2015:courses:11715900_923893321006334_1532342540_n.jpg"><img src="../../../../_media/iot2015/courses/11715900_923893321006334_1532342540_n.jpg%3Fw=400&amp;tok=603f44" class="media" alt="" width="400" /></a><br/>

<a href="../../../../_detail/iot2015/courses/11713510_923893324339667_2068273267_n.jpg%3Fid=iot2015%253Acourses%253A03.html" class="media" title="iot2015:courses:11713510_923893324339667_2068273267_n.jpg"><img src="../../../../_media/iot2015/courses/11713510_923893324339667_2068273267_n.jpg%3Fw=400&amp;tok=51c55c" class="media" alt="" width="400" /></a>
</p>

</div>

<h4 id="delay_node">Delay Node</h4>
<div class="level4">

<p>
Introduces a <strong>delay</strong> into a flow or rate limited messages. Default delay is 5 seconds and rate limit of 1 msg/second, but both can be configured.
</p>

<p>
You can easily modify the previous example from Switch and Trigger to generate a delay between the button press and the LED lighting up.
</p>

<p>
<a href="../../../../_detail/iot2015/courses/11722044_923893327673000_816910515_n.jpg%3Fid=iot2015%253Acourses%253A03.html" class="media" title="iot2015:courses:11722044_923893327673000_816910515_n.jpg"><img src="../../../../_media/iot2015/courses/11722044_923893327673000_816910515_n.jpg%3Fw=400&amp;tok=5bc2c2" class="media" alt="" width="400" /></a>
</p>

</div>
<!-- EDIT5 SECTION "Streams Programming" [4813-11880] -->
<h2 class="sectionedit6" id="signal_processing">Signal processing</h2>
<div class="level2">

<p>
Signal processing has a main role in the Internet of things field. You might want to process some part of the signal, to use or extract values received from a sensor, apart from using them via nodes or Python. For this, Wyliodrin offers as solution <strong>Octave</strong>. It is an open source software which is similar to Matlab, which handles signal processing better then other programming languages.
The trick is that you can run this programs on the board only if you install Octave on them, but this can be really difficult and also give you low performance in the end. For this problem we created the option of having an <strong>IoT Server</strong>, a Linux image that runs on our Cloud and it comes pre-installed with Octave.
</p>

<p>
<a href="../../../../_detail/iot2015/courses/octave.png%3Fid=iot2015%253Acourses%253A03.html" class="media" title="iot2015:courses:octave.png"><img src="../../../../_media/iot2015/courses/octave.png%3Fw=500&amp;tok=aa702b" class="mediacenter" alt="" width="500" /></a>
</p>

</div>
<!-- EDIT6 SECTION "Signal processing" [11881-] --></div>
</body>
</html>
