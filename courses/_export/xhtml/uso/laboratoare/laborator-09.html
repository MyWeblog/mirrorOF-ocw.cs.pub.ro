    
    

<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
  <meta charset="utf-8" />
  <title>uso:laboratoare:laborator-09</title>
<meta name="generator" content="DokuWiki"/>
<meta name="robots" content="index,follow"/>
<meta name="date" content="2015-12-11T17:49:20+0200"/>
<meta name="keywords" content="uso,laboratoare,laborator-09"/>
<link rel="search" type="application/opensearchdescription+xml" href="../../../../lib/exe/opensearch.php" title="CS Open CourseWare"/>
<link rel="start" href="../../../../../courses.1.html"/>
<link rel="alternate" type="application/rss+xml" title="Recent Changes" href="../../../../feed.php"/>
<link rel="alternate" type="application/rss+xml" title="Current Namespace" href="../../../../feed.php%3Fmode=list&amp;ns=uso:laboratoare"/>
<link rel="alternate" type="text/html" title="Plain HTML" href="laborator-09.html"/>
<link rel="canonical" href="../../../../uso/laboratoare/laborator-09.html"/>
<link rel="stylesheet" type="text/css" href="../../../../lib/exe/css.php%3Ft=arctic&amp;tseed=1479898000.css"/>
<script type="text/javascript">/*<![CDATA[*/var NS='uso:laboratoare';var JSINFO = {"id":"uso:laboratoare:laborator-09","namespace":"uso:laboratoare","isadmin":0,"isauth":0};
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="../../../../lib/exe/js.php%3Ftseed=1479898000"></script>
<script type="text/x-mathjax-config">/*<![CDATA[*/MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ["$","$"], ["\\(","\\)"] ],
        displayMath: [ ["$$","$$"], ["\\[","\\]"] ],
        processEscapes: true
    }
});
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
<script type="text/javascript">/*<![CDATA[*/
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
		  
/*!]]>*/</script>
<script type="text/javascript">/*<![CDATA[*/
var pageTracker = _gat._getTracker("UA-38383934-1");
pageTracker._initData();
pageTracker._trackPageview();
		  
/*!]]>*/</script>
</head>
<body>
<div class="dokuwiki export">
<!-- TOC START -->
<div id="dw__toc">
<h3 class="toggle">Table of Contents</h3>
<div>

<ul class="toc">
<li class="level1"><div class="li"><a href="laborator-09.html#laborator_09_-_considerente_hardware_si_masini_virtuale">Laborator 09 - Considerente hardware și mașini virtuale</a></div>
<ul class="toc">
<li class="level2"><div class="li"><a href="laborator-09.html#suport_laborator">Suport laborator</a></div></li>
<li class="level2"><div class="li"><a href="laborator-09.html#resurse">Resurse</a></div></li>
<li class="level2"><div class="li"><a href="laborator-09.html#demo">Demo</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="laborator-09.html#investigare_hardware">1. Investigare hardware</a></div></li>
<li class="level3"><div class="li"><a href="laborator-09.html#comanda_dd">2. Comanda dd</a></div></li>
<li class="level3"><div class="li"><a href="laborator-09.html#secventa_de_boot">3. Secvența de boot</a></div></li>
<li class="level3"><div class="li"><a href="laborator-09.html#virtualizare">4. Virtualizare</a></div></li>
<li class="level3"><div class="li"><a href="laborator-09.html#emulare">5. Emulare</a></div></li>
</ul>
</li>
<li class="level2"><div class="li"><a href="laborator-09.html#exercitii">Exerciții</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="laborator-09.html#pregatire_setup_si_gestiunea_masinilor_virtuale_3p">1. Pregătire setup și gestiunea mașinilor virtuale (3p)</a></div>
<ul class="toc">
<li class="level4"><div class="li"><a href="laborator-09.html#pregatire_infrastructura">1.1. Pregătire infrastructură</a></div></li>
<li class="level4"><div class="li"><a href="laborator-09.html#gestiune_masini_virtuale">1.2. Gestiune mașini virtuale</a></div></li>
</ul>
</li>
<li class="level3"><div class="li"><a href="laborator-09.html#editarea_intrarilor_din_bootloader_2p">2. Editarea intrărilor din bootloader (2p)</a></div></li>
<li class="level3"><div class="li"><a href="laborator-09.html#recuperarea_parolei_de_root_2p">3. Recuperarea parolei de root (2p)</a></div></li>
<li class="level3"><div class="li"><a href="laborator-09.html#rularea_unei_distributii_pentru_o_alta_arhitectura_1p">4. Rularea unei distribuții pentru o altă arhitectură (1p)</a></div></li>
<li class="level3"><div class="li"><a href="laborator-09.html#informatii_despre_sistem_2p">5. Informații despre sistem (2p)</a></div></li>
</ul>
</li>
<li class="level2"><div class="li"><a href="laborator-09.html#bonus">BONUS</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="laborator-09.html#rularea_unor_comenzi_periculoase_1_karma_wouso">Rularea unor comenzi &quot;periculoase&quot; (1 karma WoUSO)</a></div></li>
</ul></li>
</ul></li>
</ul>
</div>
</div>
<!-- TOC END -->

<h1 class="sectionedit1" id="laborator_09_-_considerente_hardware_si_masini_virtuale">Laborator 09 - Considerente hardware și mașini virtuale</h1>
<div class="level1">

</div>
<!-- EDIT1 SECTION "Laborator 09 - Considerente hardware și mașini virtuale" [18-90] -->
<h2 class="sectionedit2" id="suport_laborator">Suport laborator</h2>
<div class="level2">
<ul>
<li class="level1"><div class="li"> <a href="http://books.google.com/books?id=_JFGzyRxQGcC" class="urlextern" title="http://books.google.com/books?id=_JFGzyRxQGcC"  rel="nofollow"> Introducere în sisteme de operare</a></div>
<ul>
<li class="level2"><div class="li"> <a href="http://books.google.com/books?id=_JFGzyRxQGcC&amp;pg=PA185" class="urlextern" title="http://books.google.com/books?id=_JFGzyRxQGcC&amp;pg=PA185"  rel="nofollow"> Capitolul 7 - Analiza hardware a sistemului</a></div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> <a href="http://xkcd.com/1444/" class="urlextern" title="http://xkcd.com/1444/"  rel="nofollow">Cloud is the future</a></div>
</li>
</ul>

</div>
<!-- EDIT2 SECTION "Suport laborator" [91-373] -->
<h2 class="sectionedit3" id="resurse">Resurse</h2>
<div class="level2">
<ul>
<li class="level1"><div class="li"> <a href="http://www.linuxnix.com/2013/04/linux-booting-process-explained.html" class="urlextern" title="http://www.linuxnix.com/2013/04/linux-booting-process-explained.html"  rel="nofollow"> Procesul de boot pentru Linux</a></div>
</li>
<li class="level1"><div class="li"> <a href="http://www.linuxjournal.com/magazine/reducing-boot-time-embedded-linux-systems?page=0,0" class="urlextern" title="http://www.linuxjournal.com/magazine/reducing-boot-time-embedded-linux-systems?page=0,0"  rel="nofollow">Reducing boot time in embedded Linux</a></div>
</li>
<li class="level1"><div class="li"> <a href="http://www.maketecheasier.com/differences-between-uefi-and-bios/" class="urlextern" title="http://www.maketecheasier.com/differences-between-uefi-and-bios/"  rel="nofollow"> BIOS vs UEFI</a></div>
</li>
</ul>

</div>
<!-- EDIT3 SECTION "Resurse" [374-724] -->
<h2 class="sectionedit4" id="demo">Demo</h2>
<div class="level2">

<p>
O bună cunoaștere a hardware-ului folosit duce la implementarea unui software mai bun și asigură că putem folosi la maximum resursele de care dispunem.
</p>

</div>
<!-- EDIT4 SECTION "Demo" [725-900] -->
<h3 class="sectionedit5" id="investigare_hardware">1. Investigare hardware</h3>
<div class="level3">

<p>
In Linux există mai multe comenzi care ajută la descoperirea informațiilor legate de hardware-ul folosit, vizualizarea proprietăților acestora, dar și a diferitelor atribute ale componentelor.
</p>

<p>
O comandă generalistă, care listează toate informațiile despre sistem este <strong>lshw</strong>. Rulată fără niciun argument, aceasta va afișa un raport al tuturor componentelor detectate în sistem. Pentru a rezuma însă informațiile, se poate folosi argumentul <strong>-short</strong>:
</p>
<pre class="code bash"><span class="co4">$ </span>lshw <span class="re5">-short</span></pre>

<p>
<p><div class="noteclassic"> Pentru a avea acces la și mai multe informații, rulați comanda folosind <strong>sudo</strong>.
</div></p>
</p>

<p>
Aceeași comandă ne pune la dispoziție și argumente pentru afișarea informațiilor specifice unei anumite componente (cpu, memory, disk, network, etc.):
</p>
<pre class="code bash">$ lshw <span class="re5">-class</span> cpu
  <span class="sy0">*</span>-cpu                   
       product: Intel<span class="br0">&#40;</span>R<span class="br0">&#41;</span> Core<span class="br0">&#40;</span>TM<span class="br0">&#41;</span> i5-<span class="nu0">3470</span> CPU <span class="sy0">@</span> 3.20GHz
       vendor: Intel Corp.
       physical id: <span class="nu0">1</span>
       bus info: cpu<span class="sy0">@</span>0
       size: 1600MHz
       capacity: 1600MHz
       width: <span class="nu0">64</span> bits
<span class="br0">&#91;</span>...<span class="br0">&#93;</span></pre>
<pre class="code bash">$ lshw <span class="re5">-class</span> memory
  <span class="sy0">*</span>-memory                
       description: System memory
       physical id: <span class="nu0">0</span>
       size: 3828MiB
<span class="br0">&#91;</span>...<span class="br0">&#93;</span></pre>

<p>
Există, în schimb, și o serie de comenzi specializate, care realizează inspectarea anumitor componente, oferind în același timp, mai multe informații:
</p>
<ul>
<li class="level1"><div class="li"> <strong>lscpu</strong>: informații despre microprocesor</div>
</li>
</ul>
<pre class="code bash">$ lscpu
Architecture:          x86_64
CPU op-mode<span class="br0">&#40;</span>s<span class="br0">&#41;</span>:        <span class="nu0">32</span>-bit, <span class="nu0">64</span>-bit
Byte Order:            Little Endian
CPU<span class="br0">&#40;</span>s<span class="br0">&#41;</span>:                <span class="nu0">4</span>
On-line CPU<span class="br0">&#40;</span>s<span class="br0">&#41;</span> list:   <span class="nu0">0</span>-<span class="nu0">3</span>
Thread<span class="br0">&#40;</span>s<span class="br0">&#41;</span> per core:    <span class="nu0">1</span>
Core<span class="br0">&#40;</span>s<span class="br0">&#41;</span> per socket:    <span class="nu0">4</span>
<span class="br0">&#91;</span>...<span class="br0">&#93;</span></pre>
<ul>
<li class="level1"><div class="li"> <strong>free</strong>: starea memoriei RAM și swap</div>
</li>
</ul>
<pre class="code bash">$ <span class="kw2">free</span>
             total       used       <span class="kw2">free</span>     shared    buffers     cached
Mem:       <span class="nu0">3920404</span>    <span class="nu0">2370736</span>    <span class="nu0">1549668</span>     <span class="nu0">149668</span>     <span class="nu0">152316</span>    <span class="nu0">1102860</span>
-<span class="sy0">/</span>+ buffers<span class="sy0">/</span>cache:    <span class="nu0">1115560</span>    <span class="nu0">2804844</span>
Swap:      <span class="nu0">8000508</span>          <span class="nu0">0</span>    <span class="nu0">8000508</span></pre>
<ul>
<li class="level1"><div class="li"> <strong>lsblk</strong>: informații despre disk-uri și partiții</div>
</li>
</ul>
<pre class="code bash">$ lsblk
NAME   MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT
sda      <span class="nu0">8</span>:<span class="nu0">0</span>    <span class="nu0">0</span> <span class="nu0">465</span>,8G  <span class="nu0">0</span> disk 
├─sda1   <span class="nu0">8</span>:<span class="nu0">1</span>    <span class="nu0">0</span> <span class="nu0">190</span>,8G  <span class="nu0">0</span> part <span class="sy0">/</span>
├─sda2   <span class="nu0">8</span>:<span class="nu0">2</span>    <span class="nu0">0</span> <span class="nu0">190</span>,8G  <span class="nu0">0</span> part <span class="sy0">/</span>.systmp
├─sda3   <span class="nu0">8</span>:<span class="nu0">3</span>    <span class="nu0">0</span>   <span class="nu0">7</span>,6G  <span class="nu0">0</span> part <span class="br0">&#91;</span>SWAP<span class="br0">&#93;</span>
└─sda4   <span class="nu0">8</span>:<span class="nu0">4</span>    <span class="nu0">0</span>    10G  <span class="nu0">0</span> part</pre>

<p>
Aceste comenzi sunt doar niște wrappers peste fișierele corespunzătoare din <strong>/proc</strong>.
</p>
<pre class="code bash">$ <span class="kw2">ls</span> <span class="re5">-l</span> <span class="sy0">/</span>proc
<span class="br0">&#91;</span>...<span class="br0">&#93;</span>
<span class="re5">-r--r--r--</span>  <span class="nu0">1</span> root  root   <span class="nu0">0</span> dec  <span class="nu0">1</span> <span class="nu0">11</span>:<span class="nu0">41</span> cpuinfo
<span class="re5">-r--r--r--</span>  <span class="nu0">1</span> root  root   <span class="nu0">0</span> dec  <span class="nu0">1</span> <span class="nu0">11</span>:<span class="nu0">41</span> meminfo
<span class="re5">-r--r--r--</span>  <span class="nu0">1</span> root  root   <span class="nu0">0</span> dec  <span class="nu0">1</span> <span class="nu0">11</span>:<span class="nu0">41</span> partitions
<span class="re5">-r--r--r--</span>  <span class="nu0">1</span> root  root   <span class="nu0">0</span> dec  <span class="nu0">1</span> <span class="nu0">10</span>:<span class="nu0">51</span> swaps
<span class="br0">&#91;</span>...<span class="br0">&#93;</span></pre>

<p>
Încă o comandă importantă este <strong>uname</strong> care listează informații despre sistemul de operare și sistemul fizic. Parametrul <strong>-a</strong> listează toate informațiile dar acestea pot fi filtrate folosind alți parametrii.
</p>
<pre class="code bash">$ <span class="kw2">uname</span> <span class="re5">-a</span>
Linux virtual 3.13.0-<span class="nu0">32</span>-generic <span class="co0">#57-Ubuntu SMP Tue Jul 15 03:51:08 UTC 2014 x86_64 x86_64 x86_64 GNU/Linux</span></pre>

</div>
<!-- EDIT5 SECTION "1. Investigare hardware" [901-4085] -->
<h3 class="sectionedit6" id="comanda_dd">2. Comanda dd</h3>
<div class="level3">

<p>
Comanda <strong>dd</strong> este des folosită în lucrul cu fișiere și dispozitive. Aceasta realizează transferul în blocuri de la sursă la destinație. Poate fi folosită pentru construirea unor fișiere cu dimensiune fixă, shredding-ul informațiilor dintr-o anumita zone de memorie (prin scriere cu zero), recuperarea datelor de pe un disk corupt, backup-ul dispozitivelor etc.
</p>

<p>
Următorul apel al comenzii va umple fisierul <strong>myfile.dat</strong> cu 102kB (1024 * 100 = 102400) de informație, conținând doar zero-uri.
</p>
<pre class="code bash"><span class="co4">$ </span><span class="kw2">dd</span> <span class="re2">if</span>=<span class="sy0">/</span>dev<span class="sy0">/</span>zero <span class="re2">of</span>=myfile.dat <span class="re2">count</span>=<span class="nu0">100</span> <span class="re2">bs</span>=1K</pre>

<p>
<p><div class="noteclassic">
<strong>if</strong> (input file) și <strong>of</strong> (output file) determină fișierele sursă/destinație ale comenzii. <strong>bs</strong> (block size) și <strong>count</strong> determină dimensiunea informațiilor care vor fi copiate. Un <strong>bs</strong> mare poate asigura o copiere mai rapidă, în timp ce unul mai scazut, asigură integritatea datelor în cazul unui recuperari a datelor de pe un disk corupt.

</div></p>
</p>

<p>
<code>dd</code> are o mulțime de întrebuințări, printre care cele mai uzuale sunt: scrierea unei imagini (.iso) pe un dispozitiv (stick usb):
</p>
<pre class="code bash"><span class="co4">$ </span><span class="kw2">dd</span> <span class="re2">if</span>=~<span class="sy0">/</span>my_image.iso <span class="re2">of</span>=<span class="sy0">/</span>dev<span class="sy0">/</span>sdb <span class="re2">bs</span>=4M</pre>

<p>
sau pentru a crea o imagine a unui CD-ROM, pentru backup sau transfer:
</p>
<pre class="code bash"><span class="co4">$ </span><span class="kw2">dd</span> <span class="re2">if</span>=<span class="sy0">/</span>dev<span class="sy0">/</span>sr0 <span class="re2">of</span>=mycd.iso <span class="re2">bs</span>=8M</pre>

<p>
Alte întrebuințări interesante ale lui <code>dd</code> ar fi următoarele:
</p>

<p>
Generarea unui fișier de 32MB cu date aleatoare:
</p>
<pre class="code bash"><span class="co4">$ </span><span class="kw2">dd</span> <span class="re2">if</span>=<span class="sy0">/</span>dev<span class="sy0">/</span>urandom <span class="re2">of</span>=~<span class="sy0">/</span>myfile.bin <span class="re2">bs</span>=4M <span class="re2">count</span>=<span class="nu0">8</span></pre>

<p>
Generarea unui fișier de 32MB cu octeți de 0:
</p>
<pre class="code bash"><span class="co4">$ </span><span class="kw2">dd</span> <span class="re2">if</span>=<span class="sy0">/</span>dev<span class="sy0">/</span>zero <span class="re2">of</span>=~<span class="sy0">/</span>myfile.bin <span class="re2">bs</span>=4M <span class="re2">count</span>=<span class="nu0">8</span></pre>

<p>
Formatarea unei partiții: prima comandă șterge tabela de partiții a unui stick USB aflat în <code>/dev/sdc</code>, a doua comandă formatează stickul USB aflat în <code>/dev/sdc</code>. Dacă doriți să formatați un stick trebuie să vă asigurați că acesta a fost demontat în prealabil (folosiți <code>umount /dev/sdc1</code>):
</p>
<pre class="code bash">$ <span class="kw2">dd</span> <span class="re2">if</span>=<span class="sy0">/</span>dev<span class="sy0">/</span>zero <span class="re2">of</span>=<span class="sy0">/</span>dev<span class="sy0">/</span>sdc <span class="re2">bs</span>=<span class="nu0">512</span> <span class="re2">count</span>=<span class="nu0">16</span>
$ <span class="kw2">dd</span> <span class="re2">if</span>=<span class="sy0">/</span>dev<span class="sy0">/</span>zero <span class="re2">of</span>=<span class="sy0">/</span>dev<span class="sy0">/</span>sdc <span class="re2">bs</span>=1M</pre>

<p>
Despre <code>dd</code> (destoryer of disks) puteți citi mai multe <a href="http://www.noah.org/wiki/Dd_-_Destroyer_of_Disks" class="urlextern" title="http://www.noah.org/wiki/Dd_-_Destroyer_of_Disks"  rel="nofollow">în acest articol</a>
</p>

</div>
<!-- EDIT6 SECTION "2. Comanda dd" [4086-6389] -->
<h3 class="sectionedit7" id="secventa_de_boot">3. Secvența de boot</h3>
<div class="level3">

<p>
Pornirea unui sistem de calcul vine cu o problemă interesantă: PC-ul trebuie sa execute cod, înainte ca acesta să fie în memorie. Atunci avem nevoie de o secvență mai amplă, ce trebuie sa parcurgă mai multe stadii, până să ajungă să ruleze efectiv sistemul de operare. Această secvență implică inițializarea componentelor si testarea lor minimală, selectarea între mai multe dispozitive boot-abile, selectarea între mai multe sisteme de operare, încărcarea imaginii de kernel și pornirea programelor inițiale, totul într-un timp cât mai scurt.
</p>

<p>
Un model comun pentru toate arhitecturile, al secvenței de boot, este următorul:
</p>
<ol>
<li class="level1"><div class="li"> <strong>BIOS</strong> (Basic Input Output System) - inițializează și verifică hardware-ul; în prezent se încearcă înlocuirea sa cu <a href="http://en.wikipedia.org/wiki/Unified_Extensible_Firmware_Interface" class="urlextern" title="http://en.wikipedia.org/wiki/Unified_Extensible_Firmware_Interface"  rel="nofollow"> UEFI</a></div>
</li>
<li class="level1"><div class="li"> <strong>Boot sector</strong> (Master Boot Record) - reprezentat de primii octeți ai unui HDD, CD, stick USB</div>
</li>
<li class="level1"><div class="li"> <strong>Boot loader</strong> (second-stage boot loader) - permite selectarea între mai multe sisteme de operare, imagini de kernel, dar și modificarea parametrilor de boot; execmple de bootloadere: GRUB2, LILO, Windows Boot Manager</div>
</li>
<li class="level1"><div class="li"> Încărcare <strong>kernel și drivere</strong></div>
</li>
<li class="level1"><div class="li"> Pornire <strong>init</strong>: procesul părinte al tuturor</div>
</li>
<li class="level1"><div class="li"> Pornire daemoni din scripturile de iniţializare</div>
</li>
<li class="level1"><div class="li"> Pornire programe de login şi aşteptare autentificare utilizator</div>
</li>
</ol>

<p>
Directorul <strong>/boot</strong> conține imaginea de kernel (sau mai multe, pentru diferite versiuni) care este încărcată la pornirea sistemului, dar și fișiere de configurare pentru <strong>bootloader</strong>.
</p>
<pre class="code bash">$ <span class="kw2">ls</span> <span class="re5">-l</span> <span class="sy0">/</span>boot
<span class="br0">&#91;</span>...<span class="br0">&#93;</span>
drwxr-xr-x <span class="nu0">3</span> root root    <span class="nu0">4096</span> Nov  <span class="nu0">7</span> 00:00 grub
<span class="br0">&#91;</span>...<span class="br0">&#93;</span>
<span class="re5">-rw-r--r--</span> <span class="nu0">1</span> root root <span class="nu0">4151832</span> Jun <span class="nu0">11</span>  <span class="nu0">2013</span> vmlinuz-2.6.32-<span class="nu0">49</span>
<span class="re5">-rw-r--r--</span> <span class="nu0">1</span> root root <span class="nu0">4124072</span> Jul <span class="nu0">11</span>  <span class="nu0">2013</span> vmlinuz-2.6.32-<span class="nu0">50</span>
<span class="re5">-rw-r--r--</span> <span class="nu0">1</span> root root <span class="nu0">4151072</span> Sep <span class="nu0">11</span>  <span class="nu0">2013</span> vmlinuz-2.6.32-<span class="nu0">51</span>
<span class="br0">&#91;</span>...<span class="br0">&#93;</span></pre>

</div>
<!-- EDIT7 SECTION "3. Secvența de boot" [6390-8308] -->
<h3 class="sectionedit8" id="virtualizare">4. Virtualizare</h3>
<div class="level3">

<p>
Virtualizarea este o tehnologie care partajează și alocă resursele hardware ale unui server în mai multe “mașini virtuale”  (VM = Virtual Machine) și creează posibilitatea rulării simultane a mai multor sisteme de operare pe un singur computer.
</p>

<p>
Cel mai important avantaj pe care il aduce virtualizarea, apare atunci când o aplicație încetează să mai funcționeze, însă aceasta nu va antrena și căderea celorlalte, deoarece aplicațiile rulează pe mașini virtuale independente, separate, chiar dacă ele se află pe același spațiu fizic. În plus, chiar dacă serverul hardware se prăbușește, virtualizarea are abilitatea de a migra în timp real toate informațiile pe un alt server, fără să afecteze funcționalitatea programelor.
</p>

<p>
Virtualizarea stă la baza arhitecturilor de tip “cloud”, însă nu se oprește doar acolo. Așa cum o să vedem și în laborator, rularea unui sistem de operare în cadrul altuia, poate avea numeroase beneficii.
</p>

<p>
Pentru gestiunea mașinilor virtuale dintr-un sistem, VirtualBox ne pune la dispoziți suita de comenzi <strong>vboxmanage</strong>. Aceasta poate să:
</p>
<ul>
<li class="level1"><div class="li"> listeze toate mașinile virtuale</div>
</li>
</ul>
<pre class="code bash"> $ vboxmanage list vms </pre>
<ul>
<li class="level1"><div class="li"> sau doar a celoar care sunt pornite în mod curent</div>
</li>
</ul>
<pre class="code bash"> $ vboxmanage list runningvms </pre>
<ul>
<li class="level1"><div class="li"> oprirea unei mașini după nume</div>
</li>
</ul>
<pre class="code bash"> $ vboxmanage controlvm NUME_VM acpipowerbutton </pre>
<ul>
<li class="level1"><div class="li"> restart-area mașinii</div>
</li>
</ul>
<pre class="code bash"> $ vboxmanage controlvm NUME_VM reset </pre>
<ul>
<li class="level1"><div class="li"> pornirea acesteia, folosind numele</div>
</li>
</ul>
<pre class="code bash"> $ vboxmanage startvm NUME_VM </pre>

<p>
O funcționalitate utilă a unei mașini virtuale este aceea de a-și salva starea curentă, prin trecerea în starea de pauză (pause), în care nu consumă resurse, și revenirea la starea inițială atunci cand e nevoie de ea (resume). Comnezile folosite sunt:
</p>
<ul>
<li class="level1"><div class="li"> trecerea în starea de pauză</div>
</li>
</ul>
<pre class="code bash"> $ vboxmanage controlvm NUME_VM pause </pre>
<ul>
<li class="level1"><div class="li"> revenirea la starea de rulare</div>
</li>
</ul>
<pre class="code bash"> $ vboxmanage controlvm NUME_VM resume </pre>

<p>
<p><div class="noteclassic"> Aceleași funcționalități pot fi obținute și folosind interfața grafică cu care vine VirtualBox 
</div></p>
</p>

</div>
<!-- EDIT8 SECTION "4. Virtualizare" [8309-10481] -->
<h3 class="sectionedit9" id="emulare">5. Emulare</h3>
<div class="level3">

<p>
În dezvoltarea sistemelor embedded e folosita deoarece poate emula un sistem de calcul complet, nefiind necesar ca sistemul țintă (target) pentru care se face dezvoltarea, și sistemul host, pe care se face dezvoltarea, să folosească aceeași arhitectură. Acest lucru permite ca dezvoltarea software-ului pentru un sistem embedded să poată fi făcută în paralel cu proiectarea hardware-ului, lucru crucial pentru obținerea unui timp de dezvoltare scurt. Un alt avantaj pe care il poate avea emularea, mai ales a sistemelor low-end, este o viteză superioară a emulării pe un sistem host performant, în comparație cu sistemul target.
</p>

<p>
Un exemplu de emulator este <a href="http://www.dosbox.com" class="urlextern" title="http://www.dosbox.com"  rel="nofollow">DOSbox</a> folosit pentru a rula jocuri vechi. 
</p>

<p>
<a href="http://qemu.org" class="urlextern" title="http://qemu.org"  rel="nofollow">QEMU</a> este un emulator/mașină virtuală care permite rularea unui sistem de operare complet ca un simplu program în cadrul unui alt sistem. A fost dezvoltat inițial de Fabrice Bellard și este disponibil gratuit, sub o licență open source. QEMU poate rula atât pe Linux, cât și pe Windows. Este un emulator deoarece poate rula sisteme de operare și programe compilate pentru o platformă (ex: o placă cu procesor ARM, similară cu ce găsim într-un smartphone) pe o altă platformă (ex: un PC <a href="https://en.wikipedia.org/wiki/X86" class="urlextern" title="https://en.wikipedia.org/wiki/X86"  rel="nofollow">arhitectură x86</a> așa cum sunt sistemele din EG306 sau EG106). Acest lucru este făcut prin translatarea dinamică a intrucțiunilor architecturii guest în instrucțiuni pentru arhitectura host. 
</p>

</div>
<!-- EDIT9 SECTION "5. Emulare" [10482-12013] -->
<h2 class="sectionedit10" id="exercitii">Exerciții</h2>
<div class="level2">

</div>
<!-- EDIT10 SECTION "Exerciții" [12014-12037] -->
<h3 class="sectionedit11" id="pregatire_setup_si_gestiunea_masinilor_virtuale_3p">1. Pregătire setup și gestiunea mașinilor virtuale (3p)</h3>
<div class="level3">

</div>

<h4 id="pregatire_infrastructura">1.1. Pregătire infrastructură</h4>
<div class="level4">

<p>
<p><div class="noteclassic">
Pentru rezolvarea exercițiilor aveți nevoie de mașina virtuală <strong><code>puccini</code></strong>, aflată pe calculatoarele din EG306 și EG106
pe partiția de 10 <abbr title="Gigabyte">GB</abbr> (<code>/mnt/sda5</code>). Mașina se poate descărca din <a href="http://repository.grid.pub.ro/cs/uso/2015-2016/lab07/puccini-lab7.ova" class="urlextern" title="http://repository.grid.pub.ro/cs/uso/2015-2016/lab07/puccini-lab7.ova"  rel="nofollow">repository-ul facultății</a>, în cazul în care nu o găsiți pe stații. Credențialele de autentificare sunt: utilizator <code>student</code>, parola <code>student</code>.

</div></p>
</p>

<p>
<p><div class="notewarning">
Verificați existența lor pe mașina de lucru în <code><strong>/mnt/sda5</strong></code>. Dacă nu există, chemați asistentul sau descărcați-o chiar voi pe parcursul demo-ului. 

</div></p>
</p>

<p>
<p><div class="notewarning">De rezolvarea acestui exercițiu depind toate celelalte. Chemați asistentul de fiecare dată când întâmpinați probleme majore
</div></p>
</p>

<p>
Deschideți VirtualBox și importați fișierul <code>puccini-lab7.ova</code>.
</p>

<p>
<p><div class="noteimportant">
<strong>Atenție</strong>: când importați mașina în VirtualBox, să bifați opțiunea <strong><em>Reinitialize the MAC address of all network cards</em></strong>!

</div></p>
</p>

<p>
Avem nevoie de o <a href="https://www.virtualbox.org/manual/ch06.html#network_hostonly" class="urlextern" title="https://www.virtualbox.org/manual/ch06.html#network_hostonly"  rel="nofollow">interfață host-only</a>. E posibil ca atunci când importâm mașina virtuală să primim eroarea <code>Invalid settings detected</code>. Soluția este că trebuie să adăugăm o interfață virtuală de rețea care să conecteze mașina fizică de cea virtuală. Aceasta se face astfel: 
</p>

<p>
Din VirtualBox mergem la <code>File</code> –&gt; <code>Preferences</code> –&gt; <code>Network</code>. Mergem la tab-ul <code>Host-only Netwokrs</code> și apăsăm butonul de add. Urmăriți detalii în poza de mai jos: 
</p>

<p>
<a href="../../../../lib/exe/fetch.php%3Fhash=179e8e&amp;media=http%253A%252F%252Focw.cs.pub.ro%252Fcourses%252F_media%252Fuso%252Flaboratoare%252F3dxym.png" class="media" title="http://ocw.cs.pub.ro/courses/_media/uso/laboratoare/3dxym.png"><img src="../../../../lib/exe/fetch.php%3Fhash=179e8e&amp;w=500&amp;tok=d7b19d&amp;media=http%253A%252F%252Focw.cs.pub.ro%252Fcourses%252F_media%252Fuso%252Flaboratoare%252F3dxym.png" class="media" alt="" width="500" /></a>
</p>

<p>
Observați că s-a adăugat o nouă interfață <code>vboxnet0</code>. 
</p>

<p>
Conectați-vă prin SSH <strong>de pe mașina fizică</strong>, <strong>pe mașina virtuală</strong> și rulați comenzile de acolo, pentru a beneficia de folosirea mouse-lui în terminal, copy-and-paste etc.
</p>

<p>
Pentru conectarea prin SSH, folosiți adresa IP de pe interfața <code>eth1</code> a mașinii virtuale pentru conectare. 
</p>

<p>
<p><div class="noteimportant">
Va trebui să porniți serviciul de SSH <strong>pe mașina virtuală</strong> folosind comanda
</p>
<pre class="code">sudo service ssh start</pre>

<p>

</div></p>
</p>

</div>

<h4 id="gestiune_masini_virtuale">1.2. Gestiune mașini virtuale</h4>
<div class="level4">

<p>
Am văzut deja utilitatea mașinilor virtuale, fie ca izolare a mediului în care lucrăm, fie ca mediu de testare a unor programe/scripturi/comenzi, pe diferite sisteme de operare.
</p>

<p>
Dorim să alocăm mai multă memorie și mai mult CPU actualei mașini virtuale. Asta va duce la îmbunătățirea performanțelor acesteia.
</p>

<p>
<p><div class="noteimportant">
Pentru ca putea face astfel de modificări, mașina virtuală trebuie să fie oprită în totalitate (Power Off)!

</div></p>
</p>

<p>
De pe <strong>mașina fizică</strong>, folosiți comenzi <strong>vboxmanage</strong> pentru a lista mașinile virtuale care rulează și opriți mașina pe care lucrăm.
</p>

<p>
În primul rând aflați numele mașinii virtuale care rulează, folosind <strong>pe sistemul fizic</strong> comanda
</p>
<pre class="code bash"><span class="co4">$ </span>vboxmanage list runningvms</pre>

<p>
Apoi, pentru oprirea mașinii virtuale, folosiți <strong>pe sistemul fizic</strong> comanda
</p>
<pre class="code bash"><span class="co4">$ </span>vboxmanage controlvm <span class="sy0">&lt;</span>NUME_VM<span class="sy0">&gt;</span> acpipowerbutton</pre>

<p>
unde <code>&lt;NUME_VM&gt;</code> este numele mașinii virtuale afișat de comanda precedentă.
</p>

<p>
Din interfața grafică, deschideți meniul <strong>Settings</strong> al mașinii virtuale și, în tabul <strong>System</strong>, alocați:
</p>
<ul>
<li class="level1"><div class="li"> <strong>750MB</strong> de memorie RAM</div>
</li>
<li class="level1"><div class="li"> <strong>2 core</strong>-uri de CPU spre utilizare</div>
</li>
</ul>

<p>
Salvați modificările și reporniți mașina.
</p>

<p>
<p><div class="notetip">
Un feature interesant al VirtualBox realizabil în urma instalării VirtualBox Additions este posibilitatea de a partaja clipboard-ul între host și guest (copy de pe host și paste în guest). Detalii + setări puteți <a href="http://www.liberiangeek.net/2013/09/copy-paste-virtualbox-host-guest-machines/" class="urlextern" title="http://www.liberiangeek.net/2013/09/copy-paste-virtualbox-host-guest-machines/"  rel="nofollow">afla de aici</a>.

</div></p>
</p>

</div>
<!-- EDIT11 SECTION "1. Pregătire setup și gestiunea mașinilor virtuale (3p)" [12038-15906] -->
<h3 class="sectionedit12" id="editarea_intrarilor_din_bootloader_2p">2. Editarea intrărilor din bootloader (2p)</h3>
<div class="level3">

<p>
Într-un sistem dual-boot sau atunci cand avem un meniu de GRUB prea aglomerat (cu diferite versiuni de kernel) e important să înțelegem modul în care putem personaliza intrările din meniu și cum putem altera setările acestuia (ordinea intrărilor din meniu, valoarea de timeout, optiunea implicită etc.).
</p>

<p>
Configurați setările de GRUB, pe <strong>mașina virtuală</strong>, pentru a aștepta (timeout) <strong>7</strong> secunde înainte de a selecta intarea implicită.
</p>

<p>
Urmații pașii de mai jos:
</p>
<ol>
<li class="level1"><div class="li"> Căutați în <strong>/boot</strong> fișierul de configurare (.cfg) corespunzător setărilor de GRUB.</div>
</li>
<li class="level1"><div class="li"> Urmăriți conținutul (citiți primul comentariu din <strong>partea de sus</strong> a fișierului de configurare) lui și identificați fișierul șablon (<em>template</em>) care este interogat pentru parametri.</div>
</li>
<li class="level1"><div class="li"> Modificați parametrul corespunzător din fișierul șablon (e vorba de linia ce conține <code>TIMEOUT</code> fără a conține <code>HIDDEN</code>).</div>
</li>
<li class="level1"><div class="li"> Comentați liniile ce conțin parametrii <code>HIDDEN</code> care ascund ecranul de bootloader. Prin comentarea acestor linii vom activa ecranul de bootloader.</div>
</li>
<li class="level1"><div class="li"> Parametrul care este inițializat la valoarea <code>&quot;splash quiet&quot;</code> modificați-l la valoarea <code>&quot;verbose&quot;</code> pentru ca la bootarea să fie afișate cât mai multe mesaje.</div>
</li>
<li class="level1"><div class="li"> Anuntați bootloader-ul să regenereze setările sale folosind comanda<pre class="code">sudo update-grub</pre>
</div>
</li>
</ol>

<p>
Apoi reporniți <strong>mașina virtuală</strong> folosind comanda
</p>
<pre class="code">sudo reboot</pre>

<p>
 pentru a verifica funcționarea configurării. Când bootează ecranul de bootloader (GRUB) va aștepta acum <strong>7 secunde</strong> înainte de a boota în opțiunea implicită.
</p>

<p>
<p><div class="noteclassic">
Înainte de a reporni mașina virtuală, consultați-vă cu asistentul dacă modificările făcute sunt corecte.

</div></p>
</p>

</div>
<!-- EDIT12 SECTION "2. Editarea intrărilor din bootloader (2p)" [15907-17699] -->
<h3 class="sectionedit13" id="recuperarea_parolei_de_root_2p">3. Recuperarea parolei de root (2p)</h3>
<div class="level3">

<p>
Exista situatii în care sistemul poate deveni inaccesibil: am modificat greșit fișierul <strong>/etc/sudoers</strong> și nu mai putem folosi <strong>sudo</strong>, am uitat parola utilizatorului și nu mai putem face login sau dorim setarea unei parole pentru <strong>root</strong>, dar nu avem drepturi privilegiate.
</p>

<p>
Este nevoie să găsim o altă cale pentru a accesa sistemul. Este nevoie de recuperarea parolei utilizatorului <strong>root</strong>.
</p>

<p>
Pentru a realiza acest lucru trebuie sa configuram sistemul ca atunci cand inițializează kernelul, în loc să pornească procesul <strong>init</strong>, să deschidă un shell. Și pentru ca utilizatorul <strong>root</strong> e cel care deține procesele inițiale, și shell-ul nostru o sa porneasca cu drepturi &quot;speciale&quot;.
</p>

<p>
<p><div class="noteclassic">
Atenție, din motive de securitate, niciodată nu o să puteți afla parola unui utilizator. În cel mai bun caz o puteți doar suprascrie.

</div></p>
</p>

<p>
Pe <strong>mașina virtuală</strong>, reporniți sistemul. În meniul GRUB, apăsați tasta <strong>e</strong> atunci când intrarea corespunzătoare este selectată. Se va deschide un mic script într-un editor. Printre instrucțiunile de acolo, avem și parametrii cu care pornește kernel-ul (linia care începe cu <code>linux</code>). Adăugați la finalul acelei linii șirul <code>init=/bin/bash</code>, similar liniei de mai jos:
</p>
<pre class="code bash"><span class="br0">&#91;</span>...<span class="br0">&#93;</span>
linux <span class="sy0">/</span>boot<span class="sy0">/</span>vmlinuz-3.13.0-<span class="nu0">39</span>-generic <span class="br0">&#91;</span>...<span class="br0">&#93;</span> <span class="re2">init</span>=<span class="sy0">/</span>bin<span class="sy0">/</span><span class="kw2">bash</span>
<span class="br0">&#91;</span>...<span class="br0">&#93;</span></pre>

<p>
Apăsați combinația de taste <code>Ctrl+x</code> pentru a salva modificările și a porni sistemul.
</p>

<p>
În acest moment aveți acces privilegiat la sistem (vedeți prompt-ul de root care se încheie în <code>#</code>) și puteți face orice acțiuni. În mod obișnuit așa se resetează parola de <code>root</code> (folosind comanda <code>passwd</code>) și apoi se bootează în Linux obișnuit și se folosește acea parolă.
</p>

</div>
<!-- EDIT13 SECTION "3. Recuperarea parolei de root (2p)" [17700-19495] -->
<h3 class="sectionedit14" id="rularea_unei_distributii_pentru_o_alta_arhitectura_1p">4. Rularea unei distribuții pentru o altă arhitectură (1p)</h3>
<div class="level3">

<p>
<p><div class="noteimportant">
Acest exercițiu se desfășoară pe <strong>sistemul fizic</strong>. Puteți închide mașina virtuală VirtualBox <code>puccini</code>.

</div></p>
</p>

<p>
Pentru acest exercițiu sunt necesare:
</p>
<ul>
<li class="level1"><div class="li"> O imagine de kernel Linux pentru arhitectura ARM, descărcabil de <a href="http://repository.grid.pub.ro/cs/uso/2015-2016/lab09/kernel-qemu" class="urlextern" title="http://repository.grid.pub.ro/cs/uso/2015-2016/lab09/kernel-qemu"  rel="nofollow">aici</a>.</div>
</li>
<li class="level1"><div class="li"> O imagine de Raspbian (mașină virtuală de Debian care merge pe un sistem de fișiere tip Raspberry Pi), descărcabilă de <a href="http://repository.grid.pub.ro/cs/uso/2015-2016/lab09/2012-10-28-wheezy-raspbian.zip" class="urlextern" title="http://repository.grid.pub.ro/cs/uso/2015-2016/lab09/2012-10-28-wheezy-raspbian.zip"  rel="nofollow">aici</a>. Folosiți Raspbian Wheezy, un flavor de Ubuntu pentru platforma Raspberry Pi. Dezarhivați imaginea în directorul în care ați descărcat-o folosind comanda<pre class="code">unzip 2012-10-28-wheezy-raspbian.zip</pre>
</div>
</li>
<li class="level1"><div class="li"> Un set de pachete pentru a rula într-o mașina virtuală QEMU imaginea de Raspbian. Pentru a instala pachetele necesare rulați comanda<pre class="code bash"><span class="co4">student@uso~:$ </span><span class="kw2">sudo</span> <span class="kw2">apt-get install</span> qemu qemu-kvm qemu-system-arm</pre>
</div>
</li>
</ul>

<p>
<p><div class="notetip">
Există posibilitatea ca în urma rulării comenzii de mai sus să obțineți mesajele de eroare. Mesajul de eroare vă indică ce aveți de făcut, anume actualizarea pachetelor folosind comanda
</p>
<pre class="code">sudo apt-get update</pre>

<p>
după care să rulați din nou comanda de instalare, care va rula acum fără probleme.

</div></p>
</p>

<p>
Pentru a rula o distribuție de Linux pentru platforma Raspberry Pi, trebuie rulată următoarea comandă în directorul în care aveți <strong>atât</strong> imaginea de kernel <code>kernel-qemu</code> cât și imaginea de Raspbian. 
</p>
<pre class="code bash"><span class="co4">student@uso~:$ </span>qemu-system-arm <span class="re5">-kernel</span> kernel-qemu <span class="re5">-cpu</span> arm1176 <span class="re5">-m</span> <span class="nu0">256</span> <span class="re5">-M</span> versatilepb <span class="re5">-no-reboot</span> <span class="re5">-serial</span> stdio <span class="re5">-append</span> <span class="st0">&quot;root=/dev/sda2 panic=1 rootfstype=ext4 rw&quot;</span> <span class="re5">-hda</span> <span class="nu0">2012</span>-<span class="nu0">10</span>-<span class="nu0">28</span>-wheezy-raspbian.img</pre>

<p>
Să descifrăm fiecare parametru de mai sus:
</p>
<ul>
<li class="level1"><div class="li"> <code>-cpu</code> - specifică tipul de procesor care va fi emulat</div>
</li>
<li class="level1"><div class="li"> <code>-m</code> - specifică dimensiunea memoriei RAM</div>
</li>
<li class="level1"><div class="li"> <code>-hda, -hdb</code> etc. - specifică imaginea pentru primul hard disk, respectiv al doilea hard disk, ș.a.m.d</div>
</li>
<li class="level1"><div class="li"> <code>-fda, -fdb</code> - specifică imaginea pentru primul floppy disk, respectiv al doilea floppy disk</div>
</li>
<li class="level1"><div class="li"> <code>-cdrom</code> - specifică imaginea folosită de cdrom</div>
</li>
<li class="level1"><div class="li"> <code>-serial</code>, <code>-parallel</code> - specifică porturile seriale, respectiv, paralele și modul de interacțiune a acestora cu host-ul</div>
</li>
</ul>

<p>
După bootare vă apare un ecran de configurare. În ecranul apărut mergeți până la butonul <code>Finish</code> (folosind <code>Tab</code>).
</p>

<p>
<p><div class="noteclassic">
Dacă nu sunteți autentificați, folosiți următoarele date de autentificare:
</p>
<ul>
<li class="level1"><div class="li"> username: <code>pi</code></div>
</li>
<li class="level1"><div class="li"> parolă: <code>raspberry</code></div>
</li>
</ul>

<p>

</div></p>
</p>

<p>
După ce a bootat sistemul de operare din emulatorul QEMU (adică mașina virtuală Raspabian) rulați, în cadrul acestei mașini virtuale, comenzile: 
</p>
<pre class="code bash">$ lscpu
$ <span class="kw2">uname</span> <span class="re5">-a</span></pre>

<p>
<p><div class="notetip">
Comanda <code>lscpu</code> s-ar putea să nu vă meargă pentru că nu este montat sistemul de fișiere <code>proc</code> necesar comenzii <code>lscpu</code>. Pentru a monta acest sistem de fișiere rulați comanda
</p>
<pre class="code">$ sudo mount -t proc proc /proc</pre>

<p>

</div></p>
</p>

<p>
Observați că în loc de arhitectura <code>x86</code> în output (așa cum vedeam la primul exercițiu) avem ca arhitectură <code>arm</code>. Mai multe detalii despre ARM pe <a href="http://www.arm.com/products/processors/instruction-set-architectures/index.php" class="urlextern" title="http://www.arm.com/products/processors/instruction-set-architectures/index.php"  rel="nofollow">site-ul oficial</a>.
</p>

<p>
<p><div class="noteclassic">
<strong>Informativ</strong>: Pentru a scrie imaginea de mai sus pe un card SD și a o rula pe un dispozitiv de tipul <a href="https://www.raspberrypi.org/" class="urlextern" title="https://www.raspberrypi.org/"  rel="nofollow">Raspberry Pi</a> trebuie să rulăm trei comenzi: una pentru idenficarea partițiilor (e.g. <code>df</code>), una pentru demontarea partiției care repzintă cardul SD și una pentru scrierea imaginii de Raspbian pe cardul SD, folosind <code>dd</code>. Urmăriți <a href="https://www.raspberrypi.org/documentation/installation/installing-images/linux.md" class="urlextern" title="https://www.raspberrypi.org/documentation/installation/installing-images/linux.md"  rel="nofollow">indicațiile de aici</a> dacă nu sunteți siguri ce comenzi trebuie să dați. 

</div></p>
</p>

</div>
<!-- EDIT14 SECTION "4. Rularea unei distribuții pentru o altă arhitectură (1p)" [19496-23628] -->
<h3 class="sectionedit15" id="informatii_despre_sistem_2p">5. Informații despre sistem (2p)</h3>
<div class="level3">

<p>
Pe <strong>mașina fizică</strong>, folosind comenzile corespunzătoare, determinați următoarele informații despre sistem. Puteți folosi oricare dintre comenzile pe care le cunoașteți:
</p>
<ul>
<li class="level1"><div class="li"> numele stației de lucru (<code>/etc/hostname</code>)</div>
</li>
<li class="level1"><div class="li"> arhitectura procesorului (x86, x86_64, aarch64, armv7 etc.) și numărul de core-uri (Indicație: <code>/proc/cpuinfo</code> sau <a href="http://linux.die.net/man/1/lscpu" class="urlextern" title="http://linux.die.net/man/1/lscpu"  rel="nofollow">lscpu</a> și <a href="http://linux.die.net/man/1/nproc" class="urlextern" title="http://linux.die.net/man/1/nproc"  rel="nofollow">nproc</a>).</div>
</li>
<li class="level1"><div class="li"> versiunea kernelului de Linux (<a href="http://linux.die.net/man/1/uname" class="urlextern" title="http://linux.die.net/man/1/uname"  rel="nofollow">uname</a>)</div>
</li>
<li class="level1"><div class="li"> dimensiunea totală a memoriei RAM, memoria folosită și memoria liberă</div>
</li>
<li class="level1"><div class="li"> numărul de partiții din sistem</div>
</li>
<li class="level1"><div class="li"> modelul hard disk-ului, device-ul (Indicație: puteți folosi/prelucra output-ul comenzilor <a href="http://linux.die.net/man/8/lsblk" class="urlextern" title="http://linux.die.net/man/8/lsblk"  rel="nofollow">lsblk</a>, <a href="http://linux.die.net/man/1/lshw" class="urlextern" title="http://linux.die.net/man/1/lshw"  rel="nofollow">lshw</a>, <a href="http://www.binarytides.com/linux-hwinfo-command/" class="urlextern" title="http://www.binarytides.com/linux-hwinfo-command/"  rel="nofollow">hwinfo</a>, <a href="http://www.binarytides.com/inxi-system-information-linux/" class="urlextern" title="http://www.binarytides.com/inxi-system-information-linux/"  rel="nofollow">inxi</a></div>
</li>
<li class="level1"><div class="li"> cât spațiu mai este disponibil pe hard disk </div>
</li>
</ul>

<p>
Agregați informațiile/comenzile obținute mai sus într-un script care să aibă un output similar cu formatul de mai jos (nu trebuie să fie strict ca în exemplul de mai jos):
</p>
<pre class="code bash">hostname: ...
architecture type: ...
kernel version: ...
total memory: ...
used memory: ...
<span class="kw2">free</span> memory: ...
number of partitions: ...
hard disk model: ...
hard disk device: ...
hard disk <span class="kw2">free</span> space: ...</pre>

<p>
Pentru un bonus de <strong>1 karma WoUSO</strong> îmbunătățiți script-ul astfel încât să conțină următoarele informații: 
</p>
<pre class="code bash">NIC <span class="br0">&#40;</span>Network Interface Card<span class="br0">&#41;</span> model: ...
graphics card model: ...
monitor model: ...</pre>

</div>
<!-- EDIT15 SECTION "5. Informații despre sistem (2p)" [23629-25307] -->
<h2 class="sectionedit16" id="bonus">BONUS</h2>
<div class="level2">

</div>
<!-- EDIT16 SECTION "BONUS" [25308-25326] -->
<h3 class="sectionedit17" id="rularea_unor_comenzi_periculoase_1_karma_wouso">Rularea unor comenzi &quot;periculoase&quot; (1 karma WoUSO)</h3>
<div class="level3">

<p>
<p><div class="notewarning">Exercițiul se desfășoară pe <span style='color:red; '>mașina virtuală</span>. Dacă din diverse motive este stricată definitiv, este indicat să re-importați fișierul OVA în VirtualBox.
</p>

<p>
<span style='color:red; '><strong>NU RULAȚI ACESTE COMENZI PE MAȘINA FIZICĂ.</strong></span>

</div></p>
</p>

<p>
Uneori este bine să fim atenți ce comenzi executăm în terminal, pentru că putem compromite definitiv sistemul. 
</p>

<p>
Ce se întâmplă, de exemplu, dacă rulăm comanda următoare (ca <code>root</code> sau cu <code>sudo</code>):
</p>
<pre class="code bash"><span class="kw2">dd</span> <span class="re2">if</span>=<span class="sy0">/</span>dev<span class="sy0">/</span>urandom <span class="re2">of</span>=<span class="sy0">/</span>dev<span class="sy0">/</span>sda <span class="re2">bs</span>=<span class="nu0">512</span> <span class="re2">count</span>=<span class="nu0">1</span></pre>

<p>
Sau comanda
</p>
<pre class="code bash"><span class="kw2">cat</span> <span class="sy0">/</span>dev<span class="sy0">/</span>urandom <span class="sy0">|</span> <span class="kw2">head</span> <span class="re5">-c</span> <span class="nu0">512</span> <span class="sy0">&gt;</span> <span class="sy0">/</span>dev<span class="sy0">/</span>sda</pre>

<p>
Un alt mod de a compromite partiția principală este rularea comenzii:
</p>
<pre class="code bash">mkfs.ext3 <span class="sy0">/</span>dev<span class="sy0">/</span>sda</pre>

<p>
Homedir-ul se poate compromite rulând comanda următoare:
</p>
<pre class="code bash"> <span class="kw2">mv</span> <span class="sy0">/</span>home<span class="sy0">/</span>user<span class="sy0">/*</span> <span class="sy0">/</span>dev<span class="sy0">/</span>null </pre>

<p>
<a href="http://www.tecmint.com/10-most-dangerous-commands-you-should-never-execute-on-linux/" class="urlextern" title="http://www.tecmint.com/10-most-dangerous-commands-you-should-never-execute-on-linux/"  rel="nofollow">Acest articol de pe tecmint</a> prezintă comenzile pe care le-am executat mai sus, plus altele la fel de periculoase, împreună cu explicațiile aferente. Alte exemple care merită urmărite le găsiți pe <a href="http://ubuntuguide.org/wiki/Malicious_Linux_Commands" class="urlextern" title="http://ubuntuguide.org/wiki/Malicious_Linux_Commands"  rel="nofollow">UbuntuGuide</a>.
</p>

</div>
<!-- EDIT17 SECTION "Rularea unor comenzi periculoase (1 karma WoUSO)" [25327-] --></div>
</body>
</html>
