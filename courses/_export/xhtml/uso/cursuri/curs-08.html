    
    

<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
  <meta charset="utf-8" />
  <title>uso:cursuri:curs-08</title>
<meta name="generator" content="DokuWiki"/>
<meta name="robots" content="index,follow"/>
<meta name="date" content="2015-11-23T10:55:15+0200"/>
<meta name="keywords" content="uso,cursuri,curs-08"/>
<link rel="search" type="application/opensearchdescription+xml" href="../../../../lib/exe/opensearch.php" title="CS Open CourseWare"/>
<link rel="start" href="../../../../../courses.1.html"/>
<link rel="alternate" type="application/rss+xml" title="Recent Changes" href="../../../../feed.php"/>
<link rel="alternate" type="application/rss+xml" title="Current Namespace" href="../../../../feed.php%3Fmode=list&amp;ns=uso:cursuri"/>
<link rel="alternate" type="text/html" title="Plain HTML" href="curs-08.html"/>
<link rel="canonical" href="../../../../uso/cursuri/curs-08.html"/>
<link rel="stylesheet" type="text/css" href="../../../../lib/exe/css.php%3Ft=arctic&amp;tseed=1476798676.css"/>
<script type="text/javascript">/*<![CDATA[*/var NS='uso:cursuri';var JSINFO = {"id":"uso:cursuri:curs-08","namespace":"uso:cursuri","isadmin":0,"isauth":0};
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="../../../../lib/exe/js.php%3Ftseed=1476798676"></script>
<script type="text/x-mathjax-config">/*<![CDATA[*/MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ["$","$"], ["\\(","\\)"] ],
        displayMath: [ ["$$","$$"], ["\\[","\\]"] ],
        processEscapes: true
    }
});
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
<script type="text/javascript">/*<![CDATA[*/
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
		  
/*!]]>*/</script>
<script type="text/javascript">/*<![CDATA[*/
var pageTracker = _gat._getTracker("UA-38383934-1");
pageTracker._initData();
pageTracker._trackPageview();
		  
/*!]]>*/</script>
</head>
<body>
<div class="dokuwiki export">
<!-- TOC START -->
<div id="dw__toc">
<h3 class="toggle">Table of Contents</h3>
<div>

<ul class="toc">
<li class="level1"><div class="li"><a href="curs-08.html#curs_08_-_configurari_de_retea">Curs 08 - Configurări de rețea</a></div>
<ul class="toc">
<li class="level2"><div class="li"><a href="curs-08.html#demo-uri">Demo-uri</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="curs-08.html#vizualizarea_interfetelor_de_retea">Vizualizarea interfețelor de rețea</a></div></li>
<li class="level3"><div class="li"><a href="curs-08.html#vizualizarea_adresei_ip_si_adresei_mac_pe_interfetele_sistemului">Vizualizarea adresei IP și adresei MAC pe interfețele sistemului</a></div></li>
<li class="level3"><div class="li"><a href="curs-08.html#verificarea_functionarii_serviciului_dns">Verificarea funcționării serviciului DNS</a></div></li>
<li class="level3"><div class="li"><a href="curs-08.html#latenta_dns_in_internet">Latența DNS în Internet</a></div></li>
<li class="level3"><div class="li"><a href="curs-08.html#afisarea_serviciilor_active_si_a_conexiunilor_active">Afișarea serviciilor active și a conexiunilor active</a></div></li>
<li class="level3"><div class="li"><a href="curs-08.html#pornirea_unui_serviciu">Pornirea unui serviciu</a></div></li>
<li class="level3"><div class="li"><a href="curs-08.html#vizualizarea_adresei_de_broadcast_pe_o_interfata">Vizualizarea adresei de broadcast pe o interfață</a></div></li>
<li class="level3"><div class="li"><a href="curs-08.html#vizualizarea_gateway-ului_intr-un_sistem_linux">Vizualizarea gateway-ului într-un sistem Linux</a></div></li>
<li class="level3"><div class="li"><a href="curs-08.html#vizualizarea_ruterelor_catre_o_statie_din_internet">Vizualizarea ruterelor către o stație din Internet</a></div></li>
<li class="level3"><div class="li"><a href="curs-08.html#vizualizarea_unei_comunicatii_dhcp">Vizualizarea unei comunicații DHCP</a></div></li>
<li class="level3"><div class="li"><a href="curs-08.html#preambul_pentru_configurarea_accesului_la_internet">Preambul pentru configurarea accesului la Internet</a></div></li>
<li class="level3"><div class="li"><a href="curs-08.html#configurarea_temporara_statica_a_unei_interfete_de_retea">Configurarea temporară statică a unei interfețe de rețea</a></div></li>
<li class="level3"><div class="li"><a href="curs-08.html#configurarea_temporara_dinamica_a_unei_interfete_de_retea">Configurarea temporară dinamică a unei interfețe de rețea</a></div></li>
<li class="level3"><div class="li"><a href="curs-08.html#configurarea_persistenta_statica_a_unei_interfete_de_retea">Configurarea persistentă statică a unei interfețe de rețea</a></div></li>
<li class="level3"><div class="li"><a href="curs-08.html#configurarea_persistenta_dinamica_a_unei_interfete_de_retea">Configurarea persistentă dinamică a unei interfețe de rețea</a></div></li>
</ul></li>
</ul></li>
</ul>
</div>
</div>
<!-- TOC END -->

<h1 class="sectionedit1" id="curs_08_-_configurari_de_retea">Curs 08 - Configurări de rețea</h1>
<div class="level1">
<ul>
<li class="level1"><div class="li"> <a href="http://elf.cs.pub.ro/uso/res/cursuri/curs-08/curs-08-handout.pdf" class="urlextern" title="http://elf.cs.pub.ro/uso/res/cursuri/curs-08/curs-08-handout.pdf"  rel="nofollow"> Slide-uri curs</a></div>
</li>
<li class="level1"><div class="li"> <a href="http://elf.cs.pub.ro/uso/res/cursuri/curs-08/curs-08-handout-4on1-notes.pdf" class="urlextern" title="http://elf.cs.pub.ro/uso/res/cursuri/curs-08/curs-08-handout-4on1-notes.pdf"  rel="nofollow"> Handout 4on1 and notes space</a></div>
</li>
<li class="level1"><div class="li"> <a href="http://elf.cs.pub.ro/uso/res/cursuri/curs-08/curs-08-handout-8on1.pdf" class="urlextern" title="http://elf.cs.pub.ro/uso/res/cursuri/curs-08/curs-08-handout-8on1.pdf"  rel="nofollow"> Handout 8on1</a></div>
</li>
<li class="level1"><div class="li"> <strong>Cuvinte cheie</strong>: rețea de calculatoare, <abbr title="Local Area Network">LAN</abbr>, conectare, <em>end-to-end</em>, mediu de transmisie, echipament de rețea, switch, ruter, interfață de rețea, protocol, stivă de protocoale, adresă MAC, adresă IP, <abbr title="Domain Name System">DNS</abbr>, port, (sub)rețea, mască de subrețea, adresă de subrețea, adresă de broadcast, DHCP, Internet, static/dinamic, temporar/persistent</div>
</li>
<li class="level1"><div class="li"> <strong>Suport de curs</strong></div>
<ul>
<li class="level2"><div class="li"> <a href="http://books.google.com/books?id=_JFGzyRxQGcC" class="urlextern" title="http://books.google.com/books?id=_JFGzyRxQGcC"  rel="nofollow"> Introducere în sisteme de operare</a></div>
<ul>
<li class="level3"><div class="li"> <a href="http://books.google.com/books?id=_JFGzyRxQGcC&amp;pg=PA217" class="urlextern" title="http://books.google.com/books?id=_JFGzyRxQGcC&amp;pg=PA217"  rel="nofollow"> Capitolul 8 - Configurări de rețea</a></div>
</li>
</ul>
</li>
</ul>
</li>
</ul>

  <center>
    <iframe src="http://docs.google.com/viewer?url=http://elf.cs.pub.ro/uso/res/cursuri/curs-08/curs-08-handout.pdf&embedded=true" width="600" height="480" style="border: none;">
    </iframe>
  </center>

</div>
<!-- EDIT1 SECTION "Curs 08 - Configurări de rețea" [1-1160] -->
<h2 class="sectionedit2" id="demo-uri">Demo-uri</h2>
<div class="level2">

<p>
Pentru rularea demo-urilor de mai jos folosim <a href="http://repository.grid.pub.ro/cs/uso/USO%20Demo.ova" class="urlextern" title="http://repository.grid.pub.ro/cs/uso/USO%20Demo.ova"  rel="nofollow">mașina virtuală USO Demo</a>. Mașina virtuală (în format OVA) poate fi importată în VirtualBox. Comenzile le vom rula în cadrul mașinii virtuale.
</p>

<p>
Mașina virtuală deține două interfețe de rețea:
</p>
<ul>
<li class="level1"><div class="li"> <code>eth0</code> pentru accesul la Internet (interfață de tipul NAT)</div>
</li>
<li class="level1"><div class="li"> <code>eth1</code> pentru comunicarea cu sistemul fizic (gazdă, <em>host</em>) (interfață de tipul <em>Host-only Adapter</em>)</div>
</li>
</ul>

<p>
Pentru a rula demo-ul avem două opțiuni:
</p>
<ol>
<li class="level1"><div class="li"> Folosim direct consola mașinii virtuale.</div>
</li>
<li class="level1"><div class="li"> Aflăm adresa IP de pe interfața <code>eth1</code> a mașinii virtuale și ne conectăm prin SSH, de pe sistemul fizic, folosind comanda<pre class="code">ssh student@&lt;adresa-IP-vm-eth1&gt;</pre>

<p>
 unde <code>&lt;adresa-IP-vm-eth1&gt;</code> este adresa IP a interfeței <code>eth1</code> din cadrul mașinii virtuale.
</p>
</div>
</li>
</ol>

<p>
Pentru conectarea la mașina virtuală folosim numele de utilizator <code>student</code> cu parola <code>student</code>. Contul <code>student</code> are permsiuni de <code>sudo</code>. Folosind comanda
</p>
<pre class="code">sudo su -</pre>

<p>
obținem permisiuni privilegiate (de <code>root</code>) în shell.
</p>

<p>
<p><div class="noteclassic">
Dacă dorim să ne conectăm pe SSH iar mașina virtuală nu are adresă IP configurată pe interfața <code>eth1</code> atunci folosim comanda
</p>
<pre class="code">sudo dhclient eth1</pre>

<p>
pentru a obține o adresă IP.

</div></p>
</p>

<p>
<p><div class="noteclassic">
Dacă optăm pentru rularea prin SSH iar sistemul fizic rulează Windows, putem folosi <a href="http://www.chiark.greenend.org.uk/~sgtatham/putty/" class="urlextern" title="http://www.chiark.greenend.org.uk/~sgtatham/putty/"  rel="nofollow">Putty</a> pe post de client SSH pe sistemul fizic.

</div></p>
</p>

<p>
<p><div class="noteclassic">
Comenzile folosite sunt de uz general. Actualizând adresele IP cu adrese potrivite, putem rula cu succes comenzile pe orice sistem sau mașină virtuală Linux.

</div></p>
</p>

<p>
<p><div class="noteimportant">
Toate comenzile de mai jos au loc pe <strong>mașina virtuală</strong>, accesibilă la <a href="http://repository.grid.pub.ro/cs/uso/USO%20Demo.ova" class="urlextern" title="http://repository.grid.pub.ro/cs/uso/USO%20Demo.ova"  rel="nofollow">acest link</a>.

</div></p>
</p>

<p>
<p><div class="noteclassic">
În mod tradițional, configurarea rețelei în sistemele Linux/Unix s-a făcut cu ajutorul comenzilor <code>ifconfig</code> și <code>route</code>. Aceste comenzi sunt încă active; pe Linux, însă, se recomandă folosirea comenzii <code>ip</code> din suita/pachetul <code>iproute2</code>, o comandă mai puternică și mai flexibilă.
</p>

<p>
În demo vom folosi comanda <code>ip</code>; pentru folosirea comenzilor <code>ifconfig</code> și <code>route</code> putem consulta tutoriale pe Internet; modul de folosire este apropiat comenzii <code>ip</code>.

</div></p>
</p>

</div>
<!-- EDIT2 SECTION "Demo-uri" [1161-3552] -->
<h3 class="sectionedit3" id="vizualizarea_interfetelor_de_retea">Vizualizarea interfețelor de rețea</h3>
<div class="level3">

<p>
Interfața în linia de comandă ne ajută pentru vizualizarea rapidă a interfețelor de rețea prin rularea comenzii
</p>
<pre class="code">student@uso-demo:~$ ip link show
1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP mode DEFAULT group default qlen 1000
    link/ether 08:00:27:ea:9b:3f brd ff:ff:ff:ff:ff:ff
3: eth1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP mode DEFAULT group default qlen 1000
    link/ether 08:00:27:f1:16:da brd ff:ff:ff:ff:ff:ff</pre>

<p>
Comanda <code>ip link show</code> afișează interfețele de rețea ale sistemului și tipul acestora.
</p>

<p>
Comanda <code>ip</code>, folosită în configurarea rețelei în Linux are argumente care pot fi prescurtate. Astfel, forma uzuală în care rulăm comanda de mai sus este
</p>
<pre class="code">student@uso-demo:~$ ip l s
1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP mode DEFAULT group default qlen 1000
    link/ether 08:00:27:ea:9b:3f brd ff:ff:ff:ff:ff:ff
3: eth1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP mode DEFAULT group default qlen 1000
    link/ether 08:00:27:f1:16:da brd ff:ff:ff:ff:ff:ff</pre>

<p>
În urma rulării ne sunt afișate cele trei interfețe ale sistemului:
</p>
<ol>
<li class="level1"><div class="li"> interfața virtuală <code>lo</code> (numită și interfață de loopback – indicat de șirul <code>link/loopback</code> în output)</div>
</li>
<li class="level1"><div class="li"> interfața fizică (din perspectiva mașinii virtuale) <code>eth0</code> (de tip <em>Ethernet</em> – indicat de șirul <code>link/ether</code> în output)</div>
</li>
<li class="level1"><div class="li"> interfața fizică (din perspectiva mașinii virtuale) <code>eth1</code> (de tip <em>Ethernet</em> – indicat de șirul <code>link/ether</code> în output)</div>
</li>
</ol>

<p>
Interfața virtuală <code>lo</code> este o interfață virtuală specială. Ea referă sistemul curent (o auto-referință) și este utilă atunci când dorim să pornim servicii de rețea accesibile doar local sau pentru testare. Interfața este activă și atunci când nu avem conexiune la Internet.
</p>

<p>
În cazul interfețelor fizice <code>eth0</code> și <code>eth1</code> observăm că avem indicatorul <code>UP</code> deci cele două interfețe sunt active.
</p>

</div>
<!-- EDIT3 SECTION "Vizualizarea interfețelor de rețea" [3553-5947] -->
<h3 class="sectionedit4" id="vizualizarea_adresei_ip_si_adresei_mac_pe_interfetele_sistemului">Vizualizarea adresei IP și adresei MAC pe interfețele sistemului</h3>
<div class="level3">

<p>
Prin rularea comenzii <code>ip address show</code> (sau, mai uzual, <code>ip a s</code>) putem afla informații despre interfețele sistemului precum adresa MAC și adresa IP:
</p>
<pre class="code">student@uso-demo:~$ ip a s
1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host
       valid_lft forever preferred_lft forever
2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000
    link/ether 08:00:27:ea:9b:3f brd ff:ff:ff:ff:ff:ff
    inet 10.0.2.15/24 brd 10.0.2.255 scope global eth0
       valid_lft forever preferred_lft forever
    inet6 fe80::a00:27ff:feea:9b3f/64 scope link
       valid_lft forever preferred_lft forever
3: eth1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000
    link/ether 08:00:27:f1:16:da brd ff:ff:ff:ff:ff:ff
    inet 192.168.56.100/24 brd 192.168.56.255 scope global eth1
       valid_lft forever preferred_lft forever
    inet6 fe80::a00:27ff:fef1:16da/64 scope link
       valid_lft forever preferred_lft forever</pre>

<p>
<p><div class="noteclassic">
Observăm că aceleași informații pe care le-a afișat comanda <code>ip l s</code> sunt acum vizibile și aici împreună cu alte informații. Din acest motiv, este mai rar folosită comanda <code>ip l s</code>; adesea folosim comanda <code>ip a s</code> pentru a afișa interfețele sistemului și informații despre acestea.

</div></p>
</p>
<ol>
<li class="level1"><div class="li"> Interfața virtuală <code>lo</code> are adresa IP <code>127.0.0.1</code> (pe linia cu <code>inet</code>) și adresa MAC <code>00:00:00:00:00:00</code> (pe linia cu <code>link/loopback</code>).</div>
</li>
<li class="level1"><div class="li"> Interfața fizică (din perspectiva mașinii virtuale) <code>eth0</code> (de tip <em>Ethernet</em>) are adresa IP <code>10.0.2.15</code> și adresa MAC <code>08:00:27:ea:9b:3f</code>. Adresa pot diferi la rularea mașinii virtuale pe un alt sistem.</div>
</li>
<li class="level1"><div class="li"> Interfața fizică (din perspectiva mașinii virtuale) <code>eth1</code> (de tip <em>Ethernet</em>) are adresa IP <code>192.168.56.100</code> și adresa <code>08:00:27:f1:16:da</code>. Adresele pot diferi la rularea mașinii virtuale pe un alt sistem.</div>
</li>
</ol>

<p>
<p><div class="noteclassic">
În output-ul comenzii sunt indicate și adresle IPv6, dar nu vom insista pe acestea.

</div></p>
</p>

</div>
<!-- EDIT4 SECTION "Vizualizarea adresei IP și adresei MAC pe interfețele sistemului" [5948-8261] -->
<h3 class="sectionedit5" id="verificarea_functionarii_serviciului_dns">Verificarea funcționării serviciului DNS</h3>
<div class="level3">

<p>
Pentru a verifica funcționarea serviciului <abbr title="Domain Name System">DNS</abbr> putem folosi, simplist, comanda <code>ping</code> care verifică dacă avem conectivitate:
</p>
<pre class="code">student@uso-demo:~$ ping google.com
PING google.com (80.96.255.110) 56(84) bytes of data.
64 bytes from cache.google.com (80.96.255.110): icmp_seq=1 ttl=63 time=47.9 ms
64 bytes from cache.google.com (80.96.255.110): icmp_seq=2 ttl=63 time=57.0 ms
^C
--- google.com ping statistics ---
2 packets transmitted, 2 received, 0% packet loss, time 1000ms
rtt min/avg/max/mdev = 47.961/52.499/57.038/4.544 ms</pre>

<p>
Prima linie din output-ul comenzii ne indică faptul că aceasta a translatat numele <code>google.com</code> în adresa <code>80.96.255.110</code> interogând în spate, transparent utilizatorului, serviciul <abbr title="Domain Name System">DNS</abbr>.
</p>

<p>
<p><div class="noteimportant">
Când rulăm comanda <code>ping</code> pe Linux aceasta trimite în mod continuu pachete. Ca să oprim comanda/procesul folosim combinația de taste <code>Ctrl+c</code>.

</div></p>
</p>

<p>
Totuși, modul recomandat de verificare a funcționării serviciului <abbr title="Domain Name System">DNS</abbr> este folosirea unei comenzi de tip client <abbr title="Domain Name System">DNS</abbr>. O astfel de comandă este comanda <code>host</code>:
</p>
<pre class="code">student@uso-demo:~$ host google.com
google.com has address 80.96.255.109
google.com has address 80.96.255.95
google.com has address 80.96.255.82
google.com has address 80.96.255.123
google.com has address 80.96.255.116
google.com has address 80.96.255.102
google.com has address 80.96.255.103
google.com has address 80.96.255.117
google.com has address 80.96.255.89
google.com has address 80.96.255.96
google.com has address 80.96.255.88
google.com has address 80.96.255.110
google.com has IPv6 address 2a00:1450:401b:801::200e
google.com mail is handled by 30 alt2.aspmx.l.google.com.
google.com mail is handled by 10 aspmx.l.google.com.
google.com mail is handled by 50 alt4.aspmx.l.google.com.
google.com mail is handled by 20 alt1.aspmx.l.google.com.
google.com mail is handled by 40 alt3.aspmx.l.google.com.

student@uso-demo:~$ host cs.curs.pub.ro
cs.curs.pub.ro is an alias for ha-webserver-01-pub.curs.pub.ro.
ha-webserver-01-pub.curs.pub.ro has address 141.85.241.51

student@uso-demo:~$ host ocw.cs.pub.ro
ocw.cs.pub.ro has address 141.85.227.65
ocw.cs.pub.ro mail is handled by 10 ocw.cs.pub.ro.</pre>

<p>
În output-ul comenzii am identificat adresele IP corespunzătoare pentru <code>google.com</code>; sunt, în mod așteptat, mai multe adrese IP; un singur server nu ar rezista la multitudinea de cereri din Internet către engine-ul Google. Am identificat adresa IP pentru <code>cs.curs.pub.ro</code> și pentru <code>ocw.cs.pub.ro</code>.
</p>

<p>
Atunci când comanda <code>host</code> întoarce succes pentru un nume comun (precum <code>google.com</code>) înseamnă că serviciul <abbr title="Domain Name System">DNS</abbr> funcționează.
</p>

</div>
<!-- EDIT5 SECTION "Verificarea funcționării serviciului DNS" [8262-10972] -->
<h3 class="sectionedit6" id="latenta_dns_in_internet">Latența DNS în Internet</h3>
<div class="level3">

<p>
<em>You know it&#039;s love when you memorize her IP number to skip DNS overhead.</em>
</p>

<p>
Atunci când folosim o aplicație de rețea, în general folosim nume, nu adrese IP. În spate aplicația va interoga serviciul <abbr title="Domain Name System">DNS</abbr> care va întoarce adresa IP dorită și apoi aplicația se va conecta la serviciul stației identificată cu acea adresă IP. Procesul de interogare a serviciului <abbr title="Domain Name System">DNS</abbr> are latență (întârziere) și acest lucru poate fi important. Din acest motiv, când folosim în special comenzi de diagnosticare și depanare a rețelei (<em>troubleshooting</em>), dorim să evităm overhead-ul dat de serviciul <abbr title="Domain Name System">DNS</abbr>.
</p>

<p>
De exemplu, dacă dorim să afișăm conexiunile active în sistem, folosim comanda <code>netstat</code> ca mai jos:
</p>
<pre class="code">student@uso-demo:~$ time netstat -t
Active Internet connections (w/o servers)
Proto Recv-Q Send-Q Local Address           Foreign Address         State
tcp        0      0 192.168.56.100:ssh      192.168.56.1:34692      ESTABLISHED

real	0m0.097s
user	0m0.000s
sys	0m0.004s
student@uso-demo:~$ time netstat -tn
Active Internet connections (w/o servers)
Proto Recv-Q Send-Q Local Address           Foreign Address         State
tcp        0      0 192.168.56.100:22       192.168.56.1:34692      ESTABLISHED

real	0m0.007s
user	0m0.000s
sys	0m0.000s</pre>

<p>
Am folosit comanda <code>time</code> pentru a măsura durata comenzii transmisă ca argument. Observăm că a doua comandă <code>netstat</code>, cu opțiunea suplimentară <code>-n</code> durează mai puțin (timpul real de execuție este de <code>7</code> milisecunde față de <code>97</code> de milisecunde). Opțiunea <code>-n</code> dezactivează interogarea serviciului <abbr title="Domain Name System">DNS</abbr> și de aceea este mai rapidă.
</p>

<p>
<p><div class="noteimportant">
În general, în comenzile de diagnosticare și depanare a rețelei vom folosi opțiunea <code>-n</code> pentru a obține comenzi mai rapide care să nu țină cont de latența serviciului <abbr title="Domain Name System">DNS</abbr>.

</div></p>
</p>

</div>
<!-- EDIT6 SECTION "Latența DNS în Internet" [10973-12865] -->
<h3 class="sectionedit7" id="afisarea_serviciilor_active_si_a_conexiunilor_active">Afișarea serviciilor active și a conexiunilor active</h3>
<div class="level3">

<p>
Pentru a ști ce aplicații de rețea (de tip client sau de tip server) rulează pe sistemul nostru, folosim comanda <code>netstat</code> (de le <em>network statistics</em>).
</p>

<p>
Dacă vrem să afișăm serviciile TCP din sistem folosim comanda
</p>
<pre class="code">student@uso-demo:~$ netstat -tln
Active Internet connections (only servers)
Proto Recv-Q Send-Q Local Address           Foreign Address         State
tcp        0      0 0.0.0.0:44292           0.0.0.0:*               LISTEN
tcp        0      0 0.0.0.0:111             0.0.0.0:*               LISTEN
tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN
tcp        0      0 127.0.0.1:25            0.0.0.0:*               LISTEN
tcp6       0      0 :::35042                :::*                    LISTEN
tcp6       0      0 :::111                  :::*                    LISTEN
tcp6       0      0 :::22                   :::*                    LISTEN
tcp6       0      0 ::1:25                  :::*                    LISTEN

student@uso-demo:~$ sudo netstat -tlpn
Active Internet connections (only servers)
Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name
tcp        0      0 0.0.0.0:44292           0.0.0.0:*               LISTEN      482/rpc.statd
tcp        0      0 0.0.0.0:111             0.0.0.0:*               LISTEN      473/rpcbind
tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      498/sshd
tcp        0      0 127.0.0.1:25            0.0.0.0:*               LISTEN      771/exim4
tcp6       0      0 :::35042                :::*                    LISTEN      482/rpc.statd
tcp6       0      0 :::111                  :::*                    LISTEN      473/rpcbind
tcp6       0      0 :::22                   :::*                    LISTEN      498/sshd
tcp6       0      0 ::1:25                  :::*                    LISTEN      771/exim4</pre>

<p>
Am folosit următoarele opțiuni ale comenzii <code>netstat</code>:
</p>
<ul>
<li class="level1"><div class="li"> <code>-t</code> afișează informații despre TCP</div>
</li>
<li class="level1"><div class="li"> <code>-l</code> afișează procesele în starea <em>listening</em>, adică serviciile sistemului</div>
</li>
<li class="level1"><div class="li"> <code>-n</code> dezactivează interogarea serviciului <abbr title="Domain Name System">DNS</abbr> pentru o rulare mai bună a comenzii</div>
</li>
<li class="level1"><div class="li"> <code>-p</code> afișează PID-ul și numele procesului aferent</div>
</li>
</ul>

<p>
<p><div class="noteimportant">
Atunci când folosim opțiunea <code>-p</code> pentru afișarea PID-ului și numelui procesului aferent trebuie să rulăm cu drepturi privilegiate. De aceea am folosit <code>sudo</code> în fața comenzii <code>netstat -tlpn</code>.

</div></p>
</p>

<p>
În output-ul de mai sus observăm serviciile TCP ale sistemului, printre care serverul de SSH (procesul <code>sshd</code>) care ascultă conexiuni pe portul <code>22</code> și serverul de e-mail (procesul <code>exim4</code>) care ascultă conexiunie pe portul <code>25</code>.
</p>

<p>
Dacă dorim să afișăm conexiunile active TCP din sistem (adică nu aplicații de tip server care ascultă, ci conexiuni realizate între o aplicație client și o aplicație server) folosim comanda
</p>
<pre class="code">student@uso-demo:~$ sudo netstat -tpn
Active Internet connections (w/o servers)
Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name
tcp        0      0 192.168.56.100:22       192.168.56.1:34692      ESTABLISHED 896/sshd: student [</pre>

<p>
Față de comanda anterioară, am scos opțiunea <code>-l</code> (pentru servicii). Observăm că, în cazul de față, avem o conexiune realizată către serviciul local SSH (adresa IP <code>192.168.56.100</code> este adresa interfeței locale <code>eth1</code>, iar portul <code>22</code> este portul pe care asculă serviciul SSH) de la o aplicație client care s-a conectat de la adresa <code>192.168.56.1</code> de pe portul <code>34692</code>. Această conexiune apare întrucât, în situația curentă, există o conexiune SSH de pe sistemul fizic pe mașina virtuală; pe această conexiune noi rulăm de fapt comenzile.
</p>

</div>
<!-- EDIT7 SECTION "Afișarea serviciilor active și a conexiunilor active" [12866-16721] -->
<h3 class="sectionedit8" id="pornirea_unui_serviciu">Pornirea unui serviciu</h3>
<div class="level3">

<p>
Dacă dorim să pornim un serviciu de test, putem folosi comanda <code>netcat</code> (sau forma sa prescurtată <code>nc</code>). De exemplu, dacă dorim să pornim un serviciu pe portul <code>12345</code> vom folosi comanda
</p>
<pre class="code">student@uso-demo:~$ nc -l -p 12345
</pre>

<p>
În urma rulării consola nu mai afișează prompt, întrucât serviciul proaspăt pornit așteaptă cereri de conectare. Putem verifică pornirea serviciului cu ajutorul comenzii <code>netstat</code>:
</p>
<pre class="code">student@uso-demo:~$ sudo netstat -tlpn
[...]
tcp        0      0 0.0.0.0:12345           0.0.0.0:*               LISTEN      1017/nc
[...]</pre>

<p>
Observăm procesul <code>nc</code> cu PID-ul <code>1017</code> care ascultă conexiuni pe portul <code>12345</code>.
</p>

<p>
Pentru a realiza o conexiune la acest serviciu, pe o altă consolă, putem folosi tot comanda <code>netcat</code>/<code>nc</code> dar în modul client:
</p>
<pre class="code">student@uso-demo:~$ nc localhost 12345
</pre>

<p>
Cu ajutorul comezii de mai sus am inițiat o conexiune către serviciul pornit local (<code>localhost</code> este un alias pentru adresa <code>127.0.0.1</code>, stația locală) pe portul <code>12345</code>. Din nou, nu se afișează prompt, pentru că se așteaptă comunicarea de informații către server.
</p>

<p>
Pentru a verifica realizarea cu succes a conexiunii rulăm, pe o altă consolă, comanda
</p>
<pre class="code">student@uso-demo:~$ sudo netstat -tnp
Active Internet connections (w/o servers)
[...]
tcp        0      0 127.0.0.1:12345         127.0.0.1:52791         ESTABLISHED 1039/nc
tcp        0      0 127.0.0.1:52791         127.0.0.1:12345         ESTABLISHED 1040/nc</pre>

<p>
Observăm că avem o conexiune între cele două procese <code>nc</code>. Apare de două ori aceeași conexiune pentru că e afișată din perspectiva ambelor procese: procesul server lucrează pe stația locală, adresa IP <code>127.0.0.1</code> pe portul <code>12345</code>, iar procesul client lucrează pe stația locală, adresa <code>127.0.0.1</code> pe portul <code>52791</code>.
</p>

<p>
Ce scriem acum în consola clientului va ajunge la server și invers.
</p>

<p>
<p><div class="noteclassic">
Pentru a închide comunicația putem folosi
</p>
<ul>
<li class="level1"><div class="li"> combinația de taste <code>Ctrl+c</code> pentru a închide unul dintre procese și, în felul acesta, și pe celălalt care nu mai are cu cine să comunice</div>
</li>
<li class="level1"><div class="li"> combinația de taste <code>Ctrl+d</code> în client pentru a transmite <code><abbr title="End of file">EOF</abbr></code> (<em>end of file</em>) și a închide astfel canalul de comunicație</div>
</li>
</ul>

<p>

</div></p>
</p>

</div>
<!-- EDIT8 SECTION "Pornirea unui serviciu" [16722-19039] -->
<h3 class="sectionedit9" id="vizualizarea_adresei_de_broadcast_pe_o_interfata">Vizualizarea adresei de broadcast pe o interfață</h3>
<div class="level3">

<p>
Adresa de broadcast a unei interfețe este vizibilă folosind comanda <code>ip a s</code>. Mai sus, am rulat comanda <code>ip a s</code> și am putut vedea adresele de broadcast de pe cele două interfețe fizice ale sistemului: <code>eth0</code> și <code>eth1</code>. Aceste adrese de broadcast sunt:
</p>
<ul>
<li class="level1"><div class="li"> adresa de broadcast <code>10.0.2.255</code> pe interfața <code>eth0</code></div>
</li>
<li class="level1"><div class="li"> adresa de broadcast <code>192.168.56.255</code> pe interfața <code>eth1</code></div>
</li>
</ul>

<p>
<p><div class="noteclassic">
Interfața <code>lo</code> nu are adresă de broadcast pentru că este o interfață locală și are nevoie să comunice cu toate stațiile din rețeaua sa (semnificația adresei de broadcast); pentru că nu există alte stații în rețeau sa <img src="../../../../lib/images/smileys/icon_smile.gif" class="icon" alt=":-)" />

</div></p>
</p>

</div>
<!-- EDIT9 SECTION "Vizualizarea adresei de broadcast pe o interfață" [19040-19752] -->
<h3 class="sectionedit10" id="vizualizarea_gateway-ului_intr-un_sistem_linux">Vizualizarea gateway-ului într-un sistem Linux</h3>
<div class="level3">

<p>
Pentru a vizualiza gateway-ului într-un sistem Linux folosim comanda <code>ip route show</code> sau forma scurtă a acesteia <code>ip r s</code>
</p>
<pre class="code">student@uso-demo:~$ ip r s
default via 10.0.2.2 dev eth0
10.0.2.0/24 dev eth0  proto kernel  scope link  src 10.0.2.15
192.168.56.0/24 dev eth1  proto kernel  scope link  src 192.168.56.100</pre>

<p>
În vreme ce comanda <code>ip a s</code> ne afișa informații despre adresele interfețelor, comanda <code>ip r s</code> ne afișează informații despre rute și despre default gateway.
</p>

<p>
Nu vom discuta despre ultimele două intrări; pe scurt, o interfață configurată va conduce la o rută; avem două interfețe configurate (<code>eth0</code> și <code>eth1</code>) deci avem două rute. Ne interesează prima linie, care conține șirul <code>default</code> și care, deci, indică (<em>default</em>) gateway-ul. Acesta are adresa <code>10.0.2.2</code>.
</p>

<p>
Putem testa conectivitatea la gateway cu ajutorul comenzii <code>ping</code>:
</p>
<pre class="code">student@uso-demo:~$ ping 10.0.2.2
PING 10.0.2.2 (10.0.2.2) 56(84) bytes of data.
64 bytes from 10.0.2.2: icmp_seq=1 ttl=63 time=0.370 ms
64 bytes from 10.0.2.2: icmp_seq=2 ttl=63 time=0.258 ms
^C
--- 10.0.2.2 ping statistics ---
2 packets transmitted, 2 received, 0% packet loss, time 1001ms
rtt min/avg/max/mdev = 0.258/0.314/0.370/0.056 ms</pre>

<p>
Așa cum era de așteptat, avem conectivitate la gateway. Dacă nu am fi avut, nu am fi putut folosi <code>ping</code> pentru testa conectivitatea la <code>google.com</code>, cum am făcut mai sus.
</p>

</div>
<!-- EDIT10 SECTION "Vizualizarea gateway-ului într-un sistem Linux" [19753-21253] -->
<h3 class="sectionedit11" id="vizualizarea_ruterelor_catre_o_statie_din_internet">Vizualizarea ruterelor către o stație din Internet</h3>
<div class="level3">

<p>
Pentru a vedea ruterele prin care trecem ca să ajungem la o destinație în Internet folosimd comanda <code>traceroute</code>. Comanda este utilă în special pentru depanare, când ne propunem să vedem unde (în ce ruter) se estompează pachetele.
</p>
<pre class="code">student@uso-demo:~$ traceroute -n hotnews.ro
traceroute to hotnews.ro (91.195.7.1), 30 hops max, 60 byte packets
 1  10.0.2.2  0.364 ms  0.148 ms  0.299 ms
 2  * * *
 3  10.252.247.2  58.589 ms  58.430 ms  58.263 ms
 4  172.19.29.92  58.000 ms  57.879 ms  57.710 ms
 5  172.22.23.245  57.555 ms  57.363 ms  57.185 ms
 6  * * *
 7  * * *
 8  93.186.132.13  58.498 ms  58.209 ms  58.006 ms
 9  * * *
10  * * *
11  91.195.7.1  49.132 ms  59.467 ms  60.004 ms</pre>

<p>
În output-ul de mai sus vedem că avem 10 rutere intermediare până la destinația finală (<code>hotenews.ro</code>), care are index-ul 11 și adresa IP <code>91.195.7.1</code>. Dacă ar fi fost probleme într-un punct din Internet pachetele s-ar fi oprit acolo, nu ar fi trecut mai departe. Așa cum este de așteptat primul punct intermediar este chiar gateway-ul cu adresa IP <code>10.0.2.2</code>.
</p>

<p>
<p><div class="noteclassic">
Cu cât o stație destinație este mai departe în Internet cu atât numărul de rutere intermediare (numite și <em>hop</em>-uri) este mai mare.

</div></p>
</p>

<p>
<p><div class="noteclassic">
Output-ul de mai sus diferă de la caz la caz. În funcție de unde vă aflați în Internet (în ce rețea de ISP – <em>Internet Service Provider</em>) ruterele intermediare vor fi altele.

</div></p>
</p>

</div>
<!-- EDIT11 SECTION "Vizualizarea ruterelor către o stație din Internet" [21254-22768] -->
<h3 class="sectionedit12" id="vizualizarea_unei_comunicatii_dhcp">Vizualizarea unei comunicații DHCP</h3>
<div class="level3">

<p>
Pentru interfața <code>eth0</code> adresa IP a fost obținută prin DHCP. Putem vizualiza acest lucru urmărind fișierele de jurnal
</p>
<pre class="code">student@uso-demo:~$ sudo grep DHCP /var/log/syslog
[...]
Nov 22 21:23:19 uso-demo networking[241]: DHCPDISCOVER on eth0 to 255.255.255.255 port 67 interval 5
Nov 22 21:23:19 uso-demo networking[241]: DHCPREQUEST on eth0 to 255.255.255.255 port 67
Nov 22 21:23:19 uso-demo networking[241]: DHCPOFFER from 10.0.2.2
Nov 22 21:23:19 uso-demo networking[241]: DHCPACK from 10.0.2.2
[...]</pre>

<p>
Putem observa din mesaje că la o cerere a stației curente, serverul DHCP (adresa IP <code>10.0.2.2</code>) i-a oferit adresa IP stației curente pe interfața <code>eth0</code>.
</p>

<p>
<p><div class="noteclassic">
Observăm că serverul DHCP este și gateway-ul rețelei locale. Este uzual ca sistemul care este gateway să ruleze și un server DHCP care să ofere adrese IP în rețeaua locală.

</div></p>
</p>

</div>
<!-- EDIT12 SECTION "Vizualizarea unei comunicații DHCP" [22769-23699] -->
<h3 class="sectionedit13" id="preambul_pentru_configurarea_accesului_la_internet">Preambul pentru configurarea accesului la Internet</h3>
<div class="level3">

<p>
Pentru exercițiile de configurare care urmează vom folosi interfața <code>eth0</code>. În demo-urile curente interfața <code>eth0</code> are adresa IP distribuită prin DHCP <code>10.0.2.15</code>. Pentru configurările statice, vom folosi adresa IP <code>10.0.2.16</code>.
</p>

<p>
Înainte de orice configurare vom &quot;curăța&quot; configurația curentă pe interfață prin rularea comenzii <code>ip address flush eth0</code> (sau forma uzuală <code>ip a f eth0</code>):
</p>
<pre class="code">student@uso-demo:~$ ip a s eth0
2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000
    link/ether 08:00:27:ea:9b:3f brd ff:ff:ff:ff:ff:ff
    inet 10.0.2.15/24 brd 10.0.2.255 scope global eth0
       valid_lft forever preferred_lft forever
    inet6 fe80::a00:27ff:feea:9b3f/64 scope link
       valid_lft forever preferred_lft forever
student@uso-demo:~$ sudo ip a f eth0
student@uso-demo:~$ ip a s eth0
2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000
    link/ether 08:00:27:ea:9b:3f brd ff:ff:ff:ff:ff:ff</pre>

<p>
Observăm că după rularea comenzii <code>sudo ip a f eth0</code> (este nevoie de permisiuni privilegiate), configurările de adresă IP pe interfața <code>eth0</code> au dispărut.
</p>

<p>
Pentru configurarea conexiunii la Internet trebuie să configurăm trei componente:
</p>
<ol>
<li class="level1"><div class="li"> adresă IP și macă de (sub)rețea</div>
</li>
<li class="level1"><div class="li"> gateway</div>
</li>
<li class="level1"><div class="li"> server <abbr title="Domain Name System">DNS</abbr></div>
</li>
</ol>

<p>
Pentru configurarea serverului de <abbr title="Domain Name System">DNS</abbr>, indiferent de tipul de configurare, trebuie să edităm fișierul <code>/etc/resolv.conf</code>. Dacă dorim să schimbăm conținutul său putem face acest lucru:
</p>
<pre class="code">student@uso-demo:~$ cat /etc/resolv.conf
nameserver 93.122.135.198
nameserver 62.217.213.71
student@uso-demo:~$ vi /etc/resolv.conf
student@uso-demo:~$ sudo vi /etc/resolv.conf
student@uso-demo:~$ cat /etc/resolv.conf
nameserver 8.8.8.8</pre>

<p>
În comanda de mai sus am schimbat serverele <abbr title="Domain Name System">DNS</abbr> transmise de ISP-ul din care face parte stația locală în serverele <abbr title="Domain Name System">DNS</abbr> de la Google. Folosim comanda <code>host</code> pentru a verifica funcționarea corectă a serverelor de <abbr title="Domain Name System">DNS</abbr>
</p>
<pre class="code">student@uso-demo:~$ host ocw.cs.pub.ro
ocw.cs.pub.ro has address 141.85.227.65
ocw.cs.pub.ro mail is handled by 10 ocw.cs.pub.ro.</pre>

</div>
<!-- EDIT13 SECTION "Preambul pentru configurarea accesului la Internet" [23700-25937] -->
<h3 class="sectionedit14" id="configurarea_temporara_statica_a_unei_interfete_de_retea">Configurarea temporară statică a unei interfețe de rețea</h3>
<div class="level3">

<p>
Configurarea temporară statică a unei interfețe de rețea se realizează cu ajutorul comenzii <code>ip address</code> (pentru configurarea adresei) și <code>ip route</code> (pentru configurarea gateway-ului). Folosim adresa <code>10.0.2.16/24</code> pentru interfața <code>eth0</code> și adresa <code>10.0.2.2</code> (ca și până acum) pentru gateway.
</p>

<p>
Înainte de configurare curățăm configurația interfeței <code>eth0</code>:
</p>
<pre class="code">student@uso-demo:~$ sudo ip a f eth0</pre>

<p>
și verificăm faptul că nu avem configurație activă pe interfața <code>eth0</code>:
</p>
<pre class="code">student@uso-demo:~$ ip a s eth0
2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000
    link/ether 08:00:27:ea:9b:3f brd ff:ff:ff:ff:ff:ff
student@uso-demo:~$ ip r s
192.168.56.0/24 dev eth1  proto kernel  scope link  src 192.168.56.100</pre>

<p>
Întrucât totul este OK (nu avem configurație activă), adăugăm adresa <code>10.0.2.16/24</code> pe interfața <code>eth0</code> și adăugăm adresa <code>10.0.2.2</code> ca gateway:
</p>
<pre class="code">student@uso-demo:~$ sudo ip address add 10.0.2.16/24 dev eth0
student@uso-demo:~$ sudo ip link set eth0 up
student@uso-demo:~$ sudo ip a s eth0
2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000
    link/ether 08:00:27:ea:9b:3f brd ff:ff:ff:ff:ff:ff
    inet 10.0.2.16/24 scope global eth0
       valid_lft forever preferred_lft forever

student@uso-demo:~$ sudo ip route add default via 10.0.2.2
student@uso-demo:~$ ip r s
default via 10.0.2.2 dev eth0
10.0.2.0/24 dev eth0  proto kernel  scope link  src 10.0.2.16
192.168.56.0/24 dev eth1  proto kernel  scope link  src 192.168.56.100</pre>

<p>
Comanda <code>sudo ip link set eth0 up</code> este folosită pentru a garanta că interfața va fi activă.
</p>

<p>
<p><div class="notewarning">
O greșeală frecventă este omiterea măștii în momentul în care se adaugă o adresa IP. De avut grijă ca masca să fie mereu prezentă la configurarea adresei IP pe o interfață.
</p>

<p>
O altă greșeală frecventă este omiterea activării interfeței. O interfață permite adăugarea de adrese IP fără a fi activată. Activarea unei interfețe se face cu ajutorul comenzii:
</p>
<pre class="code">sudo ip link set &lt;ifname&gt; up</pre>

<p>
unde <code>&lt;ifname&gt;</code> este numele interfeței pe care dorim să o activăm.

</div></p>
</p>

<p>
<p><div class="noteimportant">
Configurările necesită privilegii: fie rulăm ca <code>root</code> fie prefixăm comenzile de configurare cu <code>sudo</code>.

</div></p>
</p>

<p>
După configurare folosim <code>ping</code> pentru a testa conectivitatea la <code>google.com</code>
</p>
<pre class="code">student@uso-demo:~$ ping google.com
PING google.com (80.96.255.117) 56(84) bytes of data.
64 bytes from cache.google.com (80.96.255.117): icmp_seq=1 ttl=63 time=48.9 ms
64 bytes from cache.google.com (80.96.255.117): icmp_seq=2 ttl=63 time=35.8 ms
^C
--- google.com ping statistics ---
2 packets transmitted, 2 received, 0% packet loss, time 1002ms
rtt min/avg/max/mdev = 35.864/42.422/48.980/6.558 ms</pre>

</div>
<!-- EDIT14 SECTION "Configurarea temporară statică a unei interfețe de rețea" [25938-28900] -->
<h3 class="sectionedit15" id="configurarea_temporara_dinamica_a_unei_interfete_de_retea">Configurarea temporară dinamică a unei interfețe de rețea</h3>
<div class="level3">

<p>
Configurarea dinamică înseamnă interogarea serverului de DHCP al rețelei locale.
</p>

<p>
Presupunând că am curățat configurația interfeței <code>eth0</code>, configurarea temporară dinamică a interfeței <code>eth0</code> o realizăm cu ajutorul comenzii
</p>
<pre class="code">student@uso-demo:~$ sudo dhclient eth0
student@uso-demo:~$ ip a s eth0
2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000
    link/ether 08:00:27:ea:9b:3f brd ff:ff:ff:ff:ff:ff
    inet 10.0.2.15/24 brd 10.0.2.255 scope global eth0
       valid_lft forever preferred_lft forever
student@uso-demo:~$ ip r s
default via 10.0.2.2 dev eth0
10.0.2.0/24 dev eth0  proto kernel  scope link  src 10.0.2.15
192.168.56.0/24 dev eth1  proto kernel  scope link  src 192.168.56.100
student@uso-demo:~$ ping google.com
PING google.com (80.96.255.102) 56(84) bytes of data.
64 bytes from cache.google.com (80.96.255.102): icmp_seq=1 ttl=63 time=37.1 ms
^C
--- google.com ping statistics ---
1 packets transmitted, 1 received, 0% packet loss, time 0ms
rtt min/avg/max/mdev = 37.144/37.144/37.144/0.000 ms</pre>

<p>
După configurarea temporară de mai sus am afișat configurația curentă și am testat conectivitatea la <code>google.com</code>.
</p>

</div>
<!-- EDIT15 SECTION "Configurarea temporară dinamică a unei interfețe de rețea" [28901-30194] -->
<h3 class="sectionedit16" id="configurarea_persistenta_statica_a_unei_interfete_de_retea">Configurarea persistentă statică a unei interfețe de rețea</h3>
<div class="level3">

<p>
Pentru configuarea persistentă, avem nevoie de un fișier de configurare. Pe distribuțiile Debian-based, acest fișier de configuare este <code>/etc/network/interfaces</code>.
</p>

<p>
În acest fișier modificăm configurația pentru interfața <code>eth0</code> într-o configurația statică pentru a avea adresa IP <code>10.0.2.16/24</code> pe interfața <code>eth0</code> și gateway-ul <code>10.0.2.2</code>:
</p>
<pre class="code">student@uso-demo:~$ cat /etc/network/interfaces
[...]
# The primary network interface
allow-hotplug eth0
iface eth0 inet dhcp
student@uso-demo:~$ sudo vi /etc/network/interfaces
student@uso-demo:~$ cat /etc/network/interfaces
[...]
# The primary network interface
auto eth0
allow-hotplug eth0
iface eth0 inet static
	address 10.0.2.16
	netmask 255.255.255.0
	gateway 10.0.2.2</pre>

<p>
În configurația de mai sus am precizat că avem o configurație statică (prin folosirea cuvântului <code>static</code>) și am precizat adresa IP, masca de (sub)rețea și gateway-ul. Linia <code>auto eth0</code> garantează că interfața <code>eth0</code> va fi configurată la pornirea sistemului.
</p>

<p>
Pentru a fi siguri că am curățat orie configurație temporară și persistentă pe interfața <code>eth0</code> rulăm comenzile aferente
</p>
<pre class="code">student@uso-demo:~$ sudo ip a f eth0
student@uso-demo:~$ sudo ifdown eth0
RTNETLINK answers: No such process
RTNETLINK answers: No such process</pre>

<p>
Comanda <code>ifdown eth0</code> este folosită pentru a curăța configurația persistentă pe interfața <code>eth0</code>.
</p>

<p>
Pentru a activa configurația statică fie repornim mașina virtuală, fie rulăm comanda
</p>
<pre class="code">student@uso-demo:~$ sudo ifup eth0</pre>

<p>
Comanda <code>ifup</code> este apelată și la pornirea sistemului pentru a activa interfețele configurate persistent.
</p>

<p>
După rularea comenzii, verificăm configurația și testăm conectivitatea la Internet
</p>
<pre class="code">student@uso-demo:~$ ip a s eth0
2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000
    link/ether 08:00:27:ea:9b:3f brd ff:ff:ff:ff:ff:ff
    inet 10.0.2.16/24 brd 10.0.2.255 scope global eth0
       valid_lft forever preferred_lft forever
    inet6 fe80::a00:27ff:feea:9b3f/64 scope link
       valid_lft forever preferred_lft forever
student@uso-demo:~$ ip r s
default via 10.0.2.2 dev eth0
10.0.2.0/24 dev eth0  proto kernel  scope link  src 10.0.2.16
192.168.56.0/24 dev eth1  proto kernel  scope link  src 192.168.56.100</pre>

<p>
Dacă dorim să curățăm configurația de pe interfață, rulăm comanda
</p>
<pre class="code">student@uso-demo:~$ sudo ifdown eth0</pre>

<p>
În urma rulării comenzii de mai sus, configurația pe interfața <code>eth0</code> dispare
</p>
<pre class="code">student@uso-demo:~$ ip a s eth0
2: eth0: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc pfifo_fast state DOWN group default qlen 1000
    link/ether 08:00:27:ea:9b:3f brd ff:ff:ff:ff:ff:ff
student@uso-demo:~$ ip r s
192.168.56.0/24 dev eth1  proto kernel  scope link  src 192.168.56.100</pre>

</div>
<!-- EDIT16 SECTION "Configurarea persistentă statică a unei interfețe de rețea" [30195-33133] -->
<h3 class="sectionedit17" id="configurarea_persistenta_dinamica_a_unei_interfete_de_retea">Configurarea persistentă dinamică a unei interfețe de rețea</h3>
<div class="level3">

<p>
Pentru configurarea persistentă dinamică (prin DHCP) folosim, la fel, fișierul <code>/etc/network/interfaces</code>:
</p>
<pre class="code">student@uso-demo:~$ sudo vi /etc/network/interfaces
student@uso-demo:~$ cat /etc/network/interfaces
[...]
# The primary network interface
auto eth0
allow-hotplug eth0
iface eth0 inet dhcp</pre>

<p>
Prin precizarea liniei <code>iface eth0 inet dhcp</code> precizăm configurația dinamică (prin DHCP).
</p>

<p>
Înainte de a activa configurația ne asigurăm că am curățat configurațiile temporare și persistente anterioare:
</p>
<pre class="code">student@uso-demo:~$ sudo ip a f eth0
student@uso-demo:~$ sudo ifdown eth0
ifdown: interface eth0 not configured</pre>

<p>
Apoi activăm configurația persistentă dinamică
</p>
<pre class="code">student@uso-demo:~$ sudo ifup eth0
Internet Systems Consortium DHCP Client 4.3.1
Copyright 2004-2014 Internet Systems Consortium.
All rights reserved.
For info, please visit https://www.isc.org/software/dhcp/

Listening on LPF/eth0/08:00:27:ea:9b:3f
Sending on   LPF/eth0/08:00:27:ea:9b:3f
Sending on   Socket/fallback
DHCPREQUEST on eth0 to 255.255.255.255 port 67
DHCPACK from 10.0.2.2
bound to 10.0.2.15 -- renewal in 38026 seconds.</pre>

<p>
și verificăm configurația obținută
</p>
<pre class="code">student@uso-demo:~$ ip a s eth0
2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000
    link/ether 08:00:27:ea:9b:3f brd ff:ff:ff:ff:ff:ff
    inet 10.0.2.15/24 brd 10.0.2.255 scope global eth0
       valid_lft forever preferred_lft forever
student@uso-demo:~$ ip r s
default via 10.0.2.2 dev eth0
10.0.2.0/24 dev eth0  proto kernel  scope link  src 10.0.2.15
192.168.56.0/24 dev eth1  proto kernel  scope link  src 192.168.56.100
student@uso-demo:~$ ping google.com
PING google.com (80.96.255.88) 56(84) bytes of data.
64 bytes from cache.google.com (80.96.255.88): icmp_seq=1 ttl=63 time=47.4 ms
64 bytes from cache.google.com (80.96.255.88): icmp_seq=2 ttl=63 time=35.0 ms
^C
--- google.com ping statistics ---
2 packets transmitted, 2 received, 0% packet loss, time 1002ms
rtt min/avg/max/mdev = 35.082/41.277/47.472/6.195 ms</pre>

<p>
Observăm mai sus procesul DHCP și primirea adresei <code>10.0.2.15</code> de la serverul DHCP (cu adresa <code>10.0.2.2</code>, adică exact gateway-ul).
</p>

<p>
La fel ca mai sus, dacă dorim să curățăm configurația persistentă curentă, folosim comanda
</p>
<pre class="code">student@uso-demo:~$ sudo ifdown eth0
Killed old client process
Internet Systems Consortium DHCP Client 4.3.1
Copyright 2004-2014 Internet Systems Consortium.
All rights reserved.
For info, please visit https://www.isc.org/software/dhcp/

Listening on LPF/eth0/08:00:27:ea:9b:3f
Sending on   LPF/eth0/08:00:27:ea:9b:3f
Sending on   Socket/fallback
DHCPRELEASE on eth0 to 10.0.2.2 port 67</pre>

<p>
Observăm că se anunță serverul DHCP de eliberarea adresei IP curente prin transmiterea unui mesaj de tip <code>DHCPRELEASE</code>.
</p>

</div>
<!-- EDIT17 SECTION "Configurarea persistentă dinamică a unei interfețe de rețea" [33134-] --></div>
</body>
</html>
