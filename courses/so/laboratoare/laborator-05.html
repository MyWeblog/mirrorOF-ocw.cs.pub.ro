    
    

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"
 lang="en" dir="ltr">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>
    Laborator 05 - Gestiunea memoriei    [CS Open CourseWare]
  </title>

  <meta name="generator" content="DokuWiki"/>
<meta name="robots" content="index,follow"/>
<meta name="date" content="2016-04-05T12:38:58+0300"/>
<meta name="keywords" content="so,laboratoare,laborator-05"/>
<link rel="search" type="application/opensearchdescription+xml" href="../../lib/exe/opensearch.php" title="CS Open CourseWare"/>
<link rel="start" href="../../../courses.1.html"/>
<link rel="alternate" type="application/rss+xml" title="Recent Changes" href="../../feed.php"/>
<link rel="alternate" type="application/rss+xml" title="Current Namespace" href="../../feed.php%3Fmode=list&amp;ns=so:laboratoare"/>
<link rel="alternate" type="text/html" title="Plain HTML" href="../../_export/xhtml/so/laboratoare/laborator-05.html"/>
<link rel="canonical" href="laborator-05.html"/>
<link rel="stylesheet" type="text/css" href="../../lib/exe/css.php%3Ft=arctic&amp;tseed=1476798676.css"/>
<script type="text/javascript">/*<![CDATA[*/var NS='so:laboratoare';var JSINFO = {"id":"so:laboratoare:laborator-05","namespace":"so:laboratoare","isadmin":0,"isauth":0};
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="../../lib/exe/js.php%3Ftseed=1476798676"></script>
<script type="text/x-mathjax-config">/*<![CDATA[*/MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ["$","$"], ["\\(","\\)"] ],
        displayMath: [ ["$$","$$"], ["\\[","\\]"] ],
        processEscapes: true
    }
});
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
<script type="text/javascript">/*<![CDATA[*/
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
		  
/*!]]>*/</script>
<script type="text/javascript">/*<![CDATA[*/
var pageTracker = _gat._getTracker("UA-38383934-1");
pageTracker._initData();
pageTracker._trackPageview();
		  
/*!]]>*/</script>

  <link rel="shortcut icon" href="../../lib/tpl/arctic/images/favicon.ico" />

  
</head>
<body>
<div id="wrapper" class='show'>
  <div class="dokuwiki">

    
    <div class="stylehead">
      <div class="header">
        <div class="pagename">
          <a href="http://ocw.cs.pub.ro/courses/so/"><img height="70" src="../../res/sigla_so.png"/> </a>        </div>
        <div class="logo">
          <a style="color: #AAA !important;" href="../../systems/index.html"/><img height="70" src="../../res/systems.png" name="dokuwiki__top"/></a>        </div>
      </div>
    
       
      <div class="breadcrumbs">
              </div>
      
            </div>

                  <div class="bar" id="bar__top">
        <div class="bar-left">
                  </div>
        <div class="bar-right">
          <a href="laborator-05%3Fdo=recent.html"  class="action recent" accesskey="r" rel="nofollow" title="Recent changes [R]">Recent changes</a><a href="laborator-05%3Fdo=login&amp;sectok=f62420cf5b01253da4b50505d148181b.html"  class="action login" rel="nofollow" title="Login">Login</a>        </div>
    </div>
        
    
    
    
              <div class="left_page">
          
<h1 class="sectionedit1" id="laborator_05_-_gestiunea_memoriei">Laborator 05 - Gestiunea memoriei</h1>
<div class="level1">

</div>

<h2 class="sectionedit2" id="materiale_ajutatoare">Materiale ajutătoare</h2>
<div class="level2">
<ul>
<li class="level1"><div class="li"><a href="http://elf.cs.pub.ro/so/res/laboratoare/lab05-slides.pdf" class="urlextern" title="http://elf.cs.pub.ro/so/res/laboratoare/lab05-slides.pdf"  rel="nofollow"> lab05-slides.pdf</a></div>
</li>
<li class="level1"><div class="li"><a href="http://elf.cs.pub.ro/so/res/laboratoare/lab05-refcard.pdf" class="urlextern" title="http://elf.cs.pub.ro/so/res/laboratoare/lab05-refcard.pdf"  rel="nofollow"> lab05-refcard.pdf</a></div>
</li>
</ul>

</div>

<h3 class="sectionedit3" id="nice_to_read">Nice to read</h3>
<div class="level3">
<ul>
<li class="level1"><div class="li"> TLPI - Chapter 7, <code>Memory Allocation</code></div>
</li>
</ul>

</div>

<h2 class="sectionedit4" id="gestiunea_memoriei">Gestiunea memoriei</h2>
<div class="level2">

<p>
Subsistemul de gestiune a memoriei din cadrul unui sistem de operare este folosit de toate celelalte subsisteme: planificator, I/O, sistemul de fișiere, gestiunea proceselor, networking. Memoria este o resursă importantă, de aceea sunt necesari algoritmi eficienți de utilizare și gestiune a acesteia.
</p>

<p>
Rolul subsistemului de gestiune a memoriei este de:
</p>
<ul>
<li class="level1"><div class="li"> a ține evidența zonelor de memorie fizică (ocupate sau libere)</div>
</li>
<li class="level1"><div class="li"> a oferi proceselor sau celorlalte subsisteme acces la memorie</div>
</li>
<li class="level1"><div class="li"> a mapa paginile de memorie virtuală ale unui proces (pages) peste paginile fizice (frames).</div>
</li>
</ul>

<p>
Nucleul sistemului de operare oferă un set de interfețe (apeluri de sistem) care permit alocarea/dealocarea de memorie, maparea unor regiuni de memorie virtuală peste fișiere, partajarea zonelor de memorie.
</p>

<p>
Din păcate, nivelul limitat de înțelegere a acestor interfețe și a acțiunilor ce se petrec în spate conduc la o serie de probleme foarte des întâlnite în aplicațiile software: memory leak-uri, accese nevalide, suprascrieri, buffer overflow, corupere de zone de memorie.
</p>

<p>
Este, în consecință, fundamentală cunoașterea contextului în care acționează subsistemul de gestiune a memoriei și înțelegerea interfeței puse la dispoziție programatorului de către sistemul de operare.
</p>

</div>

<h2 class="sectionedit5" id="spatiul_de_adresa_al_unui_proces">Spațiul de adresă al unui proces</h2>
<div class="level2">

<p>
<a href="../../_detail/so/laboratoare-2013/process_address_space.jpg%3Fid=so%253Alaboratoare%253Alaborator-05.html" class="media" title="so:laboratoare-2013:process_address_space.jpg"><img src="../../_media/so/laboratoare-2013/process_address_space.jpg" class="mediaright" title="Spațiul de adresă al unui proces" alt="Spațiul de adresă al unui proces" /></a>
</p>

<p>
Spațiul de adresă al unui proces, sau, mai bine spus, spațiul virtual de adresă al unui proces reprezintă zona de memorie virtuală utilizabilă de un proces. Fiecare proces are un spațiu de adresă propriu. Chiar în situațiile în care două procese partajează o zonă de memorie, spațiul virtual este distinct, dar se mapează peste aceeași zonă de memorie fizică.
</p>

<p>
În figura alăturată este prezentat un spațiu de adresă tipic pentru un proces. În sistemele de operare moderne, în spațiul virtual al fiecărui proces se mapează memoria nucleului, aceasta poate fi mapată fie la început, fie la sfârșitul spațiului de adresă. În continuare, ne vom referi numai la spațiul de adresă din user-space pentru un proces.
</p>

<p>
Cele 4 zone importante din spațiul de adresă al unui proces sunt zona de date, zona de cod, stiva și heap-ul. După cum se observă și din figură, stiva și heap-ul sunt zonele care pot crește. De fapt, aceste două zone sunt dinamice și au sens doar în contextul unui proces. De partea cealaltă, informațiile din zona de date și din zona de cod sunt descrise în executabil.
</p>

</div>

<h3 class="sectionedit6" id="zona_de_cod">Zona de cod</h3>
<div class="level3">

<p>
Segmentul de cod (denumit și <code>text segment</code>) reprezintă instrucțiunile în limbaj mașină ale programului. Registrul de tip <code>instruction pointer</code> (IP) va referi adrese din zona de cod. Se citește instrucțiunea indicată de către IP, se decodifică și se interpretează, după care se incrementează contorul programului și se trece la următoarea instrucțiune. 
Zona de cod este, de obicei, o zonă read-only pentru ca procesul să nu poată modifica propriile instrucțiuni prin folosirea greșită a unui pointer. Zona de cod este partajată între toate procesele care rulează același program. Astfel, o singură copie a codului este mapată în spațiul de adresă virtual al tuturor proceselor.
</p>

</div>

<h3 class="sectionedit7" id="zone_de_date">Zone de date</h3>
<div class="level3">

<p>
Zonele de date conțin variabilele globale definite într-un program și variabilele de tipul read-only. În funcție de tipul de date există mai multe subtipuri de zone de date.
</p>

</div>

<h4 id="data">.data</h4>
<div class="level4">

<p>
Zona <code>.data</code> conține variabilele globale și variabilele statice <em class="u">inițializate</em> la valori nenule ale unui program. De exemplu:
</p>
<pre class="code c"><span class="kw4">static</span> <span class="kw4">int</span> a <span class="sy0">=</span> <span class="nu0">3</span><span class="sy0">;</span>
<span class="kw4">char</span> b <span class="sy0">=</span> <span class="st0">'a'</span><span class="sy0">;</span></pre>

</div>

<h4 id="bss">.bss</h4>
<div class="level4">

<p>
Zona <code>.bss</code> conține variabilele globale și variabilele statice <em class="u">neinițializate</em> ale unui program. Înainte de execuția codului, acest segment este inițializat cu 0. De exemplu:
</p>
<pre class="code c"><span class="kw4">static</span> <span class="kw4">int</span> a<span class="sy0">;</span>
<span class="kw4">char</span> b<span class="sy0">;</span></pre>

<p>
În general aceste variabile nu vor fi prealocate în executabil, ci în momentul creării procesului. Alocarea zonei .bss se face peste pagini fizice zero (zeroed frames).
</p>

</div>

<h4 id="rodata">.rodata</h4>
<div class="level4">

<p>
Zona .rodata conține informație care poate fi doar citită, nu și modificată. Aici sunt stocate <em class="u">constantele</em>:
</p>
<pre class="code c"><span class="kw4">const</span> <span class="kw4">int</span> a<span class="sy0">;</span>
<span class="kw4">const</span> <span class="kw4">char</span> <span class="sy0">*</span>ptr<span class="sy0">;</span></pre>

<p>
și <em class="u">literalii</em>:
</p>
<pre class="code c"><span class="st0">&quot;Hello, World!&quot;</span>
<span class="st0">&quot;En Taro Adun!&quot;</span></pre>

</div>

<h3 class="sectionedit8" id="stiva">Stiva</h3>
<div class="level3">

<p>
Stiva este o regiune dinamică în cadrul unui proces, fiind gestionată automat de compilator. 
</p>

<p>
Stiva este folosită pentru a stoca “stack frame-uri”. Pentru fiecare apel de funcție se va crea un nou “stack frame”.
</p>

<p>
Un “stack frame” conține:
</p>
<ul>
<li class="level1"><div class="li">variabile locale </div>
</li>
<li class="level1"><div class="li">argumentele funcției </div>
</li>
<li class="level1"><div class="li">adresa de retur</div>
</li>
</ul>

<p>
Pe marea majoritate a arhitecturilor moderne stiva crește în jos și heap-ul crește în sus. Stiva crește la fiecare apel de funcție și scade la fiecare revenire din funcție.
</p>

<p>
În figura de mai jos este prezentată o vedere conceptuală asupra stivei in momentul apelului unei funcții.
</p>

<p>
<a href="../../_detail/so/laboratoare-2013/call_stack.png%3Fid=so%253Alaboratoare%253Alaborator-05.html" class="media" title="so:laboratoare-2013:call_stack.png"><img src="../../_media/so/laboratoare-2013/call_stack.png" class="mediacenter" alt="" /></a>
</p>

</div>

<h3 class="sectionedit9" id="heap-ul">Heap-ul</h3>
<div class="level3">

<p>
Heap-ul este zona de memorie dedicată alocării dinamice a memoriei. Heap-ul este folosit pentru alocarea de regiuni de memorie a căror dimensiune este determinată la runtime.
</p>

<p>
La fel ca și stiva, heap-ul este o regiune dinamică care își modifică dimensiunea. Spre deosebire de stivă, însă, heap-ul nu este gestionat de compilator. Este de datoria programatorului să știe câtă memorie trebuie să aloce și să rețină cât a alocat și când trebuie să dealoce. Problemele frecvente în majoritatea programelor țin de pierderea referințelor la zonele alocate (memory leaks) sau referirea de zone nealocate sau insuficient alocate (accese nevalide).
</p>

<p>
În limbaje precum Java, Lisp etc. unde nu există “pointer freedom”, eliberarea spațiului alocat se face automat prin intermediul unui garbage collector. Pe aceste sisteme se previne problema pierderii referințelor, dar încă rămâne activă problema referirii zonelor nealocate.
</p>

</div>

<h2 class="sectionedit10" id="alocareadealocarea_memoriei">Alocarea/Dealocarea memoriei</h2>
<div class="level2">

<p>
<strong>Alocarea memoriei</strong> este realizată static de compilator sau dinamic, în timpul execuției. <em>Alocarea statică</em> e realizată în segmentele de date pentru variabilele globale sau pentru literali.
</p>

<p>
În timpul execuției, variabilele se alocă pe stivă sau în heap. Alocarea pe stivă se realizează automat de compilator pentru variabilele locale unei funcții (mai puțin variabilele locale prefixate de identificatorul <strong>static</strong>).
</p>

<p>
<em>Alocarea dinamică</em> se realizează în heap. Alocarea dinamică are loc atunci când nu se știe, în momentul compilării, câtă memorie va fi necesară pentru o variabilă, o structură, un vector. Dacă se știe din momentul compilării cât spațiu va ocupa o variabilă, se recomandă alocarea ei statică, pentru a preveni erorile frecvent apărute în contextul alocării dinamice.
</p>

<p>
Pentru a fragmenta cât mai puțin spațiul de adrese al procesului, ca urmare a alocărilor și dealocărilor unor zone de dimensiuni variate, alocatorul de memorie va organiza segmentul de date alocate dinamic sub formă de <em>heap</em>, de unde și numele segmentului.
</p>

<p>
<strong>Dealocarea memoriei</strong> înseamnă eliberarea zonei de memorie (este marcată ca fiind liberă) alocate dinamic anterior. 
</p>

<p>
Dacă se omite dealocarea unei zone de memorie, aceasta va rămâne alocată pe întreaga durata de rulare a procesului. Ori de câte ori nu mai este nevoie de o zonă de memorie, aceasta trebuie dealocată pentru eficiența utilizării spațiului de memorie.
</p>

<p>
Nu trebuie neapărat realizată dealocarea diverselor zone înainte de un apel <a href="http://linux.die.net/man/3/exit" class="urlextern" title="http://linux.die.net/man/3/exit"  rel="nofollow">exit</a> sau înainte de încheierea programului pentru că acestea sunt automat eliberate de sistemul de operare.
</p>

<p>
<strong>Atenție!</strong> Pot apărea probleme și dacă se încearcă dealocarea aceleiași regiuni de memorie de două sau mai multe ori și se corup datele interne de management al zonelor alocate dintr-un heap.
</p>

</div>

<h3 class="sectionedit11" id="alocarea_memoriei_in_linux">Alocarea memoriei în Linux</h3>
<div class="level3">

<p>
În Linux, alocarea memoriei pentru procesele utilizator se realizează prin intermediul funcțiilor de bibliotecă <a href="http://linux.die.net/man/3/malloc" class="urlextern" title="http://linux.die.net/man/3/malloc"  rel="nofollow">malloc</a>, <a href="http://linux.die.net/man/3/calloc" class="urlextern" title="http://linux.die.net/man/3/calloc"  rel="nofollow">calloc</a> și <a href="http://linux.die.net/man/3/realloc" class="urlextern" title="http://linux.die.net/man/3/realloc"  rel="nofollow">realloc</a>, iar dealocarea ei prin intermediul funcției <a href="http://linux.die.net/man/3/free" class="urlextern" title="http://linux.die.net/man/3/free"  rel="nofollow">free</a>. Aceste funcții reprezintă apeluri de bibliotecă și rezolvă cererile de alocare și dealocare de memorie, pe cât posibil, în user space.
</p>
<div class="hiddenGlobal  hiddenActive"><div class="hiddenElements"></div><div class="hiddenHead  hiddenSinceBeginning"><div class="hiddenOnHidden">
<p>
Implementarea funcției malloc
</p>
</div><div class="hiddenOnVisible">
<p>
Implementarea funcției malloc
</p>
</div></div> <!-- .hiddenHead --><div class="hiddenBody">
<p>
<br/>

Implementarea funcției <a href="http://linux.die.net/man/3/malloc" class="urlextern" title="http://linux.die.net/man/3/malloc"  rel="nofollow">malloc</a> depinde de sistemul de operare.
</p>

<p>
Există implementări care țin niște tabele care specifică zonele de memorie alocate în heap. Dacă există zone libere pe heap, un apel <a href="http://linux.die.net/man/3/malloc" class="urlextern" title="http://linux.die.net/man/3/malloc"  rel="nofollow">malloc</a> care cere o zonă de memorie care poate fi încadrată într-o zonă liberă din heap va fi satisfăcut imediat, marcând în tabel zona respectivă ca fiind alocată și întorcând programului apelant un pointer spre ea. 
</p>

<p>
Dacă, în schimb, se cere o zonă care nu încape în nici o zonă liberă din heap, <a href="http://linux.die.net/man/3/malloc" class="urlextern" title="http://linux.die.net/man/3/malloc"  rel="nofollow">malloc</a> va încerca extinderea heap-ului prin apelul de sistem <a href="http://linux.die.net/man/2/brk" class="urlextern" title="http://linux.die.net/man/2/brk"  rel="nofollow">brk</a> sau <a href="http://linux.die.net/man/3/mmap" class="urlextern" title="http://linux.die.net/man/3/mmap"  rel="nofollow">mmap</a>.
</p>

<p>
<a href="../../_detail/so/laboratoare-2013/heap_bounds.gif%3Fid=so%253Alaboratoare%253Alaborator-05.html" class="media" title="so:laboratoare-2013:heap_bounds.gif"><img src="../../_media/so/laboratoare-2013/heap_bounds.gif" class="media" alt="" /></a>
</p>

<p>
Există implementări care pentru fiecare zonă de memorie cerută cu <a href="http://linux.die.net/man/3/malloc" class="urlextern" title="http://linux.die.net/man/3/malloc"  rel="nofollow">malloc</a> adaugă un header în care sunt trecute informații utile - dimensiunea unei zone, pointer la următoarea zonă, dacă zonă a fost eliberată sau nu. 
</p>

<p>
<a href="../../_detail/so/laboratoare-2013/heap_chunks.gif%3Fid=so%253Alaboratoare%253Alaborator-05.html" class="media" title="so:laboratoare-2013:heap_chunks.gif"><img src="../../_media/so/laboratoare-2013/heap_chunks.gif" class="media" alt="" /></a>
</p>

<p>
Mai multe detalii despre malloc și modul de organizare al heap-ului <a href="http://academicearth.org/lectures/heap-management" class="urlextern" title="http://academicearth.org/lectures/heap-management"  rel="nofollow">aici</a> și <a href="https://docs.google.com/viewer?url=http://wiki-prog.kh405.net/images/0/04/Malloc_tutorial.pdf" class="urlextern" title="https://docs.google.com/viewer?url=http://wiki-prog.kh405.net/images/0/04/Malloc_tutorial.pdf"  rel="nofollow">aici</a>.
</p>
</div></div>
<p>
<br/>

</p>
<pre class="code c"><span class="kw4">void</span> <span class="sy0">*</span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/malloc.html"><span class="kw3">malloc</span></a><span class="br0">&#40;</span><span class="kw4">size_t</span> size<span class="br0">&#41;</span><span class="sy0">;</span>
<span class="kw4">void</span> <span class="sy0">*</span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/calloc.html"><span class="kw3">calloc</span></a><span class="br0">&#40;</span><span class="kw4">size_t</span> nmemb<span class="sy0">,</span> <span class="kw4">size_t</span> size<span class="br0">&#41;</span><span class="sy0">;</span>
<span class="kw4">void</span> <span class="sy0">*</span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/realloc.html"><span class="kw3">realloc</span></a><span class="br0">&#40;</span><span class="kw4">void</span> <span class="sy0">*</span>ptr<span class="sy0">,</span> <span class="kw4">size_t</span> size<span class="br0">&#41;</span><span class="sy0">;</span>
<span class="kw4">void</span> <a href="http://www.opengroup.org/onlinepubs/009695399/functions/free.html"><span class="kw3">free</span></a><span class="br0">&#40;</span><span class="kw4">void</span> <span class="sy0">*</span>ptr<span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>
Întotdeauna eliberați (<a href="http://linux.die.net/man/3/free" class="urlextern" title="http://linux.die.net/man/3/free"  rel="nofollow">free</a>) memoria alocată. Memoria alocată de proces este eliberată automat la terminarea procesului, însă, de exemplu în cazul unui proces server care rulează foarte mult timp și nu eliberează memoria alocată acesta va ajunge să ocupe toată memoria disponibilă în sistem, având astfel consecințe nefaste.
</p>

<p>
<strong>Atenție!</strong> Nu eliberați de două ori aceeași zonă de memorie întrucât acest lucru va avea drept urmare coruperea tabelelor ținute de <a href="http://linux.die.net/man/3/malloc" class="urlextern" title="http://linux.die.net/man/3/malloc"  rel="nofollow">malloc</a> ceea ce va avea din nou consecințe nefaste. Întrucât funcția <a href="http://linux.die.net/man/3/free" class="urlextern" title="http://linux.die.net/man/3/free"  rel="nofollow">free</a> se întoarce imediat dacă primește ca parametru un  pointer <code>NULL</code>, este recomandat ca după un apel <a href="http://linux.die.net/man/3/free" class="urlextern" title="http://linux.die.net/man/3/free"  rel="nofollow">free</a>, pointer-ul să fie resetat la <code>NULL</code>.
</p>

<p>
În continuare, sunt prezentate câteva exemple de alocare a memoriei folosind <a href="http://linux.die.net/man/3/malloc" class="urlextern" title="http://linux.die.net/man/3/malloc"  rel="nofollow">malloc</a>:
</p>
<pre class="code c"><span class="kw4">int</span> n <span class="sy0">=</span> <a href="http://www.opengroup.org/onlinepubs/009695399/functions/atoi.html"><span class="kw3">atoi</span></a><span class="br0">&#40;</span>argv<span class="br0">&#91;</span><span class="nu0">1</span><span class="br0">&#93;</span><span class="br0">&#41;</span><span class="sy0">;</span>
<span class="kw4">char</span> <span class="sy0">*</span>str<span class="sy0">;</span>
&nbsp;
<span class="coMULTI">/* usually malloc receives the size argument like:
   num_elements * size_of_element */</span>
str <span class="sy0">=</span> <a href="http://www.opengroup.org/onlinepubs/009695399/functions/malloc.html"><span class="kw3">malloc</span></a><span class="br0">&#40;</span><span class="br0">&#40;</span>n <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">&#41;</span> <span class="sy0">*</span> <span class="kw4">sizeof</span><span class="br0">&#40;</span><span class="kw4">char</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy0">;</span>
<span class="kw1">if</span> <span class="br0">&#40;</span>NULL <span class="sy0">==</span> str<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<a href="http://www.opengroup.org/onlinepubs/009695399/functions/perror.html"><span class="kw3">perror</span></a><span class="br0">&#40;</span><span class="st0">&quot;malloc&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
	<a href="http://www.opengroup.org/onlinepubs/009695399/functions/exit.html"><span class="kw3">exit</span></a><span class="br0">&#40;</span>EXIT_FAILURE<span class="br0">&#41;</span><span class="sy0">;</span>
<span class="br0">&#125;</span>
&nbsp;
<span class="br0">&#91;</span>...<span class="br0">&#93;</span>
&nbsp;
<a href="http://www.opengroup.org/onlinepubs/009695399/functions/free.html"><span class="kw3">free</span></a><span class="br0">&#40;</span>str<span class="br0">&#41;</span><span class="sy0">;</span>
str <span class="sy0">=</span> NULL<span class="sy0">;</span></pre>
<pre class="code c"><span class="coMULTI">/* Creating an array of references to the arguments received by a program */</span>
<span class="kw4">char</span> <span class="sy0">**</span>argv_no_exec<span class="sy0">;</span>
&nbsp;
<span class="coMULTI">/* allocate space for the array */</span>
argv_no_exec <span class="sy0">=</span> <a href="http://www.opengroup.org/onlinepubs/009695399/functions/malloc.html"><span class="kw3">malloc</span></a><span class="br0">&#40;</span><span class="br0">&#40;</span>argc <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">&#41;</span> <span class="sy0">*</span> <span class="kw4">sizeof</span><span class="br0">&#40;</span><span class="kw4">char</span><span class="sy0">*</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy0">;</span>
<span class="kw1">if</span> <span class="br0">&#40;</span>NULL <span class="sy0">==</span> argv_no_exec<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<a href="http://www.opengroup.org/onlinepubs/009695399/functions/perror.html"><span class="kw3">perror</span></a><span class="br0">&#40;</span><span class="st0">&quot;malloc&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
	<a href="http://www.opengroup.org/onlinepubs/009695399/functions/exit.html"><span class="kw3">exit</span></a><span class="br0">&#40;</span>EXIT_FAILURE<span class="br0">&#41;</span><span class="sy0">;</span>
<span class="br0">&#125;</span>
&nbsp;
<span class="coMULTI">/* set references to the program arguments */</span>
<span class="kw1">for</span> <span class="br0">&#40;</span>i <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> argc<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">&#41;</span>
	argv_no_exec<span class="br0">&#91;</span>i<span class="sy0">-</span><span class="nu0">1</span><span class="br0">&#93;</span> <span class="sy0">=</span> argv<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="sy0">;</span>
&nbsp;
<span class="br0">&#91;</span>...<span class="br0">&#93;</span>
&nbsp;
<a href="http://www.opengroup.org/onlinepubs/009695399/functions/free.html"><span class="kw3">free</span></a><span class="br0">&#40;</span>argv_no_exec<span class="br0">&#41;</span><span class="sy0">;</span>
argv_no_exec <span class="sy0">=</span> NULL<span class="sy0">;</span></pre>

<p>
Apelul <a href="http://linux.die.net/man/3/realloc" class="urlextern" title="http://linux.die.net/man/3/realloc"  rel="nofollow">realloc</a> este folosit pentru modificarea spațiului de memorie alocat cu un apel <a href="http://linux.die.net/man/3/malloc" class="urlextern" title="http://linux.die.net/man/3/malloc"  rel="nofollow">malloc</a> sau <a href="http://linux.die.net/man/3/calloc" class="urlextern" title="http://linux.die.net/man/3/calloc"  rel="nofollow">calloc</a>:
</p>
<pre class="code c"><span class="kw4">int</span> <span class="sy0">*</span>p<span class="sy0">;</span>
&nbsp;
p <span class="sy0">=</span> <a href="http://www.opengroup.org/onlinepubs/009695399/functions/malloc.html"><span class="kw3">malloc</span></a><span class="br0">&#40;</span>n <span class="sy0">*</span> <span class="kw4">sizeof</span><span class="br0">&#40;</span><span class="kw4">int</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy0">;</span>
<span class="kw1">if</span> <span class="br0">&#40;</span>NULL <span class="sy0">==</span> p<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<a href="http://www.opengroup.org/onlinepubs/009695399/functions/perror.html"><span class="kw3">perror</span></a><span class="br0">&#40;</span><span class="st0">&quot;malloc&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
	<a href="http://www.opengroup.org/onlinepubs/009695399/functions/exit.html"><span class="kw3">exit</span></a><span class="br0">&#40;</span>EXIT_FAILURE<span class="br0">&#41;</span><span class="sy0">;</span>
<span class="br0">&#125;</span>
&nbsp;
<span class="br0">&#91;</span>...<span class="br0">&#93;</span>
&nbsp;
p <span class="sy0">=</span> <a href="http://www.opengroup.org/onlinepubs/009695399/functions/realloc.html"><span class="kw3">realloc</span></a><span class="br0">&#40;</span>p<span class="sy0">,</span> <span class="br0">&#40;</span>n <span class="sy0">+</span> extra<span class="br0">&#41;</span> <span class="sy0">*</span> <span class="kw4">sizeof</span><span class="br0">&#40;</span><span class="kw4">int</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
<span class="br0">&#91;</span>...<span class="br0">&#93;</span>
&nbsp;
<a href="http://www.opengroup.org/onlinepubs/009695399/functions/free.html"><span class="kw3">free</span></a><span class="br0">&#40;</span>p<span class="br0">&#41;</span><span class="sy0">;</span>
p <span class="sy0">=</span> NULL<span class="sy0">;</span></pre>

<p>
Apelul <a href="http://linux.die.net/man/3/calloc" class="urlextern" title="http://linux.die.net/man/3/calloc"  rel="nofollow">calloc</a> este folosit pentru alocarea de zone de memorie al căror conținut este nul (plin de valori de zero). Spre deosebire de <a href="http://linux.die.net/man/3/malloc" class="urlextern" title="http://linux.die.net/man/3/malloc"  rel="nofollow">malloc</a>, apelul va primi două argumente: numărul de elemente și dimensiunea unui element.
</p>
<pre class="code c">list_t <span class="sy0">*</span>list_v<span class="sy0">;</span> <span class="coMULTI">/* list_t could be any C type ( except void ) */</span>
&nbsp;
list_v <span class="sy0">=</span> <a href="http://www.opengroup.org/onlinepubs/009695399/functions/calloc.html"><span class="kw3">calloc</span></a><span class="br0">&#40;</span>n<span class="sy0">,</span> <span class="kw4">sizeof</span><span class="br0">&#40;</span>list_t<span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy0">;</span>
<span class="kw1">if</span> <span class="br0">&#40;</span>NULL <span class="sy0">==</span> list_v<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<a href="http://www.opengroup.org/onlinepubs/009695399/functions/perror.html"><span class="kw3">perror</span></a><span class="br0">&#40;</span><span class="st0">&quot;calloc&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
	<a href="http://www.opengroup.org/onlinepubs/009695399/functions/exit.html"><span class="kw3">exit</span></a><span class="br0">&#40;</span>EXIT_FAILURE<span class="br0">&#41;</span><span class="sy0">;</span>
<span class="br0">&#125;</span>
&nbsp;
<span class="br0">&#91;</span>...<span class="br0">&#93;</span>
&nbsp;
<a href="http://www.opengroup.org/onlinepubs/009695399/functions/free.html"><span class="kw3">free</span></a><span class="br0">&#40;</span>list_v<span class="br0">&#41;</span><span class="sy0">;</span>
list_v <span class="sy0">=</span> NULL<span class="sy0">;</span></pre>

<p>
<strong>Atenție</strong> Conform standardului C, este redundant (și considerat bad practice) să faceți <em>cast</em> la valoarea întoarsă de <a href="http://linux.die.net/man/3/malloc" class="urlextern" title="http://linux.die.net/man/3/malloc"  rel="nofollow">malloc</a>.
</p>
<pre class="code C"><span class="kw4">int</span> <span class="sy0">*</span>p <span class="sy0">=</span> <span class="br0">&#40;</span><span class="kw4">int</span> <span class="sy0">*</span><span class="br0">&#41;</span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/malloc.html"><span class="kw3">malloc</span></a><span class="br0">&#40;</span><span class="nu0">10</span> <span class="sy0">*</span> <span class="kw4">sizeof</span><span class="br0">&#40;</span><span class="kw4">int</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>
malloc întoarce <em>void *</em> care în C este automat convertit la tipul dorit. Mai mult, dacă se face cast, iar headerul <code>stdlib.h</code> necesar pentru funcția malloc nu este inclus, nu se va genera eroare! Pe anumite arhitecturi, acest caz poate conduce la un comportament nedefinit. Spre deosebire de C, în C++ este nevoie de cast. Mai multe detalii despre această problemă:  <a href="http://www.cprogramming.com/faq/cgi-bin/smartfaq.cgi?answer=1047673478&amp;id=1043284351" class="urlextern" title="http://www.cprogramming.com/faq/cgi-bin/smartfaq.cgi?answer=1047673478&amp;id=1043284351"  rel="nofollow"> aici </a>
</p>

<p>
Mai multe informații despre funcțiile de alocare găsiți în <a href="http://www.gnu.org/software/libc/manual/html_node/Unconstrained-Allocation.html#Unconstrained-Allocationl" class="urlextern" title="http://www.gnu.org/software/libc/manual/html_node/Unconstrained-Allocation.html#Unconstrained-Allocationl"  rel="nofollow"> manualul bibliotecii standard C</a> și în pagina de manual <strong>man malloc</strong>.
</p>

</div>

<h3 class="sectionedit12" id="alocarea_memoriei_in_windows">Alocarea memoriei în Windows</h3>
<div class="level3">

<p>
În Windows, un proces poate să-și creeze mai multe obiecte <code>Heap</code> pe lângă <code>Heap</code>-ul implicit al procesulului. Acest lucru este foarte util în momentul în care o aplicație alocă și dealocă foarte multe zone de memorie cu câteva dimensiuni fixe. Aplicația poate să-și creeze câte un <code>Heap</code> pentru fiecare dimensiune și, în cadrul fiecărui <code>Heap</code>, să aloce zone de aceeași dimensiune reducând astfel la maxim fragmentarea heap-ului.
</p>

<p>
Pentru crearea, respectiv distrugerea unui <code>Heap</code> se vor folosi funcțiile <a href="http://msdn.microsoft.com/en-us/library/aa366599%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/aa366599%28VS.85%29.aspx"  rel="nofollow">HeapCreate</a> și <a href="http://msdn.microsoft.com/en-us/library/aa366700%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/aa366700%28VS.85%29.aspx"  rel="nofollow">HeapDestroy</a>:
</p>
<pre class="code c">HANDLE HeapCreate<span class="br0">&#40;</span>
        DWORD flOptions<span class="sy0">,</span>
        SIZE_T dwInitialSize<span class="sy0">,</span>
        SIZE_T dwMaximumSize
<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
BOOL HeapDestroy<span class="br0">&#40;</span>
        HANDLE hHeap
<span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>
Pentru a obține un descriptor al heap-ului implicit al procesului (în cazul în care nu dorim crearea altor heapuri) se va apela funcția <a href="http://msdn2.microsoft.com/en-us/library/aa366569.aspx" class="urlextern" title="http://msdn2.microsoft.com/en-us/library/aa366569.aspx"  rel="nofollow">GetProcessHeap</a>. Pentru a obține descriptorii tuturor heap-urilor procesului se va apela <a href="http://msdn2.microsoft.com/en-us/library/aa366571.aspx" class="urlextern" title="http://msdn2.microsoft.com/en-us/library/aa366571.aspx"  rel="nofollow">GetProcessHeaps</a>.
</p>

<p>
Există, de asemenea, funcții care enumeră toate blocurile alocate într-un heap, validează unul sau toate blocurile alocate într-un heap sau întorc dimensiunea unui bloc pe baza descriptorului de heap și a adresei blocului: <a href="http://msdn.microsoft.com/en-us/library/aa366710%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/aa366710%28VS.85%29.aspx"  rel="nofollow">HeapWalk</a>, <a href="http://msdn.microsoft.com/en-us/library/aa366708%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/aa366708%28VS.85%29.aspx"  rel="nofollow">HeapValidate</a>, <a href="http://msdn.microsoft.com/en-us/library/aa366706%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/aa366706%28VS.85%29.aspx"  rel="nofollow">HeapSize</a>.
</p>

<p>
Pentru alocarea, dealocarea, redimensionarea unui bloc de memorie din <code>Heap</code>, Windows pune la dispoziția programatorului funcțiile <a href="http://msdn.microsoft.com/en-us/library/aa366597%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/aa366597%28VS.85%29.aspx"  rel="nofollow">HeapAlloc</a>, <a href="http://msdn.microsoft.com/en-us/library/aa366701%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/aa366701%28VS.85%29.aspx"  rel="nofollow">HeapFree</a>, respectiv <a href="http://msdn.microsoft.com/en-us/library/aa366704%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/aa366704%28VS.85%29.aspx"  rel="nofollow">HeapReAlloc</a>, cu signaturile de mai jos:
</p>
<pre class="code c">LPVOID HeapAlloc<span class="br0">&#40;</span>
        HANDLE hHeap<span class="sy0">,</span>
        DWORD dwFlags<span class="sy0">,</span>
        SIZE_T dwBytes
<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
BOOL HeapFree<span class="br0">&#40;</span>
        HANDLE hHeap<span class="sy0">,</span>
        DWORD dwFlags<span class="sy0">,</span>
        LPVOID lpMem
<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
LPVOID HeapReAlloc<span class="br0">&#40;</span>
        HANDLE hHeap<span class="sy0">,</span>
        DWORD dwFlags<span class="sy0">,</span>
        LPVOID lpMem<span class="sy0">,</span>
        SIZE_T dwBytes
<span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>
În continuare, este prezentat un exemplu de folosire al acestor funcții:
</p>
<pre class="code c"><span class="co2">#include &lt;windows.h&gt;</span>
<span class="co2">#include &quot;utils.h&quot;</span>
&nbsp;
<span class="coMULTI">/* Example of matrix allocation */</span>
&nbsp;
<span class="kw4">int</span> main<span class="br0">&#40;</span><span class="kw4">void</span><span class="br0">&#41;</span>
<span class="br0">&#123;</span>		 
	HANDLE processHeap<span class="sy0">;</span>
	DWORD <span class="sy0">**</span>mat<span class="sy0">;</span>
	DWORD i<span class="sy0">,</span> j<span class="sy0">,</span> m <span class="sy0">=</span> <span class="nu0">10</span><span class="sy0">,</span> n <span class="sy0">=</span> <span class="nu0">10</span><span class="sy0">;</span>
&nbsp;
	processHeap <span class="sy0">=</span> GetProcessHeap<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
	DIE <span class="br0">&#40;</span>processHeap <span class="sy0">==</span> NULL<span class="sy0">,</span> <span class="st0">&quot;GetProcessHeap&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
	mat <span class="sy0">=</span> HeapAlloc<span class="br0">&#40;</span>processHeap<span class="sy0">,</span> <span class="nu0">0</span><span class="sy0">,</span> m <span class="sy0">*</span> <span class="kw4">sizeof</span><span class="br0">&#40;</span><span class="sy0">*</span>mat<span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy0">;</span>
	DIE <span class="br0">&#40;</span>mat <span class="sy0">==</span> NULL<span class="sy0">,</span> <span class="st0">&quot;HeapAlloc&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
	<span class="kw1">for</span> <span class="br0">&#40;</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> n<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
		mat<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy0">=</span> HeapAlloc<span class="br0">&#40;</span>processHeap<span class="sy0">,</span> <span class="nu0">0</span><span class="sy0">,</span> n <span class="sy0">*</span> <span class="kw4">sizeof</span><span class="br0">&#40;</span><span class="sy0">**</span>mat<span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy0">;</span>
		<span class="kw1">if</span> <span class="br0">&#40;</span>mat<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy0">==</span> NULL<span class="br0">&#41;</span> <span class="br0">&#123;</span>
			PrintLastError<span class="br0">&#40;</span><span class="st0">&quot;HeapAlloc failed&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
			<span class="kw1">goto</span> freeMem<span class="sy0">;</span> <span class="coMULTI">/* free previously allocated memory */</span>
		<span class="br0">&#125;</span>
	<span class="br0">&#125;</span>
&nbsp;
	<span class="coMULTI">/* do work */</span>
&nbsp;
freeMem<span class="sy0">:</span>
	<span class="kw1">for</span> <span class="br0">&#40;</span>j <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> j <span class="sy0">&lt;</span> i<span class="sy0">;</span> j<span class="sy0">++</span><span class="br0">&#41;</span>
		HeapFree<span class="br0">&#40;</span>processHeap<span class="sy0">,</span> <span class="nu0">0</span><span class="sy0">,</span> mat<span class="br0">&#91;</span>j<span class="br0">&#93;</span><span class="br0">&#41;</span><span class="sy0">;</span>
	HeapFree<span class="br0">&#40;</span>processHeap<span class="sy0">,</span> <span class="nu0">0</span><span class="sy0">,</span> mat<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
	<span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">&#125;</span></pre>

<p>
Pe sistemele Windows se pot folosi și funcțiile bibliotecii standard C pentru gestiunea memoriei: <a href="http://linux.die.net/man/3/malloc" class="urlextern" title="http://linux.die.net/man/3/malloc"  rel="nofollow">malloc</a>, <a href="http://linux.die.net/man/3/realloc" class="urlextern" title="http://linux.die.net/man/3/realloc"  rel="nofollow">realloc</a>, <a href="http://linux.die.net/man/3/calloc" class="urlextern" title="http://linux.die.net/man/3/calloc"  rel="nofollow">calloc</a>, <a href="http://linux.die.net/man/3/free" class="urlextern" title="http://linux.die.net/man/3/free"  rel="nofollow">free</a>, dar apelurile de sistem specifice Windows oferă funcționalități suplimentare și nu implică legarea bibliotecii standard C în executabil.
</p>

</div>

<h2 class="sectionedit13" id="lucru_cu_memoria_-_probleme">Lucru cu memoria - Probleme</h2>
<div class="level2">

<p>
Lucrul cu heap-ul este una dintre cauzele principale ale aparițiilor problemelor de programare. Lucrul cu pointerii, necesitatea folosirii unor apeluri de sistem/bibliotecă pentru alocare/dealocare, pot conduce la o serie de probleme care afectează (de multe ori fatal) funcționarea unui program.
</p>

<p>
Problemele cele mai des întâlnite în lucrul cu memoria sunt:
</p>
<ul>
<li class="level1"><div class="li"> accesul nevalid la memorie - ce prespune accesarea unor zone care nu au fost alocate sau au fost eliberate. </div>
</li>
<li class="level1"><div class="li"> leak-urile de memorie      - situațiile în care se pierde referința la o zonă alocată anterior. Acea zonă va rămâne ocupată până la încheierea procesului. </div>
</li>
</ul>

<p>
Ambele probleme și utilitarele care pot fi folosite pentru combaterea acestora vor fi prezentate în continuare.
</p>

</div>

<h3 class="sectionedit14" id="acces_nevalid">Acces nevalid</h3>
<div class="level3">

<p>
De obicei, accesarea unei zone de memorie nevalide rezultă într-o eroare de pagină (page fault) și terminarea procesului (în Unix înseamnă trimiterea semnalului SIGSEGV → afișarea mesajului &#039;Segmentation fault&#039;). Totuși, dacă eroarea apare la o adresă nevalidă, dar într-o pagină validă, hardware-ul și sistemul de operare nu vor putea sesiza acțiunea ca fiind nevalidă. Acest lucru este din cauza faptului că alocarea memoriei se face la nivel de pagină. Spre exemplu, pot exista situații în care să fie folosită doar jumătate din pagină. Deși cealaltă jumătate conține adrese nevalide, sistemul de operare nu va putea detecta accesele nevalide la acea zonă. Mai multe detalii în laboratorul de <a href="../laboratoare-2013/laborator-07.html" class="wikilink1" title="so:laboratoare-2013:laborator-07">Memorie virtuală</a>
</p>

<p>
Asemenea accese pot duce la coruperea heap-ului și la pierderea consistenței memoriei alocate. După cum se va vedea în continuare, există utilitare care ajută la detectarea acestor situații.
</p>

<p>
Un tip special de acces nevalid este <a href="http://en.wikipedia.org/wiki/Buffer_overflow" class="urlextern" title="http://en.wikipedia.org/wiki/Buffer_overflow"  rel="nofollow">buffer overflow</a>. Acest tip de atac presupune referirea unor regiuni valide din spațiul de adresă al unui proces prin intermediul unei variabile care nu ar trebui să poată referenția aceste adrese. De obicei, un atac de tip buffer overflow rezultă în rularea de cod nesigur. Protejarea împotriva atacurilor de tip buffer overflow se realizează prin verificarea limitelor unui buffer/vector fie la compilare, fie la rulare.
</p>

</div>

<h4 id="gdb_-_detectarea_zonei_de_acces_nevalid_de_tip_page_fault">GDB - Detectarea zonei de acces nevalid de tip page fault</h4>
<div class="level4">

<p>
O comandă foarte utilă atunci când se depanează programe complexe este <strong><code>backtrace</code></strong>. Această comandă afișează toate apelurile de funcții în curs de execuție.
</p>
<dl class="code">
<dt><a href="../../_export/code/so/laboratoare/laborator-05%3Fcodeblock=13" title="Download Snippet" class="mediafile mf_">1</a></dt>
<dd><pre class="code c"><span class="co2">#include &lt;stdio.h&gt;</span>
<span class="co2">#include &lt;stdlib.h&gt;</span>
&nbsp;
<span class="kw4">static</span> <span class="kw4">int</span> fibonacci<span class="br0">&#40;</span><span class="kw4">int</span> no<span class="br0">&#41;</span>
<span class="br0">&#123;</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span><span class="nu0">1</span> <span class="sy0">==</span> no <span class="sy0">||</span> <span class="nu0">2</span> <span class="sy0">==</span> no<span class="br0">&#41;</span>
		<span class="kw1">return</span> <span class="nu0">1</span><span class="sy0">;</span>
	<span class="kw1">return</span> fibonacci<span class="br0">&#40;</span>no<span class="sy0">-</span><span class="nu0">1</span><span class="br0">&#41;</span> <span class="sy0">+</span> fibonacci<span class="br0">&#40;</span>no<span class="sy0">-</span><span class="nu0">2</span><span class="br0">&#41;</span><span class="sy0">;</span>
<span class="br0">&#125;</span>
&nbsp;
<span class="kw4">int</span> main<span class="br0">&#40;</span><span class="kw4">void</span><span class="br0">&#41;</span>
<span class="br0">&#123;</span>
	<span class="kw4">short</span> <span class="kw4">int</span> numar<span class="sy0">,</span> baza<span class="sy0">=</span><span class="nu0">10</span><span class="sy0">;</span>
	<span class="kw4">char</span> sir<span class="br0">&#91;</span><span class="nu0">1</span><span class="br0">&#93;</span><span class="sy0">;</span>
&nbsp;
	<a href="http://www.opengroup.org/onlinepubs/009695399/functions/scanf.html"><span class="kw3">scanf</span></a><span class="br0">&#40;</span><span class="st0">&quot;%s&quot;</span><span class="sy0">,</span> sir<span class="br0">&#41;</span><span class="sy0">;</span>
	numar<span class="sy0">=</span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/strtol.html"><span class="kw3">strtol</span></a><span class="br0">&#40;</span>sir<span class="sy0">,</span> NULL<span class="sy0">,</span> baza<span class="br0">&#41;</span><span class="sy0">;</span>
	<a href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span class="kw3">printf</span></a><span class="br0">&#40;</span><span class="st0">&quot;fibonacci(%d)=%d<span class="es1">\n</span>&quot;</span><span class="sy0">,</span> numar<span class="sy0">,</span> fibonacci<span class="br0">&#40;</span>numar<span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy0">;</span>
	<span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">&#125;</span></pre>
</dd></dl>

<p>
Pe exemplul de mai sus, vom demonstra utilitatea comenzii <code>backtrace</code>:
</p>
<pre class="code bash"> so<span class="sy0">@</span>spook$ <span class="kw2">gcc</span> <span class="re5">-Wall</span> exemplul-<span class="nu0">7</span>.c <span class="re5">-g</span>
 so<span class="sy0">@</span>spook$ <span class="kw2">gdb</span> a.out
 <span class="br0">&#40;</span><span class="kw2">gdb</span><span class="br0">&#41;</span> <span class="kw3">break</span> <span class="nu0">8</span>
 Breakpoint <span class="nu0">1</span> at 0x8048482: <span class="kw2">file</span> exemplul-<span class="nu0">7</span>.c, line <span class="nu0">8</span>.
 <span class="br0">&#40;</span><span class="kw2">gdb</span><span class="br0">&#41;</span> run
 Starting program: <span class="sy0">/</span>home<span class="sy0">/</span>tavi<span class="sy0">/</span>cursuri<span class="sy0">/</span>so<span class="sy0">/</span>lab<span class="sy0">/</span>draft<span class="sy0">/</span>intro<span class="sy0">/</span>a.out
 <span class="nu0">7</span>
&nbsp;
 Breakpoint <span class="nu0">1</span>, fibonacci <span class="br0">&#40;</span><span class="re2">no</span>=<span class="nu0">2</span><span class="br0">&#41;</span> at exemplul-<span class="nu0">7</span>.c:<span class="nu0">8</span>
 <span class="nu0">8</span>                       <span class="kw3">return</span> <span class="nu0">1</span>;
 <span class="br0">&#40;</span><span class="kw2">gdb</span><span class="br0">&#41;</span> bt
 <span class="co0">#0  fibonacci (no=2) at exemplul-7.c:8</span>
 <span class="co0">#1  0x0804849d in fibonacci (no=3) at exemplul-7.c:9</span>
 <span class="co0">#2  0x0804849d in fibonacci (no=4) at exemplul-7.c:9</span>
 <span class="co0">#3  0x0804849d in fibonacci (no=5) at exemplul-7.c:9</span>
 <span class="co0">#4  0x0804849d in fibonacci (no=6) at exemplul-7.c:9</span>
 <span class="co0">#5  0x0804849d in fibonacci (no=7) at exemplul-7.c:9</span>
 <span class="co0">#6  0x0804851c in main () at exemplul-7.c:20</span>
 <span class="co0">#7  0x4003d280 in __libc_start_main () from /lib/libc.so.6</span>
 <span class="br0">&#40;</span><span class="kw2">gdb</span><span class="br0">&#41;</span> </pre>

<p>
Se observă că la afișarea apelurilor de funcții se listează și parametrii cu care a fost apelată funcția. Acest lucru este posibil datorită faptului că atât variabilele locale, cât și parametrii acesteia sunt păstrați pe stivă până la ieșirea din funcție. (pentru detalii, revedeți secțiunea despre <a href="laborator-05.html#stiva" title="so:laboratoare:laborator-05 ↵" class="wikilink1">stivă</a>)
</p>

<p>
Fiecare funcție are alocată pe stivă un frame, în care sunt plasate variabilele locale funcției, parametrii funcției și adresa de revenire din funcție. În momentul în care o funcție este apelată, se creează un nou frame prin alocarea de spațiu pe stivă de către funcția apelată. Astfel, dacă avem apeluri de funcții imbricate, atunci stiva va conține toate frame-urile tuturor funcțiilor apelate imbricat.
</p>

<p>
GDB dă posibilitatea utilizatorului să examineze frame-urile prezente în stivă. Astfel, utilizatorul poate alege oricare din frame-urile prezente folosind comanda <code>frame</code>. După cum s-a observat, exemplul anterior are un bug ce se manifestă atunci când numărul introdus de la tastatură depășește dimensiunea buffer-ului alocat (static). Acest tip de eroare poartă denumirea de <em><em class="u">buffer overflow</em></em> și este extrem de gravă. Cele mai multe atacuri de la distanță pe un sistem sunt cauzate de acest tip de erori. Din păcate, acest tip de eroare nu este ușor de detectat, pentru că în procesul de buffer overrun se pot suprascrie alte variabile, ceea ce duce la detectarea erorii nu imediat când s-a făcut suprascrierea, ci mai târziu, când se va folosi variabila afectatã.
</p>
<pre class="code bash"> so<span class="sy0">@</span>spook$ <span class="kw2">gdb</span> a.out
 <span class="br0">&#40;</span><span class="kw2">gdb</span><span class="br0">&#41;</span> run
 Starting program: <span class="sy0">/</span>home<span class="sy0">/</span>tavi<span class="sy0">/</span>cursuri<span class="sy0">/</span>so<span class="sy0">/</span>lab<span class="sy0">/</span>draft<span class="sy0">/</span>intro<span class="sy0">/</span>a.out
 <span class="nu0">10</span>
&nbsp;
 Program received signal SIGSEGV, Segmentation fault.
 0x08048497 <span class="kw1">in</span> fibonacci <span class="br0">&#40;</span><span class="re2">no</span>=-<span class="nu0">299522</span><span class="br0">&#41;</span> at exemplul-<span class="nu0">7</span>.c:<span class="nu0">9</span>
 <span class="nu0">9</span>               <span class="kw3">return</span> fibonacci<span class="br0">&#40;</span>no-<span class="nu0">1</span><span class="br0">&#41;</span> + fibonacci<span class="br0">&#40;</span>no-<span class="nu0">2</span><span class="br0">&#41;</span>;
 <span class="br0">&#40;</span><span class="kw2">gdb</span><span class="br0">&#41;</span> bt <span class="re5">-5</span>
&nbsp;
 <span class="co0">#299520 0x0804849d in fibonacci (no=-2) at exemplul-7.c:9</span>
 <span class="co0">#299521 0x0804849d in fibonacci (no=-1) at exemplul-7.c:9</span>
 <span class="co0">#299522 0x0804849d in fibonacci (no=0) at exemplul-7.c:9</span>
 <span class="co0">#299523 0x0804851c in main () at exemplul-7.c:20</span>
 <span class="co0">#299524 0x4003e280 in __libc_start_main () from /lib/libc.so.6</span></pre>

<p>
Din analiza de mai sus se observă că funcția fibonacci a fost apelată cu valoarea 0. Cum funcția nu testează ca parametrul să fie valid, se va apela recursiv de un număr suficient de ori pentru a cauza umplerea stivei programului. Se pune problema cum s-a apelat funcția cu valoarea 0, când trebuia apelată cu valoarea 10.
</p>
<pre class="code bash"> so<span class="sy0">@</span>spook$ <span class="kw2">gdb</span> a.out
 <span class="br0">&#40;</span><span class="kw2">gdb</span><span class="br0">&#41;</span> run
 Starting program: <span class="sy0">/</span>home<span class="sy0">/</span>tavi<span class="sy0">/</span>cursuri<span class="sy0">/</span>so<span class="sy0">/</span>lab<span class="sy0">/</span>draft<span class="sy0">/</span>intro<span class="sy0">/</span>a.out
 <span class="nu0">10</span>
&nbsp;
 Program received signal SIGSEGV, Segmentation fault.
 0x08048497 <span class="kw1">in</span> fibonacci <span class="br0">&#40;</span><span class="re2">no</span>=-<span class="nu0">299515</span><span class="br0">&#41;</span> at exemplul-<span class="nu0">7</span>.c:<span class="nu0">9</span>
 <span class="nu0">9</span>               <span class="kw3">return</span> fibonacci<span class="br0">&#40;</span>no-<span class="nu0">1</span><span class="br0">&#41;</span> + fibonacci<span class="br0">&#40;</span>no-<span class="nu0">2</span><span class="br0">&#41;</span>;
 <span class="br0">&#40;</span><span class="kw2">gdb</span><span class="br0">&#41;</span> bt <span class="re5">-2</span>
 <span class="co0">#299516 0x0804851c in main () at exemplul-7.c:20</span>
 <span class="co0">#299517 0x4003d280 in __libc_start_main () from /lib/libc.so.6</span>
 <span class="br0">&#40;</span><span class="kw2">gdb</span><span class="br0">&#41;</span> fr <span class="nu0">299516</span>
 <span class="co0">#299516 0x0804851c in main () at exemplul-7.c:20</span>
 <span class="nu0">20</span>              <span class="kw3">printf</span><span class="br0">&#40;</span><span class="st0">&quot;fibonacci(%d)=%d<span class="es1">\n</span>&quot;</span>, numar, fibonacci<span class="br0">&#40;</span>numar<span class="br0">&#41;</span><span class="br0">&#41;</span>;
 <span class="br0">&#40;</span><span class="kw2">gdb</span><span class="br0">&#41;</span> print numar
 <span class="re4">$1</span> = <span class="nu0">0</span>
 <span class="br0">&#40;</span><span class="kw2">gdb</span><span class="br0">&#41;</span> print baza
 <span class="re4">$2</span> = <span class="nu0">48</span>
 <span class="br0">&#40;</span><span class="kw2">gdb</span><span class="br0">&#41;</span> </pre>

<p>
Se observă că problema este cauzată de faptul că variabila baza a fost alterată. Pentru a determina când s-a întâmplat acest lucru, se poate folosi comanda <code>watch</code>. Această comandă primește ca parametru o expresie și va opri execuția programului de fiecare dată când valoarea expresiei se schimbă.
</p>
<pre class="code bash"> <span class="br0">&#40;</span><span class="kw2">gdb</span><span class="br0">&#41;</span> quit
 so<span class="sy0">@</span>spook$ <span class="kw2">gdb</span> a.out
 <span class="br0">&#40;</span><span class="kw2">gdb</span><span class="br0">&#41;</span> <span class="kw3">break</span> main
 Breakpoint <span class="nu0">1</span> at 0x80484d6: <span class="kw2">file</span> exemplul-<span class="nu0">7</span>.c, line <span class="nu0">15</span>.
 <span class="br0">&#40;</span><span class="kw2">gdb</span><span class="br0">&#41;</span> run
 Starting program: <span class="sy0">/</span>home<span class="sy0">/</span>tavi<span class="sy0">/</span>cursuri<span class="sy0">/</span>so<span class="sy0">/</span>lab<span class="sy0">/</span>draft<span class="sy0">/</span>intro<span class="sy0">/</span>a.out
&nbsp;
 Breakpoint <span class="nu0">1</span>, main <span class="br0">&#40;</span><span class="br0">&#41;</span> at exemplul-<span class="nu0">7</span>.c:<span class="nu0">15</span>
 <span class="nu0">15</span>              short int numar, <span class="re2">baza</span>=<span class="nu0">10</span>;
 <span class="br0">&#40;</span><span class="kw2">gdb</span><span class="br0">&#41;</span> n
 <span class="nu0">18</span>              scanf<span class="br0">&#40;</span><span class="st0">&quot;%s&quot;</span>, sir<span class="br0">&#41;</span>;
 <span class="br0">&#40;</span><span class="kw2">gdb</span><span class="br0">&#41;</span> <span class="kw2">watch</span> baza
 Hardware watchpoint <span class="nu0">2</span>: baza
 <span class="br0">&#40;</span><span class="kw2">gdb</span><span class="br0">&#41;</span> <span class="kw3">continue</span>
 Continuing.
 <span class="nu0">10</span>
 Hardware watchpoint <span class="nu0">2</span>: baza
&nbsp;
 Old value = <span class="nu0">10</span>
 New value = <span class="nu0">48</span>
 0x40086b41 <span class="kw1">in</span> _IO_vfscanf <span class="br0">&#40;</span><span class="br0">&#41;</span> from <span class="sy0">/</span>lib<span class="sy0">/</span>libc.so.6
 <span class="br0">&#40;</span><span class="kw2">gdb</span><span class="br0">&#41;</span> bt
 <span class="co0">#0  0x40086b41 in _IO_vfscanf () from /lib/libc.so.6</span>
 <span class="co0">#1  0x40087259 in scanf () from /lib/libc.so.6</span>
 <span class="co0">#2  0x080484ed in main () at exemplul-7.c:18</span>
 <span class="co0">#3  0x4003d280 in __libc_start_main () from /lib/libc.so.6</span>
 <span class="br0">&#40;</span><span class="kw2">gdb</span><span class="br0">&#41;</span> </pre>

<p>
Din analiza de mai sus se observă că valoarea variabilei este modificată în funcția <code>_IO_vfscanf</code>, care la rândul ei este apelată de către functia <code>scanf</code>. Dacă se analizează apoi parametrii pasați functiei <code>scanf</code>, se observă imediat cauza erorii.
</p>

<p>
Pentru mai multe informații despre GDB consultați <a href="http://sourceware.org/gdb/download/onlinedocs/" class="urlextern" title="http://sourceware.org/gdb/download/onlinedocs/"  rel="nofollow">documentația online</a> (alternativ pagina info - <code>info gdb</code>) sau folosiți comanda <code>help</code> din cadrul GDB.
</p>

</div>

<h4 id="mcheck_-_verificarea_consistentei_heap-ului">mcheck - verificarea consistenței heap-ului</h4>
<div class="level4">

<p>
glibc permite verificarea consistenței heap-ului prin intermediul apelului <a href="http://www.gnu.org/software/libc/manual/html_node/Heap-Consistency-Checking.html#Heap-Consistency-Checking" class="urlextern" title="http://www.gnu.org/software/libc/manual/html_node/Heap-Consistency-Checking.html#Heap-Consistency-Checking"  rel="nofollow">mcheck</a> definit în <code>mcheck.h</code>. Apelul <a href="http://www.gnu.org/software/libc/manual/html_node/Heap-Consistency-Checking.html#Heap-Consistency-Checking" class="urlextern" title="http://www.gnu.org/software/libc/manual/html_node/Heap-Consistency-Checking.html#Heap-Consistency-Checking"  rel="nofollow">mcheck</a> forțează <code>malloc</code> să execute diverse verificări de consistență precum scrierea peste un bloc alocat cu <code>malloc</code>.
</p>

<p>
Alternativ, se poate folosi opțiunea <code>-lmcheck</code> la legarea programului fără a afecta sursa acestuia.
</p>

<p>
Varianta cea mai simplă este folosirea variabilei de mediu <code>MALLOC_CHECK_</code>. Dacă un program va fi lansat în execuție cu variabila <code>MALLOC_CHECK_</code> configurată, atunci vor fi afișate mesaje de eroare (eventual programul va fi terminat forțat - aborted).
</p>

<p>
În continuare, este prezentat un exemplu de cod cu probleme în alocarea și folosirea heap-ului:
</p>
<dl class="code">
<dt><a href="../../_export/code/so/laboratoare/laborator-05%3Fcodeblock=18" title="Download Snippet" class="mediafile mf_c">mcheck_test.c</a></dt>
<dd><pre class="code c"><span class="co2">#include &lt;stdio.h&gt;</span>
<span class="co2">#include &lt;stdlib.h&gt;</span>
<span class="co2">#include &lt;string.h&gt;</span>
&nbsp;
<span class="kw4">int</span> main<span class="br0">&#40;</span><span class="kw4">void</span><span class="br0">&#41;</span>
<span class="br0">&#123;</span>
	<span class="kw4">int</span> <span class="sy0">*</span>v1<span class="sy0">;</span>
&nbsp;
	v1 <span class="sy0">=</span> <a href="http://www.opengroup.org/onlinepubs/009695399/functions/malloc.html"><span class="kw3">malloc</span></a><span class="br0">&#40;</span><span class="nu0">5</span> <span class="sy0">*</span> <span class="kw4">sizeof</span><span class="br0">&#40;</span><span class="sy0">*</span>v1<span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy0">;</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span>NULL <span class="sy0">==</span> v1<span class="br0">&#41;</span> <span class="br0">&#123;</span>
		<a href="http://www.opengroup.org/onlinepubs/009695399/functions/perror.html"><span class="kw3">perror</span></a><span class="br0">&#40;</span><span class="st0">&quot;malloc&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
		<a href="http://www.opengroup.org/onlinepubs/009695399/functions/exit.html"><span class="kw3">exit</span></a> <span class="br0">&#40;</span>EXIT_FAILURE<span class="br0">&#41;</span><span class="sy0">;</span>
	<span class="br0">&#125;</span>
&nbsp;
	<span class="coMULTI">/* overflow */</span>
	v1<span class="br0">&#91;</span><span class="nu0">6</span><span class="br0">&#93;</span> <span class="sy0">=</span> <span class="nu0">100</span><span class="sy0">;</span>
&nbsp;
	<a href="http://www.opengroup.org/onlinepubs/009695399/functions/free.html"><span class="kw3">free</span></a><span class="br0">&#40;</span>v1<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
	<span class="coMULTI">/* write after free */</span>
	v1<span class="br0">&#91;</span><span class="nu0">6</span><span class="br0">&#93;</span> <span class="sy0">=</span> <span class="nu0">100</span><span class="sy0">;</span>
&nbsp;
	<span class="coMULTI">/* reallocate v1 */</span>
	v1 <span class="sy0">=</span> <a href="http://www.opengroup.org/onlinepubs/009695399/functions/malloc.html"><span class="kw3">malloc</span></a><span class="br0">&#40;</span><span class="nu0">10</span> <span class="sy0">*</span> <span class="kw4">sizeof</span><span class="br0">&#40;</span><span class="kw4">int</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy0">;</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span>NULL <span class="sy0">==</span> v1<span class="br0">&#41;</span> <span class="br0">&#123;</span>
		<a href="http://www.opengroup.org/onlinepubs/009695399/functions/perror.html"><span class="kw3">perror</span></a><span class="br0">&#40;</span><span class="st0">&quot;malloc&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
		<a href="http://www.opengroup.org/onlinepubs/009695399/functions/exit.html"><span class="kw3">exit</span></a> <span class="br0">&#40;</span>EXIT_FAILURE<span class="br0">&#41;</span><span class="sy0">;</span>
	<span class="br0">&#125;</span>
&nbsp;
	<span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">&#125;</span></pre>
</dd></dl>

<p>
Mai jos se poate vedea cum programul este compilat și rulat. Mai întâi este rulat fără opțiuni de mcheck, după care se definește variabila de mediu MALLOC_CHECK_ la rularea programului. Se observă că deși se depășește spațiul alocat pentru vectorul <code>v1</code> și se referă vectorul <strong>după</strong> eliberarea spațiului, o rulare simplă nu rezultă în afișarea nici unei erori.
</p>

<p>
Totuși, dacă definim variabila de mediu <code>MALLOC_CHECK_</code>, se detectează cele două erori. De observat că o eroare este detectată doar în momentul unui nou apel de memorie interceptat de mcheck.
</p>
<pre class="code bash"> so<span class="sy0">@</span>spook$ <span class="kw2">make</span>
 <span class="kw2">cc</span> <span class="re5">-Wall</span> <span class="re5">-g</span>    mcheck_test.c   <span class="re5">-o</span> mcheck_test
 so<span class="sy0">@</span>spook$ .<span class="sy0">/</span>mcheck_test  
 so<span class="sy0">@</span>spook$ <span class="re2">MALLOC_CHECK_</span>=<span class="nu0">1</span> .<span class="sy0">/</span>mcheck_test
 malloc: using debugging hooks
  <span class="sy0">***</span> glibc detected <span class="sy0">***</span> .<span class="sy0">/</span>mcheck_test: <span class="kw2">free</span><span class="br0">&#40;</span><span class="br0">&#41;</span>: invalid pointer: 0x0000000000601010 <span class="sy0">***</span>
  <span class="sy0">***</span> glibc detected <span class="sy0">***</span> .<span class="sy0">/</span>mcheck_test: malloc: top chunk is corrupt: 0x0000000000601020 <span class="sy0">***</span></pre>

<p>
mcheck nu este o soluție completă și nu detectează toate erorile ce pot apărea în lucrul cu memoria. Detectează, totuși, un număr important de erori și reprezintă o facilitate importantă a glibc.
</p>

<p>
O descriere completă găsiți în <a href="http://www.gnu.org/software/libc/manual/html_node/Heap-Consistency-Checking.html#Heap-Consistency-Checking" class="urlextern" title="http://www.gnu.org/software/libc/manual/html_node/Heap-Consistency-Checking.html#Heap-Consistency-Checking"  rel="nofollow">pagina asociată</a> din <a href="http://www.gnu.org/software/libc/manual" class="urlextern" title="http://www.gnu.org/software/libc/manual"  rel="nofollow">manualul glibc</a>.
</p>

</div>

<h3 class="sectionedit15" id="leak-uri_de_memorie">Leak-uri de memorie</h3>
<div class="level3">

<p>
Un <a href="http://en.wikipedia.org/wiki/Memory_leak" class="urlextern" title="http://en.wikipedia.org/wiki/Memory_leak"  rel="nofollow">leak de memorie</a> apare în două situații:
</p>
<ul>
<li class="level1"><div class="li">un program omite să elibereze o zonă de memorie</div>
</li>
<li class="level1"><div class="li">un program pierde referința la o zonă de memorie alocată și, drept consecință, nu o poate elibera</div>
</li>
</ul>

<p>
Memory leak-urile au ca efect reducerea cantității de memorie existentă în sistem. Se poate ajunge, în situații extreme, la consumarea întregii memorii a sistemului și la imposibilitatea de funcționare a diverselor aplicații ale acestuia.
</p>

<p>
Ca și în cazul problemei accesului nevalid la memorie, <a href="laborator-05.html#valgrind" title="so:laboratoare:laborator-05 ↵" class="wikilink1">utilitarul Valgrind</a> este foarte util în detectarea leak-urilor de memorie ale unui program.
</p>

</div>

<h4 id="valgrind">Valgrind</h4>
<div class="level4">

<p>
Valgrind reprezintă o suită de utilitare folosite pentru operații de debugging și profiling. Cel mai popular este <a href="http://valgrind.org/docs/manual/mc-manual.html" class="urlextern" title="http://valgrind.org/docs/manual/mc-manual.html"  rel="nofollow">Memcheck</a>, un utilitar care permite detectarea de erori de lucru cu memoria (accese nevalide, memory leak-uri etc.). Alte utilitare din suita Valgrind sunt <code>Cachegrind</code>, <code>Callgrind</code> utile pentru profiling sau <code>Helgrind</code>, util pentru depanarea programelor multithreaded.
</p>

<p>
În continuare, ne vom referi doar la utilitarul <a href="http://valgrind.org/docs/manual/mc-manual.html" class="urlextern" title="http://valgrind.org/docs/manual/mc-manual.html"  rel="nofollow">Memcheck</a> de detectare a erorilor de lucru cu memoria. Mai precis, acest utilitar detectează următoarele tipuri de erori:
</p>
<ul>
<li class="level1"><div class="li">folosirea de memorie neinițializată</div>
</li>
<li class="level1"><div class="li">citirea/scrierea din/în memorie după ce regiunea respectivă a fost eliberată</div>
</li>
<li class="level1"><div class="li">citirea/scrierea dincolo de sfârșitul zonei alocate</div>
</li>
<li class="level1"><div class="li">citirea/scrierea pe stivă în zone necorespunzătoare</div>
</li>
<li class="level1"><div class="li">memory leak-uri</div>
</li>
<li class="level1"><div class="li">folosirea necorespunzătore de apeluri malloc/new și free/delete</div>
</li>
</ul>

<p>
Valgrind nu necesită adaptarea codului unui program, ci folosește direct executabilul (binarul) asociat unui program. La o rulare obișnuită Valgrind va primi argumentul <code>--tool</code> pentru a preciza utilitarul folosit și programul care va fi verificat de erori de lucru cu memoria.
</p>

<p>
În exemplul de rulare, de mai jos, se folosește programul prezentat la <a href="laborator-05.html#mcheck_-_verificarea_consistentei_heap-ului" title="so:laboratoare:laborator-05 ↵" class="wikilink1">secțiunea &#039;&#039;mcheck&#039;&#039;</a>:
</p>
<pre class="code bash"> so<span class="sy0">@</span>spook$ <span class="kw2">valgrind</span> <span class="re5">--tool</span>=memcheck .<span class="sy0">/</span>mcheck_test
 ==<span class="nu0">17870</span>== Memcheck, a memory error detector.
 ==<span class="nu0">17870</span>== Copyright <span class="br0">&#40;</span>C<span class="br0">&#41;</span> <span class="nu0">2002</span>-<span class="nu0">2007</span>, and GNU GPL<span class="st_h">'d, by Julian Seward et al.
 ==17870== Using LibVEX rev 1804, a library for dynamic binary translation.
 ==17870== Copyright (C) 2004-2007, and GNU GPL'</span>d, by OpenWorks LLP.
 ==<span class="nu0">17870</span>== Using valgrind-3.3.0-Debian, a dynamic binary instrumentation framework.
 ==<span class="nu0">17870</span>== Copyright <span class="br0">&#40;</span>C<span class="br0">&#41;</span> <span class="nu0">2000</span>-<span class="nu0">2007</span>, and GNU GPL<span class="st_h">'d, by Julian Seward et al.
 ==17870== For more details, rerun with: -v
 ==17870== 
 ==17870== Invalid write of size 4
 ==17870==    at 0x4005B1: main (mcheck_test.c:17)
 ==17870==  Address 0x5184048 is 4 bytes after a block of size 20 alloc'</span>d
 ==<span class="nu0">17870</span>==    at 0x4C21FAB: malloc <span class="br0">&#40;</span>vg_replace_malloc.c:<span class="nu0">207</span><span class="br0">&#41;</span>
 ==<span class="nu0">17870</span>==    by 0x400589: main <span class="br0">&#40;</span>mcheck_test.c:<span class="nu0">10</span><span class="br0">&#41;</span>
 ==<span class="nu0">17870</span>== 
 ==<span class="nu0">17870</span>== Invalid <span class="kw2">write</span> of <span class="kw2">size</span> <span class="nu0">4</span>
 ==<span class="nu0">17870</span>==    at 0x4005C8: main <span class="br0">&#40;</span>mcheck_test.c:<span class="nu0">22</span><span class="br0">&#41;</span>
 ==<span class="nu0">17870</span>==  Address 0x5184048 is <span class="nu0">4</span> bytes after a block of <span class="kw2">size</span> <span class="nu0">20</span> <span class="kw2">free</span><span class="st_h">'d
 ==17870==    at 0x4C21B2E: free (vg_replace_malloc.c:323)
 ==17870==    by 0x4005BF: main (mcheck_test.c:19)
 ==17870== 
 ==17870== ERROR SUMMARY: 2 errors from 2 contexts (suppressed: 8 from 1)
 ==17870== malloc/free: in use at exit: 40 bytes in 1 blocks.
 ==17870== malloc/free: 2 allocs, 1 frees, 60 bytes allocated.
 ==17870== For counts of detected errors, rerun with: -v
 ==17870== searching for pointers to 1 not-freed blocks.
 ==17870== checked 76,408 bytes.
 ==17870== 
 ==17870== LEAK SUMMARY:
 ==17870==    definitely lost: 40 bytes in 1 blocks.
 ==17870==      possibly lost: 0 bytes in 0 blocks.
 ==17870==    still reachable: 0 bytes in 0 blocks.
 ==17870==         suppressed: 0 bytes in 0 blocks.
 ==17870== Rerun with --leak-check=full to see details of leaked memory.</span></pre>

<p>
S-a folosit utilitarul <a href="http://valgrind.org/docs/manual/mc-manual.html" class="urlextern" title="http://valgrind.org/docs/manual/mc-manual.html"  rel="nofollow">Memcheck</a> pentru obținerea informațiilor de acces la memorie.
</p>

<p>
Se recomandă folosirea opțiunii <code>-g</code> la compilarea programului pentru a include în executabil informații de depanare. În rularea de mai sus, Valgrind a identificat două erori: una apare la linia 17 de cod și este corelată cu linia 10 (<code>malloc</code>), iar cealaltă apare la linia 22 și este corelată cu linia 19 (<code>free</code>):
</p>
<dl class="code">
<dt><a href="../../_export/code/so/laboratoare/laborator-05%3Fcodeblock=21" title="Download Snippet" class="mediafile mf_">9</a></dt>
<dd><pre class="code c">       v1 <span class="sy0">=</span> <span class="br0">&#40;</span><span class="kw4">int</span> <span class="sy0">*</span><span class="br0">&#41;</span> <a href="http://www.opengroup.org/onlinepubs/009695399/functions/malloc.html"><span class="kw3">malloc</span></a> <span class="br0">&#40;</span><span class="nu0">5</span> <span class="sy0">*</span> <span class="kw4">sizeof</span><span class="br0">&#40;</span><span class="sy0">*</span>v1<span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy0">;</span>
       <span class="kw1">if</span> <span class="br0">&#40;</span>NULL <span class="sy0">==</span> v1<span class="br0">&#41;</span> <span class="br0">&#123;</span>
              <a href="http://www.opengroup.org/onlinepubs/009695399/functions/perror.html"><span class="kw3">perror</span></a> <span class="br0">&#40;</span><span class="st0">&quot;malloc&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
              <a href="http://www.opengroup.org/onlinepubs/009695399/functions/exit.html"><span class="kw3">exit</span></a> <span class="br0">&#40;</span>EXIT_FAILURE<span class="br0">&#41;</span><span class="sy0">;</span>
       <span class="br0">&#125;</span>
&nbsp;
       <span class="coMULTI">/* overflow */</span>
       v1<span class="br0">&#91;</span><span class="nu0">6</span><span class="br0">&#93;</span> <span class="sy0">=</span> <span class="nu0">100</span><span class="sy0">;</span>
&nbsp;
       <a href="http://www.opengroup.org/onlinepubs/009695399/functions/free.html"><span class="kw3">free</span></a><span class="br0">&#40;</span>v1<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
       <span class="coMULTI">/* write after free */</span>
       v1<span class="br0">&#91;</span><span class="nu0">6</span><span class="br0">&#93;</span> <span class="sy0">=</span> <span class="nu0">100</span><span class="sy0">;</span></pre>
</dd></dl>

<p>
Exemplul următor reprezintă un program cu o gamă variată de erori de alocare a memoriei:
</p>
<dl class="code">
<dt><a href="../../_export/code/so/laboratoare/laborator-05%3Fcodeblock=22" title="Download Snippet" class="mediafile mf_">1</a></dt>
<dd><pre class="code c"><span class="co2">#include &lt;stdlib.h&gt;</span>
<span class="co2">#include &lt;string.h&gt;</span>
&nbsp;
<span class="kw4">int</span> main<span class="br0">&#40;</span><span class="kw4">void</span><span class="br0">&#41;</span>
<span class="br0">&#123;</span>
	<span class="kw4">char</span> buf<span class="br0">&#91;</span><span class="nu0">10</span><span class="br0">&#93;</span><span class="sy0">;</span>
	<span class="kw4">char</span> <span class="sy0">*</span>p<span class="sy0">;</span>
&nbsp;
	<span class="coMULTI">/* no init */</span>
	<a href="http://www.opengroup.org/onlinepubs/009695399/functions/strcat.html"><span class="kw3">strcat</span></a><span class="br0">&#40;</span>buf<span class="sy0">,</span> <span class="st0">&quot;al&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
	<span class="coMULTI">/* overflow */</span>
	buf<span class="br0">&#91;</span><span class="nu0">11</span><span class="br0">&#93;</span> <span class="sy0">=</span> <span class="st0">'a'</span><span class="sy0">;</span>
&nbsp;
	p <span class="sy0">=</span> <a href="http://www.opengroup.org/onlinepubs/009695399/functions/malloc.html"><span class="kw3">malloc</span></a><span class="br0">&#40;</span><span class="nu0">70</span><span class="br0">&#41;</span><span class="sy0">;</span>
	p<span class="br0">&#91;</span><span class="nu0">10</span><span class="br0">&#93;</span> <span class="sy0">=</span> <span class="nu0">5</span><span class="sy0">;</span>
	<a href="http://www.opengroup.org/onlinepubs/009695399/functions/free.html"><span class="kw3">free</span></a><span class="br0">&#40;</span>p<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
	<span class="coMULTI">/* write after free */</span>
	p<span class="br0">&#91;</span><span class="nu0">1</span><span class="br0">&#93;</span> <span class="sy0">=</span> <span class="st0">'a'</span><span class="sy0">;</span>
	p <span class="sy0">=</span> <a href="http://www.opengroup.org/onlinepubs/009695399/functions/malloc.html"><span class="kw3">malloc</span></a><span class="br0">&#40;</span><span class="nu0">10</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
	<span class="coMULTI">/* memory leak */</span>
	p <span class="sy0">=</span> <a href="http://www.opengroup.org/onlinepubs/009695399/functions/malloc.html"><span class="kw3">malloc</span></a><span class="br0">&#40;</span><span class="nu0">10</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
	<span class="coMULTI">/* underrun */</span>
	p<span class="sy0">--;</span>
	<span class="sy0">*</span>p <span class="sy0">=</span> <span class="st0">'a'</span><span class="sy0">;</span>
&nbsp;
	<span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">&#125;</span></pre>
</dd></dl>

<p>
În continuare, se prezintă comportamentul executabilului obținut la o rulare obișnuită și la o rulare sub Valgrind:
</p>
<pre class="code bash"> so<span class="sy0">@</span>spook$ <span class="kw2">make</span>
 <span class="kw2">cc</span> <span class="re5">-Wall</span> <span class="re5">-g</span>    valgrind_test.c   <span class="re5">-o</span> valgrind_test
 so<span class="sy0">@</span>spook$ .<span class="sy0">/</span>valgrind_test 
 so<span class="sy0">@</span>spook$ <span class="kw2">valgrind</span> <span class="re5">--tool</span>=memcheck .<span class="sy0">/</span>valgrind_test
 ==<span class="nu0">18663</span>== Memcheck, a memory error detector.
 ==<span class="nu0">18663</span>== Copyright <span class="br0">&#40;</span>C<span class="br0">&#41;</span> <span class="nu0">2002</span>-<span class="nu0">2007</span>, and GNU GPL<span class="st_h">'d, by Julian Seward et al.
 ==18663== Using LibVEX rev 1804, a library for dynamic binary translation.
 ==18663== Copyright (C) 2004-2007, and GNU GPL'</span>d, by OpenWorks LLP.
 ==<span class="nu0">18663</span>== Using valgrind-3.3.0-Debian, a dynamic binary instrumentation framework.
 ==<span class="nu0">18663</span>== Copyright <span class="br0">&#40;</span>C<span class="br0">&#41;</span> <span class="nu0">2000</span>-<span class="nu0">2007</span>, and GNU GPL<span class="st_h">'d, by Julian Seward et al.
 ==18663== For more details, rerun with: -v
 ==18663== 
 ==18663== Conditional jump or move depends on uninitialised value(s)
 ==18663==    at 0x40050D: main (valgrind_test.c:10)
 ==18663== 
 ==18663== Invalid write of size 1
 ==18663==    at 0x400554: main (valgrind_test.c:20)
 ==18663==  Address 0x5184031 is 1 bytes inside a block of size 70 free'</span>d
 ==<span class="nu0">18663</span>==    at 0x4C21B2E: <span class="kw2">free</span> <span class="br0">&#40;</span>vg_replace_malloc.c:<span class="nu0">323</span><span class="br0">&#41;</span>
 ==<span class="nu0">18663</span>==    by 0x40054B: main <span class="br0">&#40;</span>valgrind_test.c:<span class="nu0">17</span><span class="br0">&#41;</span>
 ==<span class="nu0">18663</span>== 
 ==<span class="nu0">18663</span>== Invalid <span class="kw2">write</span> of <span class="kw2">size</span> <span class="nu0">1</span>
 ==<span class="nu0">18663</span>==    at 0x40057C: main <span class="br0">&#40;</span>valgrind_test.c:<span class="nu0">28</span><span class="br0">&#41;</span>
 ==<span class="nu0">18663</span>==  Address 0x51840e7 is <span class="nu0">1</span> bytes before a block of <span class="kw2">size</span> <span class="nu0">10</span> alloc<span class="st_h">'d
 ==18663==    at 0x4C21FAB: malloc (vg_replace_malloc.c:207)
 ==18663==    by 0x40056E: main (valgrind_test.c:24)
 ==18663== 
 ==18663== ERROR SUMMARY: 6 errors from 3 contexts (suppressed: 8 from 1)
 ==18663== malloc/free: in use at exit: 20 bytes in 2 blocks.
 ==18663== malloc/free: 3 allocs, 1 frees, 90 bytes allocated.
 ==18663== For counts of detected errors, rerun with: -v
 ==18663== searching for pointers to 2 not-freed blocks.
 ==18663== checked 76,408 bytes.
 ==18663== 
 ==18663== LEAK SUMMARY:
 ==18663==    definitely lost: 20 bytes in 2 blocks.
 ==18663==      possibly lost: 0 bytes in 0 blocks.
 ==18663==    still reachable: 0 bytes in 0 blocks.
 ==18663==         suppressed: 0 bytes in 0 blocks.
 ==18663== Rerun with --leak-check=full to see details of leaked memory.</span></pre>

<p>
Se poate observa că, la o rulare obișnuită, programul nu generează nici un fel de eroare. Totuși, la rularea cu Valgrind, apar erori în 3 contexte:
</p>
<ol>
<li class="level1"><div class="li"> la apelul <code>strcat</code> (linia 10) șirul nu a fost inițializat</div>
</li>
<li class="level1"><div class="li"> se scrie în memorie după <code>free</code> (linia 20: <code>p[1] = &#039;a</code>&#039;)</div>
</li>
<li class="level1"><div class="li"> underrun (linia 28)</div>
</li>
</ol>

<p>
În plus, există leak-uri de memorie datorită noului apel <code>malloc</code> care asociază o nouă valoare lui <code>p</code> (linia 24).
</p>

<p>
Valgrind este un utilitar de bază în depanarea programelor. Este facil de folosit (nu este intrusiv, nu necesită modificarea surselor) și permite detectarea unui număr important de erori de programare apărute ca urmare a gestiunii defectuoase a memoriei.
</p>

<p>
Informații complete despre modul de utilizare a Valgrind și a utilitarelor asociate se găsesc în <a href="http://valgrind.org/docs/manual/index.html" class="urlextern" title="http://valgrind.org/docs/manual/index.html"  rel="nofollow">paginile de documentație</a> Valgrind.
</p>

</div>

<h4 id="mtrace">mtrace</h4>
<div class="level4">

<p>
Un alt utilitar care poate fi folosit la depanarea erorilor de lucru cu memoria este <a href="http://en.wikipedia.org/wiki/Mtrace" class="urlextern" title="http://en.wikipedia.org/wiki/Mtrace"  rel="nofollow">mtrace</a>. Acest utilitar ajută la identificarea leak-urilor de memorie ale unui program.
</p>

<p>
Utilitarul <a href="http://www.gnu.org/software/libc/manual/html_node/Tracing-malloc.html#Tracing-malloc" class="urlextern" title="http://www.gnu.org/software/libc/manual/html_node/Tracing-malloc.html#Tracing-malloc"  rel="nofollow">mtrace</a> se folosește cu apelurile <a href="http://www.gnu.org/software/libc/manual/html_node/Tracing-malloc.html#Tracing-malloc" class="urlextern" title="http://www.gnu.org/software/libc/manual/html_node/Tracing-malloc.html#Tracing-malloc"  rel="nofollow">mtrace</a> și <a href="http://www.gnu.org/software/libc/manual/html_node/Tracing-malloc.html#Tracing-malloc" class="urlextern" title="http://www.gnu.org/software/libc/manual/html_node/Tracing-malloc.html#Tracing-malloc"  rel="nofollow">muntrace</a> implementate în biblioteca standard C:
</p>
<pre class="code c"><span class="kw4">void</span> mtrace<span class="br0">&#40;</span><span class="kw4">void</span><span class="br0">&#41;</span><span class="sy0">;</span>
<span class="kw4">void</span> muntrace<span class="br0">&#40;</span><span class="kw4">void</span><span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>
Utilitarul <a href="http://www.gnu.org/software/libc/manual/html_node/Tracing-malloc.html#Tracing-malloc" class="urlextern" title="http://www.gnu.org/software/libc/manual/html_node/Tracing-malloc.html#Tracing-malloc"  rel="nofollow">mtrace</a> introduce handlere pentru apelurile de biblioteca pentru lucrul cu memoria (<code>malloc</code>, <code>realloc</code>, <code>free</code>). Apelurile <a href="http://www.gnu.org/software/libc/manual/html_node/Tracing-malloc.html#Tracing-malloc" class="urlextern" title="http://www.gnu.org/software/libc/manual/html_node/Tracing-malloc.html#Tracing-malloc"  rel="nofollow">mtrace</a> și <a href="http://www.gnu.org/software/libc/manual/html_node/Tracing-malloc.html#Tracing-malloc" class="urlextern" title="http://www.gnu.org/software/libc/manual/html_node/Tracing-malloc.html#Tracing-malloc"  rel="nofollow">muntrace</a> activează, respectiv dezactivează monitorizarea apelurilor de bibliotecă de lucru cu memoria.
</p>

<p>
Jurnalizarea operațiilor efectuate se realizează în fișierul definit de variabila de mediu <code>MALLOC_TRACE</code>. După ce apelurile au fost înregistrate în fișierul specificat, utilizatorul poate să folosească utilitarul <code>mtrace</code> pentru analiza acestora.
</p>

<p>
În exemplul de mai jos este prezentată o situație în care se alocă memorie fără a fi eliberată:
</p>
<dl class="code">
<dt><a href="../../_export/code/so/laboratoare/laborator-05%3Fcodeblock=25" title="Download Snippet" class="mediafile mf_c">mtrace_test.c</a></dt>
<dd><pre class="code c"><span class="co2">#include &lt;stdlib.h&gt;</span>
<span class="co2">#include &lt;mcheck.h&gt;</span>
&nbsp;
<span class="kw4">int</span> main<span class="br0">&#40;</span><span class="kw4">void</span><span class="br0">&#41;</span>
<span class="br0">&#123;</span>
	<span class="coMULTI">/* start memcall monitoring */</span>
	mtrace<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
	<a href="http://www.opengroup.org/onlinepubs/009695399/functions/malloc.html"><span class="kw3">malloc</span></a><span class="br0">&#40;</span><span class="nu0">10</span><span class="br0">&#41;</span><span class="sy0">;</span>
	<a href="http://www.opengroup.org/onlinepubs/009695399/functions/malloc.html"><span class="kw3">malloc</span></a><span class="br0">&#40;</span><span class="nu0">20</span><span class="br0">&#41;</span><span class="sy0">;</span>
	<a href="http://www.opengroup.org/onlinepubs/009695399/functions/malloc.html"><span class="kw3">malloc</span></a><span class="br0">&#40;</span><span class="nu0">30</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
	<span class="coMULTI">/* stop memcall monitoring */</span>
	muntrace<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
	<span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">&#125;</span></pre>
</dd></dl>

<p>
În secvența de comenzi ce urmează se compilează fișierul de mai sus, se stabilește fișierul de jurnalizare și se rulează comanda <code>mtrace</code> pentru a detecta problemele din codul de mai sus.
</p>
<pre class="code bash"> so<span class="sy0">@</span>spook$ <span class="kw2">gcc</span> <span class="re5">-Wall</span> <span class="re5">-g</span> mtrace_test.c <span class="re5">-o</span> mtrace_test
 so<span class="sy0">@</span>spook$ <span class="kw3">export</span> <span class="re2">MALLOC_TRACE</span>=.<span class="sy0">/</span>mtrace.log
 so<span class="sy0">@</span>spook$ .<span class="sy0">/</span>mtrace_test 
 so<span class="sy0">@</span>spook$ <span class="kw2">cat</span> mtrace.log 
 = Start
 <span class="sy0">@</span> .<span class="sy0">/</span>mtrace_test:<span class="br0">&#91;</span>0x40054b<span class="br0">&#93;</span> + 0x601460 0xa
 <span class="sy0">@</span> .<span class="sy0">/</span>mtrace_test:<span class="br0">&#91;</span>0x400555<span class="br0">&#93;</span> + 0x601480 0x14
 <span class="sy0">@</span> .<span class="sy0">/</span>mtrace_test:<span class="br0">&#91;</span>0x40055f<span class="br0">&#93;</span> + 0x6014a0 0x1e
 = End
 so<span class="sy0">@</span>spook$ mtrace mtrace_test mtrace.log 
&nbsp;
 Memory not freed:
 <span class="re5">-----------------</span>
 		   Address     Size     Caller
 0x0000000000601460      0xa  at <span class="sy0">/</span>home<span class="sy0">/</span>razvan<span class="sy0">/</span>school<span class="sy0">/</span>so<span class="sy0">/</span>labs<span class="sy0">/</span>lab4<span class="sy0">/</span>samples<span class="sy0">/</span>mtrace.c:<span class="nu0">11</span>
 0x0000000000601480     0x14  at <span class="sy0">/</span>home<span class="sy0">/</span>razvan<span class="sy0">/</span>school<span class="sy0">/</span>so<span class="sy0">/</span>labs<span class="sy0">/</span>lab4<span class="sy0">/</span>samples<span class="sy0">/</span>mtrace.c:<span class="nu0">12</span>
 0x00000000006014a0     0x1e  at <span class="sy0">/</span>home<span class="sy0">/</span>razvan<span class="sy0">/</span>school<span class="sy0">/</span>so<span class="sy0">/</span>labs<span class="sy0">/</span>lab4<span class="sy0">/</span>samples<span class="sy0">/</span>mtrace.c:<span class="nu0">15</span></pre>

<p>
Mai multe informații despre detectarea problemelor de alocare folosind mtrace găsiți în <a href="http://www.gnu.org/software/libc/manual/html_node/Allocation-Debugging.html#Allocation-Debugging" class="urlextern" title="http://www.gnu.org/software/libc/manual/html_node/Allocation-Debugging.html#Allocation-Debugging"  rel="nofollow">pagina asociată</a> din <a href="http://www.gnu.org/software/libc/manual" class="urlextern" title="http://www.gnu.org/software/libc/manual"  rel="nofollow">manualul glibc</a>.
</p>

</div>

<h3 class="sectionedit16" id="dubla_dealocare">Dublă dealocare</h3>
<div class="level3">

<p>
Denumirea de “dublă dealocare” oferă o bună intuiție asupra cauzei: eliberarea de două ori a aceluiași spațiu de memorie. Dubla dealocare poate avea efecte negative deoarece afectează structurile interne folosite pentru a gestiona memoria ocupată.
</p>

<p>
În ultimele versiuni ale bibliotecii standard C, se detectează automat cazurile de dublă dealocare. Fie exemplul de mai jos:
</p>
<dl class="code">
<dt><a href="../../_export/code/so/laboratoare/laborator-05%3Fcodeblock=27" title="Download Snippet" class="mediafile mf_c">dubla_dealocare.c</a></dt>
<dd><pre class="code c"><span class="co2">#include &lt;stdlib.h&gt;</span>
&nbsp;
<span class="kw4">int</span> main<span class="br0">&#40;</span><span class="kw4">void</span><span class="br0">&#41;</span>
<span class="br0">&#123;</span>
	<span class="kw4">char</span> <span class="sy0">*</span>p<span class="sy0">;</span>
&nbsp;
	p <span class="sy0">=</span> <a href="http://www.opengroup.org/onlinepubs/009695399/functions/malloc.html"><span class="kw3">malloc</span></a><span class="br0">&#40;</span><span class="nu0">10</span><span class="br0">&#41;</span><span class="sy0">;</span>
	<a href="http://www.opengroup.org/onlinepubs/009695399/functions/free.html"><span class="kw3">free</span></a><span class="br0">&#40;</span>p<span class="br0">&#41;</span><span class="sy0">;</span>
	<a href="http://www.opengroup.org/onlinepubs/009695399/functions/free.html"><span class="kw3">free</span></a><span class="br0">&#40;</span>p<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
	<span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">&#125;</span></pre>
</dd></dl>

<p>
Rularea executabilului obținut din programul de mai sus duce la afișarea unui mesaj specific al glibc de eliberare dublă a unei regiuni de memorie și terminare a programului:
</p>
<pre class="code bash"> so<span class="sy0">@</span>spook$ <span class="kw2">make</span>
 <span class="kw2">cc</span> <span class="re5">-Wall</span> <span class="re5">-g</span>    dfree.c   <span class="re5">-o</span> dfree
 so<span class="sy0">@</span>spook$ .<span class="sy0">/</span>dfree 
  <span class="sy0">***</span> glibc detected <span class="sy0">***</span> .<span class="sy0">/</span>dfree: double <span class="kw2">free</span> or corruption <span class="br0">&#40;</span>fasttop<span class="br0">&#41;</span>: 0x0000000000601010 <span class="sy0">***</span>
 ======= Backtrace: =========
 <span class="sy0">/</span>lib<span class="sy0">/</span>libc.so.6<span class="br0">&#91;</span>0x2b675fdd502a<span class="br0">&#93;</span>
 <span class="sy0">/</span>lib<span class="sy0">/</span>libc.so.6<span class="br0">&#40;</span>cfree+0x8c<span class="br0">&#41;</span><span class="br0">&#91;</span>0x2b675fdd8bbc<span class="br0">&#93;</span>
 .<span class="sy0">/</span>dfree<span class="br0">&#91;</span>0x400510<span class="br0">&#93;</span>
 <span class="sy0">/</span>lib<span class="sy0">/</span>libc.so.6<span class="br0">&#40;</span>__libc_start_main+0xf4<span class="br0">&#41;</span><span class="br0">&#91;</span>0x2b675fd7f1c4<span class="br0">&#93;</span>
 .<span class="sy0">/</span>dfree<span class="br0">&#91;</span>0x400459<span class="br0">&#93;</span></pre>

<p>
Situațiile de dublă dealocare sunt, de asemenea, detectate de Valgrind.
</p>

</div>

<h3 class="sectionedit17" id="alte_utilitare_pentru_depanarea_problemelor_de_lucru_cu_memoria">Alte utilitare pentru depanarea problemelor de lucru cu memoria</h3>
<div class="level3">

<p>
Utilitarele prezentate mai sus nu sunt singurele folosite pentru detectarea problemelor apărute in <a href="http://en.wikipedia.org/wiki/Category:Memory_management_software" class="urlextern" title="http://en.wikipedia.org/wiki/Category:Memory_management_software"  rel="nofollow">lucrul cu memoria</a>. Alte utilitare sunt:
</p>
<ul>
<li class="level1"><div class="li"><a href="http://dmalloc.com/" class="urlextern" title="http://dmalloc.com/"  rel="nofollow">dmalloc</a></div>
</li>
<li class="level1"><div class="li"><a href="http://mpatrol.sourceforge.net/" class="urlextern" title="http://mpatrol.sourceforge.net/"  rel="nofollow">mpatrol</a></div>
</li>
<li class="level1"><div class="li"><a href="http://duma.sourceforge.net" class="urlextern" title="http://duma.sourceforge.net"  rel="nofollow">DUMA</a></div>
</li>
<li class="level1"><div class="li"><a href="http://perens.com/works/software/ElectricFence/" class="urlextern" title="http://perens.com/works/software/ElectricFence/"  rel="nofollow">Electric Fence</a>, prezentat în laboratorul de <a href="http://elf.cs.pub.ro/so/wiki/laboratoare/laborator-07#electricfence" class="urlextern" title="http://elf.cs.pub.ro/so/wiki/laboratoare/laborator-07#electricfence"  rel="nofollow">Memorie virtuală</a></div>
</li>
</ul>

</div>

<h1 class="sectionedit18" id="exercitii">Exerciții</h1>
<div class="level1">

</div>

<h2 class="sectionedit19" id="exercitiul_0_-_joc_interactiv_2p">Exercițiul 0 - Joc interactiv (2p)</h2>
<div class="level2">
<ul>
<li class="level1"><div class="li"> Detalii desfășurare <a href="../meta/notare.html#joc_interactiv" class="urlextern" title="http://ocw.cs.pub.ro/courses/so/meta/notare#joc_interactiv"  rel="nofollow">joc</a>.</div>
</li>
</ul>

</div>

<h2 class="sectionedit20" id="linux_9p">Linux (9p)</h2>
<div class="level2">

<p>
<p><div class="noteimportant">În rezolvarea laboratorului folosiți arhiva de sarcini <a href="http://elf.cs.pub.ro/so/res/laboratoare/lab05-tasks.zip" class="urlextern" title="http://elf.cs.pub.ro/so/res/laboratoare/lab05-tasks.zip"  rel="nofollow"> lab05-tasks.zip</a>
</div></p>
</p>

<p>
<p><div class="notetip">Pentru a vă ajuta la implementarea exercițiilor din laborator, în directorul <code>utils</code> din arhivă există un fișier <code>utils.h</code> cu funcții utile.

</div></p>
</p>

</div>

<h3 class="sectionedit21" id="exercitiul_1_-_zone_de_stocare_a_variabilelor_05p">Exercițiul 1 - Zone de stocare a variabilelor (0.5p)</h3>
<div class="level3">

<p>
Intrați în directorul <code>1-counter</code> și implementați funcția <code>inc()</code> care întoarce de fiecare dată un întreg reprezentând numărul de apeluri până în momentul respectiv al funcției <code>inc</code> (<strong>nu</strong> aveți voie să folosiți variabile globale).
</p>

</div>

<h3 class="sectionedit22" id="exercitiul_2_-_spatiul_de_adresa_al_unui_proces_1p">Exercițiul 2 - Spațiul de adresă al unui proces (1p)</h3>
<div class="level3">

<p>
Intrați în directorul <code>2-adr_space</code> și deschideți sursa <code>adr_space.c</code>. În alt terminal compilați și rulați programul. Observați zonele de memorie din executabil în care sunt salvate variabilele, folosind comanda:
</p>
<pre class="code bash">objdump <span class="re5">-t</span> adr_space <span class="sy0">|</span> <span class="kw2">grep</span> var</pre>

<p>
<p><div class="notetip">
Observați că unele variabile apar in tabela de simboluri (variabilele globale și cele locale statice - așa cum arată și flagurile <code>l</code> și <code>g</code> din dreptul acestora;  `man objdump` ), iar altele nu. Variabilele care nu apar in tabelă se află pe stivă.

</div></p>
</p>

<p>
Afișați conținutul zonei &#039;.rodata&#039; folosind utilitarul <code>readelf</code>
</p>

<p>
<p><div class="notetip">
<strong>Hint</strong>: Trebuie să afișați hex dump-ul secțiunii <code>.rodata</code> a executabilului <code>adr_space</code>. Consultați pagina de manual a <code>readelf</code> după parametrul potrivit. 
</p>

<p>
Nu uitați să adăugați și numele fișierului executabil ca parametru al comenzii <code>readelf</code>.

</div></p>
</p>

</div>

<h3 class="sectionedit23" id="exercitiul_3_-_alocarea_realocarea_si_dezalocarea_memoriei_1p">Exercițiul 3 - Alocarea, realocarea și dezalocarea memoriei (1p)</h3>
<div class="level3">

<p>
Intrați în directorul <code>3-alloc</code>, compilați și rulați programul <code>alloc</code>.
</p>

<p>
Folosiți <code>valgrind</code> pentru a detecta eventualele probleme de lucru cu memoria și corectați-le.
</p>

<p>
<p><div class="notetip">
Observați că se generează <strong>leak-uri de memorie</strong> din cauză că memoria alocată nu a fost eliberată corespunzător atunci când zona respectivă nu a mai fost necesară în program.

</div></p>
<p><div class="notetip">
Revedeți secțiunile <a href="laborator-05.html#valgrind" title="so:laboratoare:laborator-05 ↵" class="wikilink1">Valgrind</a> și <a href="laborator-05.html#alocarea_memoriei_in_linux" title="so:laboratoare:laborator-05 ↵" class="wikilink1">Alocarea memoriei în Linux</a> din laborator.
</div></p>
</p>

</div>

<h3 class="sectionedit24" id="exercitiul_4_-_rezolvarea_unei_probleme_de_tip_segmentation_fault_1p">Exercițiul 4 - Rezolvarea unei probleme de tip Segmentation Fault (1p)</h3>
<div class="level3">

<p>
Intrați în directorul <code>4-gdb</code> și inspectați sursa. Programul ar trebui să citescă un mesaj de la <code>stdin</code> și să-l afișeze. Compilați și rulați sursa. Rulați încă o dată programul din <code>gdb</code> (revedeți <a href="../laboratoare-2013/resurse/gdb.html#rulare_gdb" class="wikilink1" title="so:laboratoare-2013:resurse:gdb">rularea unui program din gdb</a>).
</p>

<p>
Pentru a identifica exact unde crapă programul folosiți comanda <a href="http://inside.mines.edu/fs_home/lwiencke/elab/gdb/gdb_42.html" class="urlextern" title="http://inside.mines.edu/fs_home/lwiencke/elab/gdb/gdb_42.html"  rel="nofollow"> backtrace</a>. Pentru detalii despre comenzile din gdb folosiți comanda <code>help</code>:
</p>
<pre class="code bash"><span class="br0">&#40;</span><span class="kw2">gdb</span><span class="br0">&#41;</span> <span class="kw3">help</span></pre>

<p>
Schimbați frame-ul curent cu frame-ul funcției <code>main</code> (revedeți <a href="laborator-05.html#acces_nevalid" title="so:laboratoare:laborator-05 ↵" class="wikilink1"> detectarea unui acces nevalid de tip page fault</a>):
</p>
<pre class="code bash"><span class="br0">&#40;</span><span class="kw2">gdb</span><span class="br0">&#41;</span> frame main</pre>

<p>
Inspectați valoarea variabilei <code>buf</code>:
</p>
<pre class="code bash"><span class="br0">&#40;</span><span class="kw2">gdb</span><span class="br0">&#41;</span> print buf</pre>

<p>
Acum dorim să vedem de ce este <code>buf = NULL</code>, urmărind pașii:
</p>
<ul>
<li class="level1"><div class="li"> Omorâți actualul proces:<pre class="code bash"><span class="br0">&#40;</span><span class="kw2">gdb</span><span class="br0">&#41;</span> <span class="kw2">kill</span></pre>
</div>
</li>
<li class="level1"><div class="li"> Puneți un breakpoint la începutul funcției <code>main</code>:<pre class="code bash"><span class="br0">&#40;</span><span class="kw2">gdb</span><span class="br0">&#41;</span> <span class="kw3">break</span> main</pre>
</div>
</li>
<li class="level1"><div class="li"> Rulați programul și inspectați valoarea lui <code>buf</code> înainte și după apelul funcției <code>malloc</code> (folosiți <code>next</code> pentru a trece la instrucțiunea următoare, fără a urmări apelul de funcție).</div>
</li>
<li class="level1"><div class="li"> Explicați sursa erorii, apoi rezolvați-o.</div>
</li>
</ul>

</div>

<h3 class="sectionedit25" id="exercitiul_5_-_lucru_cu_memoria_-_valgrind_1p">Exercițiul 5 - Lucru cu memoria - Valgrind (1p)</h3>
<div class="level3">

<p>
Intrați în directorul <code>5-struct</code> și completați fișierul <code>struct.c</code> conform comentariilor marcate cu <code>TODO</code>.
</p>

<p>
În funcția <code>allocate_flowers</code> alocați memorie pentru <code>no</code> elemente de tip <code>flower_info</code>, iar în funcția <code>free_flowers</code> eliberați memoria alocată în funcția <code>allocate_flowers</code>.
</p>

<p>
Observați dacă programul se execută cu succes. Corectați eventualele greșeli având în vedere următoarele aspecte:
</p>
<ul>
<li class="level1"><div class="li"> Folosiți opțiunea <code>--tool=memcheck</code> pentru <code>valgrind</code>.</div>
</li>
<li class="level1"><div class="li"> Revedeți secțiunea <a href="laborator-05.html#valgrind" title="so:laboratoare:laborator-05 ↵" class="wikilink1">Valgrind</a> din laborator. </div>
</li>
</ul>

</div>

<h3 class="sectionedit26" id="exercitiul_6_-_stack_overflow_2p">Exercițiul 6 - Stack overflow (2p)</h3>
<div class="level3">

<p>
Intrați în directorul 6-stack și inspectați sursa și completați problemele marcate cu <em>TODO1</em> astfel:
</p>
<ul>
<li class="level1"><div class="li"> în funcția <code>show_snapshot</code> iterați pe toată lungimea stivei și afișați adresa și valoarea de la adresa curentă</div>
</li>
<li class="level3"><div class="li"> în funcția <code>take_snapshot</code> salvați în structura de date ce reține imaginea stivei câmpurile adresă și valoare.</div>
</li>
</ul>

<p>
Ce reține structura <code>stack_elements</code>?
</p>

<p>
Funcția <code>f2</code> pune pe stivă un vector de 3 întregi. În ce ordine sunt puse elementele vectorului pe stivă?
</p>

<p>
Compilați și rulați programul, iar pe urmă identificați care este adresa de revenire din funcția <code>f2</code>.
</p>

<p>
<p><div class="notetip">
Dezasamblați executabilul. Observați că înainte de call <code>f2</code> se pune pe stivă <code>instruction pointer-ul(eip)</code> care este adresa primului byte de după call. La intrarea în funcție controlul s-a transmis de la caller la callee. Acesta din urmă salvează vechiul <code>base pointer(ebp)</code> iar ebp va conține adresa vârfului stivei.

</div></p>
</p>

<p>
In funcția <code>f2</code> bufferul <code>v</code> se află pe stivă sub adresa de return a funcției (IP-ul la care se întoarce programul dupa ce execută <code>f2</code>). Scriind în bufferul <code>v</code> mai multe elemente decat are acesta alocate pe stivă, vom putea suprascrie adresa de return a lui <code>f2</code> cu o alta adresă (aici, adresa funcției <code>show_message</code>). Atenție, după adresa de return este salvat pe stivă base pointerul și abia apoi găsim și bufferul <code>v</code>.
</p>

<p>
Folosindu-vă de vectorul <code>v</code> <strong>fortați execuția</strong> funcției <code>show_message</code> <strong>fără</strong> a o apela explicit. Astfel, după apelul funcției <code>f2</code>, fluxul programului nu se va mai întoarce în funcția <code>f1</code>, ci va executa <code>show_message</code>. Urmăriți comentariile marcate cu <em>TODO2</em> (revedeți partea din laborator referitoare la <a href="laborator-05.html#stiva" title="so:laboratoare:laborator-05 ↵" class="wikilink1"> stivă </a>)
</p>

</div>

<h3 class="sectionedit27" id="exercitiul_7_-_detectare_probleme_de_lucru_cu_memoria_-_mcheck_1p">Exercițiul 7 - Detectare probleme de lucru cu memoria - mcheck (1p)</h3>
<div class="level3">

<p>
În directorul <code>7-trim</code> analizați programul <code>trim.c</code>, compilați și rulați executabilul <code>trim</code>.
</p>

<p>
Încercați să detectați problema folosind gdb (revedeți tehnicile folosite la exercițiul 3). După aceea, folosiți <a href="laborator-05.html#mcheck_-_verificarea_consistentei_heap-ului" title="so:laboratoare:laborator-05 ↵" class="wikilink1">mcheck</a> pentru a detecta problema și corectați-o (citiți secțiunea <a href="laborator-05.html#mcheck_-_verificarea_consistentei_heap-ului" title="so:laboratoare:laborator-05 ↵" class="wikilink1">mcheck</a> din laborator). Rularea cu <code>mcheck</code> se face astfel:
</p>
<pre class="code bash"><span class="re2">MALLOC_CHECK_</span>=<span class="nu0">1</span> .<span class="sy0">/</span>trim</pre>

</div>

<h3 class="sectionedit28" id="exercitiul_8_-_endianess_1p">Exercițiul 8 - Endianess (1p)</h3>
<div class="level3">

<p>
Intrați în directorul <code>8-endian</code> și inspectați sursa <code>endian.c</code>. Folosindu-vă de variabila <code>w</code> afișați  numărul <code>n=0xDEADBEEF</code>.
</p>

<p>
Ce tip de arhitectură se folosește? (big-endian sau little-endian, vezi <a href="http://en.wikipedia.org/wiki/Endianness" class="urlextern" title="http://en.wikipedia.org/wiki/Endianness"  rel="nofollow">aici</a> pentru detalii). Gândiți-vă la <code>n</code> ca la un vector de caractere.
</p>

</div>

<h3 class="sectionedit29" id="exercitiul_9_-_lucrul_cu_stiva_05p">Exercițiul 9 - Lucrul cu stiva (0.5p)</h3>
<div class="level3">

<p>
Intrați în directorul <code>9-bad_stack</code> și analizați fișierul <code>bad_stack.c</code>. Compilați și rulați programul.
</p>

<p>
Se observă că în funcția <code>main</code>, prima oară se afișează valoarea din <code>str</code>, iar a doua oară nu. Observați că după ieșirea din funcția myfun() variabila <code>lab_so</code> nu mai este accesibilă deoarece se iese din stack frame-ul funcției myfun după return. Variabila va fi suprascrisă in cazul altor apeluri de funcții. Funcția myfun nu returneaza o adresă (așa cum se cere explicit) ci registrul eax conține valoarea 0x0 după return.
</p>

<p>
Care sunt tipurile de variabile care nu se află pe stivă?
</p>

<p>
Modificați sursa, mai exact funcția <code>myfun()</code>, astfel încât variabila lab_so să fie accesibilă după return.
</p>

<p>
<p><div class="notetip">Indicație: Mutați variabila <code>lab_so</code> din funcția <code>my_fun()</code> într-o altă zonă
</div></p>
</p>

</div>

<h2 class="sectionedit30" id="exercitii_bonus_3_so_karma">Exerciții BONUS (3 SO Karma)</h2>
<div class="level2">

</div>

<h3 class="sectionedit31" id="bonus_windows">BONUS Windows</h3>
<div class="level3">

</div>

<h4 id="so_karma_-_realizarea_unui_wrapper_pentru_functiile_malloc_si_free">1 so karma - Realizarea unui wrapper pentru funcțiile malloc și free</h4>
<div class="level4">

<p>
Deschideți proiectul Visual Studio din directorul <code>malloc-wrapper</code> și inspectați cele două fișiere existente: <code>xmalloc.c</code> și <code>xmalloc.h</code>.
</p>

<p>
Completați fișierul <code>xmalloc.c</code> cu definiția funcției <code>xmalloc</code> și fișierul <code>xmalloc.h</code> cu macrodefiniția <code>xfree</code> după cum urmează:
</p>
<ul>
<li class="level1"><div class="li"> în cazul <code>xmalloc</code> se alocă spațiu folosind <code>HeapAlloc</code> (trebuie să verificați dacă alocarea are succes sau nu)</div>
</li>
<li class="level1"><div class="li"> <code>xfree</code> este un macro care primește ca argument pointer-ul de eliberat (se apelează <code>HeapFree</code> și pointer-ul este resetat la <code>NULL</code>)</div>
</li>
</ul>

<p>
De ce este mai dificil să se realizeze o funcție <code>xfree</code> care să realizeze aceleași operații?
</p>

</div>

<h4 id="so_karma_-_program_de_test_pentru_wrapperul_xmalloc">1 so karma - Program de test pentru wrapperul xmalloc</h4>
<div class="level4">

<p>
Analizați fișierul <code>test.c</code> și implementați funcțiile <code>tensor_alloc</code>, respectiv <code>tensor_free</code> care alocă/dealocă un vector tridimensional (tensor). Folosiți funcțiile <code>xmalloc</code> și <code>xfree</code> implementate în cadrul exercițiului anterior (urmăriți comentariile marcate cu <code>TODO</code>).
</p>

</div>

<h3 class="sectionedit32" id="bonus_linux">BONUS Linux</h3>
<div class="level3">

</div>

<h4 id="so_karma_-_realizarea_unei_implementari_sumare_a_functiei_malloc">1 so karma - Realizarea unei implementări sumare a funcției malloc</h4>
<div class="level4">

<p>
Urmăriți în <code>man</code> specificarea apelurilor <a href="http://linux.die.net/man/2/brk" class="urlextern" title="http://linux.die.net/man/2/brk"  rel="nofollow"> brk</a> și <a href="http://linux.die.net/man/2/sbrk" class="urlextern" title="http://linux.die.net/man/2/sbrk"  rel="nofollow"> sbrk</a>. Folosind acest apel de sistem, completați implementarea funcției <a href="http://linux.die.net/man/3/malloc" class="urlextern" title="http://linux.die.net/man/3/malloc"  rel="nofollow"> malloc </a> din sursa <code>my_malloc.c</code>. Va trebui întâi să extindeți limita curentă a heap-ului (program break) cu valoarea cerută pentru alocare.
</p>

<p>
Compilați și testați rulând programul de test:
</p>
<pre class="code bash">.<span class="sy0">/</span><span class="kw3">test</span></pre>

<p>
<p><div class="notetip">Pentru rularea programului de test, nu uitați să exportați <code>LD_LIBRARY_PATH</code> (revedeți secțiunea de <a href="../laboratoare-2013/laborator-01.html#biblioteci_in_linux" class="wikilink1" title="so:laboratoare-2013:laborator-01"> biblioteci partajate din laboratorul 1</a>)
</div></p>
</p>

</div>

<h2 class="sectionedit33" id="solutii">Soluții</h2>
<div class="level2">

<p>
<a href="http://elf.cs.pub.ro/so/res/laboratoare/lab05-sol.zip" class="urlextern" title="http://elf.cs.pub.ro/so/res/laboratoare/lab05-sol.zip"  rel="nofollow"> lab05-sol.zip</a>
</p>

</div>

<h2 class="sectionedit34" id="resurse_utile">Resurse utile</h2>
<div class="level2">
<ul>
<li class="level1"><div class="li">Linux System Programming - Chapter 8 - Memory Management</div>
</li>
<li class="level1"><div class="li">Windows System Programming - Chapter 5 - Memory Management (Win32 and Win64 Memory Management Architecture, Heaps, Managing Heap Memory</div>
</li>
<li class="level1"><div class="li">Linux Application Programming - Chapter 7 - Memory Debugging Tools</div>
</li>
<li class="level1"><div class="li"><a href="http://msdn2.microsoft.com/en-us/library/aa366779(VS.85).aspx" class="urlextern" title="http://msdn2.microsoft.com/en-us/library/aa366779(VS.85).aspx"  rel="nofollow">Windows Memory Management</a></div>
</li>
<li class="level1"><div class="li"><a href="http://www.gnu.org/software/libc/manual/html_node/Memory.html#Memory Virtual" class="urlextern" title="http://www.gnu.org/software/libc/manual/html_node/Memory.html#Memory Virtual"  rel="nofollow">Memory Allocation and Paging</a></div>
</li>
<li class="level1"><div class="li"><a href="http://www.valgrind.org/" class="urlextern" title="http://www.valgrind.org/"  rel="nofollow">Valgrind Home</a></div>
</li>
<li class="level1"><div class="li"><a href="http://www.cprogramming.com/debugging/valgrind.html" class="urlextern" title="http://www.cprogramming.com/debugging/valgrind.html"  rel="nofollow">Using Valgrind to Find Memory Leaks</a></div>
</li>
<li class="level1"><div class="li"><a href="http://www.memorymanagement.org/" class="urlextern" title="http://www.memorymanagement.org/"  rel="nofollow">The Memory Management Reference</a></div>
</li>
<li class="level1"><div class="li"><a href="http://www.ibm.com/developerworks/rational/library/06/0822_satish-giridhar/" class="urlextern" title="http://www.ibm.com/developerworks/rational/library/06/0822_satish-giridhar/"  rel="nofollow">Using Purify</a></div>
</li>
<li class="level1"><div class="li"><a href="http://en.wikipedia.org/wiki/Category:Memory_management_software" class="urlextern" title="http://en.wikipedia.org/wiki/Category:Memory_management_software"  rel="nofollow">Memory Management Software</a></div>
</li>
<li class="level1"><div class="li"><a href="http://insecure.org/stf/smashstack.html" class="urlextern" title="http://insecure.org/stf/smashstack.html"  rel="nofollow">Smashing the Stack for Fun and Profit</a></div>
</li>
<li class="level1"><div class="li"><a href="http://heather.cs.ucdavis.edu/~matloff/UnixAndC/CLanguage/Debug.html" class="urlextern" title="http://heather.cs.ucdavis.edu/~matloff/UnixAndC/CLanguage/Debug.html"  rel="nofollow"> Guide to Faster, Less Frustrating Debugging</a></div>
</li>
<li class="level1"><div class="li"><a href="http://individual.utoronto.ca/n_hoa/www/Misc/gdb.html" class="urlextern" title="http://individual.utoronto.ca/n_hoa/www/Misc/gdb.html"  rel="nofollow"> GDB tutorial </a></div>
</li>
<li class="level1"><div class="li"><a href="http://www.gimpel.com/html/newbugs/bug620.htm" class="urlextern" title="http://www.gimpel.com/html/newbugs/bug620.htm"  rel="nofollow"> BUG of the month </a></div>
</li>
</ul>

</div>

        </div>
        <div class="right_sidebar">
          <form action="../../start.html" accept-charset="utf-8" class="search" id="dw__search" method="get"><div class="no"><input type="hidden" name="do" value="search" /><input type="text" id="qsearch__in" accesskey="f" name="id" class="edit" title="[F]" /><input type="submit" value="Search" class="button" title="Search" /><div id="qsearch__out" class="ajax_qsearch JSpopup"></div></div></form>          <div class="namespace_sidebar sidebar_box">



<h1 class="sectionedit1" id="informatii_generale_so">Informații generale SO</h1>
<div class="level1">

<div><div id="nojs_indexmenu_175122364758355ad77b8d3" data-jsajax="%26skipfile%3D%253D/so%253Ainfo%253Astart/" class="indexmenu_nojs">

<ul class="idx">
<li class="level1"><div class="li"><a href="../info/documentatie.html" class="wikilink1" title="so:info:documentatie">Documentație și alte resurse</a></div></li>
<li class="level1"><div class="li"><a href="../info/feed.html" class="wikilink1" title="so:info:feed">Feed RSS</a></div></li>
<li class="level1"><div class="li"><a href="../info/hall.html" class="wikilink1" title="so:info:hall">Hall of SO</a></div></li>
<li class="level1"><div class="li"><a href="../info/lista-discutii.html" class="wikilink1" title="so:info:lista-discutii">Listă de discuții</a></div></li>
<li class="level1"><div class="li"><a href="../info/mv.html" class="wikilink1" title="so:info:mv">Mașini virtuale</a></div></li>
<li class="level1"><div class="li"><a href="../info/trimitere-teme.html" class="wikilink1" title="so:info:trimitere-teme">Trimitere teme</a></div></li>
</ul>
</div></div>

</div>
<!-- EDIT1 SECTION "Informații generale SO" [12-194] -->
<h1 class="sectionedit2" id="informatii_so_2015-2016">Informații SO 2015-2016</h1>
<div class="level1">

<div><div id="nojs_indexmenu_36885895958355ad77e7a9" data-jsajax="" class="indexmenu_nojs">

<ul class="idx">
<li class="open"><div class="li"><a href="../meta/examen.html" class="indexmenu_idx_head">Examen CA/CC</a></div>
<ul class="idx">
<li class="level2"><div class="li"><a href="../meta/examen/2012-2013.html" class="wikilink1" title="so:meta:examen:2012-2013">Examen CA/CC 2012-2013</a></div></li>
<li class="level2"><div class="li"><a href="../meta/examen/2013-2014.html" class="wikilink1" title="so:meta:examen:2013-2014">Examen CA/CC 2013-2014</a></div></li>
<li class="level2"><div class="li"><a href="../meta/examen/2014-2015.html" class="wikilink1" title="so:meta:examen:2014-2015">Examen CA/CC 2014-2015</a></div></li>
</ul>
</li>
<li class="open"><div class="li"><a href="../meta/notare.html" class="indexmenu_idx_head">Reguli generale și notare</a></div>
<ul class="idx">
<li class="level2"><div class="li"><a href="../meta/notare/reguli-notare-ca-cc.html" class="wikilink1" title="so:meta:notare:reguli-notare-ca-cc">Notare CA/CC</a></div></li>
<li class="level2"><div class="li"><a href="../meta/notare/reguli-notare-cb.html" class="wikilink1" title="so:meta:notare:reguli-notare-cb">Notare CB</a></div></li>
</ul>
</li>
<li class="level1"><div class="li"><a href="../meta/anunturi.html" class="wikilink1" title="so:meta:anunturi">Anunțuri</a></div></li>
<li class="level1"><div class="li"><a href="../meta/calendar.html" class="wikilink1" title="so:meta:calendar">Calendar</a></div></li>
<li class="level1"><div class="li"><a href="../meta/catalog.html" class="wikilink1" title="so:meta:catalog">Catalog</a></div></li>
<li class="level1"><div class="li"><a href="../meta/echivalari.html" class="wikilink1" title="so:meta:echivalari">Echivalări teme</a></div></li>
<li class="level1"><div class="li"><a href="../meta/karma.html" class="wikilink1" title="so:meta:karma">Karma Awards</a></div></li>
<li class="level1"><div class="li"><a href="../meta/need-to-know.html" class="wikilink1" title="so:meta:need-to-know">SO Need to Know</a></div></li>
<li class="level1"><div class="li"><a href="../meta/orar.html" class="wikilink1" title="so:meta:orar">Orar și împărțire pe semigrupe</a></div></li>
</ul>
</div></div>

</div>
<!-- EDIT2 SECTION "Informații SO 2015-2016" [195-261] -->
<h1 class="sectionedit3" id="laboratoare">Laboratoare</h1>
<div class="level1">

<div><div id="nojs_indexmenu_140279633258355ad77f74d" data-jsajax="" class="indexmenu_nojs">

<ul class="idx">
<li class="open"><div class="li"><a href="resurse.html" class="indexmenu_idx_head">Resurse</a></div>
<ul class="idx">
<li class="level2"><div class="li"><a href="resurse/c_tips.html" class="wikilink1" title="so:laboratoare:resurse:c_tips">C/SO Tips</a></div></li>
<li class="level2"><div class="li"><a href="resurse/die.html" class="wikilink1" title="so:laboratoare:resurse:die">Macro-ul DIE</a></div></li>
<li class="level2"><div class="li"><a href="resurse/gdb.html" class="wikilink1" title="so:laboratoare:resurse:gdb">GDB</a></div></li>
<li class="level2"><div class="li"><a href="resurse/home.html" class="wikilink1" title="so:laboratoare:resurse:home">Resurse</a></div></li>
<li class="level2"><div class="li"><a href="resurse/injections.html" class="wikilink1" title="so:laboratoare:resurse:injections">Function Hooking and Windows Dll Injection</a></div></li>
<li class="level2"><div class="li"><a href="resurse/oprofile.html" class="wikilink1" title="so:laboratoare:resurse:oprofile">Oprofile</a></div></li>
<li class="level2"><div class="li"><a href="resurse/recapitulare.html" class="wikilink1" title="so:laboratoare:resurse:recapitulare">Recapitulare</a></div></li>
<li class="level2"><div class="li"><a href="resurse/threaduri_extra.html" class="wikilink1" title="so:laboratoare:resurse:threaduri_extra">Thread-uri - Extra</a></div></li>
<li class="level2"><div class="li"><a href="resurse/vs_tips.html" class="wikilink1" title="so:laboratoare:resurse:vs_tips">Visual Studio Tips and Tricks</a></div></li>
<li class="level2"><div class="li"><a href="resurse/windows-video.html" class="wikilink1" title="so:laboratoare:resurse:windows-video">windows-video</a></div></li>
</ul>
</li>
<li class="level1"><div class="li"><a href="laborator-01.html" class="wikilink1" title="so:laboratoare:laborator-01">Laborator 01 - Introducere</a></div></li>
<li class="level1"><div class="li"><a href="laborator-02.html" class="wikilink1" title="so:laboratoare:laborator-02">Laborator 02 - Operații I/O simple</a></div></li>
<li class="level1"><div class="li"><a href="laborator-03.html" class="wikilink1" title="so:laboratoare:laborator-03">Laborator 03 - Procese</a></div></li>
<li class="level1"><div class="li"><a href="laborator-04.html" class="wikilink1" title="so:laboratoare:laborator-04">Laborator 04 - Semnale</a></div></li>
<li class="level1"><div class="li"><span class="curid"><a href="laborator-05.html" class="wikilink1" title="so:laboratoare:laborator-05">Laborator 05 - Gestiunea memoriei</a></span></div></li>
<li class="level1"><div class="li"><a href="laborator-06.html" class="wikilink1" title="so:laboratoare:laborator-06">Laborator 06 - Memoria virtuală</a></div></li>
<li class="level1"><div class="li"><a href="laborator-07.html" class="wikilink1" title="so:laboratoare:laborator-07">Laborator 07 - Profiling &amp; Debugging</a></div></li>
<li class="level1"><div class="li"><a href="laborator-08.html" class="wikilink1" title="so:laboratoare:laborator-08">Laborator 08 - Thread-uri Linux</a></div></li>
<li class="level1"><div class="li"><a href="laborator-09.html" class="wikilink1" title="so:laboratoare:laborator-09">Laborator 09 - Thread-uri Windows</a></div></li>
<li class="level1"><div class="li"><a href="laborator-10.html" class="wikilink1" title="so:laboratoare:laborator-10">Laborator 10 - Operații IO avansate - Windows</a></div></li>
<li class="level1"><div class="li"><a href="laborator-11.html" class="wikilink1" title="so:laboratoare:laborator-11">Laborator 11 - Operații IO avansate - Linux</a></div></li>
<li class="level1"><div class="li"><a href="laborator-12.html" class="wikilink1" title="so:laboratoare:laborator-12">Laborator 12 - Implementarea sistemelor de fișiere</a></div></li>
</ul>
</div></div>

</div>
<!-- EDIT3 SECTION "Laboratoare" [262-322] -->
<h1 class="sectionedit4" id="cursuri">Cursuri</h1>
<div class="level1">

<div><div id="nojs_indexmenu_69975989458355ad7806f2" data-jsajax="" class="indexmenu_nojs">

<ul class="idx">
<li class="closed"><div class="li"><a href="../cursuri/curs-01.html" class="indexmenu_idx_head">Curs 01 - Introducere</a></div></li>
<li class="closed"><div class="li"><a href="../cursuri/curs-02.html" class="indexmenu_idx_head">Curs 02 - Sistemul de fișiere</a></div></li>
<li class="closed"><div class="li"><a href="../cursuri/curs-03.html" class="indexmenu_idx_head">Curs 03 - Procese</a></div></li>
<li class="closed"><div class="li"><a href="../cursuri/curs-04.html" class="indexmenu_idx_head">Curs 04 - Planificarea execuției. IPC</a></div></li>
<li class="closed"><div class="li"><a href="../cursuri/curs-05.html" class="indexmenu_idx_head">Curs 05 - Gestiunea memoriei</a></div></li>
<li class="closed"><div class="li"><a href="../cursuri/curs-06.html" class="indexmenu_idx_head">Curs 06 - Memoria virtuală</a></div></li>
<li class="closed"><div class="li"><a href="../cursuri/curs-07.html" class="indexmenu_idx_head">Curs 07 - Securitatea memoriei</a></div></li>
<li class="closed"><div class="li"><a href="../cursuri/curs-08.html" class="indexmenu_idx_head">Curs 08 - Fire de execuție</a></div></li>
<li class="closed"><div class="li"><a href="../cursuri/curs-09.html" class="indexmenu_idx_head">Curs 09 - Sincronizare</a></div></li>
<li class="closed"><div class="li"><a href="../cursuri/curs-10.html" class="indexmenu_idx_head">Curs 10 - Dispozitive de intrare/ieșire</a></div></li>
<li class="closed"><div class="li"><a href="../cursuri/curs-11.html" class="indexmenu_idx_head">Curs 11 - Networking în sistemul de operare</a></div></li>
<li class="closed"><div class="li"><a href="../cursuri/curs-12.html" class="indexmenu_idx_head">Curs 12 - Implementarea sistemelor de fișiere</a></div></li>
<li class="closed"><div class="li"><a href="../cursuri/curs-13.html" class="indexmenu_idx_head">Curs 13 - Securitatea sistemului</a></div></li>
<li class="closed"><div class="li"><a href="../cursuri/quiz/start.html" class="indexmenu_idx_head">Quizz-uri curs</a></div></li>
<li class="level1"><div class="li"><a href="../cursuri/curs-extra-2.html" class="wikilink1" title="so:cursuri:curs-extra-2">Curs extra - Android</a></div></li>
<li class="level1"><div class="li"><a href="../cursuri/curs-extra-3.html" class="wikilink1" title="so:cursuri:curs-extra-3">Curs extra - Virtualizare</a></div></li>
<li class="level1"><div class="li"><a href="../cursuri/curs-extra.html" class="wikilink1" title="so:cursuri:curs-extra">Curs extra - Sincronizarea proceselor</a></div></li>
<li class="level1"><div class="li"><a href="../cursuri/note.html" class="wikilink1" title="so:cursuri:note">Note de curs</a></div></li>
</ul>
</div></div>

</div>
<!-- EDIT4 SECTION "Cursuri" [323-374] -->
<h1 class="sectionedit5" id="teme">Teme</h1>
<div class="level1">

<div><div id="nojs_indexmenu_1925447558355ad78168c" data-jsajax="" class="indexmenu_nojs">

<ul class="idx">
<li class="closed"><div class="li"><a href="../teme/tema-asist.html" class="indexmenu_idx_head">Tema Asistenți - Guardian process</a></div></li>
<li class="level1"><div class="li"><a href="../teme/contestatii.html" class="wikilink1" title="so:teme:contestatii">Contestații</a></div></li>
<li class="level1"><div class="li"><a href="../teme/folosire-gitlab.html" class="wikilink1" title="so:teme:folosire-gitlab">Git. Indicații folosire GitLab</a></div></li>
<li class="level1"><div class="li"><a href="../teme/general.html" class="wikilink1" title="so:teme:general">Indicații generale teme</a></div></li>
<li class="level1"><div class="li"><a href="../teme/tema-1.html" class="wikilink1" title="so:teme:tema-1">Tema 1 Multi-platform Development</a></div></li>
<li class="level1"><div class="li"><a href="../teme/tema-2.html" class="wikilink1" title="so:teme:tema-2">Tema 2 Mini-shell</a></div></li>
<li class="level1"><div class="li"><a href="../teme/tema-3.html" class="wikilink1" title="so:teme:tema-3">Tema 3 Memorie virtuală</a></div></li>
<li class="level1"><div class="li"><a href="../teme/tema-4.html" class="wikilink1" title="so:teme:tema-4">Tema 4 Planificator de threaduri</a></div></li>
<li class="level1"><div class="li"><a href="../teme/tema-5.html" class="wikilink1" title="so:teme:tema-5">Tema 5 Server web asincron</a></div></li>
</ul>
</div></div>

</div>
<!-- EDIT5 SECTION "Teme" [375-] -->
</div>
<div class="toc_sidebar sidebar_box">
<!-- TOC START -->
<div id="sb__right__dw__toc">
<h3 class="toggle">Table of Contents</h3>
<div>

<ul class="toc">
<li class="level1"><div class="li"><a href="laborator-05.html#laborator_05_-_gestiunea_memoriei">Laborator 05 - Gestiunea memoriei</a></div>
<ul class="toc">
<li class="level2"><div class="li"><a href="laborator-05.html#materiale_ajutatoare">Materiale ajutătoare</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="laborator-05.html#nice_to_read">Nice to read</a></div></li>
</ul>
</li>
<li class="level2"><div class="li"><a href="laborator-05.html#gestiunea_memoriei">Gestiunea memoriei</a></div></li>
<li class="level2"><div class="li"><a href="laborator-05.html#spatiul_de_adresa_al_unui_proces">Spațiul de adresă al unui proces</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="laborator-05.html#zona_de_cod">Zona de cod</a></div></li>
<li class="level3"><div class="li"><a href="laborator-05.html#zone_de_date">Zone de date</a></div>
<ul class="toc">
<li class="level4"><div class="li"><a href="laborator-05.html#data">.data</a></div></li>
<li class="level4"><div class="li"><a href="laborator-05.html#bss">.bss</a></div></li>
<li class="level4"><div class="li"><a href="laborator-05.html#rodata">.rodata</a></div></li>
</ul>
</li>
<li class="level3"><div class="li"><a href="laborator-05.html#stiva">Stiva</a></div></li>
<li class="level3"><div class="li"><a href="laborator-05.html#heap-ul">Heap-ul</a></div></li>
</ul>
</li>
<li class="level2"><div class="li"><a href="laborator-05.html#alocareadealocarea_memoriei">Alocarea/Dealocarea memoriei</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="laborator-05.html#alocarea_memoriei_in_linux">Alocarea memoriei în Linux</a></div></li>
<li class="level3"><div class="li"><a href="laborator-05.html#alocarea_memoriei_in_windows">Alocarea memoriei în Windows</a></div></li>
</ul>
</li>
<li class="level2"><div class="li"><a href="laborator-05.html#lucru_cu_memoria_-_probleme">Lucru cu memoria - Probleme</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="laborator-05.html#acces_nevalid">Acces nevalid</a></div>
<ul class="toc">
<li class="level4"><div class="li"><a href="laborator-05.html#gdb_-_detectarea_zonei_de_acces_nevalid_de_tip_page_fault">GDB - Detectarea zonei de acces nevalid de tip page fault</a></div></li>
<li class="level4"><div class="li"><a href="laborator-05.html#mcheck_-_verificarea_consistentei_heap-ului">mcheck - verificarea consistenței heap-ului</a></div></li>
</ul>
</li>
<li class="level3"><div class="li"><a href="laborator-05.html#leak-uri_de_memorie">Leak-uri de memorie</a></div>
<ul class="toc">
<li class="level4"><div class="li"><a href="laborator-05.html#valgrind">Valgrind</a></div></li>
<li class="level4"><div class="li"><a href="laborator-05.html#mtrace">mtrace</a></div></li>
</ul>
</li>
<li class="level3"><div class="li"><a href="laborator-05.html#dubla_dealocare">Dublă dealocare</a></div></li>
<li class="level3"><div class="li"><a href="laborator-05.html#alte_utilitare_pentru_depanarea_problemelor_de_lucru_cu_memoria">Alte utilitare pentru depanarea problemelor de lucru cu memoria</a></div></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><div class="li"><a href="laborator-05.html#exercitii">Exerciții</a></div>
<ul class="toc">
<li class="level2"><div class="li"><a href="laborator-05.html#exercitiul_0_-_joc_interactiv_2p">Exercițiul 0 - Joc interactiv (2p)</a></div></li>
<li class="level2"><div class="li"><a href="laborator-05.html#linux_9p">Linux (9p)</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="laborator-05.html#exercitiul_1_-_zone_de_stocare_a_variabilelor_05p">Exercițiul 1 - Zone de stocare a variabilelor (0.5p)</a></div></li>
<li class="level3"><div class="li"><a href="laborator-05.html#exercitiul_2_-_spatiul_de_adresa_al_unui_proces_1p">Exercițiul 2 - Spațiul de adresă al unui proces (1p)</a></div></li>
<li class="level3"><div class="li"><a href="laborator-05.html#exercitiul_3_-_alocarea_realocarea_si_dezalocarea_memoriei_1p">Exercițiul 3 - Alocarea, realocarea și dezalocarea memoriei (1p)</a></div></li>
<li class="level3"><div class="li"><a href="laborator-05.html#exercitiul_4_-_rezolvarea_unei_probleme_de_tip_segmentation_fault_1p">Exercițiul 4 - Rezolvarea unei probleme de tip Segmentation Fault (1p)</a></div></li>
<li class="level3"><div class="li"><a href="laborator-05.html#exercitiul_5_-_lucru_cu_memoria_-_valgrind_1p">Exercițiul 5 - Lucru cu memoria - Valgrind (1p)</a></div></li>
<li class="level3"><div class="li"><a href="laborator-05.html#exercitiul_6_-_stack_overflow_2p">Exercițiul 6 - Stack overflow (2p)</a></div></li>
<li class="level3"><div class="li"><a href="laborator-05.html#exercitiul_7_-_detectare_probleme_de_lucru_cu_memoria_-_mcheck_1p">Exercițiul 7 - Detectare probleme de lucru cu memoria - mcheck (1p)</a></div></li>
<li class="level3"><div class="li"><a href="laborator-05.html#exercitiul_8_-_endianess_1p">Exercițiul 8 - Endianess (1p)</a></div></li>
<li class="level3"><div class="li"><a href="laborator-05.html#exercitiul_9_-_lucrul_cu_stiva_05p">Exercițiul 9 - Lucrul cu stiva (0.5p)</a></div></li>
</ul>
</li>
<li class="level2"><div class="li"><a href="laborator-05.html#exercitii_bonus_3_so_karma">Exerciții BONUS (3 SO Karma)</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="laborator-05.html#bonus_windows">BONUS Windows</a></div>
<ul class="toc">
<li class="level4"><div class="li"><a href="laborator-05.html#so_karma_-_realizarea_unui_wrapper_pentru_functiile_malloc_si_free">1 so karma - Realizarea unui wrapper pentru funcțiile malloc și free</a></div></li>
<li class="level4"><div class="li"><a href="laborator-05.html#so_karma_-_program_de_test_pentru_wrapperul_xmalloc">1 so karma - Program de test pentru wrapperul xmalloc</a></div></li>
</ul>
</li>
<li class="level3"><div class="li"><a href="laborator-05.html#bonus_linux">BONUS Linux</a></div>
<ul class="toc">
<li class="level4"><div class="li"><a href="laborator-05.html#so_karma_-_realizarea_unei_implementari_sumare_a_functiei_malloc">1 so karma - Realizarea unei implementări sumare a funcției malloc</a></div></li>
</ul>
</li>
</ul>
</li>
<li class="level2"><div class="li"><a href="laborator-05.html#solutii">Soluții</a></div></li>
<li class="level2"><div class="li"><a href="laborator-05.html#resurse_utile">Resurse utile</a></div></li>
</ul></li>
</ul>
</div>
</div>
<!-- TOC END -->
</div>
        </div>
      
    
      <div class="stylefoot">
        <div class="meta">
          <div class="user">
                    </div>
          <div class="doc">
          so/laboratoare/laborator-05.txt · Last modified: 2016/04/05 12:38 by lorena.dobrescu          </div>
        </div>
      </div>

    <div class="clearer"></div>

    
                <div class="bar" id="bar__bottom">
      <div class="bar-left">
              </div>
      <div class="bar-right">
        <a href="laborator-05%3Fdo=media&amp;ns=so%253Alaboratoare.html"  class="action media" rel="nofollow" title="Media Manager">Media Manager</a><a href="laborator-05.html#dokuwiki__top"  class="action top" accesskey="t" rel="nofollow" title="Back to top [T]">Back to top</a>      </div>
    </div>
    <div class="clearer"></div>
            
    <div align="center" class="footerinc">
  <div class="license"><a href="http://creativecommons.org/licenses/by-sa/3.0/" rel="license"><img src="../../lib/images/license/button/cc-by-sa.png" alt="CC Attribution-Share Alike 3.0 Unported" /></a></div>
  <a target="_blank" href="http://www.chimeric.de" title="www.chimeric.de"><img src="../../lib/tpl/arctic/images/button-chimeric-de.png" width="80" height="15" alt="www.chimeric.de" border="0" /></a>

  <a target="_blank" href="http://jigsaw.w3.org/css-validator/check/referer" title="Valid CSS"><img src="../../lib/tpl/arctic/images/button-css.png" width="80" height="15" alt="Valid CSS" border="0" /></a>

  <a target="_blank" href="http://wiki.splitbrain.org/wiki:dokuwiki" title="Driven by DokuWiki"><img src="../../lib/tpl/arctic/images/button-dw.png" width="80" height="15" alt="Driven by DokuWiki" border="0" /></a>

  <a target="_blank" href="http://www.firefox-browser.de" title="do yourself a favour and use a real browser - get firefox"><img src="../../lib/tpl/arctic/images/button-firefox.png" width="80" height="15" alt="do yourself a favour and use a real browser - get firefox!!" border="0" /></a>
  
  <a target="_blank" href="../../feed.php" title="Recent changes RSS feed"><img src="../../lib/tpl/arctic/images/button-rss.png" width="80" height="15" alt="Recent changes RSS feed" border="0" /></a>

  <a target="_blank" href="http://validator.w3.org/check/referer" title="Valid XHTML 1.0"><img src="../../lib/tpl/arctic/images/button-xhtml.png" width="80" height="15" alt="Valid XHTML 1.0" border="0" /></a>
</div>

  </div>
</div>

<div class="no"><img src="../../lib/exe/indexer.php%3Fid=so%253Alaboratoare%253Alaborator-05&amp;1479891671" width="2" height="1" alt="" /></div>
</body>
</html>
