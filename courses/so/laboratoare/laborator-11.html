    
    

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"
 lang="en" dir="ltr">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>
    Laborator 11 - Operații IO avansate - Linux    [CS Open CourseWare]
  </title>

  <meta name="generator" content="DokuWiki"/>
<meta name="robots" content="index,follow"/>
<meta name="date" content="2016-05-11T23:32:16+0300"/>
<meta name="keywords" content="so,laboratoare,laborator-11"/>
<link rel="search" type="application/opensearchdescription+xml" href="../../lib/exe/opensearch.php" title="CS Open CourseWare"/>
<link rel="start" href="../../../courses.1.html"/>
<link rel="alternate" type="application/rss+xml" title="Recent Changes" href="../../feed.php"/>
<link rel="alternate" type="application/rss+xml" title="Current Namespace" href="../../feed.php%3Fmode=list&amp;ns=so:laboratoare"/>
<link rel="alternate" type="text/html" title="Plain HTML" href="../../_export/xhtml/so/laboratoare/laborator-11.html"/>
<link rel="canonical" href="laborator-11.html"/>
<link rel="stylesheet" type="text/css" href="../../lib/exe/css.php%3Ft=arctic&amp;tseed=1476798676.css"/>
<script type="text/javascript">/*<![CDATA[*/var NS='so:laboratoare';var JSINFO = {"id":"so:laboratoare:laborator-11","namespace":"so:laboratoare","isadmin":0,"isauth":0};
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="../../lib/exe/js.php%3Ftseed=1476798676"></script>
<script type="text/x-mathjax-config">/*<![CDATA[*/MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ["$","$"], ["\\(","\\)"] ],
        displayMath: [ ["$$","$$"], ["\\[","\\]"] ],
        processEscapes: true
    }
});
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
<script type="text/javascript">/*<![CDATA[*/
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
		  
/*!]]>*/</script>
<script type="text/javascript">/*<![CDATA[*/
var pageTracker = _gat._getTracker("UA-38383934-1");
pageTracker._initData();
pageTracker._trackPageview();
		  
/*!]]>*/</script>

  <link rel="shortcut icon" href="../../lib/tpl/arctic/images/favicon.ico" />

  
</head>
<body>
<div id="wrapper" class='show'>
  <div class="dokuwiki">

    
    <div class="stylehead">
      <div class="header">
        <div class="pagename">
          <a href="http://ocw.cs.pub.ro/courses/so/"><img height="70" src="../../res/sigla_so.png"/> </a>        </div>
        <div class="logo">
          <a style="color: #AAA !important;" href="../../systems/index.html"/><img height="70" src="../../res/systems.png" name="dokuwiki__top"/></a>        </div>
      </div>
    
       
      <div class="breadcrumbs">
              </div>
      
            </div>

                  <div class="bar" id="bar__top">
        <div class="bar-left">
                  </div>
        <div class="bar-right">
          <a href="laborator-11%3Fdo=recent.html"  class="action recent" accesskey="r" rel="nofollow" title="Recent changes [R]">Recent changes</a><a href="laborator-11%3Fdo=login&amp;sectok=f62420cf5b01253da4b50505d148181b.html"  class="action login" rel="nofollow" title="Login">Login</a>        </div>
    </div>
        
    
    
    
              <div class="left_page">
          
<h1 class="sectionedit1" id="laborator_11_-_operatii_io_avansate_-_linux">Laborator 11 - Operații IO avansate - Linux</h1>
<div class="level1">

</div>

<h2 class="sectionedit2" id="materiale_ajutatoare">Materiale Ajutătoare</h2>
<div class="level2">
<ul>
<li class="level1"><div class="li"> <a href="http://elf.cs.pub.ro/so/res/laboratoare/lab11-slides.pdf" class="urlextern" title="http://elf.cs.pub.ro/so/res/laboratoare/lab11-slides.pdf"  rel="nofollow"> lab11-slides.pdf</a></div>
</li>
<li class="level1"><div class="li"> <a href="../../lib/exe/fetch.php%3Fhash=ebc2b7&amp;media=http%253A%252F%252Felf.cs.pub.ro%252Fso%252Fres%252Flaboratoare%252Flab11-refcard.pdf" class="urlextern" title="http://elf.cs.pub.ro/so/res/laboratoare/lab11-refcard.pdf"  rel="nofollow"> lab11-refcard.pdf</a></div>
</li>
</ul>

</div>

<h2 class="sectionedit3" id="nice_to_read">Nice to read</h2>
<div class="level2">
<ul>
<li class="level1"><div class="li"> TLPI - Chapter 63, Alternative I/O models</div>
</li>
</ul>

</div>

<h2 class="sectionedit4" id="linux_-_multiplexarea_io">Linux - multiplexarea I/O</h2>
<div class="level2">

<p>
Există situații în care un program trebuie să trateze operațiile I/O de pe mai multe canale ori de câte ori acestea apar. Un astfel de exemplu este un program de tip server care folosește mecanisme precum pipe-uri sau sockeţi pentru comunicarea cu alte procese. Un program trebuie să citească practic simultan informații atât de la intrarea standard cât și de la un socket (sau mai mulți). 
</p>

<p>
În aceste situații nu pot fi folosite operații obișnuite de citire sau scriere. Folosirea acestor operații are drept consecință blocarea thread-ului curent până la încheierea operației. O posibilă soluție este folosirea de operații non-blocante (spre exemplu folosirea flag-ul <code>O_NONBLOCK</code>) și interogarea succesivă a descriptorilor de fișier. Totuși, interogarea succesivă (polling) este o formă de <em>busy waiting</em> și este ineficientă. 
</p>
<div class="hiddenGlobal  hiddenActive"><div class="hiddenElements"></div><div class="hiddenHead  hiddenSinceBeginning"><div class="hiddenOnHidden">
<p>
Flag-ul O_NONBLOCK
</p>
</div><div class="hiddenOnVisible">
<p>
Flag-ul O_NONBLOCK
</p>
</div></div> <!-- .hiddenHead --><div class="hiddenBody">
<p>
Atunci când un fișier este deschis ( folosind apelul <code>open</code>) cu flag-ul <code>O_NONBLOCK</code> operațiile pe acel descriptor de fișier nu se vor bloca în așteptarea terminării operației. În acest caz apelul <code>read</code> va întoarce -1 și <code>errno</code> este setat la valoarea <code>EAGAIN</code> sau <code>EWOULDBLOCK</code> dacă nu sunt date de citit. Asemănător în cazul apelului <code>write</code>.
</p>
</div></div>
<p>
Soluția este folosirea unor mecanisme care permit unui thread să aștepte producerea unui eveniment I/O pe un set de descriptori. Thread-ul se va bloca până când unul dintre descriptorii din set poate fi folosit pentru citire/scriere. Un server care folosește un mecanism de acest tip are, de obicei, o structură de forma: 
</p>
<pre class="code c">set <span class="sy0">=</span> setul de descriptori urmăriți
<span class="kw1">while</span> <span class="br0">&#40;</span><span class="kw2">true</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
    așteaptă producerea unui eveniment pe unul dintre descriptori
    pentru fiecare descriptor pe care s<span class="sy0">-</span>a produs un eveniment I<span class="sy0">/</span>O <span class="br0">&#123;</span>
        tratează evenimentul I<span class="sy0">/</span>O
    <span class="br0">&#125;</span>
<span class="br0">&#125;</span></pre>

<p>
Detaliile variază de la o implementare la alta, dar secvența de pseudocod de mai sus reprezintă structura de bază pentru serverele care folosesc <em>multiplexarea I/O</em>. 
</p>

</div>

<h3 class="sectionedit5" id="select">select</h3>
<div class="level3">

<p>
O primă soluție este utilizarea funcțiilor <a href="http://linux.die.net/man/2/select" class="urlextern" title="http://linux.die.net/man/2/select"  rel="nofollow"> select</a> sau <a href="http://linux.die.net/man/2/select" class="urlextern" title="http://linux.die.net/man/2/select"  rel="nofollow"> pselect</a>. Folosirea acestor funcții conduce la blocarea thread-ului curent până la producerea unui eveniment I/O pe un set de descriptori de fișier, a unei erori pe set sau până la expirarea unui timer.
</p>

<p>
Funcțiile folosesc un set de descriptori de fișier pentru a preciza fișierele/sockeţii pe care thread-ul curent va aștepta producerea evenimentelor I/O. Tipul de date folosit pentru definirea acestui set este <code>fd_set</code>, care este, de obicei, o mască de biți. 
</p>

<p>
Funcțiile <code>select</code> și <code>pselect</code> sunt definite conform POSIX.1-2001 în <code>sys/select.h</code>
</p>
<pre class="code c"><span class="co2">#include &lt;sys/select.h&gt;</span>
&nbsp;
<span class="kw4">int</span> select<span class="br0">&#40;</span>
     <span class="kw4">int</span> nfds<span class="sy0">,</span> 
     fd_set <span class="sy0">*</span>readfds<span class="sy0">,</span> 
     fd_set <span class="sy0">*</span>writefds<span class="sy0">,</span> 
     fd_set <span class="sy0">*</span>exceptfds<span class="sy0">,</span> 
     <span class="kw4">struct</span> timeval <span class="sy0">*</span>timeout
<span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>
Nu vom insista asupra apelului <code>select</code>, căci standardul POSIX specifică un alt apel, <code>poll</code>, ce oferă o performanţă mai bună.
</p>

<p>
Avantaje:
</p>
<ul>
<li class="level1"><div class="li"> simplitate;</div>
</li>
<li class="level2"><div class="li"> portabilitate: funcția select este disponibilă chiar și in <abbr title="Application Programming Interface">API</abbr>-ul Win32; </div>
</li>
</ul>

<p>
Dezavantaje:
</p>
<ul>
<li class="level1"><div class="li"> lungimea setul de descriptori este definită cu ajutorul lui FD_SETSIZE, și implicit are valoarea 64;</div>
</li>
<li class="level2"><div class="li"> este necesar ca seturile de descriptori să fie reconstruite la fiecare apel <code>select</code>;</div>
</li>
<li class="level2"><div class="li"> la apariția unui eveniment pe unul dintre descriptori, toți descriptorii puși în set înainte de <code>select</code> trebuie testați pentru a vedea pe care dintre ei a apărut evenimentul;</div>
</li>
<li class="level2"><div class="li"> la fiecare apel, același set de descriptori este transmis în kernel.</div>
</li>
</ul>

</div>

<h3 class="sectionedit6" id="poll">poll</h3>
<div class="level3">

<p>
Funcția <a href="http://linux.die.net/man/2/poll" class="urlextern" title="http://linux.die.net/man/2/poll"  rel="nofollow">poll</a> consolidează argumentele funcției <code>select</code> și permite notificarea pentru o gamă mai largă de evenimente. Funcția se definește ca mai jos: 
</p>
<pre class="code c"><span class="co2">#include &lt;sys/poll.h&gt;</span>
&nbsp;
<span class="kw4">int</span> poll<span class="br0">&#40;</span>
     <span class="kw4">struct</span> pollfd <span class="sy0">*</span>ufds<span class="sy0">,</span> 
     <span class="kw4">unsigned</span> <span class="kw4">int</span> nfds<span class="sy0">,</span> 
     <span class="kw4">int</span> timeout
<span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>
Timeout-ul este specificat în milisecunde. În caz de valoare negativă, semnificația este de așteptare pentru o perioadă nedefinită (“infinit”).
</p>

<p>
Structura <code>pollfd</code> este definită în <code>sys/poll.h</code>: 
</p>
<pre class="code c"><span class="co2">#include &lt;sys/poll.h&gt;</span>
&nbsp;
<span class="kw4">struct</span> pollfd <span class="br0">&#123;</span>
     <span class="kw4">int</span> fd<span class="sy0">;</span>        <span class="coMULTI">/* file descriptor */</span>
     <span class="kw4">short</span> events<span class="sy0">;</span>  <span class="coMULTI">/* evenimente solicitate */</span>
     <span class="kw4">short</span> revents<span class="sy0">;</span> <span class="coMULTI">/* evenimente apărute */</span>
<span class="br0">&#125;</span><span class="sy0">;</span></pre>

<p>
Funcția <code>poll</code> permite astfel așteptarea evenimentelor descrise de vectorul <code>ufds</code> de dimensiune <code>nfds</code>.
</p>

<p>
În cadrul structurii <code>pollfd</code> avem:
</p>
<ul>
<li class="level1"><div class="li"> <code>events</code> este o mască de biți în care se specifică evenimentele urmărite de <code>poll</code> pentru descriptorul <code>fd</code> (<code>POLLIN</code> - există date ce pot fi citite, <code>POLLOUT</code> - se pot scrie date). </div>
</li>
<li class="level1"><div class="li"> <code>revents</code> este, de asemenea, o mască de biți completată de kernel cu evenimentele apărute în momentul în care apelul se întoarce (<code>POLLIN</code>, <code>POLLOUT</code>) sau cu valori predefinite (<code>POLLERR</code>, <code>POLLHUP</code>, <code>POLLNVAL</code>) pentru situații speciale.</div>
</li>
</ul>

<p>
În caz de succes, funcția returnează un număr diferit de zero reprezentând numărul de structuri pentru care <code>revents</code> nu e zero (cu alte cuvinte toți descriptorii cu evenimente sau erori). Se returnează 0 dacă a expirat timpul (timeout milisecunde) și nu a fost selectat nici un descriptor. În caz de eroare se returnează -1 și se setează errno. De asemenea, funcția <code>poll</code> poate fi întreruptă de semnale, caz în care va întoarce -1 și errno va fi setat la <code>EINTR</code>.
</p>

<p>
Un exemplu de utilizare pentru <code>poll</code> este prezentat în continuare: 
</p>
<pre class="code c"><span class="co2">#define MAX_PFDS        32</span>
&nbsp;
<span class="br0">&#91;</span>...<span class="br0">&#93;</span>
<span class="kw4">struct</span> pollfd pfds<span class="br0">&#91;</span>MAX_PFDS<span class="br0">&#93;</span><span class="sy0">;</span>
<span class="kw4">int</span> nfds<span class="sy0">;</span>
<span class="kw4">int</span> listenfd<span class="sy0">,</span> sockfd<span class="sy0">;</span>        <span class="coMULTI">/* listener socket; connection socket */</span>
&nbsp;
nfds <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
&nbsp;
<span class="coMULTI">/* read user data from standard input */</span>
pfds<span class="br0">&#91;</span>nfds<span class="br0">&#93;</span>.<span class="me1">fd</span> <span class="sy0">=</span> STDIN_FILENO<span class="sy0">;</span>
pfds<span class="br0">&#91;</span>nfds<span class="br0">&#93;</span>.<span class="me1">events</span> <span class="sy0">=</span> POLLIN<span class="sy0">;</span>
nfds<span class="sy0">++;</span>
&nbsp;
<span class="coMULTI">/* TODO ...  create server socket (listener) */</span>
&nbsp;
<span class="coMULTI">/* add listener socket */</span>
pfds<span class="br0">&#91;</span>nfds<span class="br0">&#93;</span>.<span class="me1">fd</span> <span class="sy0">=</span> listenfd
pfds<span class="br0">&#91;</span>nfds<span class="br0">&#93;</span>.<span class="me1">events</span> <span class="sy0">=</span> POLLIN<span class="sy0">;</span>
nfds<span class="sy0">++;</span>
&nbsp;
<span class="kw1">while</span> <span class="br0">&#40;</span><span class="nu0">1</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>        <span class="coMULTI">/* server loop */</span>
    <span class="coMULTI">/* wait for readiness notification */</span>
    poll<span class="br0">&#40;</span>pfds<span class="sy0">,</span> nfds<span class="sy0">,</span> <span class="sy0">-</span><span class="nu0">1</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
    <span class="kw1">if</span> <span class="br0">&#40;</span><span class="br0">&#40;</span>pfds<span class="br0">&#91;</span><span class="nu0">1</span><span class="br0">&#93;</span>.<span class="me1">revents</span> <span class="sy0">&amp;</span> POLLIN<span class="br0">&#41;</span> <span class="sy0">!=</span> <span class="nu0">0</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        <span class="coMULTI">/* TODO ... handle new connection */</span>
    <span class="br0">&#125;</span>
    <span class="kw1">else</span> <span class="kw1">if</span> <span class="br0">&#40;</span><span class="br0">&#40;</span>pfds<span class="br0">&#91;</span><span class="nu0">0</span><span class="br0">&#93;</span>.<span class="me1">revents</span> <span class="sy0">&amp;</span> POLLIN<span class="br0">&#41;</span> <span class="sy0">!=</span> <span class="nu0">0</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        <span class="coMULTI">/* TODO ... read user data from standard input */</span>
    <span class="br0">&#125;</span>
    <span class="kw1">else</span> <span class="br0">&#123;</span>
        <span class="coMULTI">/* TODO ... handle message on connection sockets */</span>
    <span class="br0">&#125;</span>
<span class="br0">&#125;</span>
<span class="br0">&#91;</span>...<span class="br0">&#93;</span></pre>

<p>
Avantaje <code>poll</code>:
</p>
<ul>
<li class="level1"><div class="li"> transmiterea setului de descriptori este mai simplă decât în cazul funcției <code>select</code>;</div>
</li>
<li class="level1"><div class="li"> setul de descriptori nu trebuie reconstruit la fiecare apel <code>poll</code>.</div>
</li>
</ul>

<p>
Dezavantaje <code>poll</code>:
</p>
<ul>
<li class="level1"><div class="li"> ineficiență - la apariția unui eveniment, trebuie parcurs tot setul de descriptori pentru a găsi descriptorul pe care a apărut evenimentul;</div>
</li>
<li class="level1"><div class="li"> la fiecare apel, același set de descriptori (care poate fi mare) este copiat în kernel și înapoi. </div>
</li>
</ul>

</div>

<h3 class="sectionedit7" id="epoll">epoll</h3>
<div class="level3">

<p>
Funcțiile <code>select</code> și <code>poll</code> nu sunt scalabile la un număr mare de conexiuni pentru că la fiecare apel al lor trebuie transmisă toată lista de descriptori. În astfel de situații, la fiecare pas, trebuie construită lista de descriptori și apelat <code>poll</code> sau <code>select</code> care copiază tot setul în kernel. La apariția unui eveniment va fi marcat corespunzător descriptorul. Utilizatorul trebuie să parcurgă tot setul de descriptori pentru a-și da seama pe care dintre ei a apărut evenimentul. În acest fel se ajunge să se petreacă tot mai mult timp scanând după evenimente în setul de descriptori și tot mai puțin timp făcând I/O. 
</p>

<p>
Din acest motiv, diverse sisteme au implementat interfețe scalabile, dar non-portabile:
</p>
<ul>
<li class="level1"><div class="li"> <code>/dev/poll</code> pe Solaris;</div>
</li>
<li class="level1"><div class="li"> <code>kqueue</code> pe FreeBSD;</div>
</li>
<li class="level1"><div class="li"> <code>epoll</code> pe Linux. </div>
</li>
</ul>

<p>
Aceste interfețe rezolvă problemele asociate cu <code>select</code> și <code>poll</code>, dar  și problemele de scalabilitate.
</p>

<p>
Pentru a folosi <a href="http://linux.die.net/man/4/epoll" class="urlextern" title="http://linux.die.net/man/4/epoll"  rel="nofollow">epoll</a>, trebuie inclus <code>sys/epoll.h</code>. 
Interfața <code>epoll</code> oferă funcții pentru:
</p>
<ul>
<li class="level1"><div class="li"> crearea unui obiect <code>epoll</code> (<code>epoll_create</code>);</div>
</li>
<li class="level1"><div class="li"> adăugarea sau eliminarea de descriptori de fișiere/sockeți la obiectul epoll (<code>epoll_ctl</code>);</div>
</li>
<li class="level1"><div class="li"> așteptarea unui eveniment pe unul dintre descriptori (<code>epoll_wait</code>). </div>
</li>
</ul>

</div>

<h3 class="sectionedit8" id="crearea_unui_obiect_epoll">Crearea unui obiect epoll</h3>
<div class="level3">

<p>
Pentru crearea unui obiect <code>epoll</code> se folosește funcția <a href="http://linux.die.net/man/2/epoll_create" class="urlextern" title="http://linux.die.net/man/2/epoll_create"  rel="nofollow">epoll_create</a>: 
</p>
<pre class="code c"><span class="kw4">int</span> epoll_create<span class="br0">&#40;</span><span class="kw4">int</span> size<span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>
Apelul <code>epoll_create</code> facilitează crearea unui descriptor de fișier ce va fi ulterior folosit pentru așteptarea de evenimente. Descriptorul întors va trebui la final închis folosind apelul <code>close</code>.
</p>

<p>
Argumentul <code>size</code> este ignorat în versiunile recente ale nucleului, acesta ajustând dinamic dimensiunea setului de descriptori asociat obiectului <code>epoll</code>. 
</p>

</div>

<h3 class="sectionedit9" id="adaugareaeliminarea_descriptorilor_lade_la_obiectul_epoll">Adăugarea/eliminarea descriptorilor la/de la obiectul epoll</h3>
<div class="level3">

<p>
Operațiile de adăugare/eliminare de descriptori se realizează cu ajutorul funcției <a href="http://linux.die.net/man/2/epoll_ctl" class="urlextern" title="http://linux.die.net/man/2/epoll_ctl"  rel="nofollow">epoll_ctl</a>: 
</p>
<pre class="code c"><span class="kw4">int</span> epoll_ctl<span class="br0">&#40;</span>
     <span class="kw4">int</span> epollfd<span class="sy0">,</span> 
     <span class="kw4">int</span> op<span class="sy0">,</span> 
     <span class="kw4">int</span> fd<span class="sy0">,</span> 
     <span class="kw4">struct</span> epoll_event <span class="sy0">*</span>event
<span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>
Apelul <code>epoll_ctl</code> permite specificarea evenimentelor care vor fi așteptate. 
</p>

<p>
Primul argument al apelului <code>epoll_ctl</code> (epollfd) este descriptorul întors de <code>epoll_create</code>.
</p>

<p>
Câmpul <code>event</code> descrie evenimentul asociat descriptorului <code>fd</code> care poate fi adăugat, șters sau modificat în funcție de valoarea argumentului op:
</p>
<ul>
<li class="level1"><div class="li"> <code>EPOLL_CTL_ADD</code>: pentru adăugare;</div>
</li>
<li class="level2"><div class="li"> <code>EPOLL_CTL_MOD</code>: pentru modificare;</div>
</li>
<li class="level2"><div class="li"> <code>EPOLL_CTL_DEL</code>: pentru ștergere. </div>
</li>
</ul>

<p>
Structura <code>epoll_event</code> specifică evenimentele așteptate:
</p>
<pre class="code c"><span class="kw4">typedef</span> <span class="kw4">union</span> epoll_data <span class="br0">&#123;</span>
     <span class="kw4">void</span> <span class="sy0">*</span>ptr<span class="sy0">;</span>              <span class="coMULTI">/* Pointer to user-defined data */</span>
     <span class="kw4">int</span> fd<span class="sy0">;</span>                 <span class="coMULTI">/* File descriptor */</span>
     __uint32_t u32<span class="sy0">;</span>         <span class="coMULTI">/* 32-bit integer */</span>
     __uint64_t u64<span class="sy0">;</span>         <span class="coMULTI">/* 64-bit integer */</span>
<span class="br0">&#125;</span> epoll_data_t<span class="sy0">;</span>
&nbsp;
<span class="kw4">struct</span> epoll_event <span class="br0">&#123;</span>
     __uint32_t events<span class="sy0">;</span>      <span class="coMULTI">/* Epoll events (bit mask) */</span>
     epoll_data_t data<span class="sy0">;</span>      <span class="coMULTI">/* User data*/</span>
<span class="br0">&#125;</span><span class="sy0">;</span></pre>

<p>
Exemple de evenimente:
</p>
<ul>
<li class="level1"><div class="li"> <code>EPOLLIN</code> - fișierul este disponibil pentru citire, </div>
</li>
<li class="level2"><div class="li"> <code>EPOLLOUT</code> - fișierul este disponibil pentru scriere.</div>
</li>
</ul>

</div>

<h3 class="sectionedit10" id="asteptarea_unui_eveniment_io">Așteptarea unui eveniment I/O</h3>
<div class="level3">

<p>
Thread-ul curent așteaptă producerea unui eveniment I/O la unul dintre descriptorii asociați obiectului <code>epoll</code> prin intermediul funcției <a href="http://linux.die.net/man/2/epoll_wait" class="urlextern" title="http://linux.die.net/man/2/epoll_wait"  rel="nofollow">epoll_wait</a>:
</p>
<pre class="code c"><span class="kw4">int</span> epoll_wait<span class="br0">&#40;</span>
     <span class="kw4">int</span> epollfd<span class="sy0">,</span> 
     <span class="kw4">struct</span> epoll_event<span class="sy0">*</span> events<span class="sy0">,</span> 
     <span class="kw4">int</span> maxevents<span class="sy0">,</span> 
     <span class="kw4">int</span> timeout
<span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>
Funcția <code>epoll_wait</code> este echivalentul funcțiilor <code>select</code> și <code>poll</code>. Este folosită pentru așteptarea unui eveniment la unul din descriptorii asociați obiectului <code>epoll</code>.
</p>

<p>
La revenirea apelului, utilizatorul nu va trebui să parcurgă toți descriptorii configurați, ci numai cei care au evenimente produse. Argumentul <code>events</code> va marca o zonă de memorie unde vor fi plasate maxim <code>maxevents</code> evenimente de nucleu. Presupunând că valoarea câmpului <code>timeout</code> este -1 (așteptare nedefinită), apelul se va întoarce imediat dacă există evenimente asociate, sau se va bloca până la apariția unui eveniment.
</p>

<p>
La fel ca și în cazul <code>select/pselect</code> și <code>poll/ppoll</code>, există apelul <code>epoll_pwait</code> care permite precizarea unei măști de semnale. 
</p>

</div>

<h3 class="sectionedit11" id="edge-triggered_sau_level-triggered">Edge-triggered sau level-triggered</h3>
<div class="level3">

<p>
Interfața <code>epoll</code> are două comportamente posibile: <code>edge-triggered</code> sau <code>level-triggered</code>. Se poate folosi unul sau altul, în funcție de prezența flag-ului <code>EPOLLET</code> la adăugarea unui descriptor în lista <code>epoll</code>.
</p>

<p>
Presupunem existența unui socket funcționând în mod <code>non-blocant</code> pe care sosesc 100 de octeți. În ambele moduri (edge sau level triggered) <code>epoll_wait</code> va raporta <code>EPOLLIN</code> pentru acel socket.
</p>

<p>
Vom presupune că se citesc 50 de octeți din cei 100 primiți. Diferența între cele două moduri de funcționare apare la un nou apel epoll_wait. În modul level-triggered se va raporta imediat EPOLLIN. În modul edge-triggered nu se va mai raporta nimic, nici măcar la sosirea unor noi date pe socket. Se poate observa cum modul edge-triggered sesizează schimbarea stării descriptorului în relație cu evenimentul, iar level-triggered prezența stării. Modul edge-triggered este implementat mai eficient în kernel, chiar dacă pare mai greu de folosit.
</p>

<p>
În continuare, în cele două spoilere de mai jos, sunt prezentate câteva reguli care trebuie urmărite cu o metodă sau alta. Pentru ambele metode este recomandată folosirea sockeților în modul non-blocant. 
</p>
<div class="hiddenGlobal  hiddenActive"><div class="hiddenElements"></div><div class="hiddenHead  hiddenSinceBeginning"><div class="hiddenOnHidden">
<p>
Level-triggered
</p>
</div><div class="hiddenOnVisible">
<p>
Level-triggered
</p>
</div></div> <!-- .hiddenHead --><div class="hiddenBody"><ul>
<li class="level1"><div class="li"> La apariția unui eveniment EPOLLIN se poate citi oricât, la următorul apel epoll_wait se va raporta din nou EPOLLIN dacă mai sunt date de citit.</div>
</li>
<li class="level5"><div class="li"> EPOLLOUT nu trebuie configurat inițial pentru un socket pentru că astfel epoll_wait va raporta imediat că este loc de scris în buffer (inițial bufferul de scriere asociat cu socketul este gol). Acesta este o formă deghizată de busy waiting. Folosirea corectă implică scrierea normală pe socket și numai dacă la un moment dat funcțiile de scriere raportează că nu mai este loc de scriere in buffer (EAGAIN), se va activa EPOLLOUT pe descriptorul respectiv și salva ce mai este de scris. Când în sfârșit se face loc, se va raporta EPOLLOUT și atunci se poate încerca să se scrie datele păstrate. Dacă se reușește scrierea lor integrală, trebuie eliminat flagul EPOLLOUT pentru a nu intra într-un nou ciclu de busy-waiting. În concluzie, EPOLLOUT trebuie activat doar când nu se reușește scrierea integrală a datelor și scos imediat după ce acestea au fost scrise. </div>
</li>
</ul>


</div></div>
<p>
<br/>

 
</p>
<div class="hiddenGlobal  hiddenActive"><div class="hiddenElements"></div><div class="hiddenHead  hiddenSinceBeginning"><div class="hiddenOnHidden">
<p>
Edge-triggered
</p>
</div><div class="hiddenOnVisible">
<p>
Edge-triggered
</p>
</div></div> <!-- .hiddenHead --><div class="hiddenBody"><ul>
<li class="level1"><div class="li"> La apariția unui eveniment EPOLLIN pe un descriptor, trebuie citit tot ce se poate citi înainte de reapelarea epoll_wait, altfel nu va mai fi raportat EPOLLIN niciodată.</div>
</li>
<li class="level5"><div class="li"> Pentru scrierea folosind edge-triggered se poate activa de la început EPOLLOUT. Aceasta va cauza apariția unui eveniment EPOLLOUT imediat după apelarea epoll_wait (pentru că bufferul de scriere este gol) care ar trebui ignorat. La următorul apel epoll_wait nu se mai generează EPOLLOUT pentru că nu s-a schimbat starea de la ultimul apel. Dacă la un moment dat se încearcă scrierea unor date pe socket și acestea nu pot fi scrise integral, la următorul epoll_wait se generează EPOLLOUT, pentru că s-a schimbat starea socketului. Mai pe scurt, asta are ca efect faptul că nu mai trebuie activat/deactivat EPOLLOUT ca în cazul level-triggered. </div>
</li>
</ul>


</div></div>
</div>

<h3 class="sectionedit12" id="exemplu_folosire_epoll">Exemplu folosire epoll</h3>
<div class="level3">

<p>
Mai jos este prezentat un exemplu de utilizare a <code>epoll</code> echivalent cu exemplele pentru select și poll (server care multiplexează mai multe conexiuni pe sockeți și intrarea standard): 
</p>
<pre class="code c"><span class="co2">#define EPOLL_INIT_BACKSTORE        2</span>
&nbsp;
<span class="br0">&#91;</span>...<span class="br0">&#93;</span>
<span class="kw4">int</span> listenfd<span class="sy0">,</span> sockfd<span class="sy0">;</span>        <span class="coMULTI">/* listener socket; connection socket */</span>
<span class="kw4">struct</span> epoll_event ev<span class="sy0">;</span>
&nbsp;
<span class="coMULTI">/* create epoll descriptor */</span>
epfd <span class="sy0">=</span> epoll_create<span class="br0">&#40;</span>EPOLL_INIT_BACKSTORE<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
<span class="coMULTI">/* read user data from standard input */</span>
ev.<span class="me1">data</span>.<span class="me1">fd</span> <span class="sy0">=</span> STDIN_FILENO<span class="sy0">;</span>        <span class="coMULTI">/* key is file descriptor */</span>
ev.<span class="me1">events</span> <span class="sy0">=</span> EPOLLIN<span class="sy0">;</span>
epoll_ctl<span class="br0">&#40;</span>epfd<span class="sy0">,</span> EPOLL_CTL_ADD<span class="sy0">,</span> STDIN_FILENO<span class="sy0">,</span> <span class="sy0">&amp;</span>ev<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
<span class="coMULTI">/* TODO ...  create server socket (listener) */</span>
&nbsp;
<span class="coMULTI">/* add listener socket */</span>
ev.<span class="me1">data</span>.<span class="me1">fd</span> <span class="sy0">=</span> listenfd<span class="sy0">;</span>        <span class="coMULTI">/* key is file descriptor */</span>
ev.<span class="me1">events</span> <span class="sy0">=</span> EPOLLIN<span class="sy0">;</span>
epoll_ctl<span class="br0">&#40;</span>epfd<span class="sy0">,</span> EPOLL_CTL_ADD<span class="sy0">,</span> listenfd<span class="sy0">,</span> <span class="sy0">&amp;</span>ev<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
<span class="kw1">while</span> <span class="br0">&#40;</span><span class="nu0">1</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>        <span class="coMULTI">/* server loop */</span>
    <span class="kw4">struct</span> epoll_event ret_ev<span class="sy0">;</span>
&nbsp;
    <span class="coMULTI">/* wait for readiness notification */</span>
    epoll_wait<span class="br0">&#40;</span>epfd<span class="sy0">,</span> <span class="sy0">&amp;</span>ret_ev<span class="sy0">,</span> <span class="nu0">1</span><span class="sy0">,</span> <span class="sy0">-</span><span class="nu0">1</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
    <span class="kw1">if</span> <span class="br0">&#40;</span><span class="br0">&#40;</span>rev_ev.<span class="me1">data</span>.<span class="me1">fd</span> <span class="sy0">==</span> listenfd <span class="sy0">&amp;&amp;</span> <span class="br0">&#40;</span><span class="br0">&#40;</span>ret_ev.<span class="me1">events</span> <span class="sy0">&amp;</span> EPOLLIN<span class="br0">&#41;</span> <span class="sy0">!=</span> <span class="nu0">0</span><span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        <span class="coMULTI">/* TODO ... handle new connection */</span>
    <span class="br0">&#125;</span>
    <span class="kw1">else</span> <span class="kw1">if</span> <span class="br0">&#40;</span><span class="br0">&#40;</span>rev_ev.<span class="me1">data</span>.<span class="me1">fd</span> <span class="sy0">==</span> STDIN_FILENO <span class="sy0">&amp;&amp;</span>
                    <span class="br0">&#40;</span><span class="br0">&#40;</span>ret_ev.<span class="me1">events</span> <span class="sy0">&amp;</span> EPOLLIN<span class="br0">&#41;</span> <span class="sy0">!=</span> <span class="nu0">0</span><span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        <span class="coMULTI">/* TODO ... read user data from standard input */</span>
    <span class="br0">&#125;</span>
    <span class="kw1">else</span> <span class="br0">&#123;</span>
        <span class="coMULTI">/* TODO ... handle message on connection sockets */</span>
    <span class="br0">&#125;</span>
<span class="br0">&#125;</span>
<span class="br0">&#91;</span>...<span class="br0">&#93;</span></pre>

</div>

<h2 class="sectionedit13" id="linux_-_generalizarea_multiplexarii">Linux - generalizarea multiplexării</h2>
<div class="level2">

<p>
O problemă a funcțiilor de multiplexare de mai sus (<code>select</code>, <code>poll</code>, <code>epoll</code>) este aceea că sunt limitate la descriptori de fișier. Altfel spus, se pot aștepta doar evenimente asociate cu un fișier/socket: gata de citire, gata de scriere. De multe ori însă se dorește să existe un punct comun de așteptare a unui semnal, a unui semafor, a unui proces, a unei operații de intrare/ieșire, a unui timer. În Windows, acest lucru se poate realiza cu ajutorul funcției <code>WaitForMultipleObjects</code> datorită faptului că majoritatea mecanismelor din Windows sunt folosite cu ajutorul tipului de date <code>HANDLE</code>. 
</p>

</div>

<h3 class="sectionedit14" id="eventfd">eventfd</h3>
<div class="level3">

<p>
Pentru a asigura în Linux posibilitatea așteptării de evenimente multiple s-a definit interfața <code>eventfd</code>. Cu ajutorul acestei interfețe și combinat cu interfețele de multiplexare I/O existente, kernel-ul poate notifica o aplicație utilizator de orice tip de eveniment.
</p>

<p>
Interfața <code>eventfd</code> este prezentă în nucleul Linux începând cu versiunea 2.6.22 și este suportată de către glibc începând cu versiunea 2.8.
</p>

<p>
Interfața <code>eventfd</code> permite unificarea mecanismelor de notificare ale kernel-ului într-un descriptor de fișier care va fi folosit de utilizator.
</p>

<p>
Cele trei apeluri de bază pentru extinderea funcționalității multiplexării I/O sunt: <a href="http://linux.die.net/man/2/eventfd" class="urlextern" title="http://linux.die.net/man/2/eventfd"  rel="nofollow"> eventfd</a>, <a href="http://linux.die.net/man/2/signalfd" class="urlextern" title="http://linux.die.net/man/2/signalfd"  rel="nofollow"> signalfd</a> și <a href="http://www.unix.com/man-page/Linux/2/timerfd_create/" class="urlextern" title="http://www.unix.com/man-page/Linux/2/timerfd_create/"  rel="nofollow"> timerfd_create</a>.
</p>
<pre class="code c"><span class="co2">#include &lt;sys/eventfd.h&gt;</span>
&nbsp;
<span class="kw4">int</span> eventfd<span class="br0">&#40;</span><span class="kw4">unsigned</span> <span class="kw4">int</span> initval<span class="sy0">,</span> <span class="kw4">int</span> flags<span class="br0">&#41;</span><span class="sy0">;</span></pre>
<pre class="code c"><span class="co2">#include &lt;sys/signalfd.h&gt;</span>
&nbsp;
<span class="kw4">int</span> signalfd<span class="br0">&#40;</span><span class="kw4">int</span> fd<span class="sy0">,</span> <span class="kw4">const</span> sigset_t <span class="sy0">*</span>mask<span class="sy0">,</span> <span class="kw4">int</span> flags<span class="br0">&#41;</span><span class="sy0">;</span></pre>
<pre class="code c"><span class="co2">#include &lt;sys/timerfd.h&gt;</span>
&nbsp;
<span class="kw4">int</span> timerfd_create<span class="br0">&#40;</span><span class="kw4">int</span> clockid<span class="sy0">,</span> <span class="kw4">int</span> flags<span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>
Toate cele trei apeluri întorc un descriptor de fișier pe care se vor putea primi notificări (evenimente, semnale, timere). Operațiile posibile pe descriptorul de fișier întors sunt:
</p>
<ul>
<li class="level1"><div class="li"> <code>write</code>: pentru transmiterea unui mesaj de notificare pe descriptor;</div>
</li>
<li class="level2"><div class="li"> <code>read</code>: pentru primirea unui mesaj care înseamnă primirea notificării;</div>
</li>
<li class="level2"><div class="li"> <code>select</code>, <code>poll</code>, <code>epoll</code>: pentru multiplexarea I/O;</div>
</li>
<li class="level2"><div class="li"> <code>close</code>: pentru închiderea descriptorului și eliberarea resurselor asociate. </div>
</li>
</ul>

<p>
În următorul exemplu, apelul <code>eventfd</code> este folosit pentru notificarea procesului părinte de către procesul fiu. Codul este cel prezent în pagina de manual (man eventfd).
</p>
<pre class="code c"><span class="br0">&#91;</span>...<span class="br0">&#93;</span>
<span class="kw4">int</span> efd<span class="sy0">;</span>
<span class="kw4">uint64_t</span> u<span class="sy0">;</span>
&nbsp;
<span class="coMULTI">/* create eventfd file descriptor */</span>
efd <span class="sy0">=</span> eventfd<span class="br0">&#40;</span><span class="nu0">0</span><span class="sy0">,</span> <span class="nu0">0</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
<span class="kw1">switch</span> <span class="br0">&#40;</span>fork<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
<span class="kw1">case</span> <span class="nu0">0</span><span class="sy0">:</span>
    <span class="coMULTI">/* notify parent process */</span>
    s <span class="sy0">=</span> write<span class="br0">&#40;</span>efd<span class="sy0">,</span> <span class="sy0">&amp;</span>u<span class="sy0">,</span> <span class="kw4">sizeof</span><span class="br0">&#40;</span><span class="kw4">uint64_t</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
    <a href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span class="kw3">printf</span></a><span class="br0">&#40;</span><span class="st0">&quot;Child completed write loop<span class="es1">\n</span>&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
    <a href="http://www.opengroup.org/onlinepubs/009695399/functions/exit.html"><span class="kw3">exit</span></a><span class="br0">&#40;</span>EXIT_SUCCESS<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
<span class="kw1">default</span><span class="sy0">:</span>
    <a href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span class="kw3">printf</span></a><span class="br0">&#40;</span><span class="st0">&quot;Parent about to read<span class="es1">\n</span>&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
    <span class="coMULTI">/* wait for notification */</span>
    s <span class="sy0">=</span> read<span class="br0">&#40;</span>efd<span class="sy0">,</span> <span class="sy0">&amp;</span>u<span class="sy0">,</span> <span class="kw4">sizeof</span><span class="br0">&#40;</span><span class="kw4">uint64_t</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy0">;</span>
    <a href="http://www.opengroup.org/onlinepubs/009695399/functions/exit.html"><span class="kw3">exit</span></a><span class="br0">&#40;</span>EXIT_SUCCESS<span class="br0">&#41;</span><span class="sy0">;</span>
<span class="br0">&#91;</span>...<span class="br0">&#93;</span></pre>

</div>

<h3 class="sectionedit15" id="signalfd">signalfd</h3>
<div class="level3">

<p>
Apelul <a href="http://linux.die.net/man/2/signalfd" class="urlextern" title="http://linux.die.net/man/2/signalfd"  rel="nofollow"> signalfd</a> este folosit în mod similar pentru recepționarea de semnale prin intermediul unui descriptor de fișier. Pentru a putea recepționa un semnal cu ajutorul interfeței signalfd, va trebui blocat în masca de semnale a procesului. La fel ca și exemplul de mai sus, codul de mai jos este cel prezent în pagina de manual (man signalfd). 
</p>
<pre class="code c"><span class="coMULTI">/* at this point Linux-specific headers are required to use struct signalfd_siginfo */</span>
<span class="co2">#include &lt;linux/types.h&gt;</span>
<span class="co2">#include &lt;linux/signalfd.h&gt;</span>
&nbsp;
<span class="co2">#define SIZEOF_SIG      (_NSIG / 8)</span>
<span class="co2">#define SIZEOF_SIGSET   (SIZEOF_SIG &gt; sizeof(sigset_t) ? \
                                  sizeof(sigset_t): SIZEOF_SIG) </span>
&nbsp;
&nbsp;
    <span class="br0">&#91;</span>...<span class="br0">&#93;</span>
    sigset_t mask<span class="sy0">;</span>
    <span class="kw4">int</span> sfd<span class="sy0">;</span>
    <span class="kw4">struct</span> signalfd_siginfo fdsi<span class="sy0">;</span>
&nbsp;
    sigemptyset<span class="br0">&#40;</span><span class="sy0">&amp;</span>mask<span class="br0">&#41;</span><span class="sy0">;</span>
    sigaddset<span class="br0">&#40;</span><span class="sy0">&amp;</span>mask<span class="sy0">,</span> SIGINT<span class="br0">&#41;</span><span class="sy0">;</span>                <span class="coMULTI">/* CTRL-C */</span>
    sigaddset<span class="br0">&#40;</span><span class="sy0">&amp;</span>mask<span class="sy0">,</span> SIGQUIT<span class="br0">&#41;</span><span class="sy0">;</span>               <span class="coMULTI">/* CTRL-\ */</span>
&nbsp;
    <span class="coMULTI">/*
     * Block signals so that they aren't handled
     * according to their default dispositions
     */</span>
&nbsp;
    sigprocmask<span class="br0">&#40;</span>SIG_BLOCK<span class="sy0">,</span> <span class="sy0">&amp;</span>mask<span class="sy0">,</span> NULL<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
    <span class="coMULTI">/* create signalfd descriptor */</span>
    sfd <span class="sy0">=</span> signalfd<span class="br0">&#40;</span><span class="sy0">-</span><span class="nu0">1</span><span class="sy0">,</span> <span class="sy0">&amp;</span>mask<span class="sy0">,</span> <span class="nu0">0</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
    <span class="kw1">for</span> <span class="br0">&#40;</span><span class="sy0">;;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        <span class="coMULTI">/* wait for signals to be delivered by user */</span>
        s <span class="sy0">=</span> read<span class="br0">&#40;</span>sfd<span class="sy0">,</span> <span class="sy0">&amp;</span>fdsi<span class="sy0">,</span> <span class="kw4">sizeof</span><span class="br0">&#40;</span><span class="kw4">struct</span> signalfd_siginfo<span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
        <span class="kw1">if</span> <span class="br0">&#40;</span>fdsi.<span class="me1">ssi_signo</span> <span class="sy0">==</span> SIGINT<span class="br0">&#41;</span> <span class="br0">&#123;</span>
             <a href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span class="kw3">printf</span></a><span class="br0">&#40;</span><span class="st0">&quot;Got SIGINT<span class="es1">\n</span>&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
        <span class="br0">&#125;</span> <span class="kw1">else</span> <span class="kw1">if</span> <span class="br0">&#40;</span>fdsi.<span class="me1">ssi_signo</span> <span class="sy0">==</span> SIGQUIT<span class="br0">&#41;</span> <span class="br0">&#123;</span>
             <a href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span class="kw3">printf</span></a><span class="br0">&#40;</span><span class="st0">&quot;Got SIGQUIT<span class="es1">\n</span>&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
             <a href="http://www.opengroup.org/onlinepubs/009695399/functions/exit.html"><span class="kw3">exit</span></a><span class="br0">&#40;</span>EXIT_SUCCESS<span class="br0">&#41;</span><span class="sy0">;</span>
        <span class="br0">&#125;</span> <span class="kw1">else</span> <span class="br0">&#123;</span>
             <a href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span class="kw3">printf</span></a><span class="br0">&#40;</span><span class="st0">&quot;Read unexpected signal<span class="es1">\n</span>&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
        <span class="br0">&#125;</span>
    <span class="br0">&#125;</span>
    <span class="br0">&#91;</span>...<span class="br0">&#93;</span></pre>

</div>

<h2 class="sectionedit16" id="linux_-_operatii_asincrone">Linux - operații asincrone</h2>
<div class="level2">

<p>
În mod clasic, operațiile de lucru cu datele aflate pe suporturi externe înseamnă utilizarea apelurilor sincrone de tipul <code>read</code>, <code>write</code> și <code>fsync</code>. Aceste apeluri garantează faptul că, la terminarea apelului, datele sunt scrise/citite (de) pe suportul extern (sau în cache-ul asociat). Un astfel de apel poate întârzia continuarea fluxului de instrucțiuni curent până la terminarea operației cerute.
</p>

<p>
Pentru fire de execuție care nu au nevoie frecvent de operații de intrare-ieșire, această abordare funcționează. În schimb, pentru aplicații specializate pe lucrul cu memoria externă, folosirea apelurilor sincrone (blocante) încetinește semnificativ execuția programului. Timpul necesar unui acces la memorie (cu atât mai mult memoria externă) depășește cu mult timpul de execuție a unei instrucțiuni strict aritmetice.
</p>

</div>

<h3 class="sectionedit17" id="linux_aio">Linux AIO</h3>
<div class="level3">

<p>
Standardul <code>POSIX.1b</code> definește un nou set de operații I/O care pot reduce semnificativ timpul pe care o aplicație îl petrece așteptând pentru I/O. Noile funcții permit unui program să inițieze una sau mai multe operații de I/O și să-și continue lucrul normal în timp ce operațiile de I/O sunt executate în paralel. 
</p>

<p>
Această funcționalitate este disponibilă dacă se instalează biblioteca <code>libaio</code>: 
</p>
<pre class="code bash"><span class="co4">so$ </span><span class="kw2">apt-cache search</span> libaio
libaio-dev - Linux kernel AIO access library - development files
libaio1 - Linux kernel AIO access library - shared library
libaio1-dbg - Linux kernel AIO access library - debugging symbols
<span class="co4">so$ </span><span class="kw2">sudo</span> <span class="kw2">apt-get install</span> libaio1 libaio-dev</pre>

<p>
Totodată, programul care folosește acest <abbr title="Application Programming Interface">API</abbr> trebuie să includă fișierul header <code><a href="http://www.koders.com/c/fid4725E35EA2BE17467E3BB724D74D9FA6A471BFE7.aspx" class="urlextern" title="http://www.koders.com/c/fid4725E35EA2BE17467E3BB724D74D9FA6A471BFE7.aspx"  rel="nofollow"> libaio.h</a></code> și să link-eze biblioteca <code>libaio</code>. Toate funcțiile și structurile de care vom vorbi în continuare se pot găsi în acest fișier header. Dacă ați instalat pachetul, fișierul se găsește în <code>/usr/include/libaio.h</code>.
</p>

</div>

<h3 class="sectionedit18" id="structuri_de_baza_linux_aio">Structuri de bază Linux AIO</h3>
<div class="level3">

<p>
Structura <code>iocb</code> folosită pentru încapsularea unei operații asincrone. Structura este definită în header-ul <code><a href="http://www.koders.com/c/fid4725E35EA2BE17467E3BB724D74D9FA6A471BFE7.aspx" class="urlextern" title="http://www.koders.com/c/fid4725E35EA2BE17467E3BB724D74D9FA6A471BFE7.aspx"  rel="nofollow"> libaio.h</a></code>.
</p>
<pre class="code c"><span class="kw4">struct</span> iocb <span class="br0">&#123;</span>
     PADDEDptr<span class="br0">&#40;</span><span class="kw4">void</span> <span class="sy0">*</span>data<span class="sy0">,</span> __pad1<span class="br0">&#41;</span><span class="sy0">;</span>	   <span class="coMULTI">/* Return in the io completion event */</span>
     PADDED<span class="br0">&#40;</span><span class="kw4">unsigned</span> key<span class="sy0">,</span> __pad2<span class="br0">&#41;</span><span class="sy0">;</span>	   <span class="coMULTI">/* For use in identifying io requests */</span>
&nbsp;
     <span class="kw4">short</span> aio_lio_opcode<span class="sy0">;</span>	
     <span class="kw4">short</span> aio_reqprio<span class="sy0">;</span>    
     <span class="kw4">int</span> aio_fildes<span class="sy0">;</span>                       <span class="coMULTI">/* Perform async IO on this file descriptor */</span>
&nbsp;
     <span class="kw4">union</span> <span class="br0">&#123;</span>
          <span class="kw4">struct</span> io_iocb_common	c<span class="sy0">;</span>         <span class="coMULTI">/* common read/write operation */</span>
          <span class="kw4">struct</span> io_iocb_vector	v<span class="sy0">;</span>         <span class="coMULTI">/* vectored read/write operations */</span>
          <span class="kw4">struct</span> io_iocb_poll poll<span class="sy0">;</span> 
          <span class="kw4">struct</span> io_iocb_sockaddr saddr<span class="sy0">;</span>   <span class="coMULTI">/* socket read/write operations */</span>
	<span class="br0">&#125;</span> u<span class="sy0">;</span>
<span class="br0">&#125;</span><span class="sy0">;</span></pre>

<p>
În principiu, nu se lucrează direct cu elementele din structura <code>iocb</code>. Pentru asta există funcții de inițializare:
</p>
<ul>
<li class="level1"><div class="li">Pentru operații normale de citire/scriere:</div>
</li>
</ul>
<pre class="code c"><span class="kw4">void</span> io_prep_pread<span class="br0">&#40;</span>
     <span class="kw4">struct</span> iocb <span class="sy0">*</span>iocb<span class="sy0">,</span> 
     <span class="kw4">int</span> fd<span class="sy0">,</span> 
     <span class="kw4">void</span> <span class="sy0">*</span>buf<span class="sy0">,</span> 
     <span class="kw4">size_t</span> count<span class="sy0">,</span> 
     <span class="kw4">long</span> <span class="kw4">long</span> offset
<span class="br0">&#41;</span><span class="sy0">;</span></pre>
<pre class="code c"><span class="kw4">void</span> io_prep_pwrite<span class="br0">&#40;</span>
     <span class="kw4">struct</span> iocb <span class="sy0">*</span>iocb<span class="sy0">,</span> 
     <span class="kw4">int</span> fd<span class="sy0">,</span> 
     <span class="kw4">void</span> <span class="sy0">*</span>buf<span class="sy0">,</span> 
     <span class="kw4">size_t</span> count<span class="sy0">,</span> 
     <span class="kw4">long</span> <span class="kw4">long</span> offset
<span class="br0">&#41;</span><span class="sy0">;</span></pre>
<ul>
<li class="level1"><div class="li">Pentru operații Vectored I/O de citire/scriere:</div>
</li>
</ul>
<pre class="code c"><span class="kw4">void</span> io_prep_preadv<span class="br0">&#40;</span>
     <span class="kw4">struct</span> iocb <span class="sy0">*</span>iocb<span class="sy0">,</span> 
     <span class="kw4">int</span> fd<span class="sy0">,</span> 
     <span class="kw4">const</span> <span class="kw4">struct</span> iovec <span class="sy0">*</span>iov<span class="sy0">,</span> 
     <span class="kw4">int</span> iovcnt<span class="sy0">,</span> 
     <span class="kw4">long</span> <span class="kw4">long</span> offset
<span class="br0">&#41;</span><span class="sy0">;</span></pre>
<pre class="code c"><span class="kw4">void</span> io_prep_pwritev<span class="br0">&#40;</span>
     <span class="kw4">struct</span> iocb <span class="sy0">*</span>iocb<span class="sy0">,</span> 
     <span class="kw4">int</span> fd<span class="sy0">,</span> 
     <span class="kw4">const</span> <span class="kw4">struct</span> iovec <span class="sy0">*</span>iov<span class="sy0">,</span> 
     <span class="kw4">int</span> iovcnt<span class="sy0">,</span> 
     <span class="kw4">long</span> <span class="kw4">long</span> offset
<span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>
 Pentru folosirea acesteia o aplicație va include <code><a href="http://www.koders.com/c/fid4725E35EA2BE17467E3BB724D74D9FA6A471BFE7.aspx" class="urlextern" title="http://www.koders.com/c/fid4725E35EA2BE17467E3BB724D74D9FA6A471BFE7.aspx"  rel="nofollow"> libaio.h</a></code>. Un exemplu de inițializare a acestei structuri este:
</p>
<pre class="code c">        <span class="co2">#include &lt;libaio.h&gt;</span>
&nbsp;
        <span class="coMULTI">/* ... */</span>
&nbsp;
        <span class="kw4">struct</span> iocb iocb<span class="sy0">;</span>
&nbsp;
        <a href="http://www.opengroup.org/onlinepubs/009695399/functions/memset.html"><span class="kw3">memset</span></a><span class="br0">&#40;</span><span class="sy0">&amp;</span>iocb<span class="sy0">,</span> <span class="nu0">0</span><span class="sy0">,</span> <span class="kw4">sizeof</span><span class="br0">&#40;</span>iocb<span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy0">;</span>
        io_prep_pwrite<span class="br0">&#40;</span><span class="sy0">&amp;</span>iocb<span class="sy0">,</span> fd<span class="sy0">,</span> buffer<span class="sy0">,</span> BUFER_SIZE<span class="sy0">,</span> <span class="nu0">0</span><span class="br0">&#41;</span><span class="sy0">;</span></pre>

</div>

<h3 class="sectionedit19" id="context_aio">Context AIO</h3>
<div class="level3">

<p>
Orice operație sau set de operații Linux AIO sunt identificate printr-o valoare de tipul <code>io_context_t</code> ce reprezintă un context de operații asincrone.
</p>

<p>
Inițializarea, respectiv distrugerea contextului se realizează cu ajutorul funcțiilor <a href="http://linux.die.net/man/2/io_setup" class="urlextern" title="http://linux.die.net/man/2/io_setup"  rel="nofollow">io_setup</a> și <a href="http://linux.die.net/man/2/io_destroy" class="urlextern" title="http://linux.die.net/man/2/io_destroy"  rel="nofollow">io_destroy</a>:
</p>
<pre class="code c"><span class="co2">#include &lt;libaio.h&gt;</span>
&nbsp;
<span class="kw4">int</span> io_setup<span class="br0">&#40;</span><span class="kw4">unsigned</span> nr_events<span class="sy0">,</span> aio_context_t <span class="sy0">*</span>ctxp<span class="br0">&#41;</span><span class="sy0">;</span></pre>
<pre class="code c"><span class="co2">#include &lt;libaio.h&gt;</span>
&nbsp;
<span class="kw4">int</span> io_destroy<span class="br0">&#40;</span>aio_context_t ctx<span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>
Un exemplu de inițializare și distrugere a contextului:
</p>
<pre class="code c"><span class="co2">#include &lt;libaio.h&gt;</span>
&nbsp;
io_context_t ctx<span class="sy0">;</span>
<span class="kw4">int</span> num_ops <span class="sy0">=</span> <span class="nu0">10</span><span class="sy0">;</span>
&nbsp;
<span class="coMULTI">/* crează un context de I/O asincron capabil să primească măcar num_ops evenimente */</span> 
&nbsp;
<span class="kw1">if</span> <span class="br0">&#40;</span>io_setup<span class="br0">&#40;</span>num_ops<span class="sy0">,</span> <span class="sy0">&amp;</span>ctx<span class="br0">&#41;</span> <span class="sy0">&lt;</span> <span class="nu0">0</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
    <span class="coMULTI">/* handle error */</span>    
<span class="br0">&#125;</span>
&nbsp;
<span class="coMULTI">/* do work */</span>
<span class="coMULTI">/* ... */</span>
&nbsp;
<span class="coMULTI">/* distruge contextul și anulează toate operațiile I/O asincrone necompletate */</span>
&nbsp;
<span class="kw1">if</span> <span class="br0">&#40;</span>io_destroy<span class="br0">&#40;</span>ctx<span class="br0">&#41;</span> <span class="sy0">&lt;</span> <span class="nu0">0</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
    <span class="coMULTI">/* handle error */</span>
<span class="br0">&#125;</span></pre>

</div>

<h3 class="sectionedit20" id="operatii_aio">Operații AIO</h3>
<div class="level3">

<p>
Pentru realizarea unei operații asincrone se folosește funcția <a href="http://linux.die.net/man/2/io_submit" class="urlextern" title="http://linux.die.net/man/2/io_submit"  rel="nofollow">io_submit</a>. Această funcție declanșează pornirea operațiilor asincrone definite în vectorul de pointeri de structuri <code>iocb</code> primit ca argument. Această funcție nu blochează procesul curent.
</p>
<pre class="code c"><span class="co2">#include &lt;libaio.h&gt;</span>
&nbsp;
<span class="kw4">int</span> io_submit<span class="br0">&#40;</span>
     aio_context_t ctx_id<span class="sy0">,</span> 
     <span class="kw4">long</span> nr<span class="sy0">,</span> 
     <span class="kw4">struct</span> iocb <span class="sy0">**</span>iocbpp
<span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>
Un exemplu de utilizare este:
</p>
<pre class="code c"><span class="co2">#include &lt;libaio.h&gt;</span>
&nbsp;
<span class="co2">#define NUM_AIO_OPS       10</span>
&nbsp;
<span class="kw4">struct</span> iocb iocb<span class="br0">&#91;</span>NUM_AIO_OPS<span class="br0">&#93;</span><span class="sy0">;</span>      <span class="coMULTI">/* array of asynchronous operations */</span>
<span class="kw4">struct</span> iocb <span class="sy0">*</span>piocb<span class="br0">&#91;</span>NUM_AIO_OPS<span class="br0">&#93;</span><span class="sy0">;</span>    <span class="coMULTI">/* array of pointers to asynchronous operations */</span>
io_context_t ctx <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
&nbsp;
<span class="coMULTI">/* init context, iocb */</span>
&nbsp;
<span class="coMULTI">/* fill piocb */</span>
<span class="kw1">for</span> <span class="br0">&#40;</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> NUM_AIO_OPS<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">&#41;</span>
    piocb<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy0">=</span> <span class="sy0">&amp;</span>iocb<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="sy0">;</span>
&nbsp;
<span class="coMULTI">/*
  * Submit NUM_AIO_OPS async operations in context 'ctx'
  * This does not wait for the operations to finish
  */</span>
&nbsp;
<span class="kw1">if</span> <span class="br0">&#40;</span>io_submit<span class="br0">&#40;</span>ctx<span class="sy0">,</span> NUM_AIO_OPS<span class="sy0">,</span> piocb<span class="br0">&#41;</span> <span class="sy0">&lt;</span> <span class="nu0">0</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
    <span class="coMULTI">/* handle error */</span>
<span class="br0">&#125;</span>
&nbsp;
<span class="coMULTI">/* Do some other stuff in paralel with the execution of async I/O operations */</span></pre>

<p>
Pentru așteptarea încheierii unei operații AIO și obținerea de informații despre rezultatul acesteia se folosește funcția <a href="http://linux.die.net/man/2/io_getevents" class="urlextern" title="http://linux.die.net/man/2/io_getevents"  rel="nofollow">io_getevents</a>. Funcția folosește structura <code>io_event</code> pentru a obține informații despre încheierea unei operații asincrone. 
</p>
<pre class="code c"><span class="co2">#include &lt;linux/time.h&gt;</span>
<span class="co2">#include &lt;libaio.h&gt;</span>
&nbsp;
<span class="kw4">int</span> io_getevents<span class="br0">&#40;</span>
     aio_context_t ctx_id<span class="sy0">,</span> 
     <span class="kw4">long</span> min_nr<span class="sy0">,</span> 
     <span class="kw4">long</span> nr<span class="sy0">,</span>
     <span class="kw4">struct</span> io_event <span class="sy0">*</span>events<span class="sy0">,</span> 
     <span class="kw4">struct</span> timespec <span class="sy0">*</span>timeout
<span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>
Un exemplu de utilizare este:
</p>
<pre class="code c"><span class="co2">#include &lt;libaio.h&gt;</span>
<span class="co2">#define       NUM_AIO_OPS  10</span>
&nbsp;
io_context_t ctx <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="kw4">struct</span> io_event events<span class="br0">&#91;</span>NUM_AIO_OPS<span class="br0">&#93;</span><span class="sy0">;</span>     <span class="coMULTI">/* aio result array */</span>
<span class="coMULTI">/* ... */</span>
&nbsp;
<span class="coMULTI">/*
  * Wait _exactly_ NUM_AIO_OPS async operations to finish
  * min_nr - min nummber of async aio to finish for the function to return
  * max_nr - max nummber of async aio operations that can be returned
  */</span>
rc <span class="sy0">=</span> io_getevents<span class="br0">&#40;</span>ctx<span class="sy0">,</span> NUM_AIO_OPS<span class="sy0">,</span> <span class="coMULTI">/* min_nr */</span>
                       NUM_AIO_OPS<span class="sy0">,</span> <span class="coMULTI">/* max_nr */</span>
                       events<span class="sy0">,</span>      <span class="coMULTI">/* vector to store completed events */</span>
                       NULL<span class="br0">&#41;</span><span class="sy0">;</span>        <span class="coMULTI">/* no timeout */</span>
<span class="kw1">if</span> <span class="br0">&#40;</span>rc <span class="sy0">&lt;</span> <span class="nu0">0</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>                     
    <span class="coMULTI">/* handle error */</span>
<span class="br0">&#125;</span></pre>

</div>

<h3 class="sectionedit21" id="integrarea_linux_aio_cu_eventfd">Integrarea Linux AIO cu eventfd</h3>
<div class="level3">

<p>
Este utilă folosirea apelurilor de multiplexare I/O (<code>select</code>, <code>poll</code>, <code>epoll</code>) și pentru așteptarea încheierii operațiilor asincrone. Pentru aceasta, interfața AIO a Linux 2.6 permite integrarea <abbr title="Application Programming Interface">API</abbr>-ului de operații asincrone cu mecanismul eventfd.
</p>

<p>
Pentru aceasta se configurează flag-ul <code>IOCB_FLAG_RESFD</code> iar câmpul <code>resfd</code> al structurii <code>iocb</code> va conține un descriptor <code>eventfd</code> ce va fi notificat în momentul încheierii operației asincrone. Acest lucru se poate configura din start apelând funcția: 
</p>
<pre class="code c"><span class="kw4">void</span> io_set_eventfd<span class="br0">&#40;</span><span class="kw4">struct</span> iocb <span class="sy0">*</span>iocb<span class="sy0">,</span> <span class="kw4">int</span> eventfd<span class="br0">&#41;</span></pre>

<p>
Apelul <code><a href="http://linux.die.net/man/2/io_getevents" class="urlextern" title="http://linux.die.net/man/2/io_getevents"  rel="nofollow"> io_getevents</a></code> este în continuare util pentru a obține informații despre încheierea operațiilor. <code>eventfd</code> oferă doar mecanismul de așteptare a acestora.
</p>
<pre class="code c"><span class="co2">#include &lt;libaio.h&gt;</span>
<span class="kw4">int</span> efd<span class="sy0">;</span>
&nbsp;
<span class="co1">// creare event cu valoare inițială 0, fără flaguri speciale</span>
efd <span class="sy0">=</span> eventfd<span class="br0">&#40;</span><span class="nu0">0</span><span class="sy0">,</span> <span class="nu0">0</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
<span class="coMULTI">/* ... */</span>
<span class="kw4">struct</span> iocb <span class="sy0">*</span>iocb<span class="sy0">;</span>
&nbsp;
<span class="coMULTI">/* ... */</span>
<span class="coMULTI">/* use eventfd */</span>
io_set_eventfd<span class="br0">&#40;</span><span class="sy0">&amp;</span>iocb<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="sy0">,</span> efd<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
<span class="coMULTI">/* ... */</span>
u_int64_t efd_val<span class="sy0">;</span>
<span class="kw1">if</span> <span class="br0">&#40;</span>read<span class="br0">&#40;</span>efd<span class="sy0">,</span> <span class="sy0">&amp;</span>efd_val<span class="sy0">,</span> <span class="kw4">sizeof</span><span class="br0">&#40;</span>efd_val<span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="sy0">&lt;</span> <span class="nu0">0</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
    <span class="coMULTI">/* handle error */</span>
<span class="br0">&#125;</span>
&nbsp;
<a href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span class="kw3">printf</span></a><span class="br0">&#40;</span><span class="st0">&quot;%llu operations have completed<span class="es1">\n</span>&quot;</span><span class="sy0">,</span> efd_val<span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>
Citirea din descriptorul eventfd reprezintă numărul de operații I/O încheiate. Această valoare va fi, de obicei, folosită ca al doilea și al treilea argument al <code><a href="http://linux.die.net/man/2/io_getevents" class="urlextern" title="http://linux.die.net/man/2/io_getevents"  rel="nofollow"> io_getevents</a></code>.
</p>

<p>
<p><div class="notetip">Util pentru <code>Tema 5</code>: Folosind integrarea operațiilor asincrone cu eventfd și mecanismele de multiplexare I/O (<code>select</code>, <code>poll</code>, <code>epoll</code>) se poate aștepta unificat încheierea unei operații asincrone sau sosirea de date pe sockeți.
</div></p>
</p>

</div>

<h2 class="sectionedit22" id="zero-copy_io">Zero-copy I/O</h2>
<div class="level2">

</div>

<h3 class="sectionedit23" id="linux_-_splice">Linux - splice</h3>
<div class="level3">

<p>
Este un apel de sistem ce permite transferul de date între 2 descriptori de fișier, dintre care cel puțin unul este pipe. Avantajul este că nu se folosește un buffer (byte array) în userspace. 
</p>
<pre class="code c"><span class="co2">#define _GNU_SOURCE // trebuie definit pentru că splice este o extensie nespecificată de standardele POSIX/SYSV/BSD/etc.</span>
&nbsp;
<span class="co2">#include &lt;fcntl.h&gt;</span>
&nbsp;
<span class="kw4">long</span> splice<span class="br0">&#40;</span>
     <span class="kw4">int</span> fd_in<span class="sy0">,</span> 
     loff_t <span class="sy0">*</span>off_in<span class="sy0">,</span> 
     <span class="kw4">int</span> fd_out<span class="sy0">,</span> 
     loff_t <span class="sy0">*</span>off_out<span class="sy0">,</span> 
     <span class="kw4">size_t</span> len<span class="sy0">,</span> 
     <span class="kw4">unsigned</span> <span class="kw4">int</span> flags
<span class="br0">&#41;</span><span class="sy0">;</span></pre>
<ul>
<li class="level1"><div class="li"> dacă descriptorul <code>fd_in</code> reprezintă un pipe, atunci pointer-ul la offset <code>off_in</code> trebuie să fie NULL</div>
</li>
<li class="level2"><div class="li"> altfel:</div>
<ul>
<li class="level3"><div class="li"> dacă <code>off_in</code> este NULL, atunci datele sunt citite de la <code>fd_in</code> de la offset-ul curent, acesta modificându-se corespunzător</div>
</li>
<li class="level3"><div class="li"> altfel, <code>off_in</code> trebuie să fie un pointer la un întreg care reprezintă offset-ul de start de la care se va face citirea, iar offset-ul propriu descriptorului <code>fd_in</code> rămâne neschimbat </div>
</li>
</ul>
</li>
<li class="level2"><div class="li"> comportamentul de mai sus este valabil și pentru <code>fd_out</code> și <code>off_out</code>, la scriere</div>
</li>
<li class="level2"><div class="li"> parametrul len specifică numărul maxim de octeți transferați</div>
</li>
<li class="level2"><div class="li"> masca de biți flags poate specifica o operație non-blocantă sau hint-uri pentru nucleu. Citiți pagina de manual a funcției pentru mai multe detalii. </div>
</li>
</ul>

<p>
Exemplu de folosire:
</p>
<pre class="code c"><span class="kw4">int</span> pipe<span class="sy0">,</span> file1<span class="sy0">,</span> file2<span class="sy0">;</span>
loff_t offset <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="kw4">size_t</span> count <span class="sy0">=</span> <span class="nu0">4096</span><span class="sy0">;</span>
&nbsp;
<span class="co1">// ... deschideri fișiere, creare pipe</span>
&nbsp;
splice<span class="br0">&#40;</span>file1<span class="sy0">,</span> <span class="sy0">&amp;</span>offset<span class="sy0">,</span> pipe<span class="sy0">,</span> NULL<span class="sy0">,</span> count<span class="sy0">,</span> <span class="nu0">0</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
splice<span class="br0">&#40;</span>pipe<span class="sy0">,</span> NULL<span class="sy0">,</span> file2<span class="sy0">,</span> <span class="sy0">&amp;</span>offset<span class="sy0">,</span> count<span class="sy0">,</span> <span class="nu0">0</span><span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>
O altă funcție foarte utilă și care folosește zero-copy este <a href="http://linux.die.net/man/2/sendfile" class="urlextern" title="http://linux.die.net/man/2/sendfile"  rel="nofollow"> sendfile</a>
</p>

</div>

<h2 class="sectionedit24" id="vectored_io">Vectored I/O</h2>
<div class="level2">

<p>
Vectored I/O (sau scatter/gather I/O) reprezintă o metodă prin intermediul căreia un singur apel permite scrierea de date din mai multe buffere către un flux de ieșire sau citirea de date de la un flux de intrare în mai multe buffere. Bufferele sunt precizate ca un vector de buffere, de unde și denumirea de vectored I/O.
</p>

<p>
Apelurile din clasa vectored I/O sunt utile în momentul în care datele sunt disparate/dezasamblate în memorie și se dorește “concatenarea” acestora într-un singur flux de scriere sau “desfacerea” acestora dintr-un flux de citire. Un exemplu îl reprezintă pachetele de rețea în care headerele, datele și trailerele se găsesc, de obicei, în locații de memorie diferite pentru a facilita prelucrarea acestora. Folosirea Vectored I/O permite asamblarea/dezasamblarea pachetului în/din mai multe zone de memorie printr-o singură operație. Nu este nevoie de crearea unui buffer nou cu pachetele concatenate, drept care Vectored I/O poate fi considerat o formă de zero-copy.
</p>

<p>
Apeluri:
</p>
<ul>
<li class="level1"><div class="li"> UNIX: <a href="http://linux.die.net/man/2/readv" class="urlextern" title="http://linux.die.net/man/2/readv"  rel="nofollow">readv</a>, <a href="http://linux.die.net/man/2/writev" class="urlextern" title="http://linux.die.net/man/2/writev"  rel="nofollow">writev</a>.</div>
</li>
<li class="level2"><div class="li"> Windows (fișiere) ReadFileScatter, WriteFileGather.</div>
</li>
<li class="level2"><div class="li"> Windows (sockeți) WSARecv,WSASend. </div>
</li>
</ul>

</div>

<h3 class="sectionedit25" id="readvwritev">readv/writev</h3>
<div class="level3">

<p>
Funcțiile <a href="http://linux.die.net/man/2/readv" class="urlextern" title="http://linux.die.net/man/2/readv"  rel="nofollow">readv</a> și <a href="http://linux.die.net/man/2/writev" class="urlextern" title="http://linux.die.net/man/2/writev"  rel="nofollow">writev</a> sunt folosite în sistemele Unix ca operații de tipul vectored I/O. Structura de bază folosită de aceste funcții este <code>struct iovec</code>:
</p>
<pre class="code c"><span class="co2">#include &lt;sys/uio.h&gt;</span>
&nbsp;
<span class="kw4">struct</span> iovec <span class="br0">&#123;</span>
     <span class="kw4">void</span> <span class="sy0">*</span>iov_base<span class="sy0">;</span>   <span class="coMULTI">/* Starting address */</span>
     <span class="kw4">size_t</span> iov_len<span class="sy0">;</span>   <span class="coMULTI">/* bytes to transfer */</span>
<span class="br0">&#125;</span><span class="sy0">;</span></pre>
<pre class="code c"><span class="co2">#include &lt;sys/uio.h&gt;</span>
&nbsp;
ssize_t readv<span class="br0">&#40;</span><span class="kw4">int</span> fd<span class="sy0">,</span> <span class="kw4">const</span> <span class="kw4">struct</span> iovec <span class="sy0">*</span>iov<span class="sy0">,</span> <span class="kw4">int</span> iovcnt<span class="br0">&#41;</span><span class="sy0">;</span></pre>
<pre class="code c"><span class="co2">#include &lt;sys/uio.h&gt;</span>
&nbsp;
ssize_t writev<span class="br0">&#40;</span><span class="kw4">int</span> fd<span class="sy0">,</span> <span class="kw4">const</span> <span class="kw4">struct</span> iovec <span class="sy0">*</span>iov<span class="sy0">,</span> <span class="kw4">int</span> iovcnt<span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>
Un apel <a href="http://linux.die.net/man/2/readv" class="urlextern" title="http://linux.die.net/man/2/readv"  rel="nofollow">readv</a> sau <a href="http://linux.die.net/man/2/writev" class="urlextern" title="http://linux.die.net/man/2/writev"  rel="nofollow">writev</a> va permite recepționarea/transmiterea unui număr de buffere reprezentate de structura <code>iovec</code>. Funcțiile întorc numărul total de octeți citiți sau scriși. 
</p>

<p>
Apelul <a href="http://linux.die.net/man/2/writev" class="urlextern" title="http://linux.die.net/man/2/writev"  rel="nofollow">writev</a> scrie datele (reprezentate de elementele din <code>iov</code> în fișier), în ordinea în care acestea apar în vector:
</p>
<pre class="code c"><span class="co2">#include &lt;sys/uio.h&gt;</span>
&nbsp;
<span class="coMULTI">/* ... */</span>
<span class="kw4">char</span> <span class="sy0">*</span>str0 <span class="sy0">=</span> <span class="st0">&quot;Ana &quot;</span><span class="sy0">;</span>
<span class="kw4">char</span> <span class="sy0">*</span>str1 <span class="sy0">=</span> <span class="st0">&quot;are multe &quot;</span><span class="sy0">;</span>
<span class="kw4">char</span> <span class="sy0">*</span>str2 <span class="sy0">=</span> <span class="st0">&quot;mere, pere etc.&quot;</span><span class="sy0">;</span>
<span class="kw4">struct</span> iovec iov<span class="br0">&#91;</span><span class="nu0">3</span><span class="br0">&#93;</span><span class="sy0">;</span>
ssize_t nwritten<span class="sy0">;</span>
&nbsp;
iov<span class="br0">&#91;</span><span class="nu0">0</span><span class="br0">&#93;</span>.<span class="me1">iov_base</span> <span class="sy0">=</span> str0<span class="sy0">;</span>
iov<span class="br0">&#91;</span><span class="nu0">0</span><span class="br0">&#93;</span>.<span class="me1">iov_len</span>  <span class="sy0">=</span> <a href="http://www.opengroup.org/onlinepubs/009695399/functions/strlen.html"><span class="kw3">strlen</span></a><span class="br0">&#40;</span>str0<span class="br0">&#41;</span><span class="sy0">;</span>
iov<span class="br0">&#91;</span><span class="nu0">1</span><span class="br0">&#93;</span>.<span class="me1">iov_base</span> <span class="sy0">=</span> str1<span class="sy0">;</span>
iov<span class="br0">&#91;</span><span class="nu0">1</span><span class="br0">&#93;</span>.<span class="me1">iov_len</span>  <span class="sy0">=</span> <a href="http://www.opengroup.org/onlinepubs/009695399/functions/strlen.html"><span class="kw3">strlen</span></a><span class="br0">&#40;</span>str1<span class="br0">&#41;</span><span class="sy0">;</span>
iov<span class="br0">&#91;</span><span class="nu0">2</span><span class="br0">&#93;</span>.<span class="me1">iov_base</span> <span class="sy0">=</span> str2<span class="sy0">;</span>
iov<span class="br0">&#91;</span><span class="nu0">2</span><span class="br0">&#93;</span>.<span class="me1">iov_len</span>  <span class="sy0">=</span> <a href="http://www.opengroup.org/onlinepubs/009695399/functions/strlen.html"><span class="kw3">strlen</span></a><span class="br0">&#40;</span>str2<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
nwritten <span class="sy0">=</span> writev<span class="br0">&#40;</span>fd<span class="sy0">,</span> iov<span class="sy0">,</span> <span class="nu0">3</span><span class="br0">&#41;</span><span class="sy0">;</span>
<span class="kw1">if</span> <span class="br0">&#40;</span>nwritten <span class="sy0">&lt;</span> <span class="nu0">0</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
     <span class="coMULTI">/* handle error */</span>
<span class="br0">&#125;</span></pre>

</div>

<h2 class="sectionedit26" id="exercitiul_0_-_joc_interactiv_2p">Exercițiul 0 - Joc interactiv (2p)</h2>
<div class="level2">
<ul>
<li class="level1"><div class="li"> Detalii desfășurare <a href="../meta/notare.html#joc_interactiv" class="urlextern" title="http://ocw.cs.pub.ro/courses/so/meta/notare#joc_interactiv"  rel="nofollow">joc</a>.</div>
</li>
</ul>

</div>

<h2 class="sectionedit27" id="linux_9p">Linux (9p)</h2>
<div class="level2">

<p>
În rezolvarea laboratorului folosiți arhiva de sarcini <a href="http://elf.cs.pub.ro/so/res/laboratoare/lab11-tasks.zip" class="urlextern" title="http://elf.cs.pub.ro/so/res/laboratoare/lab11-tasks.zip"  rel="nofollow"> lab11-tasks.zip</a>
</p>

<p>
<p><div class="noteimportant">
Acest laborator se desfășoară în echipe. O echipă este formată din 2 studenți. În cazul în care numărul de studenți prezenți este impar, o singură echipă va avea dreptul de a avea 3 studenți.
</p>

<p>
Discutați exercițiile și colaborați pe parcursul întregului laborator. Have fun! <img src="../../lib/images/smileys/icon_smile.gif" class="icon" alt=":-)" />

</div></p>
</p>

</div>

<h3 class="sectionedit28" id="exercitiul_1_-_poll_1p">Exercițiul 1 - poll (1p)</h3>
<div class="level3">

<p>
Intrați în directorul <code>1-pollpipe</code>. Parcurgeți fișierul <code>poll.c</code> pentru a vedea un exemplu de folosire al funcției <code>poll</code>.
</p>

<p>
Programul creează folosind <code>fork</code> o aplicație de test pentru <code>poll</code>. Aplicația folosește un server (părintele) și <code>CLIENT_COUNT</code> clienți (copiii) ce comunică prin pipe-uri anonime.
</p>

<p>
<strong>Server-ul:</strong>
</p>
<ul>
<li class="level1"><div class="li"> construiește un vector de pipe-uri (în funcția <code>main</code>);</div>
</li>
<li class="level1"><div class="li"> creează clienții;</div>
</li>
<li class="level1"><div class="li"> se blochează în așteptarea datelor de la clienți și tipărește datele primite;</div>
</li>
<li class="level1"><div class="li"> termină execuția după ce a primit date de la fiecare client; </div>
</li>
</ul>

<p>
<strong>Clienții:</strong>
</p>
<ul>
<li class="level1"><div class="li"> așteaptă un număr aleator de secunde (mai mic decât 10);</div>
</li>
<li class="level1"><div class="li"> scriu în pipe-ul corespunzător un șir de <code>MSG_SIZE</code> caractere de forma <pre class="code">&lt;pid&gt;:&lt;caracter random&gt; (&#039;a&#039; + random() % 30)</pre>
</div>
</li>
<li class="level1"><div class="li"> scrierile și citirile în pipe-uri de până la PIPE_BUF octeți (4096 pe Linux) sunt atomice. </div>
</li>
</ul>

<p>
Compilați și rulați programul. Pentru nelămuriri puteti consulta secțiunea <a href="laborator-11.html#poll" title="so:laboratoare:laborator-11 ↵" class="wikilink1">poll</a> și <a href="laborator-03.html#pipe-uri_anonime_in_linux" class="wikilink1" title="so:laboratoare:laborator-03">pipe-uri</a> în Linux. 
</p>

</div>

<h3 class="sectionedit29" id="exercitiul_2_-_epoll_2p">Exercițiul 2 - epoll (2p)</h3>
<div class="level3">

<p>
Intrați în directorul <code>2-epollpipe</code> și parcurgeți fișierul <code>epoll.c</code>. Considerând cerința de la exercițiul anterior, în loc de <code>poll</code> folosiți <code>epoll</code>.
</p>

<p>
În partea de inițializare realizați următoare operații:
</p>
<ul>
<li class="level1"><div class="li"> Inițializați, înainte de ciclul <code>for</code>, handle-ul de epoll folosing <code>epoll_create</code>.</div>
</li>
<li class="level1"><div class="li"> Adăugați câte un eveniment pentru fiecare pipe (folosind variabila <code>ev</code>) folosind <code>epoll_ctl</code> cu opțiunea <code>EPOLL_CTL_ADD</code>.</div>
<ul>
<li class="level2"><div class="li"> Câmpul <code>events</code> al variabilei <code>ev</code> îl veți inițializa la <code>EPOLLIN</code>.</div>
</li>
<li class="level2"><div class="li"> Câmpul <code>data.fd</code> al variabilei <code>ev</code> îl veți inițializa la capătul de citire al pipelului.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Închideți capătul de scriere al pipe-ului.</div>
</li>
</ul>

<p>
În partea de așteptare realizați, în bucla <code>while</code> următoarele operații:
</p>
<ul>
<li class="level1"><div class="li"> Așteptați un eveniment folosind funcția <code>epoll_wait</code>.</div>
<ul>
<li class="level2"><div class="li"> Descriptorul indicat în structura întoarsă de <code>epoll_wait</code> (adică <code>ev.data.fd</code>) este capătul de citire al pipe-ului.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Din pipe citiți mesajul trimis de client, folosind <code>read</code>.</div>
</li>
<li class="level1"><div class="li"> Eliminați pipe-ul din multiplexor (folosind <code>epoll_ctl</code> cu opțiunea <code>EPOLL_CTL_DEL</code>) și închideți-l folosind <code>close</code>.</div>
</li>
<li class="level1"><div class="li"> Incremenetați valoarea variabilei <code>recv_msgs</code>.</div>
</li>
</ul>

</div>

<h3 class="sectionedit30" id="exercitiul_3_-_eventfd_2p">Exercițiul 3 - eventfd (2p)</h3>
<div class="level3">

<p>
Pornind de la codul scris pentru execițiul anterior, notificați serverul de terminarea unui client utilizând <code>eventfd</code>. Clientul transmite mesaje către server și, când dorește să închidă comunicația, va trimite un mesaj pe canalul de control reprezentat de <code>eventfd</code>. Acum, <code>epoll</code> este folosit pentru a demultiplexa atât descriptorii de pipe, cât și descriptorul de <code>eventfd</code>.
</p>

<p>
Decomentați în <code>epoll.c</code> linia cu 
</p>
<pre class="code c"><span class="co2">#define USE_EVENTFD</span></pre>

<p>
Clientul va scrie mesaje în pipe-ul aferent, iar la sfârșit va genera un mesaj de notificare. Acesta va folosi funcția <code>set_event</code> definită în program. Mesajul de notificare este un număr pe 64 de biți organizat astfel:
</p>
<ul>
<li class="level1"><div class="li"> Primii 32 de biți conțin valoarea definită de macro-ul <code>MAGIC_EXIT</code>.</div>
</li>
<li class="level1"><div class="li"> Ultimii 32 de biți conțin indexul clientului.</div>
</li>
</ul>

<p>
Serverul va adăuga descriptorul de <code>eventfd</code> în <code>epoll</code> (cu eveniment de tipul <code>EPOLLIN</code>). Evenimentele vor fi așteptate folosind <code>epoll_wait</code> (așa cum făcea și până acum). Apelul <code>epoll_wait</code> se întoarce când un descriptor din <code>epoll</code> are informații de citit. Descriptorul întors în urma <code>epoll_wait</code> (identificat de câmpul <code>ev.data.fd</code>) poate fi descriptor de pipe sau poate fi descriptorul de <code>eventfd</code>.
</p>

<p>
Dacă descriptorul întors în urma <code>epoll_wait</code> este descriptorul de <code>eventfd</code>, atunci veți citi <code>64</code> de biți de pe acest descriptor (folosind <code>read</code>). Dacă primii 32 biți sunt valoarea descrisă de macro-ul <code>MAGIC_EXIT</code>, atunci <strong>scoate</strong> capătul pipe-ului corespunzător din <code>epoll</code> și închide acel capăt (adică folosește <code>epoll_ctl</code> cu opțiunea <code>EPOLL_CTL_DEL</code> și apoi <code>close</code>). Pentru a extrage ultimii 32 de biți din mesajul de <code>64</code> de biți primit pe descriptorul de <code>eventfd</code>, reprezentând indexul clientului, folosiți funcția <code>get_index</code> definită local în program.
</p>

</div>

<h3 class="sectionedit31" id="exercitiul_4_-_async_io_kaio_2p">Exercițiul 4 - async I/O (KAIO) (2p)</h3>
<div class="level3">

<p>
Intrați în directorul <code>4-kaio</code> și parcurgeți fișierul <code>kaio.c</code>. Completați zonele lipsă pentru a programa scrierea a 4 fișiere cu numele date de variabila <code>files</code>.
</p>

<p>
Folosiți <abbr title="Application Programming Interface">API</abbr>-ul KAIO (io_setup, io_destroy, io_submit, io_getevents). Folosiți <strong>doar</strong> io_getevents pentru așteptarea încheierii operațiilor asincrone.
</p>

<p>
Parcurgeți secțiunea <a href="laborator-11.html#linux_aio" title="so:laboratoare:laborator-11 ↵" class="wikilink1">Linux AIO</a> și consultați exemplul lui <a href="http://www.xmailserver.org/eventfd-aio-test.c" class="urlextern" title="http://www.xmailserver.org/eventfd-aio-test.c"  rel="nofollow"> Davide Libenzi</a>. Urmăriți comentariile cu <em> TODO 1 </em>
</p>

<p>
Compilați și rulați programul. Va trebui să aveți 4 fișiere de dimensiune 8192 octeți create în <code>/tmp</code>. 
</p>

<p>
<strong>Atenţie!</strong> În cazul în care, la compilare, header-ul &#039;libaio&#039; nu este găsit rulaţi 
</p>
<pre class="code bash"><span class="co4">so$ </span><span class="kw2">sudo</span> <span class="kw2">apt-get install</span> libaio1 libaio-dev</pre>

</div>

<h3 class="sectionedit32" id="exercitiul_5_-_async_io_kaio_2p">Exercițiul 5 - async I/O (KAIO) (2p)</h3>
<div class="level3">

<p>
 Folosiți <code>eventfd</code> pentru așteptarea operațiilor asincrone. Porniți de la codul scris pentru execițiul anterior.
</p>

<p>
Decomentați în <code>kaio.c</code> linia cu 
</p>
<pre class="code c"><span class="co2">#define USE_EVENTFD</span></pre>

<p>
La inițializarea structurilor <code>iocb</code>, folosiți funcția <code>io_set_eventfd</code> pentru a activa folosirea <code>eventfd</code>. Completați funcția <code>wait_aio</code> pentru a aștepta terminarea operațiilor asincrone folosind <code>eventfd</code>.
</p>

<p>
Parcurgeți secțiunea <a href="laborator-11.html#linux_aio" title="so:laboratoare:laborator-11 ↵" class="wikilink1">Linux AIO</a> și urmăriți comentariile cu <em> TODO 2 </em>. Consultați exemplul lui <a href="http://www.xmailserver.org/eventfd-aio-test.c" class="urlextern" title="http://www.xmailserver.org/eventfd-aio-test.c"  rel="nofollow"> Davide Libenzi</a>. 
</p>

<p>
Compilați și rulați programul. Va trebui să aveți 4 fișiere de dimensiune 8192 octeți create în <code>/tmp</code>. 
</p>

</div>

<h2 class="sectionedit33" id="bonus">BONUS</h2>
<div class="level2">
<ol>
<li class="level1"><div class="li"> <strong>(1 so karma)</strong> <code>signalfd</code></div>
<ul>
<li class="level2"><div class="li"> Modificați codul de la exercițiul 2 pentru a permite notificarea de terminare a clienților bazată pe semnale.</div>
</li>
<li class="level2"><div class="li"> Server-ul:</div>
<ul>
<li class="level3"><div class="li"> creează un descriptor via <a href="laborator-11.html#signalfd" title="so:laboratoare:laborator-11 ↵" class="wikilink1">signalfd</a> pentru semnalul SIGCHLD și îl adaugă la epoll</div>
</li>
<li class="level3"><div class="li"> la primirea unui semnal, prin read(2) pe descriptorul creat, determină PID-ul copilului defunct, afișează un mesaj și scoate pipe-ul din epoll. </div>
</li>
</ul>
</li>
<li class="level2"><div class="li"> <strong>Hints</strong>: </div>
<ul>
<li class="level3"><div class="li"> Consultați secțiunea <a href="laborator-11.html#signalfd" title="so:laboratoare:laborator-11 ↵" class="wikilink1">signalfd</a></div>
</li>
<li class="level3"><div class="li"> <a href="http://linux.die.net/man/2/signalfd" class="urlextern" title="http://linux.die.net/man/2/signalfd"  rel="nofollow"> man signalfd </a></div>
</li>
</ul>
</li>
</ul>
</li>
</ol>

</div>

<h2 class="sectionedit34" id="solutii">Soluții</h2>
<div class="level2">

<p>
<a href="http://elf.cs.pub.ro/so/res/laboratoare/lab11-sol.zip" class="urlextern" title="http://elf.cs.pub.ro/so/res/laboratoare/lab11-sol.zip"  rel="nofollow"> Soluţii laborator 11</a>
</p>

</div>

        </div>
        <div class="right_sidebar">
          <form action="../../start.html" accept-charset="utf-8" class="search" id="dw__search" method="get"><div class="no"><input type="hidden" name="do" value="search" /><input type="text" id="qsearch__in" accesskey="f" name="id" class="edit" title="[F]" /><input type="submit" value="Search" class="button" title="Search" /><div id="qsearch__out" class="ajax_qsearch JSpopup"></div></div></form>          <div class="namespace_sidebar sidebar_box">



<h1 class="sectionedit1" id="informatii_generale_so">Informații generale SO</h1>
<div class="level1">

<div><div id="nojs_indexmenu_25747817458355addd75b4" data-jsajax="%26skipfile%3D%253D/so%253Ainfo%253Astart/" class="indexmenu_nojs">

<ul class="idx">
<li class="level1"><div class="li"><a href="../info/documentatie.html" class="wikilink1" title="so:info:documentatie">Documentație și alte resurse</a></div></li>
<li class="level1"><div class="li"><a href="../info/feed.html" class="wikilink1" title="so:info:feed">Feed RSS</a></div></li>
<li class="level1"><div class="li"><a href="../info/hall.html" class="wikilink1" title="so:info:hall">Hall of SO</a></div></li>
<li class="level1"><div class="li"><a href="../info/lista-discutii.html" class="wikilink1" title="so:info:lista-discutii">Listă de discuții</a></div></li>
<li class="level1"><div class="li"><a href="../info/mv.html" class="wikilink1" title="so:info:mv">Mașini virtuale</a></div></li>
<li class="level1"><div class="li"><a href="../info/trimitere-teme.html" class="wikilink1" title="so:info:trimitere-teme">Trimitere teme</a></div></li>
</ul>
</div></div>

</div>
<!-- EDIT1 SECTION "Informații generale SO" [12-194] -->
<h1 class="sectionedit2" id="informatii_so_2015-2016">Informații SO 2015-2016</h1>
<div class="level1">

<div><div id="nojs_indexmenu_72679474858355addd94f6" data-jsajax="" class="indexmenu_nojs">

<ul class="idx">
<li class="open"><div class="li"><a href="../meta/examen.html" class="indexmenu_idx_head">Examen CA/CC</a></div>
<ul class="idx">
<li class="level2"><div class="li"><a href="../meta/examen/2012-2013.html" class="wikilink1" title="so:meta:examen:2012-2013">Examen CA/CC 2012-2013</a></div></li>
<li class="level2"><div class="li"><a href="../meta/examen/2013-2014.html" class="wikilink1" title="so:meta:examen:2013-2014">Examen CA/CC 2013-2014</a></div></li>
<li class="level2"><div class="li"><a href="../meta/examen/2014-2015.html" class="wikilink1" title="so:meta:examen:2014-2015">Examen CA/CC 2014-2015</a></div></li>
</ul>
</li>
<li class="open"><div class="li"><a href="../meta/notare.html" class="indexmenu_idx_head">Reguli generale și notare</a></div>
<ul class="idx">
<li class="level2"><div class="li"><a href="../meta/notare/reguli-notare-ca-cc.html" class="wikilink1" title="so:meta:notare:reguli-notare-ca-cc">Notare CA/CC</a></div></li>
<li class="level2"><div class="li"><a href="../meta/notare/reguli-notare-cb.html" class="wikilink1" title="so:meta:notare:reguli-notare-cb">Notare CB</a></div></li>
</ul>
</li>
<li class="level1"><div class="li"><a href="../meta/anunturi.html" class="wikilink1" title="so:meta:anunturi">Anunțuri</a></div></li>
<li class="level1"><div class="li"><a href="../meta/calendar.html" class="wikilink1" title="so:meta:calendar">Calendar</a></div></li>
<li class="level1"><div class="li"><a href="../meta/catalog.html" class="wikilink1" title="so:meta:catalog">Catalog</a></div></li>
<li class="level1"><div class="li"><a href="../meta/echivalari.html" class="wikilink1" title="so:meta:echivalari">Echivalări teme</a></div></li>
<li class="level1"><div class="li"><a href="../meta/karma.html" class="wikilink1" title="so:meta:karma">Karma Awards</a></div></li>
<li class="level1"><div class="li"><a href="../meta/need-to-know.html" class="wikilink1" title="so:meta:need-to-know">SO Need to Know</a></div></li>
<li class="level1"><div class="li"><a href="../meta/orar.html" class="wikilink1" title="so:meta:orar">Orar și împărțire pe semigrupe</a></div></li>
</ul>
</div></div>

</div>
<!-- EDIT2 SECTION "Informații SO 2015-2016" [195-261] -->
<h1 class="sectionedit3" id="laboratoare">Laboratoare</h1>
<div class="level1">

<div><div id="nojs_indexmenu_38054704958355addda496" data-jsajax="" class="indexmenu_nojs">

<ul class="idx">
<li class="open"><div class="li"><a href="resurse.html" class="indexmenu_idx_head">Resurse</a></div>
<ul class="idx">
<li class="level2"><div class="li"><a href="resurse/c_tips.html" class="wikilink1" title="so:laboratoare:resurse:c_tips">C/SO Tips</a></div></li>
<li class="level2"><div class="li"><a href="resurse/die.html" class="wikilink1" title="so:laboratoare:resurse:die">Macro-ul DIE</a></div></li>
<li class="level2"><div class="li"><a href="resurse/gdb.html" class="wikilink1" title="so:laboratoare:resurse:gdb">GDB</a></div></li>
<li class="level2"><div class="li"><a href="resurse/home.html" class="wikilink1" title="so:laboratoare:resurse:home">Resurse</a></div></li>
<li class="level2"><div class="li"><a href="resurse/injections.html" class="wikilink1" title="so:laboratoare:resurse:injections">Function Hooking and Windows Dll Injection</a></div></li>
<li class="level2"><div class="li"><a href="resurse/oprofile.html" class="wikilink1" title="so:laboratoare:resurse:oprofile">Oprofile</a></div></li>
<li class="level2"><div class="li"><a href="resurse/recapitulare.html" class="wikilink1" title="so:laboratoare:resurse:recapitulare">Recapitulare</a></div></li>
<li class="level2"><div class="li"><a href="resurse/threaduri_extra.html" class="wikilink1" title="so:laboratoare:resurse:threaduri_extra">Thread-uri - Extra</a></div></li>
<li class="level2"><div class="li"><a href="resurse/vs_tips.html" class="wikilink1" title="so:laboratoare:resurse:vs_tips">Visual Studio Tips and Tricks</a></div></li>
<li class="level2"><div class="li"><a href="resurse/windows-video.html" class="wikilink1" title="so:laboratoare:resurse:windows-video">windows-video</a></div></li>
</ul>
</li>
<li class="level1"><div class="li"><a href="laborator-01.html" class="wikilink1" title="so:laboratoare:laborator-01">Laborator 01 - Introducere</a></div></li>
<li class="level1"><div class="li"><a href="laborator-02.html" class="wikilink1" title="so:laboratoare:laborator-02">Laborator 02 - Operații I/O simple</a></div></li>
<li class="level1"><div class="li"><a href="laborator-03.html" class="wikilink1" title="so:laboratoare:laborator-03">Laborator 03 - Procese</a></div></li>
<li class="level1"><div class="li"><a href="laborator-04.html" class="wikilink1" title="so:laboratoare:laborator-04">Laborator 04 - Semnale</a></div></li>
<li class="level1"><div class="li"><a href="laborator-05.html" class="wikilink1" title="so:laboratoare:laborator-05">Laborator 05 - Gestiunea memoriei</a></div></li>
<li class="level1"><div class="li"><a href="laborator-06.html" class="wikilink1" title="so:laboratoare:laborator-06">Laborator 06 - Memoria virtuală</a></div></li>
<li class="level1"><div class="li"><a href="laborator-07.html" class="wikilink1" title="so:laboratoare:laborator-07">Laborator 07 - Profiling &amp; Debugging</a></div></li>
<li class="level1"><div class="li"><a href="laborator-08.html" class="wikilink1" title="so:laboratoare:laborator-08">Laborator 08 - Thread-uri Linux</a></div></li>
<li class="level1"><div class="li"><a href="laborator-09.html" class="wikilink1" title="so:laboratoare:laborator-09">Laborator 09 - Thread-uri Windows</a></div></li>
<li class="level1"><div class="li"><a href="laborator-10.html" class="wikilink1" title="so:laboratoare:laborator-10">Laborator 10 - Operații IO avansate - Windows</a></div></li>
<li class="level1"><div class="li"><span class="curid"><a href="laborator-11.html" class="wikilink1" title="so:laboratoare:laborator-11">Laborator 11 - Operații IO avansate - Linux</a></span></div></li>
<li class="level1"><div class="li"><a href="laborator-12.html" class="wikilink1" title="so:laboratoare:laborator-12">Laborator 12 - Implementarea sistemelor de fișiere</a></div></li>
</ul>
</div></div>

</div>
<!-- EDIT3 SECTION "Laboratoare" [262-322] -->
<h1 class="sectionedit4" id="cursuri">Cursuri</h1>
<div class="level1">

<div><div id="nojs_indexmenu_166027450658355adddb437" data-jsajax="" class="indexmenu_nojs">

<ul class="idx">
<li class="closed"><div class="li"><a href="../cursuri/curs-01.html" class="indexmenu_idx_head">Curs 01 - Introducere</a></div></li>
<li class="closed"><div class="li"><a href="../cursuri/curs-02.html" class="indexmenu_idx_head">Curs 02 - Sistemul de fișiere</a></div></li>
<li class="closed"><div class="li"><a href="../cursuri/curs-03.html" class="indexmenu_idx_head">Curs 03 - Procese</a></div></li>
<li class="closed"><div class="li"><a href="../cursuri/curs-04.html" class="indexmenu_idx_head">Curs 04 - Planificarea execuției. IPC</a></div></li>
<li class="closed"><div class="li"><a href="../cursuri/curs-05.html" class="indexmenu_idx_head">Curs 05 - Gestiunea memoriei</a></div></li>
<li class="closed"><div class="li"><a href="../cursuri/curs-06.html" class="indexmenu_idx_head">Curs 06 - Memoria virtuală</a></div></li>
<li class="closed"><div class="li"><a href="../cursuri/curs-07.html" class="indexmenu_idx_head">Curs 07 - Securitatea memoriei</a></div></li>
<li class="closed"><div class="li"><a href="../cursuri/curs-08.html" class="indexmenu_idx_head">Curs 08 - Fire de execuție</a></div></li>
<li class="closed"><div class="li"><a href="../cursuri/curs-09.html" class="indexmenu_idx_head">Curs 09 - Sincronizare</a></div></li>
<li class="closed"><div class="li"><a href="../cursuri/curs-10.html" class="indexmenu_idx_head">Curs 10 - Dispozitive de intrare/ieșire</a></div></li>
<li class="closed"><div class="li"><a href="../cursuri/curs-11.html" class="indexmenu_idx_head">Curs 11 - Networking în sistemul de operare</a></div></li>
<li class="closed"><div class="li"><a href="../cursuri/curs-12.html" class="indexmenu_idx_head">Curs 12 - Implementarea sistemelor de fișiere</a></div></li>
<li class="closed"><div class="li"><a href="../cursuri/curs-13.html" class="indexmenu_idx_head">Curs 13 - Securitatea sistemului</a></div></li>
<li class="closed"><div class="li"><a href="../cursuri/quiz/start.html" class="indexmenu_idx_head">Quizz-uri curs</a></div></li>
<li class="level1"><div class="li"><a href="../cursuri/curs-extra-2.html" class="wikilink1" title="so:cursuri:curs-extra-2">Curs extra - Android</a></div></li>
<li class="level1"><div class="li"><a href="../cursuri/curs-extra-3.html" class="wikilink1" title="so:cursuri:curs-extra-3">Curs extra - Virtualizare</a></div></li>
<li class="level1"><div class="li"><a href="../cursuri/curs-extra.html" class="wikilink1" title="so:cursuri:curs-extra">Curs extra - Sincronizarea proceselor</a></div></li>
<li class="level1"><div class="li"><a href="../cursuri/note.html" class="wikilink1" title="so:cursuri:note">Note de curs</a></div></li>
</ul>
</div></div>

</div>
<!-- EDIT4 SECTION "Cursuri" [323-374] -->
<h1 class="sectionedit5" id="teme">Teme</h1>
<div class="level1">

<div><div id="nojs_indexmenu_142655464258355adddc3d5" data-jsajax="" class="indexmenu_nojs">

<ul class="idx">
<li class="closed"><div class="li"><a href="../teme/tema-asist.html" class="indexmenu_idx_head">Tema Asistenți - Guardian process</a></div></li>
<li class="level1"><div class="li"><a href="../teme/contestatii.html" class="wikilink1" title="so:teme:contestatii">Contestații</a></div></li>
<li class="level1"><div class="li"><a href="../teme/folosire-gitlab.html" class="wikilink1" title="so:teme:folosire-gitlab">Git. Indicații folosire GitLab</a></div></li>
<li class="level1"><div class="li"><a href="../teme/general.html" class="wikilink1" title="so:teme:general">Indicații generale teme</a></div></li>
<li class="level1"><div class="li"><a href="../teme/tema-1.html" class="wikilink1" title="so:teme:tema-1">Tema 1 Multi-platform Development</a></div></li>
<li class="level1"><div class="li"><a href="../teme/tema-2.html" class="wikilink1" title="so:teme:tema-2">Tema 2 Mini-shell</a></div></li>
<li class="level1"><div class="li"><a href="../teme/tema-3.html" class="wikilink1" title="so:teme:tema-3">Tema 3 Memorie virtuală</a></div></li>
<li class="level1"><div class="li"><a href="../teme/tema-4.html" class="wikilink1" title="so:teme:tema-4">Tema 4 Planificator de threaduri</a></div></li>
<li class="level1"><div class="li"><a href="../teme/tema-5.html" class="wikilink1" title="so:teme:tema-5">Tema 5 Server web asincron</a></div></li>
</ul>
</div></div>

</div>
<!-- EDIT5 SECTION "Teme" [375-] -->
</div>
<div class="toc_sidebar sidebar_box">
<!-- TOC START -->
<div id="sb__right__dw__toc">
<h3 class="toggle">Table of Contents</h3>
<div>

<ul class="toc">
<li class="level1"><div class="li"><a href="laborator-11.html#laborator_11_-_operatii_io_avansate_-_linux">Laborator 11 - Operații IO avansate - Linux</a></div>
<ul class="toc">
<li class="level2"><div class="li"><a href="laborator-11.html#materiale_ajutatoare">Materiale Ajutătoare</a></div></li>
<li class="level2"><div class="li"><a href="laborator-11.html#nice_to_read">Nice to read</a></div></li>
<li class="level2"><div class="li"><a href="laborator-11.html#linux_-_multiplexarea_io">Linux - multiplexarea I/O</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="laborator-11.html#select">select</a></div></li>
<li class="level3"><div class="li"><a href="laborator-11.html#poll">poll</a></div></li>
<li class="level3"><div class="li"><a href="laborator-11.html#epoll">epoll</a></div></li>
<li class="level3"><div class="li"><a href="laborator-11.html#crearea_unui_obiect_epoll">Crearea unui obiect epoll</a></div></li>
<li class="level3"><div class="li"><a href="laborator-11.html#adaugareaeliminarea_descriptorilor_lade_la_obiectul_epoll">Adăugarea/eliminarea descriptorilor la/de la obiectul epoll</a></div></li>
<li class="level3"><div class="li"><a href="laborator-11.html#asteptarea_unui_eveniment_io">Așteptarea unui eveniment I/O</a></div></li>
<li class="level3"><div class="li"><a href="laborator-11.html#edge-triggered_sau_level-triggered">Edge-triggered sau level-triggered</a></div></li>
<li class="level3"><div class="li"><a href="laborator-11.html#exemplu_folosire_epoll">Exemplu folosire epoll</a></div></li>
</ul>
</li>
<li class="level2"><div class="li"><a href="laborator-11.html#linux_-_generalizarea_multiplexarii">Linux - generalizarea multiplexării</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="laborator-11.html#eventfd">eventfd</a></div></li>
<li class="level3"><div class="li"><a href="laborator-11.html#signalfd">signalfd</a></div></li>
</ul>
</li>
<li class="level2"><div class="li"><a href="laborator-11.html#linux_-_operatii_asincrone">Linux - operații asincrone</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="laborator-11.html#linux_aio">Linux AIO</a></div></li>
<li class="level3"><div class="li"><a href="laborator-11.html#structuri_de_baza_linux_aio">Structuri de bază Linux AIO</a></div></li>
<li class="level3"><div class="li"><a href="laborator-11.html#context_aio">Context AIO</a></div></li>
<li class="level3"><div class="li"><a href="laborator-11.html#operatii_aio">Operații AIO</a></div></li>
<li class="level3"><div class="li"><a href="laborator-11.html#integrarea_linux_aio_cu_eventfd">Integrarea Linux AIO cu eventfd</a></div></li>
</ul>
</li>
<li class="level2"><div class="li"><a href="laborator-11.html#zero-copy_io">Zero-copy I/O</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="laborator-11.html#linux_-_splice">Linux - splice</a></div></li>
</ul>
</li>
<li class="level2"><div class="li"><a href="laborator-11.html#vectored_io">Vectored I/O</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="laborator-11.html#readvwritev">readv/writev</a></div></li>
</ul>
</li>
<li class="level2"><div class="li"><a href="laborator-11.html#exercitiul_0_-_joc_interactiv_2p">Exercițiul 0 - Joc interactiv (2p)</a></div></li>
<li class="level2"><div class="li"><a href="laborator-11.html#linux_9p">Linux (9p)</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="laborator-11.html#exercitiul_1_-_poll_1p">Exercițiul 1 - poll (1p)</a></div></li>
<li class="level3"><div class="li"><a href="laborator-11.html#exercitiul_2_-_epoll_2p">Exercițiul 2 - epoll (2p)</a></div></li>
<li class="level3"><div class="li"><a href="laborator-11.html#exercitiul_3_-_eventfd_2p">Exercițiul 3 - eventfd (2p)</a></div></li>
<li class="level3"><div class="li"><a href="laborator-11.html#exercitiul_4_-_async_io_kaio_2p">Exercițiul 4 - async I/O (KAIO) (2p)</a></div></li>
<li class="level3"><div class="li"><a href="laborator-11.html#exercitiul_5_-_async_io_kaio_2p">Exercițiul 5 - async I/O (KAIO) (2p)</a></div></li>
</ul>
</li>
<li class="level2"><div class="li"><a href="laborator-11.html#bonus">BONUS</a></div></li>
<li class="level2"><div class="li"><a href="laborator-11.html#solutii">Soluții</a></div></li>
</ul></li>
</ul>
</div>
</div>
<!-- TOC END -->
</div>
        </div>
      
    
      <div class="stylefoot">
        <div class="meta">
          <div class="user">
                    </div>
          <div class="doc">
          so/laboratoare/laborator-11.txt · Last modified: 2016/05/11 23:32 by elena.sandulescu          </div>
        </div>
      </div>

    <div class="clearer"></div>

    
                <div class="bar" id="bar__bottom">
      <div class="bar-left">
              </div>
      <div class="bar-right">
        <a href="laborator-11%3Fdo=media&amp;ns=so%253Alaboratoare.html"  class="action media" rel="nofollow" title="Media Manager">Media Manager</a><a href="laborator-11.html#dokuwiki__top"  class="action top" accesskey="t" rel="nofollow" title="Back to top [T]">Back to top</a>      </div>
    </div>
    <div class="clearer"></div>
            
    <div align="center" class="footerinc">
  <div class="license"><a href="http://creativecommons.org/licenses/by-sa/3.0/" rel="license"><img src="../../lib/images/license/button/cc-by-sa.png" alt="CC Attribution-Share Alike 3.0 Unported" /></a></div>
  <a target="_blank" href="http://www.chimeric.de" title="www.chimeric.de"><img src="../../lib/tpl/arctic/images/button-chimeric-de.png" width="80" height="15" alt="www.chimeric.de" border="0" /></a>

  <a target="_blank" href="http://jigsaw.w3.org/css-validator/check/referer" title="Valid CSS"><img src="../../lib/tpl/arctic/images/button-css.png" width="80" height="15" alt="Valid CSS" border="0" /></a>

  <a target="_blank" href="http://wiki.splitbrain.org/wiki:dokuwiki" title="Driven by DokuWiki"><img src="../../lib/tpl/arctic/images/button-dw.png" width="80" height="15" alt="Driven by DokuWiki" border="0" /></a>

  <a target="_blank" href="http://www.firefox-browser.de" title="do yourself a favour and use a real browser - get firefox"><img src="../../lib/tpl/arctic/images/button-firefox.png" width="80" height="15" alt="do yourself a favour and use a real browser - get firefox!!" border="0" /></a>
  
  <a target="_blank" href="../../feed.php" title="Recent changes RSS feed"><img src="../../lib/tpl/arctic/images/button-rss.png" width="80" height="15" alt="Recent changes RSS feed" border="0" /></a>

  <a target="_blank" href="http://validator.w3.org/check/referer" title="Valid XHTML 1.0"><img src="../../lib/tpl/arctic/images/button-xhtml.png" width="80" height="15" alt="Valid XHTML 1.0" border="0" /></a>
</div>

  </div>
</div>

<div class="no"><img src="../../lib/exe/indexer.php%3Fid=so%253Alaboratoare%253Alaborator-11&amp;1479891677" width="2" height="1" alt="" /></div>
</body>
</html>
