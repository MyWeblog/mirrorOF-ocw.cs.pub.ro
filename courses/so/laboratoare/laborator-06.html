    
    

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"
 lang="en" dir="ltr">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>
    Laborator 06 - Memoria virtuală    [CS Open CourseWare]
  </title>

  <meta name="generator" content="DokuWiki"/>
<meta name="robots" content="index,follow"/>
<meta name="date" content="2016-04-05T02:41:55+0300"/>
<meta name="keywords" content="so,laboratoare,laborator-06"/>
<link rel="search" type="application/opensearchdescription+xml" href="../../lib/exe/opensearch.php" title="CS Open CourseWare"/>
<link rel="start" href="../../../courses.1.html"/>
<link rel="alternate" type="application/rss+xml" title="Recent Changes" href="../../feed.php"/>
<link rel="alternate" type="application/rss+xml" title="Current Namespace" href="../../feed.php%3Fmode=list&amp;ns=so:laboratoare"/>
<link rel="alternate" type="text/html" title="Plain HTML" href="../../_export/xhtml/so/laboratoare/laborator-06.html"/>
<link rel="canonical" href="laborator-06.html"/>
<link rel="stylesheet" type="text/css" href="../../lib/exe/css.php%3Ft=arctic&amp;tseed=1476798676.css"/>
<script type="text/javascript">/*<![CDATA[*/var NS='so:laboratoare';var JSINFO = {"id":"so:laboratoare:laborator-06","namespace":"so:laboratoare","isadmin":0,"isauth":0};
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="../../lib/exe/js.php%3Ftseed=1476798676"></script>
<script type="text/x-mathjax-config">/*<![CDATA[*/MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ["$","$"], ["\\(","\\)"] ],
        displayMath: [ ["$$","$$"], ["\\[","\\]"] ],
        processEscapes: true
    }
});
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
<script type="text/javascript">/*<![CDATA[*/
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
		  
/*!]]>*/</script>
<script type="text/javascript">/*<![CDATA[*/
var pageTracker = _gat._getTracker("UA-38383934-1");
pageTracker._initData();
pageTracker._trackPageview();
		  
/*!]]>*/</script>

  <link rel="shortcut icon" href="../../lib/tpl/arctic/images/favicon.ico" />

  
</head>
<body>
<div id="wrapper" class='show'>
  <div class="dokuwiki">

    
    <div class="stylehead">
      <div class="header">
        <div class="pagename">
          <a href="http://ocw.cs.pub.ro/courses/so/"><img height="70" src="../../res/sigla_so.png"/> </a>        </div>
        <div class="logo">
          <a style="color: #AAA !important;" href="../../systems/index.html"/><img height="70" src="../../res/systems.png" name="dokuwiki__top"/></a>        </div>
      </div>
    
       
      <div class="breadcrumbs">
              </div>
      
            </div>

                  <div class="bar" id="bar__top">
        <div class="bar-left">
                  </div>
        <div class="bar-right">
          <a href="laborator-06%3Fdo=recent.html"  class="action recent" accesskey="r" rel="nofollow" title="Recent changes [R]">Recent changes</a><a href="laborator-06%3Fdo=login&amp;sectok=f62420cf5b01253da4b50505d148181b.html"  class="action login" rel="nofollow" title="Login">Login</a>        </div>
    </div>
        
    
    
    
              <div class="left_page">
          
<h1 class="sectionedit1" id="laborator_06_-_memoria_virtuala">Laborator 06 - Memoria virtuală</h1>
<div class="level1">

</div>

<h2 class="sectionedit2" id="materiale_ajutatoare">Materiale ajutătoare</h2>
<div class="level2">
<ul>
<li class="level1"><div class="li"><a href="http://elf.cs.pub.ro/so/res/laboratoare/lab06-slides.pdf" class="urlextern" title="http://elf.cs.pub.ro/so/res/laboratoare/lab06-slides.pdf"  rel="nofollow"> lab06-slides.pdf</a></div>
</li>
<li class="level1"><div class="li"><a href="http://elf.cs.pub.ro/so/res/laboratoare/lab06-refcard.pdf" class="urlextern" title="http://elf.cs.pub.ro/so/res/laboratoare/lab06-refcard.pdf"  rel="nofollow"> lab06-refcard.pdf</a></div>
</li>
</ul>

</div>

<h3 class="sectionedit3" id="nice_to_read">Nice to read</h3>
<div class="level3">
<ul>
<li class="level1"><div class="li"> TLPI - Chapter 49, Memory mappings </div>
</li>
<li class="level1"><div class="li"> TLPI - Chapter 50, Virtual memory operations</div>
</li>
</ul>

</div>

<h2 class="sectionedit4" id="memoria_virtuala">Memoria virtuală</h2>
<div class="level2">

<p>
Mecanismul de memorie virtuală este folosit de către nucleul sistemului de operare pentru a implementa o politică eficientă de gestiune a memoriei. Astfel, cu toate că aplicațiile folosesc în mod curent memoria virtuală, ele nu fac acest lucru în mod explicit. Există însă câteva cazuri în care aplicațiile folosesc memoria virtuală în mod explicit.
</p>

<p>
Sistemul de operare oferă primitive de mapare a fișierelor, a memoriei sau a dispozitivelor în spațiul de adresă al unui proces.
</p>
<ul>
<li class="level1"><div class="li"><strong>Maparea fișierelor</strong> în memorie este folosită în unele sisteme de operare pentru a implementa mecanisme de memorie partajată. De asemenea, acest mecanism face posibilă implementarea paginării la cerere și a bibliotecilor partajate.</div>
</li>
<li class="level1"><div class="li"><strong>Maparea memoriei</strong> în spațiul de adresă este folositoare atunci când un proces dorește să aloce o cantitate mare de memorie.</div>
</li>
<li class="level1"><div class="li"><strong>Maparea dispozitivelor</strong> este folositoare atunci când un proces dorește să folosească direct memoria unui dispozitiv cum ar fi placa video.</div>
</li>
</ul>

</div>

<h3 class="sectionedit5" id="concepte_teoretice">Concepte teoretice</h3>
<div class="level3">

<p>
Dimensiunea spațiului de adresă virtual al unui proces depinde de dimensiunea registrelor procesorului. Astfel, pe un sistem cu 32-bit un proces va putea accesa 2^32 = 4GB spațiu de memorie (pe de altă parte, pe un sistem de 64-bit va accesa teoretic 2^64). Spațiul de memorie al procesului este împărțit în spațiu rezervat pentru adresele virtuale de kernel - acest spațiu este comun tuturor proceselor - și spațiul virtual (propriu) de adrese al procesului. De cele mai multe ori împărțirea între cele două este de 3/1 (3G userspace vs 1G kernelspace).
</p>

<p>
Memoria fizică (RAM) este împărțită între procesele active în momentul respectiv și sistemul de operare. Astfel că, în funcție de câtă memorie avem pe mașina fizică, este posibil să epuizăm toate resursele și să nu mai putem porni un proces nou. Pentru a evita acest scenariu s-a introdus mecanismul de memorie virtuală. În felul acesta, chiar dacă spațiul virtual (compus din segmentul de text, data, heap, stivă) al unui proces este mai mare decât memoria fizică disponibilă pe sistem, procesul va putea rula încărcându-și în memorie doar paginile de care are nevoie în timpul execuției (on demand paging).
</p>

<p>
Spațiul virtual de adrese este împărțit în <em>pagini virtuale</em> (page). Corespondentul pentru memoria fizică este <em>pagina fizică</em> (frame). Dimensiunea unei pagini virtuale este egală cu cea a unei pagini fizice. Dimensiunea este dată de hardware (în majoritatea cazurilor o pagină are 4K pe un sistem de 32-bit sau 64-bit).
</p>

<p>
Atât timp cât un proces în timpul rulării accesează numai pagini rezidente în memorie, se execută ca și când ar avea tot spațiul mapat în memoria fizică. În momentul în care un proces va dori să acceseze o anumită pagină virtuală, care nu este mapată în memorie, se va genera un <em>page fault</em>, iar în urma acestui page fault pagina virtuală va fi mapată la o pagină fizică. Două procese diferite au spațiu virtual diferit, însă anumite pagini virtuale din aceste procese se pot mapa la aceeași pagină fizică. Astfel că, două procese diferite pot partaja o aceeași pagină fizică, dar nu partajează pagini virtuale.
</p>

</div>

<h4 id="malloc">malloc</h4>
<div class="level4">

<p>
Așa cum am aflat la laboratorul de <a href="laborator-05.html#alocareadealocarea_memoriei" class="urlextern" title="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-05#alocareadealocarea_memoriei"  rel="nofollow"> gestiunea memoriei</a>, <code>malloc</code> alocă memorie pe heap, deci în spațiul virtual al procesului. Funcția <code>malloc</code> poate fi implementată fie folosind apeluri de sistem <code>brk</code>, fie apeluri <code>mmap</code> (mai multe detalii găsiți <a href="../cursuri/curs-06.html#alocarea_de_memorie_virtuala" class="urlextern" title="http://ocw.cs.pub.ro/courses/so/cursuri/curs-06#alocarea_de_memorie_virtuala"  rel="nofollow">aici</a>). Despre funcția <code>mmap</code> vom vorbi în următoarele paragrafe din laboratorul curent. 
</p>

<p>
Alocarea memoriei virtuale se face la nivel de pagină, astfel că <code>malloc</code> va aloca de fapt cel mai mic număr de pagini virtuale ce cuprinde spațiul de memorie cerut. Fie următorul cod:
</p>
<pre class="code c"><span class="kw4">char</span> <span class="sy0">*</span>p <span class="sy0">=</span> <a href="http://www.opengroup.org/onlinepubs/009695399/functions/malloc.html"><span class="kw3">malloc</span></a><span class="br0">&#40;</span><span class="nu0">4150</span><span class="br0">&#41;</span><span class="sy0">;</span>
DIE<span class="br0">&#40;</span>p <span class="sy0">==</span> NULL<span class="sy0">,</span> <span class="st0">&quot;malloc failed&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>
Considerând că o pagină virtuală are 4K = 4096 octeți, atunci apelul <code>malloc</code> va aloca 4096 octeți + 54 octeți = 4K + 54 octeți, spațiu care nu este cuprins într-o singură pagină virtuală, astfel că se vor aloca 2 pagini virtuale. În momentul alocării cu <code>malloc</code> nu se vor aloca (tot timpul) și pagini fizice, acestea vor fi alocate doar atunci când sunt accesate datele din zona de memorie alocată cu <code>malloc</code>. De exemplu, în momentul accesării unui element din p se va genera un <em>page fault</em>, iar pagina virtuală ce cuprinde acel element va fi mapată la o pagină fizică.
</p>

<p>
<p><div class="noteclassic">
În general, la apelul malloc de dimensiuni mici, când se apelează în spate apelul de sistem <code>brk</code>, biblioteca standard C parcurge paginile alocate, se generează page fault-uri, iar la revenirea din apel paginile fizice vor fi deja alocate. Putem spune că pentru dimensiuni mici, apelul <code>malloc</code> așa cum este văzut el din aplicație (din afara bibliotecii standard C) alocă și pagini fizice și pagini virtuale.
</p>

<p>
Mai mult, alocarea efectivă de pagini virtuale și fizice are loc în momentul apelului de sistem <code>brk</code>. Acesta prealocă un spațiu mai mare, iar viitoarele apeluri <code>malloc</code> vor folosi acest spațiu. În acest fel, apelurile <code>malloc</code> vor fi eficiente: nu vor face apel de sistem, nu vor face alocare efectivă de spațiu fizic sau virtual, nu vor genera <em>page fault-uri</em>.
</p>

<p>
Apelul <code>malloc</code> este mai eficient decât apelul <code>calloc</code> pentru că nu parcurge spațiul alocat pentru a-l umple cu zero-uri. Acest lucru înseamnă că <code>malloc</code> va întoarce zona alocată cu informațiile de acolo; în anumite situații, acest lucru poate fi un risc de securitate - dacă datele de acolo sunt private.

</div></p>
</p>

</div>

<h2 class="sectionedit6" id="linux">Linux</h2>
<div class="level2">

<p>
Funcțiile cu ajutorul cărora se pot face cereri explicite asupra memoriei virtuale sunt funcțiile din familia <code>mmap(2)</code>. Funcțiile folosesc ca unitate minimă de alocare <em>pagina</em> (adică se poate aloca numai un număr întreg de pagini, iar adresele trebuie să fie aliniate corespunzător).
</p>

</div>

<h3 class="sectionedit7" id="maparea_fisierelor">Maparea fișierelor</h3>
<div class="level3">

<p>
În urma mapării unui fișier în spațiul de adresă al unui proces, accesul la acest fișier se poate face similar cu accesarea datelor dintr-un vector. Eficiența metodei vine din faptul că zona de memorie este gestionată similar cu memoria virtuală, supunându-se regulilor de evacuare pe disc atunci când memoria devine insuficientă (în felul acesta se poate lucra cu mapări care depășesc dimensiunea efectivă a memoriei fizice). Mai mult, partea de <code>I/O</code> este realizată de către kernel, programatorul scriind cod care doar preia/stochează valori în regiunea mapată. Astfel nu se mai apelează <code>read</code>, <code>write</code>, <code>lseek</code> - ceea ce adesea simplifică scrierea codului.
</p>

<p>
<p><div class="noteimportant"> Nu orice descriptor de fișier poate fi mapat în memorie. Socket-urile, pipe-urile, majoritatea dispozitivelor nu permit decât accesul secvențial (ex. char device) și sunt incompatibile din această cauză cu conceptele de mapare. Există cazuri în care fișiere obișnuite nu pot fi mapate (spre exemplu, dacă nu au fost deschise pentru a putea fi citite; pentru mai multe informații: <strong>man mmap</strong>). 
</div></p>
</p>

</div>

<h4 id="mmap">mmap</h4>
<div class="level4">

<p>
Prototipul funcției <a href="http://linux.die.net/man/2/mmap" class="urlextern" title="http://linux.die.net/man/2/mmap"  rel="nofollow">mmap</a> ce permite maparea unui fișier în spațiul de adresă al unui proces este următorul:
</p>
<pre class="code cpp"><span class="kw4">void</span> <span class="sy2">*</span>mmap<span class="br0">&#40;</span><span class="kw4">void</span> <span class="sy2">*</span>start, <span class="kw4">size_t</span> length, <span class="kw4">int</span> prot, <span class="kw4">int</span> flags, <span class="kw4">int</span> fd, off_t offset<span class="br0">&#41;</span><span class="sy4">;</span></pre>

<p>
Funcția va întoarce în caz de eroare <code>MAP_FAILED</code>. Dacă maparea s-a făcut cu succes, va întoarce un pointer spre o zonă de memorie din spațiul de adresă al procesului, zonă în care a fost mapat fișierul descris de descriptorul <code>fd</code>, începând cu offset-ul <code>offset</code>. Folosirea parametrului <code>start</code> permite propunerea unei anumite zone de memorie la care să se facă maparea. Folosirea valorii <code>NULL</code> pentru parametrul <code>start</code> indică lipsa vreunei preferințe în ceea ce privește zona în care se va face alocarea. Adresa precizată prin parametrul <code>start</code> trebuie să fie multiplu de <em>dimensiunea unei pagini</em>. Dacă sistemul de operare nu poate să mapeze fișierul la adresa cerută, atunci îl va mapa la altă adresă apropiată multiplu de dimensiunea unei pagini. Adresa la care se mapează fișierul este întoarsă de funcție. 
</p>

<p>
Parametrul <code>prot</code> specifică tipul de acces care se dorește; poate fi <code>PROT_READ</code> (citire), <code>PROT_WRITE</code> (scriere), <code>PROT_EXEC</code> (execuție) sau <code>PROT_NONE</code>; dacă zona e folosită altfel decât s-a declarat se va genera un semnal <code>SIGSEGV</code>.
</p>

<p>
Parametrul <code>flags</code> permite stabilirea tipului de mapare ce se dorește; poate lua următoarele valori (combinate prin SAU pe biți; trebuie să existe cel puțin una: fie <code>MAP_PRIVATE</code>, fie <code>MAP_SHARED</code>):
</p>
<ul>
<li class="level1"><div class="li"><code>MAP_PRIVATE</code> - se folosește o politică de tip copy-on-write; zona va conține inițial o copie a fișierului, dar scrierile nu sunt făcute în fișier; modificările nu vor fi vizibile în alte procese dacă există mai multe procese care au făcut <code>mmap</code> pe aceeași zonă din același fișier</div>
</li>
<li class="level1"><div class="li"><code>MAP_SHARED</code> - scrierile sunt actualizate imediat în toate mapările existente (în acest fel toate procesele care au realizat mapări vor vedea modificările); pentru ca modificările să fie vizibile și pentru un proces ce utilizează read/write se poate folosi <code>msync</code>; altfel actualizarea va avea loc la un moment de timp nespecificat</div>
</li>
<li class="level1"><div class="li"><code>MAP_FIXED</code> - dacă nu se poate face alocarea la adresa specificată de <code>start</code>, apelul va eșua</div>
</li>
<li class="level1"><div class="li"><code>MAP_LOCKED</code> - se va bloca paginarea pe această zonă, în maniera <a href="http://linux.die.net/man/2/mlock" class="urlextern" title="http://linux.die.net/man/2/mlock"  rel="nofollow">mlock</a></div>
</li>
<li class="level1"><div class="li"><code>MAP_ANONYMOUS</code> - se mapează memorie (argumentele <code>fd</code> și <code>offset</code> sunt ignorate)</div>
</li>
</ul>

<p>
 Este de remarcat că folosirea <code>MAP_SHARED</code> permite partajarea memoriei între procese care nu sunt înrudite. În acest caz, conținutul fișierului devine conținutul inițial al memoriei partajate, și orice modificare făcută de procese în această zonă este copiată apoi în fișier, asigurând persistență prin sistemul de fișiere.  
</p>

</div>

<h4 id="msync">msync</h4>
<div class="level4">

<p>
Pentru a declanșa în mod explicit sincronizarea fișierului cu maparea din memorie este disponibilă funcția <a href="http://linux.die.net/man/2/msync" class="urlextern" title="http://linux.die.net/man/2/msync"  rel="nofollow">msync</a>:
</p>
<pre class="code c"><span class="kw4">int</span> msync<span class="br0">&#40;</span><span class="kw4">void</span> <span class="sy0">*</span>start<span class="sy0">,</span> <span class="kw4">size_t</span> length<span class="sy0">,</span> <span class="kw4">int</span> flags<span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>
unde <code>flags</code> poate fi:
</p>
<ul>
<li class="level1"><div class="li"><code>MS_SYNC</code> - datele vor fi scrise în fișier și după aceea funcția se va termina.</div>
</li>
<li class="level1"><div class="li"><code>MS_ASYNC</code> - este inițiată secvența de salvare, dar nu se așteaptă terminarea ei.</div>
</li>
<li class="level1"><div class="li"><code>MS_INVALIDATE</code> - se invalidează mapările zonei din alte procese, pentru a forța recitirea paginii în toate celelalte procese la următorul acces.</div>
</li>
</ul>

</div>

<h3 class="sectionedit8" id="alocare_de_memorie_in_spatiul_de_adresa_al_procesului">Alocare de memorie în spațiul de adresă al procesului</h3>
<div class="level3">

<p>
În UNIX, tradițional, pentru alocarea <em>memoriei dinamice</em>, se folosește apelul de sistem <a href="http://linux.die.net/man/2/brk" class="urlextern" title="http://linux.die.net/man/2/brk"  rel="nofollow">brk</a>. Acest apel crește sau descrește zona de heap asociată procesului. Odată cu oferirea către aplicații a unor apeluri de sistem de gestiune a memoriei virtuale (<a href="http://linux.die.net/man/2/mmap" class="urlextern" title="http://linux.die.net/man/2/mmap"  rel="nofollow">mmap</a>), a existat posibilitatea ca procesele să aloce memorie folosind aceste noi apeluri de sistem. Practic, procesele pot mapa memorie în spațiul de adresă, nu fișiere.
</p>

<p>
Procesele pot cere alocarea unei zone de memorie de la o anumită adresă din spațiul de adresare, chiar și cu o anumită politică de acces (citire, scriere sau execuție). În UNIX, acest lucru se face tot prin intermediul funcției <a href="http://linux.die.net/man/2/mmap" class="urlextern" title="http://linux.die.net/man/2/mmap"  rel="nofollow">mmap</a>. Pentru acest lucru parametrul de flag-uri trebuie să conțină flag-ul <code>MAP_ANONYMOUS</code>.
</p>

</div>

<h3 class="sectionedit9" id="maparea_dispozitivelor">Maparea dispozitivelor</h3>
<div class="level3">

<p>
Există chiar și posibilitatea ca aplicațiile să mapeze în spațiul de adresă al unui proces un dispozitiv de intrare-ieșire. Acest lucru este util de exemplu pentru plăcile video: o aplicație poate mapa în spațiul de adresă memoria fizica a plăcii video. În UNIX, dispozitivele fiind reprezentate prin fișiere, pentru a realiza acest lucru nu trebuie decât să deschidem fișierul asociat dispozitivului și să-l folosim într-un apel <code>mmap</code>.
</p>

<p>
<p><div class="noteimportant"> Nu toate dispozitivele pot fi mapate în memorie, iar atunci când pot fi mapate, ce înseamnă acest lucru depinde de dispozitiv. 
</div></p>
</p>

<p>
Un alt exemplu de dispozitiv care poate fi mapat este chiar memoria. În Linux se poate folosi fișierul <code>/dev/zero</code> pentru a face mapări de memorie, ca și când s-ar folosi flag-ul <code>MAP_ANONYMOUS</code>.
</p>

</div>

<h3 class="sectionedit10" id="demaparea_unei_zone_din_spatiul_de_adresa">Demaparea unei zone din spațiul de adresă</h3>
<div class="level3">

<p>
Dacă se dorește demaparea unei zone din spațiul de adresă al procesului se poate folosi funcția <a href="http://linux.die.net/man/3/munmap" class="urlextern" title="http://linux.die.net/man/3/munmap"  rel="nofollow">munmap</a>:
</p>
<pre class="code c"> <span class="kw4">int</span> munmap<span class="br0">&#40;</span><span class="kw4">void</span> <span class="sy0">*</span>start<span class="sy0">,</span> <span class="kw4">size_t</span> length<span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>
<code>start</code> reprezintă adresa primei pagini ce va fi demapată (trebuie să fie multiplu de <em>dimensiunea unei pagini</em>). Dacă <code>length</code> nu este o dimensiune care reprezintă un număr întreg de pagini, va fi rotunjit superior. Zona poate să conțină bucăți deja demapate. Se pot astfel demapa mai multe zone în același timp.
</p>

</div>

<h3 class="sectionedit11" id="redimensionarea_unei_zone_mapate">Redimensionarea unei zone mapate</h3>
<div class="level3">

<p>
Pentru a executa operații de redimensionare a zonei mapate se poate utiliza funcția <a href="http://linux.die.net/man/2/mremap" class="urlextern" title="http://linux.die.net/man/2/mremap"  rel="nofollow">mremap</a>:
</p>
<pre class="code c"><span class="kw4">void</span> <span class="sy0">*</span>mremap<span class="br0">&#40;</span><span class="kw4">void</span> <span class="sy0">*</span>old_address<span class="sy0">,</span> <span class="kw4">size_t</span> old_size<span class="sy0">,</span> <span class="kw4">size_t</span> new_size<span class="sy0">,</span> <span class="kw4">unsigned</span> <span class="kw4">long</span> flags<span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>
Zona pe care <code>old_address</code> și <code>old_size</code> o descriu trebuie să aparțină unei singure mapări. O singură opțiune este disponibilă pentru <code>flags</code>: <code>MREMAP_MAYMOVE</code> care arată că este în regulă ca pentru obținerea noii mapări să se realizeze o nouă mapare într-o altă zonă de memorie (vechea zona fiind dealocată).
</p>

</div>

<h3 class="sectionedit12" id="schimbarea_protectiei_unei_zone_mapate">Schimbarea protecției unei zone mapate</h3>
<div class="level3">

<p>
Uneori este nevoie ca modul (drepturile de acces) în care a fost mapată o zonă să fie schimbat. Pentru acest lucru se poate folosi funcția <a href="http://linux.die.net/man/2/mprotect" class="urlextern" title="http://linux.die.net/man/2/mprotect"  rel="nofollow">mprotect</a>:
</p>
<pre class="code c"><span class="kw4">int</span> mprotect<span class="br0">&#40;</span><span class="kw4">const</span> <span class="kw4">void</span> <span class="sy0">*</span>addr<span class="sy0">,</span> <span class="kw4">size_t</span> len<span class="sy0">,</span> <span class="kw4">int</span> prot<span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>
Funcția primește ca parametri intervalul de adrese [<code>addr</code>, <code>addr</code> + <code>len</code> - 1] și noile drepturi de access (<code>PROT_READ</code>, <code>PROT_WRITE</code>, <code>PROT_EXEC</code>, <code>PROT_NONE</code>). Ca și  la <a href="http://linux.die.net/man/2/munmap" class="urlextern" title="http://linux.die.net/man/2/munmap"  rel="nofollow">munmap</a>, <code>addr</code> trebuie să fie multiplu de <em>dimensiunea unei pagini</em>. Funcția va schimba protecția pentru toate paginile care conțin cel puțin un octet în intervalul specificat.
</p>

</div>

<h3 class="sectionedit13" id="exemplu">Exemplu</h3>
<div class="level3">
<pre class="code cpp"><span class="kw4">int</span> fd <span class="sy1">=</span> open<span class="br0">&#40;</span><span class="st0">&quot;fisier&quot;</span>, O_RDWR<span class="br0">&#41;</span><span class="sy4">;</span>
<span class="kw4">void</span> <span class="sy2">*</span>p <span class="sy1">=</span> mmap<span class="br0">&#40;</span><span class="kw2">NULL</span>, <span class="nu0">2</span><span class="sy2">*</span>getpagesize<span class="br0">&#40;</span><span class="br0">&#41;</span>, PROT_NONE, MAP_SHARED, fd, <span class="nu0">0</span><span class="br0">&#41;</span><span class="sy4">;</span>
<span class="co1">// *(char*)p = 'a'; // segv fault</span>
mprotect<span class="br0">&#40;</span>p, <span class="nu0">2</span><span class="sy2">*</span>getpagesize<span class="br0">&#40;</span><span class="br0">&#41;</span>, PROT_WRITE<span class="br0">&#41;</span><span class="sy4">;</span>
<span class="sy2">*</span><span class="br0">&#40;</span><span class="kw4">char</span><span class="sy2">*</span><span class="br0">&#41;</span>p <span class="sy1">=</span> <span class="st0">'a'</span><span class="sy4">;</span>
munmap<span class="br0">&#40;</span>p, <span class="nu0">2</span><span class="sy2">*</span>getpagesize<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy4">;</span></pre>

<p>
Apelul <code>getpagesize</code> va returna dimensiunea unei pagini in bytes.
</p>

</div>

<h3 class="sectionedit14" id="optimizari">Optimizări</h3>
<div class="level3">

<p>
Pentru ca sistemul de operare să poată implementa cât mai eficient accesele la o zona de memorie mapată, programatorul poate să informeze kernel-ul (prin apelul de sistem <a href="http://linux.die.net/man/2/madvise" class="urlextern" title="http://linux.die.net/man/2/madvise"  rel="nofollow">madvise</a>) despre modul în care zona va fi folosită. 
</p>
<div class="hiddenGlobal  hiddenActive"><div class="hiddenElements"></div><div class="hiddenHead  hiddenSinceBeginning"><div class="hiddenOnHidden">
<p>
Detalii despre madvise
</p>
</div><div class="hiddenOnVisible">
<p>
Detalii despre madvise
</p>
</div></div> <!-- .hiddenHead --><div class="hiddenBody">
<p>
<a href="http://linux.die.net/man/2/madvise" class="urlextern" title="http://linux.die.net/man/2/madvise"  rel="nofollow">madvise</a> e utilă mai ales atunci când în spatele memoriei virtuale se află un dispozitiv fizic (de ex., când se mapează fișiere de pe hard-disk, kernel-ul poate citi în avans pagini de pe disc, reducând latența datorată poziționării capului de citire). Prototipul funcției este următorul:
</p>
<pre class="code c"><span class="kw4">int</span> madvise<span class="br0">&#40;</span><span class="kw4">void</span> <span class="sy0">*</span>start<span class="sy0">,</span> <span class="kw4">size_t</span> length<span class="sy0">,</span> <span class="kw4">int</span> advice<span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>
unde valorile acceptate pentru <code>advice</code> sunt:
</p>
<ul>
<li class="level1"><div class="li"><code>MADV_NORMAL</code> - regiunea este una obișnuită și nu are nevoie de un tratament special.</div>
</li>
<li class="level1"><div class="li"><code>MADV_RANDOM</code> - regiunea va fi accesată în mod aleator; sistemul de operare nu va citi în avans pagini.</div>
</li>
<li class="level1"><div class="li"><code>MADV_SEQUENTIAL</code> - regiunea va fi accesată în mod secvențial; sistemul de operare ar putea citi în avans pagini.</div>
</li>
<li class="level1"><div class="li"><code>MADV_WILLNEED</code> - regiunea va fi utilizată undeva în viitorul apropiat (nucleul poate decide să preîncarce paginile în memorie).</div>
</li>
<li class="level1"><div class="li"><code>MADV_DONTNEED</code> - regiunea nu va mai fi utilizată; nucleul poate să elibereze zona alocată din memorie, dar zona nu este demapată; nu se garantează păstrarea datelor la accesări ulterioare.</div>
</li>
</ul>
</div></div>
<p>
<br/>

</p>

</div>

<h3 class="sectionedit15" id="blocarea_paginarii">Blocarea paginării</h3>
<div class="level3">

<p>
Paginarea se referă la evacuarea paginilor pe disc (swap out) si restaurarea lor (swap in) atunci când sunt folosite. Există o categorie de procese care trebuie să execute anumite acțiuni la momente de timp bine determinate, pentru a se păstra calitatea execuției. Pentru exemplificare, putem considera un player audio/video sau un program ce controlează mersul unui robot biped. Problema cu acest gen de procese este dată de faptul că dacă o anumită pagină nu este prezentă în memorie, va dura un timp până ce ea va fi adusă de pe disc. Pentru a contracara aceste probleme, sistemele UNIX pun la dispoziție apelurile <a href="http://linux.die.net/man/2/mlock" class="urlextern" title="http://linux.die.net/man/2/mlock"  rel="nofollow">mlock</a> și <a href="http://linux.die.net/man/2/mlockall" class="urlextern" title="http://linux.die.net/man/2/mlockall"  rel="nofollow">mlockall</a>.
</p>
<pre class="code c"><span class="kw4">int</span> mlock<span class="br0">&#40;</span><span class="kw4">const</span> <span class="kw4">void</span> <span class="sy0">*</span>addr<span class="sy0">,</span> <span class="kw4">size_t</span> len<span class="br0">&#41;</span><span class="sy0">;</span>
<span class="kw4">int</span> mlockall<span class="br0">&#40;</span><span class="kw4">int</span> flags<span class="br0">&#41;</span><span class="sy0">;</span></pre>
<div class="hiddenGlobal  hiddenActive"><div class="hiddenElements"></div><div class="hiddenHead  hiddenSinceBeginning"><div class="hiddenOnHidden">
<p>
Detalii despre mlock şi mlockall
</p>
</div><div class="hiddenOnVisible">
<p>
Detalii despre mlock şi mlockall
</p>
</div></div> <!-- .hiddenHead --><div class="hiddenBody">
<p>
Funcția <a href="http://linux.die.net/man/2/mlock" class="urlextern" title="http://linux.die.net/man/2/mlock"  rel="nofollow">mlock</a> va bloca paginarea (nu se va mai face swap out) paginilor incluse în intervalul [<code>addr</code>, <code>addr</code> + <code>len</code> - 1]. 
Funcția <a href="http://linux.die.net/man/2/mlockall" class="urlextern" title="http://linux.die.net/man/2/mlockall"  rel="nofollow">mlockall</a> va bloca paginarea tuturor paginilor procesului, în funcție de flag-uri:
</p>
<ul>
<li class="level1"><div class="li"><code>MCL_CURRENT</code> - se va bloca paginarea tuturor paginilor mapate în spațiul de adresă al procesului la momentul apelului</div>
</li>
<li class="level1"><div class="li"><code>MCL_FUTURE</code> - se va bloca paginarea noilor pagini mapate în spațiul de adresă al procesului (noi mapări realizate cu funcția <code>mmap</code>, dar și paginile de stivă mapate automat de sistem)</div>
</li>
</ul>

<p>
<strong> Notă: </strong>
</p>

<p>
Flag-ul <code>MCL_FUTURE</code> nu garantează faptul că paginile de stivă vor fi automat mapate în sistem. Dacă procesul depășește limita de memorie impusă de sistem, va primi semnalul <code>SIGSEGV</code>. Pentru a nu se ajunge în astfel de situații, programul trebuie să folosească <code>mlockall(MCL_CURRENT | MCL_FUTURE)</code> și apoi să aloce dimensiunea maximă a stivei pe care urmează să o folosească (prin declararea unei variabile locale, un vector de exemplu, și accesarea completă a acesteia).
</p>
</div></div>
<p>
<br/>

Există, bineînțeles, și funcții ce readuc lucrurile la normal:
</p>
<pre class="code c"><span class="kw4">int</span> munlock<span class="br0">&#40;</span><span class="kw4">const</span> <span class="kw4">void</span> <span class="sy0">*</span>addr<span class="sy0">,</span> <span class="kw4">size_t</span> len<span class="br0">&#41;</span><span class="sy0">;</span>
<span class="kw4">int</span> munlockall<span class="br0">&#40;</span><span class="kw4">void</span><span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>
Astfel, funcția <a href="http://linux.die.net/man/2/munlock" class="urlextern" title="http://linux.die.net/man/2/munlock"  rel="nofollow">munlock</a> va reporni mecanismul de paginare al tuturor paginilor din intervalul [<code>addr</code>, <code>addr</code> + <code>len</code> - 1], iar funcția <a href="http://linux.die.net/man/2/munlockall" class="urlextern" title="http://linux.die.net/man/2/munlockall"  rel="nofollow">munlockall</a> face același lucru pentru toate paginile procesului, atât curente, cât și viitoare. Trebuie notat faptul că, dacă s-au efectuat mai multe apeluri <a href="http://linux.die.net/man/2/mlock" class="urlextern" title="http://linux.die.net/man/2/mlock"  rel="nofollow">mlock</a> sau <a href="http://linux.die.net/man/2/mlockall" class="urlextern" title="http://linux.die.net/man/2/mlockall"  rel="nofollow">mlockall</a>, este suficient un singur apel <a href="http://linux.die.net/man/2/munlock" class="urlextern" title="http://linux.die.net/man/2/munlock"  rel="nofollow">munlock</a> sau <a href="http://linux.die.net/man/2/munlockall" class="urlextern" title="http://linux.die.net/man/2/munlockall"  rel="nofollow">munlockall</a> pentru a reactiva paginarea.
</p>

</div>

<h3 class="sectionedit16" id="exceptii">Excepții</h3>
<div class="level3">

<p>
Atunci când se detectează o încălcare a protecției la accesul la memorie, se va trimite semnalul <code>SIGSEGV</code> sau <code>SIGBUS</code> procesului. După cum am văzut atunci când am discutat despre semnale, semnalul poate fi tratat cu două tipuri de funcții pe care aici o să le denumim <code>signal</code> și <a href="http://linux.die.net/man/2/sigaction" class="urlextern" title="http://linux.die.net/man/2/sigaction"  rel="nofollow">sigaction</a>. Funcția de tip <a href="http://linux.die.net/man/2/sigaction" class="urlextern" title="http://linux.die.net/man/2/sigaction"  rel="nofollow">sigaction</a> va primi ca parametru o structură <code>siginfo_t</code>. În cazul semnalelor ce tratează excepții cauzate de un acces incorect la memorie, următoarele câmpuri din această structură sunt setate:
</p>
<ul>
<li class="level1"><div class="li"><code>si_signo</code> - setat la <code>SIGSEGV</code> sau <code>SIGBUS</code></div>
</li>
<li class="level1"><div class="li"><code>si_code</code> - pentru <code>SIGSEGV</code> poate fi <code>SEGV_MAPPER</code> pentru a arăta că zona accesată nu este mapată în spațiul de adresă al procesului, sau <code>SEGV_ACCERR</code> pentru a arăta că zona este mapată dar a fost accesată necorespunzător; pentru <code>SIGBUS</code> poate fi <code>BUS_ADRALN</code> pentru a arăta că s-a făcut un acces nealiniat la memorie, <code>BUS_ADRERR</code> pentru a arăta că s-a încercat accesarea unei adrese fizice inexistente sau <code>BUS_OBJERR</code> pentru a indica o eroare hardware</div>
</li>
<li class="level1"><div class="li"><code>si_addr</code> - adresa care a generat excepția</div>
</li>
</ul>

</div>

<h3 class="sectionedit17" id="electricfence">ElectricFence</h3>
<div class="level3">

<p>
<a href="http://linux.die.net/man/3/efence" class="urlextern" title="http://linux.die.net/man/3/efence"  rel="nofollow">ElectricFence</a> este un pachet ce ajută programatorii la depanarea problemelor de tipul <em>buffer overrun</em>. Aceste probleme sunt cauzate de faptul că anumite date sunt suprascrise fiindcă nu se fac verificări când se modifică date <strong>adiacente</strong>. Soluția folosită de <a href="http://linux.die.net/man/3/efence" class="urlextern" title="http://linux.die.net/man/3/efence"  rel="nofollow">Electric Fence</a> este înlocuirea apelurilor standard <code>malloc</code> și <code>free</code> cu implementări proprii. <a href="http://linux.die.net/man/3/efence" class="urlextern" title="http://linux.die.net/man/3/efence"  rel="nofollow">Electric Fence</a> va plasa zona de memorie alocată în spațiul de adrese al procesului, astfel încât ea să fie mărginită de pagini neaccesibile (protejate la scriere și citire).
</p>

<p>
Din păcate, sistemul de operare și  arhitectura procesorului limitează dimensiunea paginii la cel puțin 1-4K, astfel încât dacă zona de memorie alocată nu este multiplu de această dimensiune, există posibilitatea ca programul să poată citi sau scrie și în zone în care nu ar trebui, fără ca sistemul de operare să oprească executia programului. Pentru a preveni situații de acestă natură, <a href="http://linux.die.net/man/3/efence" class="urlextern" title="http://linux.die.net/man/3/efence"  rel="nofollow">Electric Fence</a> alocă zonele de memorie la limita superioară a unei pagini, mapând o pagină neaccesibilă după aceasta. Această abordare nu previne <em>buffer underrun</em>-ul, în care datele sunt citite sau scrise peste limita inferioară.
</p>

<p>
Pentru a putea verifica și astfel de situații, utilizatorul trebuie să definescă variabila de mediu <code>EF_PROTECT_BELOW</code> înainte de rula programul. În acest caz, <a href="http://linux.die.net/man/3/efence" class="urlextern" title="http://linux.die.net/man/3/efence"  rel="nofollow">Electric Fence</a> va plasa zona de memorie alocată la începutul unei pagini, pagină care la rândul ei este plasată după o pagină inaccesibilă procesului.
</p>

<p>
De ce este importantă detectarea situațiilor de <em>buffer overrun</em>? Așa cum am explicat și în secțiunea precedentă, astfel de situații vor produce în cele din urmă erori, dar la un moment de timp ulterior, când va fi mai greu să determine cauza erorii cu mijloace de depanare obișnuite. În plus, în situațiile de <em>buffer overrun</em> se pot suprascrie nu numai variabile, ci și alte date importante pentru stabilitatea programului cum ar fi datele de control folosite de rutinele <code>malloc</code> și <code>free</code>. Biblioteca <a href="http://linux.die.net/man/3/efence" class="urlextern" title="http://linux.die.net/man/3/efence"  rel="nofollow">Electric Fence</a> poate determina erorile de <em>buffer overrun</em> doar dacă acestea apar în memoria alocată dinamic (adică în zona <em>heap</em>) cu rutinele <code>malloc</code> și <code>free</code>. Pentru a folosi <a href="http://linux.die.net/man/3/efence" class="urlextern" title="http://linux.die.net/man/3/efence"  rel="nofollow">Electric Fence</a> utilizatorul trebuie să folosească la link-editarea bibliotecii <code>libefence</code>. Pentru a vedea utilitatea acestui pachet, să analizăm programul de mai jos:
</p>
<dl class="code">
<dt><a href="../../_export/code/so/laboratoare/laborator-06%3Fcodeblock=10" title="Download Snippet" class="mediafile mf_c">ef_example.c</a></dt>
<dd><pre class="code c"><span class="co2">#include &lt;stdio.h&gt;</span>
<span class="co2">#include &lt;malloc.h&gt;</span>
&nbsp;
<span class="kw4">int</span> main<span class="br0">&#40;</span><span class="kw4">void</span><span class="br0">&#41;</span>
<span class="br0">&#123;</span>
	<span class="kw4">int</span> i<span class="sy0">;</span>
	<span class="kw4">int</span> <span class="sy0">*</span>data_1<span class="sy0">,</span> <span class="sy0">*</span>data_2<span class="sy0">;</span>
&nbsp;
	data_1 <span class="sy0">=</span> <a href="http://www.opengroup.org/onlinepubs/009695399/functions/malloc.html"><span class="kw3">malloc</span></a><span class="br0">&#40;</span><span class="nu0">11</span> <span class="sy0">*</span> <span class="kw4">sizeof</span><span class="br0">&#40;</span><span class="kw4">int</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
	<span class="kw1">for</span> <span class="br0">&#40;</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;=</span> <span class="nu0">11</span><span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">&#41;</span>
		data_1<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy0">=</span> i<span class="sy0">;</span>
&nbsp;
	data_2 <span class="sy0">=</span> <a href="http://www.opengroup.org/onlinepubs/009695399/functions/malloc.html"><span class="kw3">malloc</span></a><span class="br0">&#40;</span><span class="nu0">11</span> <span class="sy0">*</span> <span class="kw4">sizeof</span><span class="br0">&#40;</span><span class="kw4">int</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
	<span class="kw1">for</span> <span class="br0">&#40;</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;=</span> <span class="nu0">11</span><span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">&#41;</span>
		data_2<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy0">=</span> <span class="nu0">11</span> <span class="sy0">-</span> i<span class="sy0">;</span>
&nbsp;
	<span class="kw1">for</span> <span class="br0">&#40;</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;=</span> <span class="nu0">11</span><span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">&#41;</span>
		<a href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span class="kw3">printf</span></a><span class="br0">&#40;</span><span class="st0">&quot;%d %d<span class="es1">\n</span>&quot;</span><span class="sy0">,</span> data_1<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="sy0">,</span> data_2<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
	<a href="http://www.opengroup.org/onlinepubs/009695399/functions/free.html"><span class="kw3">free</span></a><span class="br0">&#40;</span>data_1<span class="br0">&#41;</span><span class="sy0">;</span> 
	<a href="http://www.opengroup.org/onlinepubs/009695399/functions/free.html"><span class="kw3">free</span></a><span class="br0">&#40;</span>data_2<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
	<span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">&#125;</span></pre>
</dd></dl>

<p>
Aparent totul pare în regulă. La execuția programului însă obținem următorul output:
</p>
<pre class="code bash"> so<span class="sy0">@</span>spook$ <span class="kw2">gcc</span> <span class="re5">-Wall</span> <span class="re5">-g</span> ef_example.c
 so<span class="sy0">@</span>spook$ .<span class="sy0">/</span>a.out
ff: malloc.c:<span class="nu0">3074</span>: sYSMALLOc: Assertion <span class="sy0">`</span><span class="br0">&#40;</span>old_top == <span class="br0">&#40;</span><span class="br0">&#40;</span><span class="br0">&#40;</span>mbinptr<span class="br0">&#41;</span> <span class="br0">&#40;</span><span class="br0">&#40;</span><span class="br0">&#40;</span>char <span class="sy0">*</span><span class="br0">&#41;</span> 
<span class="sy0">&amp;</span><span class="br0">&#40;</span><span class="br0">&#40;</span>av<span class="br0">&#41;</span>-<span class="sy0">&gt;</span>bins<span class="br0">&#91;</span><span class="br0">&#40;</span><span class="br0">&#40;</span><span class="nu0">1</span><span class="br0">&#41;</span> - <span class="nu0">1</span><span class="br0">&#41;</span> <span class="sy0">*</span> <span class="nu0">2</span><span class="br0">&#93;</span><span class="br0">&#41;</span><span class="br0">&#41;</span> - __builtin_offsetof <span class="br0">&#40;</span>struct malloc_chunk, fd<span class="br0">&#41;</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="br0">&#41;</span> 
<span class="sy0">&amp;&amp;</span> old_size == <span class="nu0">0</span><span class="br0">&#41;</span> <span class="sy0">||</span> <span class="br0">&#40;</span><span class="br0">&#40;</span>unsigned long<span class="br0">&#41;</span><span class="br0">&#40;</span>old_size<span class="br0">&#41;</span> <span class="sy0">&gt;</span>= <span class="br0">&#40;</span>unsigned long<span class="br0">&#41;</span>
<span class="br0">&#40;</span><span class="br0">&#40;</span><span class="br0">&#40;</span><span class="br0">&#40;</span>__builtin_offsetof <span class="br0">&#40;</span>struct malloc_chunk, fd_nextsize<span class="br0">&#41;</span><span class="br0">&#41;</span>+<span class="br0">&#40;</span><span class="br0">&#40;</span><span class="nu0">2</span> <span class="sy0">*</span> <span class="br0">&#40;</span>sizeof<span class="br0">&#40;</span>size_t<span class="br0">&#41;</span><span class="br0">&#41;</span><span class="br0">&#41;</span>
 - <span class="nu0">1</span><span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="sy0">&amp;</span> ~<span class="br0">&#40;</span><span class="br0">&#40;</span><span class="nu0">2</span> <span class="sy0">*</span> <span class="br0">&#40;</span>sizeof<span class="br0">&#40;</span>size_t<span class="br0">&#41;</span><span class="br0">&#41;</span><span class="br0">&#41;</span> - <span class="nu0">1</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="sy0">&amp;&amp;</span> <span class="br0">&#40;</span><span class="br0">&#40;</span>old_top<span class="br0">&#41;</span>-<span class="sy0">&gt;</span><span class="kw2">size</span> <span class="sy0">&amp;</span> 0x1<span class="br0">&#41;</span> <span class="sy0">&amp;&amp;</span> 
<span class="br0">&#40;</span><span class="br0">&#40;</span>unsigned long<span class="br0">&#41;</span>old_end <span class="sy0">&amp;</span> pagemask<span class="br0">&#41;</span> == <span class="nu0">0</span><span class="br0">&#41;</span><span class="st_h">' failed.</span></pre>

<p>
Ceva este clar în neregulă. Dacă folosim biblioteca efence și GDB eroarea va fi vizibilă imediat:
</p>
<pre class="code bash"> so<span class="sy0">@</span>spook$ <span class="kw2">gcc</span> <span class="re5">-Wall</span> <span class="re5">-g</span> ef_example.c <span class="re5">-lefence</span>
 so<span class="sy0">@</span>spook$ <span class="kw2">gdb</span> .<span class="sy0">/</span>a.out 
 Reading symbols from <span class="sy0">/</span>home<span class="sy0">/</span>so<span class="sy0">/</span>a.out...done.
 <span class="br0">&#40;</span><span class="kw2">gdb</span><span class="br0">&#41;</span> run
 Starting program: <span class="sy0">/</span>home<span class="sy0">/</span>so<span class="sy0">/</span>a.out 
 <span class="br0">&#91;</span>Thread debugging using libthread_db enabled<span class="br0">&#93;</span>
&nbsp;
   Electric Fence <span class="nu0">2.1</span> Copyright <span class="br0">&#40;</span>C<span class="br0">&#41;</span> <span class="nu0">1987</span>-<span class="nu0">1998</span> Bruce Perens.
&nbsp;
 Program received signal SIGSEGV, Segmentation fault.
 0x08048536 <span class="kw1">in</span> main <span class="br0">&#40;</span><span class="br0">&#41;</span> at ef.c:<span class="nu0">12</span>
 <span class="nu0">12</span>			data_1<span class="br0">&#91;</span>i<span class="br0">&#93;</span> = i;
 <span class="br0">&#40;</span><span class="kw2">gdb</span><span class="br0">&#41;</span> print i
 <span class="re4">$1</span> = <span class="nu0">11</span>
 <span class="br0">&#40;</span><span class="kw2">gdb</span><span class="br0">&#41;</span></pre>

<p>
Se observă că eroarea apare în momentul în care încercăm să inițializăm al 12-lea element al vectorului, deși vectorul nu are decât 11 elemente.
</p>

<p>
Pentru mai multe informații despre <a href="http://linux.die.net/man/3/efence" class="urlextern" title="http://linux.die.net/man/3/efence"  rel="nofollow">Electric Fence</a> consultați pagina de manual (<strong>man efence</strong>).
</p>

</div>

<h2 class="sectionedit18" id="windows">Windows</h2>
<div class="level2">

<p>
În Windows funcțiile de control al memoriei virtuale sau mai bine zis al spațiului de adresă al unui proces nu mai sunt grupate, ca în cazul Unix, într-o singură primitivă oferită de sistemul de operare. Avem funcții pentru maparea fișierelor în memorie și funcții pentru alocarea de memorie fizică în spațiul de adresă al unui proces.
</p>

</div>

<h3 class="sectionedit19" id="maparea_fisierelor1">Maparea fișierelor</h3>
<div class="level3">

<p>
Pentru a mapa un fișier în spațiul de adresă al unui proces trebuie mai întâi creat un handle către un obiect de tipul <a href="http://msdn.microsoft.com/en-us/library/aa366556%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/aa366556%28VS.85%29.aspx"  rel="nofollow">FileMapping</a> și apoi realizată efectiv maparea. Funcțiile <a href="http://msdn.microsoft.com/en-us/library/aa366537%28v=VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/aa366537%28v=VS.85%29.aspx"  rel="nofollow">CreateFileMapping</a> și <a href="http://msdn.microsoft.com/en-us/library/aa366761%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/aa366761%28VS.85%29.aspx"  rel="nofollow">MapViewOfFile</a> sunt prezentate mai în detaliu <a href="../laboratoare-2013/laborator-05.html#memorie_partajata_filemapping" class="wikilink1" title="so:laboratoare-2013:laborator-05">aici</a>. 
</p>

<p>
Pentru a crea un obiect de tip <code>FileMapping</code> se folosește funcția <a href="http://msdn.microsoft.com/en-us/library/aa366537%28v=VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/aa366537%28v=VS.85%29.aspx"  rel="nofollow">CreateFileMapping</a>:
</p>
<pre class="code c">HANDLE CreateFileMapping<span class="br0">&#40;</span>
   HANDLE hFile<span class="sy0">,</span>
   LPSECURITY_ATTRIBUTES lpAttributes<span class="sy0">,</span>
   DWORD flProtect<span class="sy0">,</span>
   DWORD dwMaximumSizeHigh<span class="sy0">,</span>
   DWORD dwMaximumSizeLow<span class="sy0">,</span>
   LPCTSTR lpName
 <span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>
Funcția primește ca parametri handle-ul fișierului care se dorește a fi mapat, atribute de securitate care controlează accesul la handle-ul obiectului <code>FileMapping</code> creat, tipul mapării (<code>PAGE_READONLY</code>, <code>PAGE_READWRITE</code>, <code>PAGE_WRITECOPY</code> pentru copy-on-write) și dimensiunea maximă care poate fi mapată cu ajutorul funcției <code>MapViewOfFile</code>. Opțional se poate specifica și un șir care să identifice obiectul <code>FileMapping</code> creat. Dacă mai există un obiect de acest tip, funcția <code>CreateFileMapping</code> nu va crea unul nou, ci îl va folosi pe cel existent. Atenție însă, obiectul trebuie să fi fost creat cu drepturi care să permită procesului apelant să îl deschidă. 
</p>

<p>
Pentru deschiderea unui obiect de tip <code>FileMapping</code> deja creat se mai poate folosi funcția <a href="http://msdn.microsoft.com/en-us/library/aa366791%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/aa366791%28VS.85%29.aspx"  rel="nofollow">OpenFileMapping</a>:
</p>
<pre class="code c">HANDLE OpenFileMapping<span class="br0">&#40;</span>
  DWORD dwDesiredAccess<span class="sy0">,</span>
  BOOL bInheritHandle<span class="sy0">,</span>
  LPCTSTR lpName
<span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>
Maparea în spațiul de adrese al procesului se face folosind funcția <a href="http://msdn.microsoft.com/en-us/library/aa366761%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/aa366761%28VS.85%29.aspx"  rel="nofollow">MapViewOfFile</a>:
</p>
<pre class="code c">LPVOID MapViewOfFile<span class="br0">&#40;</span>
   HANDLE hFileMappingObject<span class="sy0">,</span>
   DWORD dwDesiredAccess<span class="sy0">,</span>
   DWORD dwFileOffsetHigh<span class="sy0">,</span>
   DWORD dwFileOffsetLow<span class="sy0">,</span>
   SIZE_T dwNumberOfBytesToMap
 <span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>
Funcția primește ca parametri un handle către un obiect de tip <code>FileMapping</code>, modul de acces la zona mapată (<code>FILE_MAP_READ</code>, <code>FILE_MAP_WRITE</code>, <code>FILE_MAP_COPY</code> pentru copy-on-write), offset-ul în fișier de unde începe maparea și numărul de octeți de mapat. Funcția va întoarce un pointer în spațiul de adresă al procesului, la zona mapată.
</p>

</div>

<h3 class="sectionedit20" id="alocare_de_memorie_in_spatiul_de_adresa_al_procesului1">Alocare de memorie în spațiul de adresă al procesului</h3>
<div class="level3">

<p>
Pentru alocarea de memorie în spațiul de adresă al procesului se pot folosi funcțiile <a href="http://msdn.microsoft.com/en-us/library/aa366887%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/aa366887%28VS.85%29.aspx"  rel="nofollow">VirtualAlloc</a> sau <a href="http://msdn.microsoft.com/en-us/library/aa366890%28v=VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/aa366890%28v=VS.85%29.aspx"  rel="nofollow">VirtualAllocEx</a>:
</p>
<pre class="code c"> LPVOID VirtualAlloc<span class="br0">&#40;</span>
   LPVOID lpAddress<span class="sy0">,</span>
   SIZE_T dwSize<span class="sy0">,</span>
   DWORD flAllocationType<span class="sy0">,</span>
   DWORD flProtect
 <span class="br0">&#41;</span><span class="sy0">;</span></pre>
<pre class="code c"> LPVOID VirtualAllocEx<span class="br0">&#40;</span>
   HANDLE hProcess<span class="sy0">,</span>
   LPVOID lpAddress<span class="sy0">,</span>
   SIZE_T dwSize<span class="sy0">,</span>
   DWORD flAllocationType<span class="sy0">,</span>
   DWORD flProtect
 <span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>
Cu funcția <a href="http://msdn.microsoft.com/en-us/library/aa366890%28v=VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/aa366890%28v=VS.85%29.aspx"  rel="nofollow">VirtualAllocEx</a> se poate aloca memorie în spațiul de adresă al unui proces arbitrar, specificat în parametrul <code>hProcess</code>. Procesul curent trebuie să aibă drepturi corespunzătoare asupra procesului pe care se încearcă operația (<code>PROCESS_VM_OPERATION</code>). Funcțiile întorc un pointer către adresa de start, iar parametrii așteptați de funcții sunt descriși în spoiler:
</p>
<div class="hiddenGlobal  hiddenActive"><div class="hiddenElements"></div><div class="hiddenHead  hiddenSinceBeginning"><div class="hiddenOnHidden">
<p>
Descrierea parametrilor funcţiei VirtualAllocEx
</p>
</div><div class="hiddenOnVisible">
<p>
Descrierea parametrilor funcţiei VirtualAllocEx
</p>
</div></div> <!-- .hiddenHead --><div class="hiddenBody"><ul>
<li class="level1"><div class="li"><code>lpAddress</code> - adresa de unde începe alocarea; trebuie să fie multiplu de 4KB pentru alocare și 64KB pentru rezervare; dacă parametrul este <code>NULL</code>, sistemul va furniza automat o adresă</div>
</li>
<li class="level1"><div class="li"><code>dwSize</code> - dimensiunea zonei</div>
</li>
<li class="level1"><div class="li"><code>fAllocationType</code> - specifică tipul operației: rezervare (<code>MEM_RESERVE</code>), alocare (<code>MEM_COMMIT</code>) sau renunțare la zonă (<code>MEM_RESET</code>); rezervarea unei zone înseamnă de fapt “punerea deoparte” a unui interval din spațiul de adrese virtuale al procesului, fără a se aloca însă memorie fizică; dacă se folosește <code>MEM_COMMIT</code>, se alocă  efectiv memorie (dar doar dacă în prealabil zona vizată a fost rezervată); atunci când se renunță la zonă nucleul poate face discard la paginile din zonă, fără a face însă dezalocarea lor; după această operație datele nu se păstrează</div>
</li>
<li class="level1"><div class="li"><code>flProtect</code> - specifică modul de acces permis la zona alocată: <code>PAGE_EXECUTE</code>, <code>PAGE_EXECUTE_READ</code>, <code>PAGE_EXECUTE_READWRITE</code>, <code>PAGE_EXECUTE_WRITECOPY</code>, <code>PAGE_READONLY</code>, <code>PAGE_READWRITE</code>, <code>PAGE_WRITECOPY</code>, <code>PAGE_NOACCESS</code>, <code>PAGE_GUARD</code>, <code>PAGE_NOCACHE</code>. Modurile <code>_WRITECOPY</code> arată că se va folosi mecanismul copy-on-write. Modul <code>PAGE_GUARD</code> specifică faptul că la primul acces la o astfel de zonă se va genera o excepție <code>STATUS_GUARD_PAGE</code>. <code>PAGE_GUARD</code> și <code>PAGE_NOCACHE</code> se pot folosi împreună cu celelalte moduri.</div>
</li>
</ul>
</div></div>
</div>

<h3 class="sectionedit21" id="demaparea_unei_zone_din_spatiul_de_adresa1">Demaparea unei zone din spațiul de adresă</h3>
<div class="level3">

<p>
Pentru demaparea unei fișier mapat în memorie se folosește funcția <a href="http://msdn.microsoft.com/en-us/library/aa366882%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/aa366882%28VS.85%29.aspx"  rel="nofollow">UnmapViewOfFile</a>:
</p>
<pre class="code c">BOOL UnmapViewOfFile<span class="br0">&#40;</span>
   LPCVOID lpBaseAddress
<span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>
Funcția primește adresa de început a zonei.
</p>

<p>
Pentru dezalocarea unei zone de memorie din spațiul de adresă se folosesc funcțiile <a href="http://msdn.microsoft.com/en-us/library/aa366892%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/aa366892%28VS.85%29.aspx"  rel="nofollow">VirtualFree</a> și <a href="http://msdn.microsoft.com/en-us/library/aa366894%28v=VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/aa366894%28v=VS.85%29.aspx"  rel="nofollow">VirtualFreeEx</a>:
</p>
<pre class="code c">BOOL VirtualFree<span class="br0">&#40;</span>
   LPVOID lpAddress<span class="sy0">,</span>
   SIZE_T dwSize<span class="sy0">,</span>
   DWORD dwFreeType
<span class="br0">&#41;</span><span class="sy0">;</span></pre>
<pre class="code c">BOOL VirtualFreeEx<span class="br0">&#40;</span>
   HANDLE hProcess<span class="sy0">,</span>
   LPVOID lpAddress<span class="sy0">,</span>
   SIZE_T dwSize<span class="sy0">,</span>
   DWORD dwFreeType
<span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>
Funcția <a href="http://msdn.microsoft.com/en-us/library/aa366894%28v=VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/aa366894%28v=VS.85%29.aspx"  rel="nofollow">VirtualFreeEx</a> va dezaloca o zonă de memorie din spațiul de adresă al unui proces arbitrar, specificat în parametrul <code>hProcess</code>. Procesul curent trebuie să aibă drepturi corespunzătoare asupra procesului pe care se încearcă operația (<code>PROCESS_VM_OPERATION</code>).
</p>

<p>
Parametrii <code>lpAddress</code> și <code>dwSize</code> identifică zona de dezalocat. <code>dwFreeType</code> specifică tipul operației: <code>MEM_DECOMMIT</code>, <code>MEM_RELEASE</code>. Prima operație va demapa paginile din spațiul de adresă, dar ele vor rămâne rezervate. Cea de-a doua operație va anula rezervarea întregii zone „puse deoparte” anterior, astfel încât adresa de start trebuie să coincidă cu adresa de start a zonei rezervate, iar dimensiunea trebuie să fie 0.
</p>

</div>

<h3 class="sectionedit22" id="schimbarea_protectiei_unei_zone_mapate1">Schimbarea protecției unei zone mapate</h3>
<div class="level3">

<p>
În Windows, schimbarea drepturilor de acces a unei zone mapate se poate face cu ajutorul funcțiilor <a href="http://msdn.microsoft.com/en-us/library/aa366898%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/aa366898%28VS.85%29.aspx"  rel="nofollow">VirtualProtect</a> și <a href="http://msdn.microsoft.com/en-us/library/aa366899%28v=VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/aa366899%28v=VS.85%29.aspx"  rel="nofollow">VirtualProtectEx</a>:
</p>
<pre class="code c">BOOL VirtualProtect<span class="br0">&#40;</span>
   LPVOID lpAddress<span class="sy0">,</span>
   SIZE_T dwSize<span class="sy0">,</span>
   DWORD flNewProtect<span class="sy0">,</span>
   PDWORD lpflOldProtect
<span class="br0">&#41;</span><span class="sy0">;</span></pre>
<pre class="code c">BOOL VirtualProtectEx<span class="br0">&#40;</span>
   HANDLE hProcess<span class="sy0">,</span>
   LPVOID lpAddress<span class="sy0">,</span>
   SIZE_T dwSize<span class="sy0">,</span>
   DWORD flNewProtect<span class="sy0">,</span>
   PDWORD lpflOldProtect
<span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>
Funcțiile vor schimba protecția paginilor care au măcar un octet în intervalul [<code>lpAddress</code>, <code>lpAddress</code> + <code>dwSize</code> - 1] la cea specificată în <code>flNewProtect</code>. Vechile drepturi de acces sunt salvate în <code>lpfOldProtect</code>.
</p>

<p>
<p><div class="noteimportant"> Toate paginile din intervalul specificat trebuie să fie din aceeași regiune rezervată cu apelul <code>VirtualAlloc</code> sau <code>VirtualAllocEx</code> folosind <code>MEM_RESERVE</code>. Paginile nu pot fi localizate în regiuni adiacente rezervate prin apeluri separate ale <code>VirtualAlloc</code> sau <code>VirtualAllocEx</code> folosind <code>MEM_RESERVE</code>. 
</div></p>
</p>

</div>

<h3 class="sectionedit23" id="interogarea_zonelor_mapate">Interogarea zonelor mapate</h3>
<div class="level3">

<p>
Pentru a afla informații despre o zonă mapată în spațiul de adresă al unui proces se pot folosi funcțiile <a href="http://msdn.microsoft.com/en-us/library/aa366902%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/aa366902%28VS.85%29.aspx"  rel="nofollow">VirtualQuery</a> și <a href="http://msdn.microsoft.com/en-us/library/aa366907%28v=VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/aa366907%28v=VS.85%29.aspx"  rel="nofollow">VirtualQueryEx</a>. Ele vor oferi informații apelantului despre adresa de start a zonei, protecție, dimensiune etc.
</p>
<pre class="code c">DWORD VirtualQuery<span class="br0">&#40;</span>
   LPCVOID lpAddress<span class="sy0">,</span>
   PMEMORY_BASIC_INFORMATION lpBuffer<span class="sy0">,</span>
   SIZE_T dwLength
<span class="br0">&#41;</span><span class="sy0">;</span></pre>
<pre class="code c">DWORD VirtualQueryEx<span class="br0">&#40;</span>
   HANDLE hProcess<span class="sy0">,</span>
   LPCVOID lpAddress<span class="sy0">,</span>
   PMEMORY_BASIC_INFORMATION lpBuffer<span class="sy0">,</span>
   SIZE_T dwLength
<span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>
Funcțiile primesc ca parametri o adresă din cadrul zonei ce se dorește a fi interogată, un pointer către un buffer alocat ce va primi informații despre zonă și întorc numărul de octeți scriși în buffer. Dacă funcția întoarce 0 înseamnă că nici o informație nu a fost furnizată. Acest lucru se întâmplă dacă funcției îi este pasată o adresă din spațiul kernel.
</p>

<p>
Informațiile primite vor descrie două zone: zona alocată (cu <code>VirtualAlloc</code>) în care este inclusă adresa dată, și zona care conține pagini de același fel (cu aceeași protecție și stare) în care este inclusă adresa dată:
</p>
<pre class="code c"><span class="kw4">typedef</span> <span class="kw4">struct</span> _MEMORY_BASIC_INFORMATION <span class="br0">&#123;</span>
   PVOID BaseAddress<span class="sy0">;</span>
   PVOID AllocationBase<span class="sy0">;</span>
   DWORD AllocationProtect<span class="sy0">;</span>
   SIZE_T RegionSize<span class="sy0">;</span>
   DWORD State<span class="sy0">;</span>
   DWORD Protect<span class="sy0">;</span>
   DWORD Type<span class="sy0">;</span>
<span class="br0">&#125;</span> MEMORY_BASIC_INFORMATION<span class="sy0">,</span> <span class="sy0">*</span>PMEMORY_BASIC_INFORMATION<span class="sy0">;</span></pre>

<p>
Câmpurile <code>AllocationBase</code> și <code>AllocationProtect</code> se referă la zona alocată, iar <code>BaseAddress</code>, <code>RegionSize</code>, <code>Type</code> și <code>Protect</code> la zona ce conține pagini de același fel. <code>State</code> indică starea paginilor din zonă: <code>MEM_COMMIT</code> pentru zonă alocată, <code>MEM_RESERVED</code> pentru zonă rezervată și <code>MEM_FREE</code> pentru zonă nealocată. <code>Type</code> indică dacă în zonă este mapat un fișier (<code>MEM_IMAGE</code> sau <code>MEM_MAPPED</code>) sau nu, și indică de asemenea dacă zona este partajată sau nu (<code>MEM_PRIVATE</code>).
</p>

</div>

<h3 class="sectionedit24" id="blocarea_paginarii1">Blocarea paginării</h3>
<div class="level3">

<p>
Pentru blocarea paginării pentru un set de pagini (nu se va mai face swap out - în consecință apelurile ulterioare nu mai produc page fault), sistemul de operare Windows pune la dispoziția utilizatorilor funcția <a href="http://msdn.microsoft.com/en-us/library/aa366895%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/aa366895%28VS.85%29.aspx"  rel="nofollow">VirtualLock</a>:
</p>
<pre class="code c">BOOL VirtualLock<span class="br0">&#40;</span>
   LPVOID lpAddress<span class="sy0">,</span>
   SIZE_T dwSize
<span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>
Funcția primește prin parametri un interval de pagini (alcătuit din paginile care au măcar un octet în intervalul [<code>lpAddress</code>, <code>lpAddress</code> + <code>dwSize</code>]) pentru care se vrea blocarea paginării.
</p>

<p>
Funcția pentru reactivarea paginării este <a href="http://msdn.microsoft.com/en-us/library/aa366910%28v=VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/aa366910%28v=VS.85%29.aspx"  rel="nofollow">VirtualUnlock</a>:
</p>
<pre class="code c">BOOL VirtualUnlock<span class="br0">&#40;</span>
   LPVOID lpAddress<span class="sy0">,</span>
   SIZE_T dwSize
<span class="br0">&#41;</span><span class="sy0">;</span></pre>

</div>

<h3 class="sectionedit25" id="exceptii1">Excepții</h3>
<div class="level3">

<p>
Atunci când sistemul de operare detectează accese incorecte la memorie, va genera o excepție către procesul care a efectuat accesul. Pentru tratarea excepției se pot folosi construcții <code>__try</code> și <code>__except</code>, pentru care este necesar suport din partea compilatorului, sau se poate folosi funcția <a href="http://msdn.microsoft.com/en-us/library/ms679274%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms679274%28VS.85%29.aspx"  rel="nofollow">AddVectoredExceptionHandler</a>.
</p>
<pre class="code c">PVOID AddVectoredExceptionHandler<span class="br0">&#40;</span>
   ULONG FirstHandler<span class="sy0">,</span>
   PVECTORED_EXCEPTION_HANDLER VectoredHandler
<span class="br0">&#41;</span><span class="sy0">;</span></pre>
<pre class="code c">ULONG RemoveVectoredExceptionHandler<span class="br0">&#40;</span>
   PVOID VectoredHandlerHandle
<span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>
Funcția <a href="http://msdn.microsoft.com/en-us/library/ms679274%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms679274%28VS.85%29.aspx"  rel="nofollow">AddVectoredExceptionHandler</a> va adăuga pe lista funcțiilor de executat atunci când se generează o excepție, pe cea primită ca parametru în <code>VectoredHandler</code>. Parametrul <code>FirstHandler</code> indică dacă funcția dorește să fie adăugată la începutul listei sau la sfârșit. Funcția de tratare a excepțiilor trebuie să aibă următoarea semnătură:
</p>
<pre class="code c">LONG WINAPI VectoredHandler<span class="br0">&#40;</span>
   PEXCEPTION_POINTERS ExceptionInfo
<span class="br0">&#41;</span><span class="sy0">;</span></pre>
<pre class="code c"><span class="kw4">typedef</span> <span class="kw4">struct</span> _EXCEPTION_POINTERS <span class="br0">&#123;</span>
  PEXCEPTION_RECORD ExceptionRecord<span class="sy0">;</span>
  PCONTEXT ContextRecord<span class="sy0">;</span>
<span class="br0">&#125;</span> EXCEPTION_POINTERS<span class="sy0">,</span> <span class="sy0">*</span>PEXCEPTION_POINTERS<span class="sy0">;</span></pre>
<pre class="code c"><span class="kw4">typedef</span> <span class="kw4">struct</span> _EXCEPTION_RECORD <span class="br0">&#123;</span>
  DWORD ExceptionCode<span class="sy0">;</span>
  DWORD ExceptionFlags<span class="sy0">;</span>
  <span class="kw4">struct</span> _EXCEPTION_RECORD<span class="sy0">*</span> ExceptionRecord<span class="sy0">;</span>
  PVOID ExceptionAddress<span class="sy0">;</span>
  DWORD NumberParameters<span class="sy0">;</span>
  ULONG_PTR ExceptionInformation<span class="br0">&#91;</span>EXCEPTION_MAXIMUM_PARAMETERS<span class="br0">&#93;</span><span class="sy0">;</span>
<span class="br0">&#125;</span> EXCEPTION_RECORD<span class="sy0">,</span> <span class="sy0">*</span>PEXCEPTION_RECORD<span class="sy0">;</span></pre>

<p>
În cazul unor excepții cauzate de un acces invalid la memorie, <code>ExceptionCode</code> va fi setat la <code>EXCEPTION_ACCESS_VIOLATION</code> sau <code>EXCEPTION_DATATYPE_MISALIGNMENT</code>, iar <code>ExceptionAddress</code> la adresa instrucțiunii care a cauzat excepția; <code>NumberParameters</code> va fi setat pe 2, iar prima intrare în <code>ExceptionInformation</code> va fi <code>0</code> dacă s-a efectuat o operație de citire sau <code>1</code> dacă s-a efectuat o operație de scriere. A doua intrare din <code>ExceptionInformation</code> va conține adresa virtuală la care s-a încercat accesarea fără drepturi, fapt care a dus la generarea excepției. Așadar, corespondentul câmpului <code>si_addr</code> din structura <code>siginfo_t</code> de pe Linux este <code>ExceptionInformation</code> pe Windows, NU <code>ExceptionAddress</code>.
</p>

<p>
Funcția de tratare a excepției înregistrată cu <a href="http://msdn.microsoft.com/en-us/library/ms679274%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms679274%28VS.85%29.aspx"  rel="nofollow">AddVectoredExceptionHandler</a> trebuie să întoarcă <code>EXCEPTION_CONTINUE_EXECUTION</code>, dacă excepția a fost tratată și se dorește continuarea execuției, sau <code>EXCEPTION_CONTINUE_SEARCH</code> pentru a continua parcurgerea listei de funcții de tratare a excepțiilor, în caz că au fost înregistrate mai multe astfel de funcții.
</p>

</div>

<h2 class="sectionedit26" id="exercitii">Exerciții</h2>
<div class="level2">

</div>

<h2 class="sectionedit27" id="exercitiul_0_-_joc_interactiv_2p">Exercițiul 0 - Joc interactiv (2p)</h2>
<div class="level2">
<ul>
<li class="level1"><div class="li"> Detalii desfășurare <a href="../meta/notare.html#joc_interactiv" class="urlextern" title="http://ocw.cs.pub.ro/courses/so/meta/notare#joc_interactiv"  rel="nofollow">joc</a>.</div>
</li>
</ul>

<p>
<p><div class="noteimportant">În rezolvarea laboratorului, folosiți arhiva de sarcini <a href="http://elf.cs.pub.ro/so/res/laboratoare/lab06-tasks.zip" class="urlextern" title="http://elf.cs.pub.ro/so/res/laboratoare/lab06-tasks.zip"  rel="nofollow"> lab06-tasks.zip</a>.
Platforma este la alegerea voastră. Punctajul maxim se poate obține fie pe Linux, fie pe Windows. Lucrați în mașina virtuală

</div></p>
</p>

<p>
<p><div class="noteclassic"> Pentru a vă ajuta la implementarea exercițiilor din laborator, în directorul <code>utils</code> din arhivă există un fișier <code>utils.h</code> cu funcții utile. 
</div></p>
</p>

</div>

<h2 class="sectionedit28" id="linux_9p">Linux (9p)</h2>
<div class="level2">

</div>

<h3 class="sectionedit29" id="exercitiul_1_-_investigarea_maparilor_folosind_pmap_05p">Exercițiul 1 - Investigarea mapărilor folosind pmap (0.5p)</h3>
<div class="level3">

<p>
Intrați în directorul <code>1-intro</code> și compilați sursa <code>intro.c</code>. Rulați programul <code>intro</code>:
</p>
<pre class="code">./intro</pre>

<p>
Într-o altă consolă, folosiți comanda <a href="http://linux.die.net/man/1/pmap" class="urlextern" title="http://linux.die.net/man/1/pmap"  rel="nofollow"> pmap</a>.:
</p>
<pre class="code bash"> <span class="kw2">watch</span> <span class="re5">-d</span> pmap $<span class="br0">&#40;</span><span class="kw2">pidof</span> intro<span class="br0">&#41;</span></pre>

<p>
 pentru a urmări modificările asupra memoriei procesului. 
</p>

<p>
În prima consolă, folosiți <code>ENTER</code> pentru a continua programul. În cea de-a doua consolă urmăriți modificările care apar în urma diferitelor tipuri de mapare din cod. De ce unele zone de biblioteci sunt mapate cu drept de scriere?
</p>

<p>
Analizați mapările făcute de procesul <code>init</code> folosind comanda:
</p>
<pre class="code bash"><span class="kw2">sudo</span> pmap <span class="nu0">1</span></pre>

</div>

<h3 class="sectionedit30" id="exercitiul_2_-_scrierea_in_fisier_-_write_vs_mmap_1p">Exercițiul 2 - Scrierea în fișier - write vs. mmap (1p)</h3>
<div class="level3">

<p>
Intrați în directorul <code>2-compare</code> și inspectați sursele <code>write.c</code> și <code>mmap.c</code>, apoi compilați. Obțineți timpul de execuție al celor două programe folosind comanda <code>time</code>: 
</p>
<pre class="code bash"><span class="kw1">time</span> .<span class="sy0">/</span><span class="kw2">write</span>; <span class="kw1">time</span> .<span class="sy0">/</span>mmap</pre>

<p>
Care timp este mai mare și de ce? (Hint: folosiți <a href="http://linux.die.net/man/1/strace" class="urlextern" title="http://linux.die.net/man/1/strace"  rel="nofollow">strace</a> pentru a vedea câte apeluri de sistem se realizează pentru rularea fiecărui program)
</p>

<p>
Ce se întâmplă dacă în programul <code>mmap.c</code> schimbați flagul de creare al memoriei partajate din <code>MAP_SHARED</code> în <code>MAP_PRIVATE</code>? (Hint: <a href="http://linux.die.net/man/2/mmap" class="urlextern" title="http://linux.die.net/man/2/mmap"  rel="nofollow"> man mmap</a>, în special secțiunea despre MAP_PRIVATE).
</p>

<p>
<p><div class="notetip">Modificările aduse unei zone de memorie mapată cu <code>MAP_PRIVATE</code> nu vor fi vizible nici altor procese și nici nu vor ajunge în fișierul mapat de pe disc.
</div></p>
</p>

<p>
Ce conține fișierul &#039;test_mmap&#039; în cele două cazuri? Rețineți faptul că apelul <code>mmap</code> folosește una dintre opțiunile <code>MAP_SHARED</code> sau <code>MAP_PRIVATE</code> (una singură).
</p>

<p>
<p><div class="notetip">Observăm că în cazul mapării fișierului cu flagul <code>MAP_SHARED</code>, fișierul <code>test_mmap</code> conține textul <em>Testing testing 123…</em> de 10000 de ori, în schimb în cel de-al doilea caz (cu flagul <code>MAP_PRIVATE</code>) fișierul este gol deoarece modificările nu se propagă pe disc.
</div></p>
</p>

</div>

<h3 class="sectionedit31" id="exercitiul_3_-_detectare_buffer_underrun_folosind_electricfence_1p">Exercițiul 3 - Detectare &#039;buffer underrun&#039; folosind ElectricFence (1p)</h3>
<div class="level3">

<p>
Intrați în directorul <code>3-efence</code> și urmăriți sursa <code>bug.c</code>. Compilați și rulați executabilul <code>bug</code>:
</p>
<pre class="code bash"><span class="kw2">make</span>
.<span class="sy0">/</span>bug</pre>

<p>
Folosiți <a href="laborator-06.html#electricfence" title="so:laboratoare:laborator-06 ↵" class="wikilink1">ElectricFence</a> pentru a prinde situația de &#039;buffer underrun&#039; urmărind pașii:
</p>
<ul>
<li class="level1"><div class="li"> Instalati pachetul <code>electric-fence</code> in cazul in care biblioteca <code>libefence.so</code> nu se gaseste pe sistem.</div>
</li>
<li class="level1"><div class="li"> Setați în bash următoarea variabila <code>EF_PROTECT_BELOW</code> la <code>1</code>: <pre class="code bash"><span class="kw3">export</span> <span class="re2">EF_PROTECT_BELOW</span>=<span class="nu0">1</span></pre>
</div>
</li>
<li class="level1"><div class="li"> Creați și rulați programul <code>ef_bug</code> utilizând makefile-ul <code>Makefile_efence</code>:<pre class="code bash"><span class="kw2">make</span> <span class="re5">-f</span> Makefile_efence
.<span class="sy0">/</span>ef_bug</pre>
</div>
</li>
</ul>

<p>
Explicați de ce bug-ul nu s-a manifestat anterior urmărind exemplul din secțiunea <a href="laborator-06.html#electricfence" title="so:laboratoare:laborator-06 ↵" class="wikilink1">ElectricFence</a>. 
</p>

</div>

<h3 class="sectionedit32" id="exercitiul_4_-_copierea_fisierelor_folosind_mmap_2p">Exercițiul 4 - Copierea fișierelor folosind mmap (2p)</h3>
<div class="level3">

<p>
Intrați în directorul <code>4-cp</code> și completați sursa <code>mycp.c</code> astfel încât să realizeze copierea unui fișier primit ca argument. Pentru aceasta, mapați ambele fișiere în memorie și realizați copierea folosind <code>memcpy</code>. Urmăriți comentariile cu <code>TODO</code> din sursă și următoarele hint-uri:
</p>
<ul>
<li class="level1"><div class="li"> Înainte de mapare, aflați dimensiunea fișierului sursă folosind <a href="http://linux.die.net/man/2/fstat" class="urlextern" title="http://linux.die.net/man/2/fstat"  rel="nofollow"> fstat</a>.</div>
</li>
<li class="level1"><div class="li"> Trunchiați fișierul destinație la dimensiunea fișierului sursă.</div>
</li>
<li class="level1"><div class="li"> Folosiți <code>MAP_SHARED</code> pentru mapare pentru a fi transmise schimbările în fișier: rețineți faptul că apelul mmap folosește una dintre opțiunile <code>MAP_SHARED</code> și <code>MAP_PRIVATE</code> (una singură)</div>
</li>
<li class="level1"><div class="li"> Pentru fișierul de intrare protecția trebuie să fie <code>PROT_READ</code>: fișierul a fost deschis read-only.</div>
</li>
<li class="level1"><div class="li"> Pentru fișierul de ieșire protecția trebuie să fie <code>PROT_READ | PROT_WRITE</code>; anumite arhitecturi/implementări se pot plânge dacă folosiți <strong>doar</strong> <code>PROT_WRITE</code>.</div>
</li>
<li class="level1"><div class="li"> Argumentele funcției <a href="http://man7.org/linux/man-pages/man3/memcpy.3.html" class="urlextern" title="http://man7.org/linux/man-pages/man3/memcpy.3.html"  rel="nofollow">memcpy</a> sunt, în ordine: destinația, sursa, numărul de octeți care să fie copiați.</div>
</li>
<li class="level1"><div class="li"> Revedeți secțiunea <a href="laborator-06.html#maparea-fisierelor" title="so:laboratoare:laborator-06 ↵" class="wikilink1">maparea fișierelor</a>.</div>
</li>
</ul>

<p>
Puteți testa în felul următor: 
</p>
<pre class="code bash">.<span class="sy0">/</span>mycp Makefile <span class="sy0">/</span>tmp<span class="sy0">/</span>Makefile
<span class="kw2">diff</span> Makefile <span class="sy0">/</span>tmp<span class="sy0">/</span>Makefile</pre>

<p>
Verificați cum realizează utilitarul <a href="http://linux.die.net/man/1/cp" class="urlextern" title="http://linux.die.net/man/1/cp"  rel="nofollow"> cp</a> copierea de fișiere (folosind mmap sau read/write) folosind <a href="http://linux.die.net/man/1/strace" class="urlextern" title="http://linux.die.net/man/1/strace"  rel="nofollow"> strace</a>. De ce credeți că se folosește această variantă?
</p>

<p>
<p><div class="notetip">Utilitarul <code>cp</code> folosește <code>read/write</code> pentru a copia fișiere în special pentru a limita consumul de memorie în cazul copierii unor fișiere de dimensiuni mari. De asemenea, în cazul mapării fișierului în memorie cu <code>mmap</code>, scrierea efectivă a datelor pe disc se va face într-un timp mai îndelungat, lucru care de cele mai multe ori nu este dorit. (Vezi <a href="http://stackoverflow.com/a/27987994" class="urlextern" title="http://stackoverflow.com/a/27987994"  rel="nofollow">link</a>). 
</div></p>
</p>

</div>

<h3 class="sectionedit33" id="exercitiul_5_-_tipuri_de_acces_pentru_pagini_3p">Exercițiul 5 - Tipuri de acces pentru pagini (3p)</h3>
<div class="level3">

<p>
Intrați în directorul <code>5-prot</code> și inspectați sursa <code>prot.c</code>. Creați trei zone de memorie în spațiul de adresă, cu drepturi de citire, scriere, respectiv nici un drept. Zonele vor avea dimensiunea de o pagină. Testați comportamentul programului când se fac accese de citire și scriere în aceste zone. Completați comentariile cu <code>TODO 1</code>.
</p>

<p>
Adăugați un handler de tratare a excepțiilor care să remapeze zonele cu protecție de citire și scriere la generarea excepțiilor. Completați comentariile cu <code>TODO 2</code>.
</p>

<p>
<p><div class="notetip"><strong>Atenție: </strong> Este precizat și în comentariile sursei, trebuie să ștergeți prima linie <code>old_action.sa_sigaction(signum, info, context);</code> pentru a putea rezolva a doua parte a exercițiului.
</div></p>
</p>

</div>

<h3 class="sectionedit34" id="exercitiul_6_-_page_fault-uri_05p">Exercițiul 6 - Page fault-uri (0.5p)</h3>
<div class="level3">

<p>
Intrați în directorul <code>6-faults</code> și urmăriți conținutul fișierului <code>fork-faults.c</code>. <strong>Câte page-fault-uri</strong> credeți că se realizează la rulare?
</p>

<p>
Vom folosi utilitarul <code>pidstat</code> din pachetul <code>sysstat</code> care permite monitorizarea page fault-urilor unui proces (un mic tutorial despre cum poate fi folosit <code>pidstat</code> <a href="http://www.cyberciti.biz/open-source/command-line-hacks/linux-monitor-process-using-pidstat" class="urlextern" title="http://www.cyberciti.biz/open-source/command-line-hacks/linux-monitor-process-using-pidstat"  rel="nofollow">găsiți aici</a>). Rulați programul <code>fork-faults</code>. Folosiți <code>ENTER</code> pentru a continua programul și executați comanda 
</p>
<pre class="code bash">pidstat <span class="re5">-r</span> <span class="re5">-T</span> ALL <span class="re5">-p</span> $<span class="br0">&#40;</span><span class="kw2">pidof</span> fork-faults<span class="br0">&#41;</span> <span class="nu0">5</span> <span class="nu0">100</span></pre>

<p>
pentru a urmări page fault-urile.
</p>

<p>
<p><div class="notetip">Dacă întâmpinați probleme în instalarea pachetului <code>sysstat</code>, descărcați-l de <a href="http://ro.archive.ubuntu.com/ubuntu/pool/main/s/sysstat/sysstat_11.2.0-1_i386.deb" class="urlextern" title="http://ro.archive.ubuntu.com/ubuntu/pool/main/s/sysstat/sysstat_11.2.0-1_i386.deb"  rel="nofollow">aici</a> și instalați-l folosind comanda <code>dpkg</code>.
</p>
<pre class="code">student@spook:~$ wget http://ro.archive.ubuntu.com/ubuntu/pool/main/s/sysstat/sysstat_11.2.0-1_i386.deb
student@spook:~$ sudo dpkg -i sysstat_11.2.0-1_i386.deb </pre>

<p>

</div></p>
</p>

<p>
Comanda de mai sus vă afișează câte un mesaj la fiecare 5 secunde. Sincronizați apăsarea tastei ENTER cu afișajul comenzii <code>pidstat</code>. Urmăriți evoluția numărului de page fault-uri pentru cele două procese: părinte și copil. Page fault-urile care apar în cazul unui copy-on-write în procesul copil vor fi vizibile ulterior și în procesul părinte.
</p>

<p>
<p><div class="noteclassic">Pachetul <code>sysstat</code> mai conține și utilitarul <code>sar</code> prin care puteți colecta și realiza rapoarte despre activitatea sistemului. Pentru a activa salvarea datelor, trebuie setat flag-ul <code>ENABLED</code> din <code>/etc/default/sysstat</code>. 
Cu ajutorul utilitarului <code>sar</code> puteți monitoriza informații precum încărcarea CPU-ului, utilizarea memoriei și a paginilor, operațiile de I/O, activitatea proceselor etc. Detalii puteți afla <a href="http://www.cyberciti.biz/tips/identifying-linux-bottlenecks-sar-graphs-with-ksar.html" class="urlextern" title="http://www.cyberciti.biz/tips/identifying-linux-bottlenecks-sar-graphs-with-ksar.html"  rel="nofollow">de aici</a>. 
</div></p>
</p>

</div>

<h3 class="sectionedit35" id="exercitiul_7_-_blocarea_paginarii_1p">Exercițiul 7 - Blocarea paginării (1p)</h3>
<div class="level3">

<p>
Vă aflați într-o situație în care trebuie să procesați în timp real datele dintr-un buffer și vreți să evitați swaparea paginilor. Intrați în directorul <code>7-paging</code> și completați <code>TODO-urile</code> astfel încât paginarea va fi blocată pentru variabila <em>data</em> pe parcursul lucrului cu aceasta, iar la final va fi deblocată. Deși pe Linux, adresa va fi aliniată automat la dimensiunea unei pagini, acest lucru nu se întâmplă pe toate sistemele POSIX compliant, prin urmare este o practică bună să o aliniem manual.
</p>
<ul>
<li class="level1"><div class="li"> Revedeți secțiunea referitoare la <a href="laborator-06.html#blocarea_paginarii" title="so:laboratoare:laborator-06 ↵" class="wikilink1">blocarea paginării</a> precum și <a href="http://linux.die.net/man/2/mlock" class="urlextern" title="http://linux.die.net/man/2/mlock"  rel="nofollow">pagina de manual</a>.</div>
</li>
</ul>

<p>
Cât de mare poate fi <em>DATA_SIZE</em>? Încercați cu diverse valori și explicați comportamentul.
</p>

<p>
<p><div class="notetip">Limita maximă pentru care se poate executa cu succes <code>mlock</code> este dată de <code>RLIMIT_MEMLOCK</code> (max locked memory). Aceasta are de obicei valoarea <code>64KB</code> și poate fi configurată folosind <code>ulimit</code>.
</div></p>
</p>

<p>
Memoria blocată este prin definiție memorie rezidentă - nu poate fi trimisă pe swap. Puteți urmări cum se modifică dimensiunea memoriei rezidente (cea care nu poate fi trimisa pe swap) folosind după fiecare pas al programului următoarea comandă:
</p>
<pre class="code bash"><span class="kw2">ps</span> <span class="re5">-p</span> $<span class="br0">&#40;</span><span class="kw2">pidof</span> paging<span class="br0">&#41;</span> <span class="re5">-o</span> pid,rss,vsz,<span class="kw2">comm</span></pre>

</div>

<h3 class="sectionedit36" id="bonus_linux">Bonus Linux</h3>
<div class="level3">

</div>

<h4 id="so_karma_-_schimbarea_tipului_de_acces_pentru_pagini_din_segmentul_de_cod">1 so karma - Schimbarea tipului de acces pentru pagini din segmentul de cod.</h4>
<div class="level4">

<p>
Intrați în directorul <code>8-hack</code>. Programul apelează funcția <em>foo()</em>. Având determinată pagina în care se află funcția în spațiul de adresă al procesului, i se schimbă drepturile de acces în <code>PROT_READ|PROT_WRITE|PROT_EXEC</code> și se modifică valoarea de retur a funcției (se scrie în segmentul de cod).
</p>

<p>
Analizați cu atenție programul. Analizați comportamentul cu <code>gdb</code>. Având <em>pid-ul</em> procesului afișat la <code>stdout</code>, folosiți <a href="http://linux.die.net/man/1/pmap" class="urlextern" title="http://linux.die.net/man/1/pmap"  rel="nofollow">pmap</a> pentru a observa pagina cu drepturile schimbate.
</p>

<p>
Observați tipul de acces pentru celelalte pagini din spațiul de adresă al procesului. Modificați drepturile de acces în <code>PROT_READ|PROT_EXEC</code> și recompilați sursa. Ce se întâmplă și de ce?
</p>

</div>

<h2 class="sectionedit37" id="windows_9p">Windows (9p)</h2>
<div class="level2">

</div>

<h3 class="sectionedit38" id="exercitiul_1_-_maparea_memoriei_05p">Exercițiul 1 - Maparea memoriei (0.5p)</h3>
<div class="level3">

<p>
Deschideți proiectul <code>1-intro</code>. Inspectați și compilați sursa <code>intro.c</code>. Rulați proiectul, iar în paralel urmăriți comportamentul programului <code>intro</code> în Task Manager - în special coloanele <code>Mem Usage</code> și <code>Page Faults</code> (pentru a vedea o listă completă cu coloanele care pot fi activate, Task Manager→View→Select Columns).
</p>

</div>

<h3 class="sectionedit39" id="exercitiul_2_-_crearea_unor_rutine_in_mod_dinamic_1p">Exercițiul 2 - Crearea unor rutine în mod dinamic (1p)</h3>
<div class="level3">

<p>
Deschideți proiectul <code>2-dyn</code> și urmăriți sursa <code>dyn.c</code>. Programul alocă memorie în spațiul de adresă al procesului pentru a stoca o rutină, de forma <code>dyncode</code>. Rutina va incrementa parametrul primit și va întoarce această valoare. Urmăriți conțintul lui <code>code</code>. Deși în acest caz conținutul rutinei este definit direct în program prin <code>code</code>, el ar putea fi primit în orice alt mod (fișier, etc).
</p>

</div>

<h3 class="sectionedit40" id="exercitiul_3_-_mapare_fisiere_in_memorie_15p">Exercițiul 3 - Mapare fișiere în memorie (1.5p)</h3>
<div class="level3">

<p>
Să se scrie un program care copiază un fișier folosind proiectul <code>3-copy</code>. Programul primește ca argumente numele fișierului sursă, numele fișierului desținație, mapează în memorie cele două fișiere și copiază conținutul primului fișier folosind <code>memcpy(3)</code>. Pentru aflarea lungimii unui fișier folosiți <a href="http://msdn.microsoft.com/en-us/library/aa364946(VS.85).aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/aa364946(VS.85).aspx"  rel="nofollow"> GetFileAttributesEx</a>. Fișierul destinație trebuie trunchiat la dimensiunea fișierului sursă folosind <a href="http://msdn.microsoft.com/en-us/library/aa365541(VS.85).aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/aa365541(VS.85).aspx"  rel="nofollow"> SetFilePointer</a> și <a href="http://msdn.microsoft.com/en-us/library/aa365531(VS.85).aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/aa365531(VS.85).aspx"  rel="nofollow"> SetEndOfFile</a>.
</p>

</div>

<h3 class="sectionedit41" id="exercitiul_4_-_tipuri_de_acces_pentru_pagini_3p">Exercițiul 4 - Tipuri de acces pentru pagini (3p)</h3>
<div class="level3">

<p>
Încărcați proiectul <code>4-prot</code> și inspectați sursa <code>libvm.c</code>.
</p>

<p>
Să se creeze trei zone de memorie în spațiul de adresă, cu drepturi de citire, scriere, respectiv niciun drept. Zonele vor avea dimensiunea de o pagină. Să se testeze comportamentul programului când se fac accese de citire și scriere în aceste zone. Urmăriți comentariile cu <code>TODO 1</code>. (în Windows se poate apela <a href="http://msdn.microsoft.com/en-us/library/aa366898%28v=VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/aa366898%28v=VS.85%29.aspx"  rel="nofollow">VirtualProtect</a> doar pentru o zonă de memorie alocată cu <a href="http://msdn.microsoft.com/en-us/library/aa366887%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/aa366887%28VS.85%29.aspx"  rel="nofollow">VirtualAlloc</a>).
</p>

<p>
Adăugați un handler de tratare a excepțiilor care să remapeze zonele cu protecție de citire și scriere la generarea excepțiilor (revedeți secțiunea despre <a href="laborator-06.html#schimbarea_protectiei_unei_zone_mapate1" title="so:laboratoare:laborator-06 ↵" class="wikilink1">Schimbarea protecției unei zone mapate</a>). Pentru implementarea handlerului, revedeți secțiunea referitoare la <a href="laborator-06.html#exceptii1" title="so:laboratoare:laborator-06 ↵" class="wikilink1">Excepții</a> și urmăriți comentariile cu <code>TODO 2</code>.
</p>

</div>

<h3 class="sectionedit42" id="exercitiul_5_-_detectare_buffer_overrun_-_implementare_utilitar_asemanator_cu_electric_fence_2p">Exercițiul 5 - Detectare &#039;buffer overrun&#039; - implementare utilitar asemănător cu Electric Fence (2p)</h3>
<div class="level3">

<p>
Încărcați proiectul <code>5-ef</code> și inspectați sursa, ignorând pentru moment funcția <code>MyMalloc</code>. Compilați și rulați proiectul. Ar trebui să apară erori?
</p>

<p>
Completați funcția <code>MyMalloc</code> astfel încât orice depășire a bufferului alocat să producă eroare (urmăriți commentariile cu <code>TODO</code>). Alocați cu <a href="http://msdn.microsoft.com/en-us/library/aa366887%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/aa366887%28VS.85%29.aspx"  rel="nofollow">VirtualAlloc</a> memorie de dimensiunea primită ca parametru + încă o pagină la final (o vom numi <code>guard page</code>). Schimbați dreptul de acces pentru pagina de final în PAGE_NOACCESS utilizând <code><a href="http://msdn.microsoft.com/en-us/library/aa366898%28v=VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/aa366898%28v=VS.85%29.aspx"  rel="nofollow">VirtualProtect</a></code>. Întoarceți un pointer la o zonă de memorie cu dimensiunea egală cu dimensiunea cerută, dar care se termină fix înainte de <code>guard page</code>).
</p>

<p>
Testați din nou folosind de data aceasta <code>MyMalloc</code>, atât în cazul în care inițializarea vectorului depășește dimensiunea alocată, cât și în cazul în care nu depășește.
</p>

</div>

<h3 class="sectionedit43" id="exercitiul_6_-_blocarea_paginarii_1p">Exercițiul 6 - Blocarea paginării (1p)</h3>
<div class="level3">

<p>
Vă aflați într-o situație în care trebuie să procesați în timp real datele dintr-un buffer și vreți să evitați swaparea paginilor. Intrați în directorul <code>6-lock</code> și completați <code>TODO-urile</code> astfel încât paginarea să fie blocată pentru variabila <em>data</em> pe parcursul lucrului cu aceasta, iar la final să fie deblocată. Nu uitați că adresa trebuie aliniată la limita unei pagini.
</p>
<ul>
<li class="level1"><div class="li"> Revedeți secțiunea referitoare la <a href="laborator-06.html#blocarea-paginarii1" title="so:laboratoare:laborator-06 ↵" class="wikilink1">blocarea paginării în Windows</a>.</div>
</li>
</ul>

<p>
Cât de mare poate fi <em>DATA_SIZE</em>? Încercați cu diverse valori și explicați comportamentul. Urmăriți comportamentul programului în <code>Task Manager</code>.
</p>

</div>

<h3 class="sectionedit44" id="extra">EXTRA</h3>
<div class="level3">

<p>
Comparați timpii de execuție ai algoritmilor de numărare a liniilor din fișier, aflați în această <a href="../../_media/so/laboratoare-2013/lines_counter.zip" class="media mediafile mf_zip" title="so:laboratoare-2013:lines_counter.zip (1.4 KB)">arhivă</a>
</p>
<ul>
<li class="level1"><div class="li"> Cât de performantă este metoda cu mapare a fișierului în memorie?</div>
</li>
<li class="level1"><div class="li"> Care sunt cele mai importante diferențe între metoda mmap din modulul de Python cu același nume și funcția nativă din Linux?</div>
</li>
</ul>

</div>

<h2 class="sectionedit45" id="solutii">Soluții</h2>
<div class="level2">

<p>
 <a href="http://elf.cs.pub.ro/so/res/laboratoare/lab06-sol.zip" class="urlextern" title="http://elf.cs.pub.ro/so/res/laboratoare/lab06-sol.zip"  rel="nofollow"> Soluții exerciții laborator 6</a>
</p>

</div>

<h2 class="sectionedit46" id="resurse_utile">Resurse Utile</h2>
<div class="level2">
<ul>
<li class="level1"><div class="li"><a href="http://en.wikipedia.org/wiki/Memory_management" class="urlextern" title="http://en.wikipedia.org/wiki/Memory_management"  rel="nofollow"> Wikipedia: Memory Management</a></div>
</li>
<li class="level1"><div class="li"><a href="http://tldp.org/LDP/tlk/mm/memory.html" class="urlextern" title="http://tldp.org/LDP/tlk/mm/memory.html"  rel="nofollow"> Memory Management in Linux</a></div>
</li>
<li class="level1"><div class="li"><a href="http://www.opengroup.org/onlinepubs/009695399/functions/mmap.html" class="urlextern" title="http://www.opengroup.org/onlinepubs/009695399/functions/mmap.html"  rel="nofollow"> Opengroup - mmap</a></div>
</li>
<li class="level1"><div class="li"><a href="http://msdn.microsoft.com/en-us/library/ms810627.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms810627.aspx"  rel="nofollow"> MSDN: Managing Virtual Memory in Win32</a></div>
</li>
<li class="level1"><div class="li"><a href="http://msdn2.microsoft.com/en-us/library/ms810613.aspx" class="urlextern" title="http://msdn2.microsoft.com/en-us/library/ms810613.aspx"  rel="nofollow"> MSDN: Managing Memory-Mapped Files in Win32</a></div>
</li>
<li class="level1"><div class="li"><a href="http://msdn2.microsoft.com/en-us/library/ms680657.aspx" class="urlextern" title="http://msdn2.microsoft.com/en-us/library/ms680657.aspx"  rel="nofollow"> MSDN: Structured Exception Handling</a></div>
</li>
<li class="level1"><div class="li"><a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms681411(v=vs.85).aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/windows/desktop/ms681411(v=vs.85).aspx"  rel="nofollow"> Utilizarea vectorilor de excepție (Windows)</a></div>
</li>
</ul>

</div>

        </div>
        <div class="right_sidebar">
          <form action="../../start.html" accept-charset="utf-8" class="search" id="dw__search" method="get"><div class="no"><input type="hidden" name="do" value="search" /><input type="text" id="qsearch__in" accesskey="f" name="id" class="edit" title="[F]" /><input type="submit" value="Search" class="button" title="Search" /><div id="qsearch__out" class="ajax_qsearch JSpopup"></div></div></form>          <div class="namespace_sidebar sidebar_box">



<h1 class="sectionedit1" id="informatii_generale_so">Informații generale SO</h1>
<div class="level1">

<div><div id="nojs_indexmenu_168694002458355ad8bdf53" data-jsajax="%26skipfile%3D%253D/so%253Ainfo%253Astart/" class="indexmenu_nojs">

<ul class="idx">
<li class="level1"><div class="li"><a href="../info/documentatie.html" class="wikilink1" title="so:info:documentatie">Documentație și alte resurse</a></div></li>
<li class="level1"><div class="li"><a href="../info/feed.html" class="wikilink1" title="so:info:feed">Feed RSS</a></div></li>
<li class="level1"><div class="li"><a href="../info/hall.html" class="wikilink1" title="so:info:hall">Hall of SO</a></div></li>
<li class="level1"><div class="li"><a href="../info/lista-discutii.html" class="wikilink1" title="so:info:lista-discutii">Listă de discuții</a></div></li>
<li class="level1"><div class="li"><a href="../info/mv.html" class="wikilink1" title="so:info:mv">Mașini virtuale</a></div></li>
<li class="level1"><div class="li"><a href="../info/trimitere-teme.html" class="wikilink1" title="so:info:trimitere-teme">Trimitere teme</a></div></li>
</ul>
</div></div>

</div>
<!-- EDIT1 SECTION "Informații generale SO" [12-194] -->
<h1 class="sectionedit2" id="informatii_so_2015-2016">Informații SO 2015-2016</h1>
<div class="level1">

<div><div id="nojs_indexmenu_161758678658355ad8c0e30" data-jsajax="" class="indexmenu_nojs">

<ul class="idx">
<li class="open"><div class="li"><a href="../meta/examen.html" class="indexmenu_idx_head">Examen CA/CC</a></div>
<ul class="idx">
<li class="level2"><div class="li"><a href="../meta/examen/2012-2013.html" class="wikilink1" title="so:meta:examen:2012-2013">Examen CA/CC 2012-2013</a></div></li>
<li class="level2"><div class="li"><a href="../meta/examen/2013-2014.html" class="wikilink1" title="so:meta:examen:2013-2014">Examen CA/CC 2013-2014</a></div></li>
<li class="level2"><div class="li"><a href="../meta/examen/2014-2015.html" class="wikilink1" title="so:meta:examen:2014-2015">Examen CA/CC 2014-2015</a></div></li>
</ul>
</li>
<li class="open"><div class="li"><a href="../meta/notare.html" class="indexmenu_idx_head">Reguli generale și notare</a></div>
<ul class="idx">
<li class="level2"><div class="li"><a href="../meta/notare/reguli-notare-ca-cc.html" class="wikilink1" title="so:meta:notare:reguli-notare-ca-cc">Notare CA/CC</a></div></li>
<li class="level2"><div class="li"><a href="../meta/notare/reguli-notare-cb.html" class="wikilink1" title="so:meta:notare:reguli-notare-cb">Notare CB</a></div></li>
</ul>
</li>
<li class="level1"><div class="li"><a href="../meta/anunturi.html" class="wikilink1" title="so:meta:anunturi">Anunțuri</a></div></li>
<li class="level1"><div class="li"><a href="../meta/calendar.html" class="wikilink1" title="so:meta:calendar">Calendar</a></div></li>
<li class="level1"><div class="li"><a href="../meta/catalog.html" class="wikilink1" title="so:meta:catalog">Catalog</a></div></li>
<li class="level1"><div class="li"><a href="../meta/echivalari.html" class="wikilink1" title="so:meta:echivalari">Echivalări teme</a></div></li>
<li class="level1"><div class="li"><a href="../meta/karma.html" class="wikilink1" title="so:meta:karma">Karma Awards</a></div></li>
<li class="level1"><div class="li"><a href="../meta/need-to-know.html" class="wikilink1" title="so:meta:need-to-know">SO Need to Know</a></div></li>
<li class="level1"><div class="li"><a href="../meta/orar.html" class="wikilink1" title="so:meta:orar">Orar și împărțire pe semigrupe</a></div></li>
</ul>
</div></div>

</div>
<!-- EDIT2 SECTION "Informații SO 2015-2016" [195-261] -->
<h1 class="sectionedit3" id="laboratoare">Laboratoare</h1>
<div class="level1">

<div><div id="nojs_indexmenu_171989978658355ad8c1dd2" data-jsajax="" class="indexmenu_nojs">

<ul class="idx">
<li class="open"><div class="li"><a href="resurse.html" class="indexmenu_idx_head">Resurse</a></div>
<ul class="idx">
<li class="level2"><div class="li"><a href="resurse/c_tips.html" class="wikilink1" title="so:laboratoare:resurse:c_tips">C/SO Tips</a></div></li>
<li class="level2"><div class="li"><a href="resurse/die.html" class="wikilink1" title="so:laboratoare:resurse:die">Macro-ul DIE</a></div></li>
<li class="level2"><div class="li"><a href="resurse/gdb.html" class="wikilink1" title="so:laboratoare:resurse:gdb">GDB</a></div></li>
<li class="level2"><div class="li"><a href="resurse/home.html" class="wikilink1" title="so:laboratoare:resurse:home">Resurse</a></div></li>
<li class="level2"><div class="li"><a href="resurse/injections.html" class="wikilink1" title="so:laboratoare:resurse:injections">Function Hooking and Windows Dll Injection</a></div></li>
<li class="level2"><div class="li"><a href="resurse/oprofile.html" class="wikilink1" title="so:laboratoare:resurse:oprofile">Oprofile</a></div></li>
<li class="level2"><div class="li"><a href="resurse/recapitulare.html" class="wikilink1" title="so:laboratoare:resurse:recapitulare">Recapitulare</a></div></li>
<li class="level2"><div class="li"><a href="resurse/threaduri_extra.html" class="wikilink1" title="so:laboratoare:resurse:threaduri_extra">Thread-uri - Extra</a></div></li>
<li class="level2"><div class="li"><a href="resurse/vs_tips.html" class="wikilink1" title="so:laboratoare:resurse:vs_tips">Visual Studio Tips and Tricks</a></div></li>
<li class="level2"><div class="li"><a href="resurse/windows-video.html" class="wikilink1" title="so:laboratoare:resurse:windows-video">windows-video</a></div></li>
</ul>
</li>
<li class="level1"><div class="li"><a href="laborator-01.html" class="wikilink1" title="so:laboratoare:laborator-01">Laborator 01 - Introducere</a></div></li>
<li class="level1"><div class="li"><a href="laborator-02.html" class="wikilink1" title="so:laboratoare:laborator-02">Laborator 02 - Operații I/O simple</a></div></li>
<li class="level1"><div class="li"><a href="laborator-03.html" class="wikilink1" title="so:laboratoare:laborator-03">Laborator 03 - Procese</a></div></li>
<li class="level1"><div class="li"><a href="laborator-04.html" class="wikilink1" title="so:laboratoare:laborator-04">Laborator 04 - Semnale</a></div></li>
<li class="level1"><div class="li"><a href="laborator-05.html" class="wikilink1" title="so:laboratoare:laborator-05">Laborator 05 - Gestiunea memoriei</a></div></li>
<li class="level1"><div class="li"><span class="curid"><a href="laborator-06.html" class="wikilink1" title="so:laboratoare:laborator-06">Laborator 06 - Memoria virtuală</a></span></div></li>
<li class="level1"><div class="li"><a href="laborator-07.html" class="wikilink1" title="so:laboratoare:laborator-07">Laborator 07 - Profiling &amp; Debugging</a></div></li>
<li class="level1"><div class="li"><a href="laborator-08.html" class="wikilink1" title="so:laboratoare:laborator-08">Laborator 08 - Thread-uri Linux</a></div></li>
<li class="level1"><div class="li"><a href="laborator-09.html" class="wikilink1" title="so:laboratoare:laborator-09">Laborator 09 - Thread-uri Windows</a></div></li>
<li class="level1"><div class="li"><a href="laborator-10.html" class="wikilink1" title="so:laboratoare:laborator-10">Laborator 10 - Operații IO avansate - Windows</a></div></li>
<li class="level1"><div class="li"><a href="laborator-11.html" class="wikilink1" title="so:laboratoare:laborator-11">Laborator 11 - Operații IO avansate - Linux</a></div></li>
<li class="level1"><div class="li"><a href="laborator-12.html" class="wikilink1" title="so:laboratoare:laborator-12">Laborator 12 - Implementarea sistemelor de fișiere</a></div></li>
</ul>
</div></div>

</div>
<!-- EDIT3 SECTION "Laboratoare" [262-322] -->
<h1 class="sectionedit4" id="cursuri">Cursuri</h1>
<div class="level1">

<div><div id="nojs_indexmenu_71652835458355ad8c2d74" data-jsajax="" class="indexmenu_nojs">

<ul class="idx">
<li class="closed"><div class="li"><a href="../cursuri/curs-01.html" class="indexmenu_idx_head">Curs 01 - Introducere</a></div></li>
<li class="closed"><div class="li"><a href="../cursuri/curs-02.html" class="indexmenu_idx_head">Curs 02 - Sistemul de fișiere</a></div></li>
<li class="closed"><div class="li"><a href="../cursuri/curs-03.html" class="indexmenu_idx_head">Curs 03 - Procese</a></div></li>
<li class="closed"><div class="li"><a href="../cursuri/curs-04.html" class="indexmenu_idx_head">Curs 04 - Planificarea execuției. IPC</a></div></li>
<li class="closed"><div class="li"><a href="../cursuri/curs-05.html" class="indexmenu_idx_head">Curs 05 - Gestiunea memoriei</a></div></li>
<li class="closed"><div class="li"><a href="../cursuri/curs-06.html" class="indexmenu_idx_head">Curs 06 - Memoria virtuală</a></div></li>
<li class="closed"><div class="li"><a href="../cursuri/curs-07.html" class="indexmenu_idx_head">Curs 07 - Securitatea memoriei</a></div></li>
<li class="closed"><div class="li"><a href="../cursuri/curs-08.html" class="indexmenu_idx_head">Curs 08 - Fire de execuție</a></div></li>
<li class="closed"><div class="li"><a href="../cursuri/curs-09.html" class="indexmenu_idx_head">Curs 09 - Sincronizare</a></div></li>
<li class="closed"><div class="li"><a href="../cursuri/curs-10.html" class="indexmenu_idx_head">Curs 10 - Dispozitive de intrare/ieșire</a></div></li>
<li class="closed"><div class="li"><a href="../cursuri/curs-11.html" class="indexmenu_idx_head">Curs 11 - Networking în sistemul de operare</a></div></li>
<li class="closed"><div class="li"><a href="../cursuri/curs-12.html" class="indexmenu_idx_head">Curs 12 - Implementarea sistemelor de fișiere</a></div></li>
<li class="closed"><div class="li"><a href="../cursuri/curs-13.html" class="indexmenu_idx_head">Curs 13 - Securitatea sistemului</a></div></li>
<li class="closed"><div class="li"><a href="../cursuri/quiz/start.html" class="indexmenu_idx_head">Quizz-uri curs</a></div></li>
<li class="level1"><div class="li"><a href="../cursuri/curs-extra-2.html" class="wikilink1" title="so:cursuri:curs-extra-2">Curs extra - Android</a></div></li>
<li class="level1"><div class="li"><a href="../cursuri/curs-extra-3.html" class="wikilink1" title="so:cursuri:curs-extra-3">Curs extra - Virtualizare</a></div></li>
<li class="level1"><div class="li"><a href="../cursuri/curs-extra.html" class="wikilink1" title="so:cursuri:curs-extra">Curs extra - Sincronizarea proceselor</a></div></li>
<li class="level1"><div class="li"><a href="../cursuri/note.html" class="wikilink1" title="so:cursuri:note">Note de curs</a></div></li>
</ul>
</div></div>

</div>
<!-- EDIT4 SECTION "Cursuri" [323-374] -->
<h1 class="sectionedit5" id="teme">Teme</h1>
<div class="level1">

<div><div id="nojs_indexmenu_80607700758355ad8c3d12" data-jsajax="" class="indexmenu_nojs">

<ul class="idx">
<li class="closed"><div class="li"><a href="../teme/tema-asist.html" class="indexmenu_idx_head">Tema Asistenți - Guardian process</a></div></li>
<li class="level1"><div class="li"><a href="../teme/contestatii.html" class="wikilink1" title="so:teme:contestatii">Contestații</a></div></li>
<li class="level1"><div class="li"><a href="../teme/folosire-gitlab.html" class="wikilink1" title="so:teme:folosire-gitlab">Git. Indicații folosire GitLab</a></div></li>
<li class="level1"><div class="li"><a href="../teme/general.html" class="wikilink1" title="so:teme:general">Indicații generale teme</a></div></li>
<li class="level1"><div class="li"><a href="../teme/tema-1.html" class="wikilink1" title="so:teme:tema-1">Tema 1 Multi-platform Development</a></div></li>
<li class="level1"><div class="li"><a href="../teme/tema-2.html" class="wikilink1" title="so:teme:tema-2">Tema 2 Mini-shell</a></div></li>
<li class="level1"><div class="li"><a href="../teme/tema-3.html" class="wikilink1" title="so:teme:tema-3">Tema 3 Memorie virtuală</a></div></li>
<li class="level1"><div class="li"><a href="../teme/tema-4.html" class="wikilink1" title="so:teme:tema-4">Tema 4 Planificator de threaduri</a></div></li>
<li class="level1"><div class="li"><a href="../teme/tema-5.html" class="wikilink1" title="so:teme:tema-5">Tema 5 Server web asincron</a></div></li>
</ul>
</div></div>

</div>
<!-- EDIT5 SECTION "Teme" [375-] -->
</div>
<div class="toc_sidebar sidebar_box">
<!-- TOC START -->
<div id="sb__right__dw__toc">
<h3 class="toggle">Table of Contents</h3>
<div>

<ul class="toc">
<li class="level1"><div class="li"><a href="laborator-06.html#laborator_06_-_memoria_virtuala">Laborator 06 - Memoria virtuală</a></div>
<ul class="toc">
<li class="level2"><div class="li"><a href="laborator-06.html#materiale_ajutatoare">Materiale ajutătoare</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="laborator-06.html#nice_to_read">Nice to read</a></div></li>
</ul>
</li>
<li class="level2"><div class="li"><a href="laborator-06.html#memoria_virtuala">Memoria virtuală</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="laborator-06.html#concepte_teoretice">Concepte teoretice</a></div>
<ul class="toc">
<li class="level4"><div class="li"><a href="laborator-06.html#malloc">malloc</a></div></li>
</ul>
</li>
</ul>
</li>
<li class="level2"><div class="li"><a href="laborator-06.html#linux">Linux</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="laborator-06.html#maparea_fisierelor">Maparea fișierelor</a></div>
<ul class="toc">
<li class="level4"><div class="li"><a href="laborator-06.html#mmap">mmap</a></div></li>
<li class="level4"><div class="li"><a href="laborator-06.html#msync">msync</a></div></li>
</ul>
</li>
<li class="level3"><div class="li"><a href="laborator-06.html#alocare_de_memorie_in_spatiul_de_adresa_al_procesului">Alocare de memorie în spațiul de adresă al procesului</a></div></li>
<li class="level3"><div class="li"><a href="laborator-06.html#maparea_dispozitivelor">Maparea dispozitivelor</a></div></li>
<li class="level3"><div class="li"><a href="laborator-06.html#demaparea_unei_zone_din_spatiul_de_adresa">Demaparea unei zone din spațiul de adresă</a></div></li>
<li class="level3"><div class="li"><a href="laborator-06.html#redimensionarea_unei_zone_mapate">Redimensionarea unei zone mapate</a></div></li>
<li class="level3"><div class="li"><a href="laborator-06.html#schimbarea_protectiei_unei_zone_mapate">Schimbarea protecției unei zone mapate</a></div></li>
<li class="level3"><div class="li"><a href="laborator-06.html#exemplu">Exemplu</a></div></li>
<li class="level3"><div class="li"><a href="laborator-06.html#optimizari">Optimizări</a></div></li>
<li class="level3"><div class="li"><a href="laborator-06.html#blocarea_paginarii">Blocarea paginării</a></div></li>
<li class="level3"><div class="li"><a href="laborator-06.html#exceptii">Excepții</a></div></li>
<li class="level3"><div class="li"><a href="laborator-06.html#electricfence">ElectricFence</a></div></li>
</ul>
</li>
<li class="level2"><div class="li"><a href="laborator-06.html#windows">Windows</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="laborator-06.html#maparea_fisierelor1">Maparea fișierelor</a></div></li>
<li class="level3"><div class="li"><a href="laborator-06.html#alocare_de_memorie_in_spatiul_de_adresa_al_procesului1">Alocare de memorie în spațiul de adresă al procesului</a></div></li>
<li class="level3"><div class="li"><a href="laborator-06.html#demaparea_unei_zone_din_spatiul_de_adresa1">Demaparea unei zone din spațiul de adresă</a></div></li>
<li class="level3"><div class="li"><a href="laborator-06.html#schimbarea_protectiei_unei_zone_mapate1">Schimbarea protecției unei zone mapate</a></div></li>
<li class="level3"><div class="li"><a href="laborator-06.html#interogarea_zonelor_mapate">Interogarea zonelor mapate</a></div></li>
<li class="level3"><div class="li"><a href="laborator-06.html#blocarea_paginarii1">Blocarea paginării</a></div></li>
<li class="level3"><div class="li"><a href="laborator-06.html#exceptii1">Excepții</a></div></li>
</ul>
</li>
<li class="level2"><div class="li"><a href="laborator-06.html#exercitii">Exerciții</a></div></li>
<li class="level2"><div class="li"><a href="laborator-06.html#exercitiul_0_-_joc_interactiv_2p">Exercițiul 0 - Joc interactiv (2p)</a></div></li>
<li class="level2"><div class="li"><a href="laborator-06.html#linux_9p">Linux (9p)</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="laborator-06.html#exercitiul_1_-_investigarea_maparilor_folosind_pmap_05p">Exercițiul 1 - Investigarea mapărilor folosind pmap (0.5p)</a></div></li>
<li class="level3"><div class="li"><a href="laborator-06.html#exercitiul_2_-_scrierea_in_fisier_-_write_vs_mmap_1p">Exercițiul 2 - Scrierea în fișier - write vs. mmap (1p)</a></div></li>
<li class="level3"><div class="li"><a href="laborator-06.html#exercitiul_3_-_detectare_buffer_underrun_folosind_electricfence_1p">Exercițiul 3 - Detectare &#039;buffer underrun&#039; folosind ElectricFence (1p)</a></div></li>
<li class="level3"><div class="li"><a href="laborator-06.html#exercitiul_4_-_copierea_fisierelor_folosind_mmap_2p">Exercițiul 4 - Copierea fișierelor folosind mmap (2p)</a></div></li>
<li class="level3"><div class="li"><a href="laborator-06.html#exercitiul_5_-_tipuri_de_acces_pentru_pagini_3p">Exercițiul 5 - Tipuri de acces pentru pagini (3p)</a></div></li>
<li class="level3"><div class="li"><a href="laborator-06.html#exercitiul_6_-_page_fault-uri_05p">Exercițiul 6 - Page fault-uri (0.5p)</a></div></li>
<li class="level3"><div class="li"><a href="laborator-06.html#exercitiul_7_-_blocarea_paginarii_1p">Exercițiul 7 - Blocarea paginării (1p)</a></div></li>
<li class="level3"><div class="li"><a href="laborator-06.html#bonus_linux">Bonus Linux</a></div>
<ul class="toc">
<li class="level4"><div class="li"><a href="laborator-06.html#so_karma_-_schimbarea_tipului_de_acces_pentru_pagini_din_segmentul_de_cod">1 so karma - Schimbarea tipului de acces pentru pagini din segmentul de cod.</a></div></li>
</ul>
</li>
</ul>
</li>
<li class="level2"><div class="li"><a href="laborator-06.html#windows_9p">Windows (9p)</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="laborator-06.html#exercitiul_1_-_maparea_memoriei_05p">Exercițiul 1 - Maparea memoriei (0.5p)</a></div></li>
<li class="level3"><div class="li"><a href="laborator-06.html#exercitiul_2_-_crearea_unor_rutine_in_mod_dinamic_1p">Exercițiul 2 - Crearea unor rutine în mod dinamic (1p)</a></div></li>
<li class="level3"><div class="li"><a href="laborator-06.html#exercitiul_3_-_mapare_fisiere_in_memorie_15p">Exercițiul 3 - Mapare fișiere în memorie (1.5p)</a></div></li>
<li class="level3"><div class="li"><a href="laborator-06.html#exercitiul_4_-_tipuri_de_acces_pentru_pagini_3p">Exercițiul 4 - Tipuri de acces pentru pagini (3p)</a></div></li>
<li class="level3"><div class="li"><a href="laborator-06.html#exercitiul_5_-_detectare_buffer_overrun_-_implementare_utilitar_asemanator_cu_electric_fence_2p">Exercițiul 5 - Detectare &#039;buffer overrun&#039; - implementare utilitar asemănător cu Electric Fence (2p)</a></div></li>
<li class="level3"><div class="li"><a href="laborator-06.html#exercitiul_6_-_blocarea_paginarii_1p">Exercițiul 6 - Blocarea paginării (1p)</a></div></li>
<li class="level3"><div class="li"><a href="laborator-06.html#extra">EXTRA</a></div></li>
</ul>
</li>
<li class="level2"><div class="li"><a href="laborator-06.html#solutii">Soluții</a></div></li>
<li class="level2"><div class="li"><a href="laborator-06.html#resurse_utile">Resurse Utile</a></div></li>
</ul></li>
</ul>
</div>
</div>
<!-- TOC END -->
</div>
        </div>
      
    
      <div class="stylefoot">
        <div class="meta">
          <div class="user">
                    </div>
          <div class="doc">
          so/laboratoare/laborator-06.txt · Last modified: 2016/04/05 02:41 by costin.lupu          </div>
        </div>
      </div>

    <div class="clearer"></div>

    
                <div class="bar" id="bar__bottom">
      <div class="bar-left">
              </div>
      <div class="bar-right">
        <a href="laborator-06%3Fdo=media&amp;ns=so%253Alaboratoare.html"  class="action media" rel="nofollow" title="Media Manager">Media Manager</a><a href="laborator-06.html#dokuwiki__top"  class="action top" accesskey="t" rel="nofollow" title="Back to top [T]">Back to top</a>      </div>
    </div>
    <div class="clearer"></div>
            
    <div align="center" class="footerinc">
  <div class="license"><a href="http://creativecommons.org/licenses/by-sa/3.0/" rel="license"><img src="../../lib/images/license/button/cc-by-sa.png" alt="CC Attribution-Share Alike 3.0 Unported" /></a></div>
  <a target="_blank" href="http://www.chimeric.de" title="www.chimeric.de"><img src="../../lib/tpl/arctic/images/button-chimeric-de.png" width="80" height="15" alt="www.chimeric.de" border="0" /></a>

  <a target="_blank" href="http://jigsaw.w3.org/css-validator/check/referer" title="Valid CSS"><img src="../../lib/tpl/arctic/images/button-css.png" width="80" height="15" alt="Valid CSS" border="0" /></a>

  <a target="_blank" href="http://wiki.splitbrain.org/wiki:dokuwiki" title="Driven by DokuWiki"><img src="../../lib/tpl/arctic/images/button-dw.png" width="80" height="15" alt="Driven by DokuWiki" border="0" /></a>

  <a target="_blank" href="http://www.firefox-browser.de" title="do yourself a favour and use a real browser - get firefox"><img src="../../lib/tpl/arctic/images/button-firefox.png" width="80" height="15" alt="do yourself a favour and use a real browser - get firefox!!" border="0" /></a>
  
  <a target="_blank" href="../../feed.php" title="Recent changes RSS feed"><img src="../../lib/tpl/arctic/images/button-rss.png" width="80" height="15" alt="Recent changes RSS feed" border="0" /></a>

  <a target="_blank" href="http://validator.w3.org/check/referer" title="Valid XHTML 1.0"><img src="../../lib/tpl/arctic/images/button-xhtml.png" width="80" height="15" alt="Valid XHTML 1.0" border="0" /></a>
</div>

  </div>
</div>

<div class="no"><img src="../../lib/exe/indexer.php%3Fid=so%253Alaboratoare%253Alaborator-06&amp;1479891672" width="2" height="1" alt="" /></div>
</body>
</html>
