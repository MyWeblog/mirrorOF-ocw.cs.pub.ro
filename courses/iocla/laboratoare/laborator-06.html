    
    

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"
 lang="en" dir="ltr">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>
    Laborator 06: Apeluri de funcții    [CS Open CourseWare]
  </title>

  <meta name="generator" content="DokuWiki"/>
<meta name="robots" content="index,follow"/>
<meta name="date" content="2016-11-11T10:48:26+0200"/>
<meta name="keywords" content="iocla,laboratoare,laborator-06"/>
<link rel="search" type="application/opensearchdescription+xml" href="../../lib/exe/opensearch.php" title="CS Open CourseWare"/>
<link rel="start" href="../../../courses.1.html"/>
<link rel="alternate" type="application/rss+xml" title="Recent Changes" href="../../feed.php"/>
<link rel="alternate" type="application/rss+xml" title="Current Namespace" href="../../feed.php%3Fmode=list&amp;ns=iocla:laboratoare"/>
<link rel="alternate" type="text/html" title="Plain HTML" href="../../_export/xhtml/iocla/laboratoare/laborator-06.html"/>
<link rel="canonical" href="laborator-06.html"/>
<link rel="stylesheet" type="text/css" href="../../lib/exe/css.php%3Ft=arctic&amp;tseed=1476798676.css"/>
<script type="text/javascript">/*<![CDATA[*/var NS='iocla:laboratoare';var JSINFO = {"id":"iocla:laboratoare:laborator-06","namespace":"iocla:laboratoare","isadmin":0,"isauth":0};
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="../../lib/exe/js.php%3Ftseed=1476798676"></script>
<script type="text/x-mathjax-config">/*<![CDATA[*/MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ["$","$"], ["\\(","\\)"] ],
        displayMath: [ ["$$","$$"], ["\\[","\\]"] ],
        processEscapes: true
    }
});
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
<script type="text/javascript">/*<![CDATA[*/
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
		  
/*!]]>*/</script>
<script type="text/javascript">/*<![CDATA[*/
var pageTracker = _gat._getTracker("UA-38383934-1");
pageTracker._initData();
pageTracker._trackPageview();
		  
/*!]]>*/</script>

  <link rel="shortcut icon" href="../../lib/tpl/arctic/images/favicon.ico" />

  
</head>
<body>
<div id="wrapper" class='show'>
  <div class="dokuwiki">

    
    <div class="stylehead">
      <div class="header">
        <div class="pagename">
          <a href="http://ocw.cs.pub.ro/courses/iocla/"><img height="70" src="../../res/sigla_iocla.png"/> </a>        </div>
        <div class="logo">
          <a style="color: #AAA !important;" href="../../../courses.1.html"/>Open CourseWare</a>        </div>
      </div>
    
       
      <div class="breadcrumbs">
              </div>
      
            </div>

                  <div class="bar" id="bar__top">
        <div class="bar-left">
                  </div>
        <div class="bar-right">
          <a href="laborator-06%3Fdo=recent.html"  class="action recent" accesskey="r" rel="nofollow" title="Recent changes [R]">Recent changes</a><a href="laborator-06%3Fdo=login&amp;sectok=f62420cf5b01253da4b50505d148181b.html"  class="action login" rel="nofollow" title="Login">Login</a>        </div>
    </div>
        
    
    
    
              <div class="left_page">
          
<h1 class="sectionedit1" id="laborator_06apeluri_de_functii">Laborator 06: Apeluri de funcții</h1>
<div class="level1">

<p>
În acest laborator vom prezenta modul în care se realizează apeluri de funcții. Vom vedea cum putem folosi instrucțiunile <code>call</code> și <code>ret</code> pentru a realiza apeluri de funcții și cum folosim stiva pentru a transmite parametrii unei funcții.
</p>

<p>
Laboratorul este de forma <em>learn by doing</em> partea practică alternând între secțiuni de tip tutorial, cu parcurgere pas cu pas și prezentarea soluției, și exerciții care trebuie să fie rezolvate.
</p>

</div>

<h2 class="sectionedit2" id="mediul_de_lucru">Mediul de lucru</h2>
<div class="level2">

<p>
Pentru acest laborator vom folosi un sistem Microsoft Windows, asamblorul <a href="http://www.nasm.us/" class="urlextern" title="http://www.nasm.us/"  rel="nofollow">nasm</a> și IDE-ul <a href="http://dman95.github.io/SASM/english.html" class="urlextern" title="http://dman95.github.io/SASM/english.html"  rel="nofollow">SASM</a>. Pentru compilarea codului sursă C vom folosi compilatorul din suita Microsoft Visual Studio (<code>cl</code>).
</p>

</div>

<h2 class="sectionedit3" id="cunostinte_si_abilitati_ce_vor_fi_dobandite">Cunoștințe și abilități ce vor fi dobândite</h2>
<div class="level2">
<ul>
<li class="level1"><div class="li"> Traducerea apelului și implementării unei funcții din limbajul C în limbaj de asamblare</div>
</li>
<li class="level1"><div class="li"> Folosirea instrucțiunilor <code>call</code> și <code>ret</code> pentru a realiza un apel de funcție</div>
</li>
<li class="level1"><div class="li"> Implementarea unei funcții în limbaj de asamblare</div>
</li>
<li class="level1"><div class="li"> Folosirea stivei pentru a transmite parametrii unei funcții</div>
</li>
<li class="level1"><div class="li"> Apelarea unei funcții externe (aflată în biblioteca standard C) din limbaj de asamblare</div>
</li>
</ul>

</div>

<h2 class="sectionedit4" id="exercitii">Exerciții</h2>
<div class="level2">

<p>
În cadrul exercițiilor vom folosi <a href="http://elf.cs.pub.ro/asm/res/laboratoare/lab-06-tasks.zip" class="urlextern" title="http://elf.cs.pub.ro/asm/res/laboratoare/lab-06-tasks.zip"  rel="nofollow">arhiva de laborator</a>.
</p>

<p>
Descărcați arhiva, decomprimați-o și accesați directorul aferent.
</p>

</div>

<h3 class="sectionedit5" id="p_1_recapitulareprogram_in_limbaj_de_asamblare">[1p] 1. Recapitulare: Program în limbaj de asamblare</h3>
<div class="level3">

<p>
În SASM deschideți fișierul <code>NASMHello.asm</code>, fișier din instalarea implicită de SASM și compilați-l și rulați-l. Observați afișarea mesajului <em>Hello, world!</em>
</p>

<p>
<p><div class="notetip">
Pentru deschiderea fișierului, accesați în SASM, meniul <code>File</code> și apoi opțiunea <code>Open</code>. Vi se va deschide un file browser în directorul cu fișierele din instalarea implicită de SASM. De acolo veți putea deschide fișierul <code>NASMHello.asm</code>.
</p>

<p>
Pentru compilare/rulare puteți folosi opțiunea <code>Build</code> din meniu, sau direct tasta <code>F9</code>.

</div></p>
</p>

<p>
Deschideți în SASM fișierul <code>hello-world.asm</code> din arhiva de laborator. Compilați-l și rulați-l și pe acesta și observați comportamentul.
</p>

<p>
Sunt câteva diferențe între cele două programe:
</p>
<ul>
<li class="level1"><div class="li"> Programul <code>hello-world.asm</code> folosește apelul funcției <code>puts</code> (funcție externă modulului curent) pentru a efectua a afișarea. Pentru aceasta pune argumentul pe stivă și apelează funcția.</div>
</li>
<li class="level1"><div class="li"> Variabila <code>msg</code> din programul <code>hello-world.asm</code> conține octeții <code>13</code> și <code>10</code>. Aceștia simbolizează caracterele <em>carriage-return</em> și <em>line-feed</em>, mai cunoscute și sub numele forma <code>\r\n</code>, folosite pentru a adăuga o linie nouă pe Windows.</div>
</li>
</ul>

<p>
Încheierea cu <code>\r\n</code> este, în general, utilă pentru afișarea șirurilor. Întrucât însă funcția <code>puts</code> pune automat o linie nouă după șirul afișat, prezența acestor caractere este opțională. Este, însă, utilă în cazul folosirii funcției <code>printf</code>.
</p>

</div>

<h3 class="sectionedit6" id="p_2_dezasamblarea_unui_program_scris_in_c">[1p] 2. Dezasamblarea unui program scris în C</h3>
<div class="level3">

<p>
După cum spuneam, în final, totul ajunge în limbaj de asamblare. Adesea ajungem să avem acces doar la codul obiect al unor programe și vrem să inspectăm modul în care arată.
</p>

<p>
Pentru a observa acest lucru, haideți să compilăm până la codul obiect un program scris în C și apoi să-l dezasamblăm. Este vorba de programul <code>test.c</code> din arhiva de laborator.
</p>

<p>
Pentru a compila un program vom folosi linia de comandă și de acolo comanda <code>cl</code> care reprezintă compilatorul și linker-ul din Visual Studio.
</p>

<p>
<p><div class="notetip">
Pentru a compila un fișier cod sursă C/C++ în linia de comandă folosind Visual Studio, urmați pașii:
</p>
<ol>
<li class="level1"><div class="li"> Deschideți prompt-ul pentru Visual Studio folosind icon-ul de pe Desktop intitulat <code>Visual Studio Command Prompt 2010</code>.</div>
</li>
<li class="level1"><div class="li"> Accesați directorul în care aveți codul sursă. De exemplu, pentru a accesa desktop-ul, folosiți comanda<pre class="code">cd c:\Users\Student\Desktop</pre>
</div>
</li>
<li class="level1"><div class="li"> Folosiți comanda<pre class="code">cl &lt;nume-fisier&gt;.c</pre>

<p>
 unde <code>&lt;nume-fisier&gt;</code> este numele fișierului.
</p>
</div>
</li>
<li class="level1"><div class="li"> Dacă doriți <strong>doar</strong> să compilați fișierul (<strong>fără</strong> să-l link-ați), atunci folosiți comanda<pre class="code">cl /c &lt;nume-fisier&gt;.c</pre>

<p>
 unde <code>&lt;nume-fisier&gt;</code> este numele fișierului.
</p>
</div>
</li>
</ol>

<p>

</div></p>
</p>

<p>
În cazul nostru, întrucât dorim doar să compilăm fișierul <code>test.c</code> la modulul obiect, vom accesa din prompt-ul Visual Studio directorul în care se găsește fișierul și apoi vom rula comanda
</p>
<pre class="code">cl /c test.c</pre>

<p>
În urma rulării comenzii de mai sus în directorul curent vom avea fișierul obiect test.obj.
</p>

<p>
Putem obține și forma în limbaj de asamblare a acestuia folosind comanda
</p>
<pre class="code">cl /c /FAs test.c</pre>

<p>
În urma rulării comenzii de mai sus obținem fișierul <code>test.asm</code> pe care îl putem vizualiza folosind comanda
</p>
<pre class="code">type test.asm</pre>

<p>
Pentru a dezasambla codul unui modul obiect vom folosi un utilitar frecvent întâlnit în lumea Unix: <code>objdump</code>. Pentru aceasta trebuie ca în prompt-ul Visual Studio sau în alt prompt să accesați directorul de binare al SASM. Este vorba de <code>C:\Program Files (x86)\SASM\MinGW64\bin</code>. De acolo, pentru dezasamblare, vom rula comanda
</p>
<pre class="code">.\objdump.exe -d &lt;path-to-obj-file&gt;</pre>

<p>
unde <code>&lt;path-to-obj-file&gt;</code> este calea către fișierul obiect <code>test.obj</code>.
</p>

<p>
Veți obține un output similar celui de mai jos
</p>
<pre class="code">C:\Program Files (x86)\SASM\MinGW\bin&gt;.\objdump.exe -d -M intel C:\Users\razvan\test.obj

C:\Users\razvan\test.obj:     file format pe-i386


Disassembly of section .text:

00000000 &lt;_main&gt;:
   0:   55                      push   ebp
   1:   8b ec                   mov    ebp,esp
   3:   6a 0f                   push   0xf
   5:   e8 00 00 00 00          call   a &lt;_main+0xa&gt;
   a:   83 c4 04                add    esp,0x4
   d:   50                      push   eax
   e:   68 00 00 00 00          push   0x0
  13:   e8 00 00 00 00          call   18 &lt;_main+0x18&gt;
  18:   83 c4 08                add    esp,0x8
  1b:   33 c0                   xor    eax,eax
  1d:   5d                      pop    ebp
  1e:   c3                      ret
  1f:   cc                      int3

00000020 &lt;_first_func&gt;:
  20:   55                      push   ebp
  21:   8b ec                   mov    ebp,esp
  23:   51                      push   ecx
  24:   c7 45 fc 03 00 00 00    mov    DWORD PTR [ebp-0x4],0x3
  2b:   68 00 00 00 00          push   0x0
  30:   e8 00 00 00 00          call   35 &lt;_first_func+0x15&gt;
  35:   83 c4 04                add    esp,0x4
  38:   8b 45 fc                mov    eax,DWORD PTR [ebp-0x4]
  3b:   50                      push   eax
  3c:   8d 4d 08                lea    ecx,[ebp+0x8]
  3f:   51                      push   ecx
  40:   e8 00 00 00 00          call   45 &lt;_first_func+0x25&gt;
  45:   83 c4 08                add    esp,0x8
  48:   8b 45 08                mov    eax,DWORD PTR [ebp+0x8]
  4b:   8b e5                   mov    esp,ebp
  4d:   5d                      pop    ebp
  4e:   c3                      ret
  4f:   cc                      int3

00000050 &lt;_second_func&gt;:
  50:   55                      push   ebp
  51:   8b ec                   mov    ebp,esp
  53:   8b 45 08                mov    eax,DWORD PTR [ebp+0x8]
  56:   8b 08                   mov    ecx,DWORD PTR [eax]
  58:   03 4d 0c                add    ecx,DWORD PTR [ebp+0xc]
  5b:   8b 55 08                mov    edx,DWORD PTR [ebp+0x8]
  5e:   89 0a                   mov    DWORD PTR [edx],ecx
  60:   5d                      pop    ebp
  61:   c3</pre>

<p>
Există multe alte utilitare care permit dezasamblare de module obiect, majoritatea cu interfața grafică și oferind și suport pentru debugging. <code>objdump</code> este un utilitar simplu care poate fi rapid folosit în linia de comandă.
</p>

<p>
Este interesant de urmărit, atât în fișierul <code>test.asm</code> cât și în dezasamblarea sa, modul în care se face un apel de funcție, lucru despre care vom discuta în continuare.
</p>

</div>

<h3 class="sectionedit7" id="breviarapelul_unei_functii">Breviar: Apelul unei funcții</h3>
<div class="level3">

<p>
Atunci când apelăm o funcție, pașii sunt următorii:
</p>
<ul>
<li class="level1"><div class="li"> Punem argumentele pe stivă, apelul de tip push fiind în ordinea inversă în care sunt trimiși ca argumente funcției.</div>
</li>
<li class="level1"><div class="li"> Apelăm call.</div>
</li>
<li class="level1"><div class="li"> Restaurăm stiva la sfârșitul apelului.</div>
</li>
</ul>

</div>

<h4 id="functionarea_stivei">Funcționarea stivei</h4>
<div class="level4">

<p>
După cum știm, operațiile pe stivă sunt de două tipuri:
</p>
<ul>
<li class="level1"><div class="li"> <code>push val</code> în care valoarea <code>val</code> este plasată pe stivă</div>
</li>
<li class="level1"><div class="li"> <code>pop reg/mem</code> în care ce se găsește în vârful stivei se plasează în registru sau într-o zonă de memorie</div>
</li>
</ul>

<p>
În momentul în care se face <code>push</code> spunem că stiva <strong>crește</strong> (se adaugă elemente). În mod oarecum paradoxal însă, pointerul de stivă (indicat de registrul <code>esp</code> pe 32 de biți) scade. Acest lucru se întâmplă întrucât stiva crește în jos, de la adresa mari către adrese mici.
</p>

<p>
La fel, în momentul care facem <code>pop</code> spunem că stiva <strong>scade</strong> (se scot elemente). Acum pointer-ul de stivă (indicat de registrul <code>esp</code> pe 32 de biți) crește.
</p>

<p>
Un sumar al acestui lucru este explicat foarte bine la acest link: <a href="https://en.wikibooks.org/wiki/X86_Disassembly/The_Stack" class="urlextern" title="https://en.wikibooks.org/wiki/X86_Disassembly/The_Stack"  rel="nofollow">https://en.wikibooks.org/wiki/X86_Disassembly/The_Stack</a>
</p>

</div>

<h4 id="exemplu_de_apelare_de_functie_in_assembly">Exemplu de apelare de funcție în assembly</h4>
<div class="level4">

<p>
După cum spuneam, în momentul în care realizăm un apel de funcție în assembly acesta se traduce în cei trei pași de mai sus. De exemplu, în fișierul <code>hello-world.asm</code> am apelat funcția <code>puts</code> folosind sintaxa:
</p>
<pre class="code">    push msg
    call puts
    add esp, 4</pre>

<p>
În primă fază am plasat pe stivă argumentul funcției <code>puts</code> adică adresa șirului <code>msg</code>. Apoi am apelat funcția <code>puts</code>. Apoi am restaurat stiva (care crescuse prin apelul <code>push</code>) adăugând <code>4</code> octeți (dimensiunea unui cuvânt pe 32 de biți) la registrul de stivă (<code>esp</code>).
</p>

<p>
Astfel sunt traduse majoritatea apelurilor de funcții. Dacă urmărim dezasamblarea fișierul <code>test.obj</code> putem observa acest șablon de apel și în alte părți. Mai jos sunt secvențele extrase din dezasamblarea de mai sus:
</p>
<pre class="code">   d:   50                      push   %eax
   e:   68 00 00 00 00          push   $0x0
  13:   e8 00 00 00 00          call   18 &lt;_main+0x18&gt;
  18:   83 c4 08                add    $0x8,%esp

  2b:   68 00 00 00 00          push   $0x0
  30:   e8 00 00 00 00          call   35 &lt;_first_func+0x15&gt;
  35:   83 c4 04                add    $0x4,%esp

  3b:   50                      push   %eax
  3c:   8d 4d 08                lea    0x8(%ebp),%ecx
  3f:   51                      push   %ecx
  40:   e8 00 00 00 00          call   45 &lt;_first_func+0x25&gt;
  45:   83 c4 08                add    $0x8,%esp</pre>

<p>
Contează mai puțin, pentru înțelegerea noastră din acest moment, de ce unele instrucțiuni arată cum arată, este importantă înțelegerea pașilor urmați pentru apelarea unei funcții: plasarea argumentelor pe stivă, apelul funcției, restaurarea stivei.
</p>

</div>

<h3 class="sectionedit8" id="p_3_afisarea_unui_sir">[1p] 3. Afișarea unui șir</h3>
<div class="level3">

<p>
Pentru afișarea unui string în SASM putem folosi macro-ul <code>PRINT_STRING</code>. Sau putem folosi o funcție precum <code>puts</code>. În fișierul <code>print-string.asm</code> este implementată afișarea unui string folosind macro-ul <code>PRINT_STRING</code>.
</p>

<p>
Urmărind fișierul <code>hello-world.asm</code> ca exemplu, implementați afișarea șirului folosind și <code>puts</code>.
</p>

<p>
<p><div class="notetip">
Urmăriți și indicațiile din secțiunea de mai sus, legate de apelul unei funcții.

</div></p>
</p>

</div>

<h3 class="sectionedit9" id="p_4_afisarea_lungimii_unui_sir">[2p] 4. Afișarea lungimii unui șir</h3>
<div class="level3">

<p>
Programul <code>print-string-len.asm</code> afișează lungimea unui șir folosind macro-ul <code>PRINT_DEC</code>. Calculul lungimii șirului <code>mystring</code> are loc în cadrul programului (este deja implementat).
</p>

<p>
Implementați programul pentru a face afișarea lungimii șirului folosind funcția <code>printf</code>.
</p>

<p>
La sfârșit veți avea afișată de două ori lungimea șirului: o dată cu apelul macro-ului SASM <code>PRINT_DEC</code> și apoi cu apelul funcției externe <code>printf</code>.
</p>

<p>
<p><div class="notetip">
Gândiți-vă că apelul <code>printf</code> este de forma <code>printf(&quot;String length is %u\n&quot;, len);</code>. Trebuie să construiți stiva pentru acest apel.
</p>

<p>
Pașii de urmat sunt:
</p>
<ol>
<li class="level1"><div class="li"> Marcarea simbolului <code>printf</code> ca simbol extern.</div>
</li>
<li class="level1"><div class="li"> Definirea șirului de formatare <code>&quot;String length is %u&quot;, 13, 10, 0</code>.</div>
</li>
<li class="level1"><div class="li"> Realizarea apelului funcției <code>printf</code>, adică:</div>
<ol>
<li class="level2"><div class="li"> Punerea celor două argumente pe stivă: șirul de formatarea și lungimea.</div>
</li>
<li class="level2"><div class="li"> Apelul <code>printf</code> folosind <code>call</code>.</div>
</li>
<li class="level2"><div class="li"> Restaurarea stivei.</div>
</li>
</ol>
</li>
</ol>

<p>
Lungimea șirului se găsește în registrul <code>ecx</code>.

</div></p>
</p>

</div>

<h3 class="sectionedit10" id="p_5_afisarea_sirului_inversat">[3p] 5. Afișarea șirului inversat</h3>
<div class="level3">

<p>
În soluția de mai sus adăugați funcția <code>reverse_string</code> astfel încât să aveți un listing similar celui de mai jos:
</p>
<pre class="code">[...]
section .text
global CMAIN

reverse_string:
    push ebp
    mov ebp, esp

    mov eax, dword [ebp+8]
    mov ecx, dword [ebp+12]
    add eax, ecx
    dec eax
    mov edx, dword [ebp+16]

copy_one_byte:
    mov bl, byte [eax]
    mov byte [edx], bl
    dec eax
    inc edx
    loopnz copy_one_byte

    inc edx
    mov byte [edx], 0

    leave
    ret

CMAIN:
    push ebp
    mov ebp, esp
[...]</pre>

<p>
<p><div class="noteimportant">
Când copiați funcția <code>reverse_string</code> în programul vostru, rețineți că fucția începe la eticheta <code>reverse_string</code> și se oprește la eticheta <code>CMAIN</code>. Eticheta <code>copy_one_byte</code> este parte a funcției <code>reverse_string</code>.

</div></p>
</p>

<p>
Funcția <code>reverse_string</code> inversează un șir și are următoarea signatură: <code>void reverse_string(const char *src, size_t len, char *dst);</code>. Astfel ca primele <code>len</code> caractere și șirul <code>src</code> sunt inversate în șirul <code>dst</code>.
</p>

<p>
Realizați inversarea șirului <code>mystring</code> într-un nou șir și afișați acel nou șir.
</p>

<p>
<p><div class="notetip">
Pentru a defini un nou șir, recomandăm ca, în secțiunea de date să folosiți construcția
</p>
<pre class="code">    store_string times 64 db 0</pre>

<p>
Construcția creează un șir de 64 de octeți de zero, suficient pentru a stoca inversul șirului.
</p>

<p>
Apelul echivalent în C al funcției este <code>reverse_string(mystring, ecx, store_string);</code>. În registrul <code>ecx</code> am presupus că este calculată lungimea șirului.
</p>

<p>
Nu puteți folosi direct valoarea <code>ecx</code> în forma ei curentă. După apelul funcției <code>printf</code> pentru afișare numărului valoarea <code>ecx</code> se pierde. Ca să o păstrați, aveți două opțiuni:
</p>
<ol>
<li class="level1"><div class="li"> Stocați valoarea registrului <code>ecx</code> în prealabil pe stivă (folosind <code>push ecx</code> înaintea apelului <code>printf</code>) și apoi să o restaurați după apelul <code>printf</code> (folosind <code>pop ecx</code>).</div>
</li>
<li class="level1"><div class="li"> Stocați valoarea registrului <code>ecx</code> într-o variabilă globală, pe care o definiți în secțiunea <code>.data</code>.</div>
</li>
</ol>

<p>
Nu puteți folosi un alt registru pentru că sunt șanse foarte mari ca și acel registru să fie modificat de apelul <code>printf</code> pentru afișarea lungimii șirului.

</div></p>
</p>

</div>

<h3 class="sectionedit11" id="breviarapelatul_in_cadrul_unei_functii">Breviar: Apelatul în cadrul unei funcții</h3>
<div class="level3">

<p>
Atunci când apelăm o funcție spune că funcția care apelează (contextul care apelează) se cheamă <strong>apelant</strong> (sau <strong>caller</strong>) iar funcția apelată se cheamă <strong>apelat</strong> (sau <strong>callee</strong>). Până acum am discutat despre cum arată lucrurile la nivelul apelantului (cum construim stiva acolo). Haideți să urmărim ce se întâmplă la nivelul apelatului.
</p>

<p>
Până în momentul instrucțiunii <code>call</code> stiva conține parametrii funcției. Apelul <code>call</code> poate fi echivalat grosier următoarei secvențe:
</p>
<pre class="code">    push eip
    jmp function_name</pre>

<p>
Adică și apelul <code>call</code> folosește în continuare stiva și salvează adresa următoarei instrucțiuni, cea de după <code>call</code> numită și instrucțiunea de retur sau adresa de retur (<em>return value</em>, <em>return address</em>). Aceasta este necesară pentru a ști, în apelat, unde să revenim.
</p>

<p>
Suplimentar, în apelat, la începutul său (numit preambul, <em>preamble</em>) se salvează frame pointer-ul (în arhitectura i386 este vorba de registrul <code>ebp</code>) urmând ca frame pointer-ul să refere adresa curentă de pe stivă (adică tocmai fostul frame pointer). Deși nu este obligatorie, salvarea frame pointer-ului ajută la debugging și este în cele mai multe cazuri folosită. Din aceste motive, orice apel de funcție va avea în general, preambulul:
</p>
<pre class="code">    push ebp
    mov ebp, esp</pre>

<p>
Aceste modificări au loc în apelat. De aceea este responsabilitatea apelatului să restaureze stiva la vechea sa valoare. De aceea este uzuală existența unui epilog care să readucă stiva la starea sa inițială; acest epilog este:
</p>
<pre class="code">    leave</pre>

<p>
În acest moment stiva este ca la începutul funcției, adică imediat după <code>call</code>, referind adresa de retur. Urmează apelul
</p>
<pre class="code">    ret</pre>

<p>
care este grosier echivalentul instrucțiunii:
</p>
<pre class="code">    pop eip</pre>

<p>
Adică ia valoarea din vârful stivei și o plasează în <code>eip</code> urmând continuarea execuției programului de la acea adresă.
</p>

<p>
Un sumar al acestui comportament, plasat pe apelul echivalent <code>reverse_string(mystring, len, store_string);</code> este indicat în diagrama de mai jos, accesibilă în format PDF și original DIA la adresa: <a href="http://elf.cs.pub.ro/asm/res/laboratoare/lab-04-img/" class="urlextern" title="http://elf.cs.pub.ro/asm/res/laboratoare/lab-04-img/"  rel="nofollow">http://elf.cs.pub.ro/asm/res/laboratoare/lab-04-img/</a>
</p>

<p>
<a href="../../_detail/iocla/laboratoare/stack-in-function-call.png%3Fid=iocla%253Alaboratoare%253Alaborator-06.html" class="media" title="iocla:laboratoare:stack-in-function-call.png"><img src="../../_media/iocla/laboratoare/stack-in-function-call.png%3Fw=600&amp;tok=2b8152" class="mediacenter" alt="" width="600" /></a>
</p>

<p>
De observat că pe parcursul execuției funcției, ceea ce nu se schimbă este poziția frame pointer-ul. Acesta este și motivul denumirii sale: pointează la frame-ul curent de funcției. De aceea este comun ca accesarea parametrilor unei funcții să se realizeze prin intermediul frame pointer-ului. Presupunând un sistem pe 32 de biți și parametri de dimensiunea cuvântului procesorului (32 de biți, 4 octeți) vom avea:
</p>
<ul>
<li class="level1"><div class="li"> primul argument se găsește la adresa <code>ebp+8</code></div>
</li>
<li class="level1"><div class="li"> al doilea argument se găsește la adresa <code>ebp+12</code></div>
</li>
<li class="level1"><div class="li"> al treilea argument se găsește la adresa <code>ebp+16</code></div>
</li>
<li class="level1"><div class="li"> etc.</div>
</li>
</ul>

<p>
Acesta este motivul pentru care, pentru a obține parametrii funcției <code>reverse_string</code> în registrele respectiv <code>eax</code>, <code>ecx</code>, <code>edx</code>, folosim construcțiile:
</p>
<pre class="code">    mov eax, dword [ebp+8]   ; retrieve first function argument in eax
    mov ecx, dword [ebp+12]  ; retrieve second function argument in ecx
    mov edx, dword [ebp+16]  ; retrieve third function argument in edx</pre>

</div>

<h3 class="sectionedit12" id="p_6_implementarea_functiei_toupper">[2p] 6. Implementarea funcției toupper</h3>
<div class="level3">

<p>
Ne propunem implementarea funcției <code>toupper</code> care traduce literele mici în litere mari. Pentru aceasta, porniți de la fișierul <code>toupper.asm</code> din arhiva de exerciții a laboratorului și completați corpul funcției <code>topupper</code>.
</p>

<p>
Șirul folosit este <code>mystring</code> și presupunem că este un șir valid. Acest șir este transmis ca argument funcției <code>toupper</code> în momentul apelului.
</p>

<p>
Faceți înlocuirea <em>in place</em>, nu este nevoie de un alt șir.
</p>

<p>
<p><div class="notetip">
Ca să traduceți o litera mică în literă mare, trebuie să <strong>scădeți</strong> <code>0x20</code> din valoare. Aceasta este diferența între litere mici și mari; de exemplu <code>a</code> este <code>0x61</code> iar <code>A</code> este <code>0x41</code>. Puteți vedea în <a href="http://man7.org/linux/man-pages/man7/ascii.7.html" class="urlextern" title="http://man7.org/linux/man-pages/man7/ascii.7.html"  rel="nofollow">pagina de manual ascii</a>.
</p>

<p>
Ca să citiți sau să scrieți octet cu octet folosiți construcția <code>byte [reg]</code> așa cum apare și în implementarea determinării lungimii unui șir  în fișierul <code>print-string-len.asm</code>, unde <code>[reg]</code> este registrul de tip pointer în care este stocată adresa șirului în acel punct.
</p>

<p>
Vă opriți atunci când ați ajuns la valoarea <code>0</code> (<code>NUL</code> byte). Pentru verificare puteți folosi <code>test</code> așa cum se întâmplă și în implementarea determinării unui șir în fișierul <code>print-string-len.asm</code>.

</div></p>
</p>

</div>

<h3 class="sectionedit13" id="p_bonustoupper_doar_pentru_litere_mici">[2p] Bonus: toupper doar pentru litere mici</h3>
<div class="level3">

<p>
Implementați funcția <code>toupper</code> astfel încât translatarea să aibă loc doar pentru caractare reprezentând litere mici, nu litere mari sau alte tipuri de caractere.
</p>

</div>

<h3 class="sectionedit14" id="p_bonusrot13">[2p] Bonus: rot13</h3>
<div class="level3">

<p>
Realizați și folosiți o funcție care face translatarea <a href="http://www.decode.org/" class="urlextern" title="http://www.decode.org/"  rel="nofollow">rot13</a> a unui șir.
</p>

</div>

<h3 class="sectionedit15" id="p_bonusrot131">[2p] Bonus: rot13++</h3>
<div class="level3">

<p>
Implementați <code>rot13</code> pe un array de șiruri: șirurile sunt continue în memorie separate prin terminatorul de șirul (<code>NUL</code>-byte, <code>0</code>). De exemplu: <code>ana\0are\0mere\0</code> este un array de trei șiruri.
</p>

<p>
<p><div class="notetip">
Va trebui să știți când sa vă opriți din parcurgerea array-ului de șiruri. Cel mai simplu este să definiți o variabilă de lungime în secțiunea <code>.data</code>, de forma
</p>
<pre class="code">    len dd 10</pre>

<p>
în care să rețineți fie lungimea totală a șirului (de la începutul până la ultimul <code>NUL</code>-byte), fie numărul de șiruri din array.

</div></p>
</p>

</div>

<h2 class="sectionedit16" id="alte_resurse">Alte resurse</h2>
<div class="level2">
<ul>
<li class="level1"><div class="li"> <a href="http://www.nasm.us/" class="urlextern" title="http://www.nasm.us/"  rel="nofollow">nasm</a></div>
</li>
<li class="level1"><div class="li"> <a href="http://dman95.github.io/SASM/english.html" class="urlextern" title="http://dman95.github.io/SASM/english.html"  rel="nofollow">SASM</a></div>
</li>
</ul>

</div>

        </div>
        <div class="right_sidebar">
          <form action="../../start.html" accept-charset="utf-8" class="search" id="dw__search" method="get"><div class="no"><input type="hidden" name="do" value="search" /><input type="text" id="qsearch__in" accesskey="f" name="id" class="edit" title="[F]" /><input type="submit" value="Search" class="button" title="Search" /><div id="qsearch__out" class="ajax_qsearch JSpopup"></div></div></form>          <div class="namespace_sidebar sidebar_box">



<div><div id="nojs_indexmenu_46940418958355a6da74d5" data-jsajax="%26skipfile%3D%252B/iocla%253A%2528sidebar%257Cindex%2529/" class="indexmenu_nojs">

<ul class="idx">
<li class="level1"><div class="li"><a href="../anunturi.html" class="wikilink1" title="iocla:anunturi">Anunțuri</a></div></li>
<li class="level1"><div class="li"><a href="../bune-practici.html" class="wikilink1" title="iocla:bune-practici">Bune practici</a></div></li>
<li class="level1"><div class="li"><a href="../calendar.html" class="wikilink1" title="iocla:calendar">Calendar</a></div></li>
<li class="level1"><div class="li"><a href="../catalog.html" class="wikilink1" title="iocla:catalog">Catalog</a></div></li>
<li class="level1"><div class="li"><a href="../feed.html" class="wikilink1" title="iocla:feed">Feed RSS</a></div></li>
<li class="level1"><div class="li"><a href="../need-to-know.html" class="wikilink1" title="iocla:need-to-know">IOCLA Need to Know</a></div></li>
<li class="level1"><div class="li"><a href="../reguli-notare.html" class="wikilink1" title="iocla:reguli-notare">Reguli și notare</a></div></li>
<li class="level1"><div class="li"><a href="../utile.html" class="wikilink1" title="iocla:utile">Resurse utile</a></div></li>
</ul>
</div></div>

<h1 class="sectionedit1" id="cursuri">Cursuri</h1>
<div class="level1">
<ul>
<li class="level1"><div class="li"> <a href="../cursuri/capitol-01.html" class="wikilink1" title="iocla:cursuri:capitol-01">Capitol 01: Introducere</a></div>
</li>
<li class="level1"><div class="li"> <a href="../cursuri/capitol-02.html" class="wikilink1" title="iocla:cursuri:capitol-02">Capitol 02: Reprezentarea datelor în sistemele de calcul</a></div>
</li>
<li class="level1"><div class="li"> <a href="../cursuri/capitol-03.html" class="wikilink1" title="iocla:cursuri:capitol-03">Capitol 03: Arhitectura unui sistem de calcul</a></div>
</li>
<li class="level1"><div class="li"> <a href="../cursuri/capitol-04.html" class="wikilink1" title="iocla:cursuri:capitol-04">Capitol 04: Arhitectura x86</a></div>
</li>
<li class="level1"><div class="li"> <a href="../cursuri/capitol-05.html" class="wikilink1" title="iocla:cursuri:capitol-05">Capitol 05: Moduri de adresare</a></div>
</li>
<li class="level1"><div class="li"> <a href="../cursuri/capitol-06.html" class="wikilink1" title="iocla:cursuri:capitol-06">Capitol 06: Setul de instrucțiuni</a></div>
</li>
<li class="level1"><div class="li"> <a href="../cursuri/capitol-07.html" class="wikilink1" title="iocla:cursuri:capitol-07">Capitol 07: Dezvoltarea în limbaj de asamblare pe x86</a></div>
</li>
<li class="level1"><div class="li"> <a href="../cursuri/capitol-08.html" class="wikilink1" title="iocla:cursuri:capitol-08">Capitol 08: Inginerie inversă și exploatarea aplicațiilor</a></div>
</li>
<li class="level1"><div class="li"> <a href="../cursuri/capitol-09.html" class="wikilink1" title="iocla:cursuri:capitol-09">Capitol 09: Operații și extensii dedicate</a></div>
</li>
<li class="level1"><div class="li"> <a href="../cursuri/capitol-10.html" class="wikilink1" title="iocla:cursuri:capitol-10">Capitol 10: Programarea pentru medii specifice</a></div>
</li>
</ul>

</div>
<!-- EDIT1 SECTION "Cursuri" [166-529] -->
<h1 class="sectionedit2" id="laboratoare">Laboratoare</h1>
<div class="level1">
<ul>
<li class="level1"><div class="li"> <a href="laborator-01.html" class="wikilink1" title="iocla:laboratoare:laborator-01">Laborator 01: Introducere</a></div>
</li>
<li class="level1"><div class="li"> <a href="laborator-02.html" class="wikilink1" title="iocla:laboratoare:laborator-02">Laborator 02: Toolchain</a></div>
</li>
<li class="level1"><div class="li"> <a href="laborator-03.html" class="wikilink1" title="iocla:laboratoare:laborator-03">Laborator 03: First baby steps</a></div>
</li>
<li class="level1"><div class="li"> <a href="laborator-04.html" class="wikilink1" title="iocla:laboratoare:laborator-04">Laborator 04: Rolul registrelor, adresare directă și bazată</a></div>
</li>
<li class="level1"><div class="li"> <a href="laborator-05.html" class="wikilink1" title="iocla:laboratoare:laborator-05">Laborator 05: Structuri, vectori, explorarea memoriei</a></div>
</li>
<li class="level1"><div class="li"> <span class="curid"><a href="laborator-06.html" class="wikilink1" title="iocla:laboratoare:laborator-06">Laborator 06: Apeluri de funcții</a></span></div>
</li>
<li class="level1"><div class="li"> <a href="laborator-07.html" class="wikilink1" title="iocla:laboratoare:laborator-07">Laborator 07: Operații pe numere mari</a></div>
</li>
<li class="level1"><div class="li"> <a href="laborator-08.html" class="wikilink1" title="iocla:laboratoare:laborator-08">Laborator 08: Interfața în linia de comandă, analiza statică și dinamică</a></div>
</li>
<li class="level1"><div class="li"> <a href="laborator-09.html" class="wikilink1" title="iocla:laboratoare:laborator-09">Laborator 09: Gestiunea bufferelor. Buffer overflow</a></div>
</li>
<li class="level1"><div class="li"> <a href="laborator-10.html" class="wikilink1" title="iocla:laboratoare:laborator-10">Laborator 10: Exploatarea memoriei. Shellcodes</a></div>
</li>
<li class="level1"><div class="li"> <a href="laborator-11.html" class="wikilink1" title="iocla:laboratoare:laborator-11">Laborator 11: Interactiunea C-assembly</a></div>
</li>
<li class="level1"><div class="li"> <a href="laborator-12.html" class="wikilink1" title="iocla:laboratoare:laborator-12">Laborator 12: Calcul în virgulă mobilă</a></div>
</li>
</ul>

</div>
<!-- EDIT2 SECTION "Laboratoare" [530-1037] -->
<h1 class="sectionedit3" id="teme">Teme</h1>
<div class="level1">
<ul>
<li class="level1"><div class="li"> <a href="../teme/tema-1.html" class="wikilink1" title="iocla:teme:tema-1">Tema 1</a></div>
</li>
<li class="level1"><div class="li"> <a href="../teme/tema-2.html" class="wikilink1" title="iocla:teme:tema-2">Tema 2</a></div>
</li>
<li class="level1"><div class="li"> <a href="../teme/tema-3.html" class="wikilink1" title="iocla:teme:tema-3">Tema 3</a></div>
</li>
</ul>

</div>
<!-- EDIT3 SECTION "Teme" [1038-] -->
</div>
<div class="toc_sidebar sidebar_box">
<!-- TOC START -->
<div id="sb__right__dw__toc">
<h3 class="toggle">Table of Contents</h3>
<div>

<ul class="toc">
<li class="level1"><div class="li"><a href="laborator-06.html#laborator_06apeluri_de_functii">Laborator 06: Apeluri de funcții</a></div>
<ul class="toc">
<li class="level2"><div class="li"><a href="laborator-06.html#mediul_de_lucru">Mediul de lucru</a></div></li>
<li class="level2"><div class="li"><a href="laborator-06.html#cunostinte_si_abilitati_ce_vor_fi_dobandite">Cunoștințe și abilități ce vor fi dobândite</a></div></li>
<li class="level2"><div class="li"><a href="laborator-06.html#exercitii">Exerciții</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="laborator-06.html#p_1_recapitulareprogram_in_limbaj_de_asamblare">[1p] 1. Recapitulare: Program în limbaj de asamblare</a></div></li>
<li class="level3"><div class="li"><a href="laborator-06.html#p_2_dezasamblarea_unui_program_scris_in_c">[1p] 2. Dezasamblarea unui program scris în C</a></div></li>
<li class="level3"><div class="li"><a href="laborator-06.html#breviarapelul_unei_functii">Breviar: Apelul unei funcții</a></div>
<ul class="toc">
<li class="level4"><div class="li"><a href="laborator-06.html#functionarea_stivei">Funcționarea stivei</a></div></li>
<li class="level4"><div class="li"><a href="laborator-06.html#exemplu_de_apelare_de_functie_in_assembly">Exemplu de apelare de funcție în assembly</a></div></li>
</ul>
</li>
<li class="level3"><div class="li"><a href="laborator-06.html#p_3_afisarea_unui_sir">[1p] 3. Afișarea unui șir</a></div></li>
<li class="level3"><div class="li"><a href="laborator-06.html#p_4_afisarea_lungimii_unui_sir">[2p] 4. Afișarea lungimii unui șir</a></div></li>
<li class="level3"><div class="li"><a href="laborator-06.html#p_5_afisarea_sirului_inversat">[3p] 5. Afișarea șirului inversat</a></div></li>
<li class="level3"><div class="li"><a href="laborator-06.html#breviarapelatul_in_cadrul_unei_functii">Breviar: Apelatul în cadrul unei funcții</a></div></li>
<li class="level3"><div class="li"><a href="laborator-06.html#p_6_implementarea_functiei_toupper">[2p] 6. Implementarea funcției toupper</a></div></li>
<li class="level3"><div class="li"><a href="laborator-06.html#p_bonustoupper_doar_pentru_litere_mici">[2p] Bonus: toupper doar pentru litere mici</a></div></li>
<li class="level3"><div class="li"><a href="laborator-06.html#p_bonusrot13">[2p] Bonus: rot13</a></div></li>
<li class="level3"><div class="li"><a href="laborator-06.html#p_bonusrot131">[2p] Bonus: rot13++</a></div></li>
</ul>
</li>
<li class="level2"><div class="li"><a href="laborator-06.html#alte_resurse">Alte resurse</a></div></li>
</ul></li>
</ul>
</div>
</div>
<!-- TOC END -->
</div>
        </div>
      
    
      <div class="stylefoot">
        <div class="meta">
          <div class="user">
                    </div>
          <div class="doc">
          iocla/laboratoare/laborator-06.txt · Last modified: 2016/11/11 10:48 by razvan.deaconescu          </div>
        </div>
      </div>

    <div class="clearer"></div>

    
                <div class="bar" id="bar__bottom">
      <div class="bar-left">
              </div>
      <div class="bar-right">
        <a href="laborator-06%3Fdo=media&amp;ns=iocla%253Alaboratoare.html"  class="action media" rel="nofollow" title="Media Manager">Media Manager</a><a href="laborator-06.html#dokuwiki__top"  class="action top" accesskey="t" rel="nofollow" title="Back to top [T]">Back to top</a>      </div>
    </div>
    <div class="clearer"></div>
            
    <div align="center" class="footerinc">
  <div class="license"><a href="http://creativecommons.org/licenses/by-sa/3.0/" rel="license"><img src="../../lib/images/license/button/cc-by-sa.png" alt="CC Attribution-Share Alike 3.0 Unported" /></a></div>
  <a target="_blank" href="http://www.chimeric.de" title="www.chimeric.de"><img src="../../lib/tpl/arctic/images/button-chimeric-de.png" width="80" height="15" alt="www.chimeric.de" border="0" /></a>

  <a target="_blank" href="http://jigsaw.w3.org/css-validator/check/referer" title="Valid CSS"><img src="../../lib/tpl/arctic/images/button-css.png" width="80" height="15" alt="Valid CSS" border="0" /></a>

  <a target="_blank" href="http://wiki.splitbrain.org/wiki:dokuwiki" title="Driven by DokuWiki"><img src="../../lib/tpl/arctic/images/button-dw.png" width="80" height="15" alt="Driven by DokuWiki" border="0" /></a>

  <a target="_blank" href="http://www.firefox-browser.de" title="do yourself a favour and use a real browser - get firefox"><img src="../../lib/tpl/arctic/images/button-firefox.png" width="80" height="15" alt="do yourself a favour and use a real browser - get firefox!!" border="0" /></a>
  
  <a target="_blank" href="../../feed.php" title="Recent changes RSS feed"><img src="../../lib/tpl/arctic/images/button-rss.png" width="80" height="15" alt="Recent changes RSS feed" border="0" /></a>

  <a target="_blank" href="http://validator.w3.org/check/referer" title="Valid XHTML 1.0"><img src="../../lib/tpl/arctic/images/button-xhtml.png" width="80" height="15" alt="Valid XHTML 1.0" border="0" /></a>
</div>

  </div>
</div>

<div class="no"><img src="../../lib/exe/indexer.php%3Fid=iocla%253Alaboratoare%253Alaborator-06&amp;1479891565" width="2" height="1" alt="" /></div>
</body>
</html>
