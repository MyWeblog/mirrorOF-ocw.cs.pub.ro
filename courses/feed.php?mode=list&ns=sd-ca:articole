    
    

<?xml version="1.0" encoding="utf-8"?>
<!-- generator="FeedCreator 1.7.2-ppt DokuWiki" -->
<?xml-stylesheet href="http://ocw.cs.pub.ro/courses/lib/exe/css.php?s=feed" type="text/css"?>
<rdf:RDF
    xmlns="http://purl.org/rss/1.0/"
    xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
    xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
    xmlns:dc="http://purl.org/dc/elements/1.1/">
    <channel rdf:about="http://ocw.cs.pub.ro/courses/feed.php">
        <title>CS Open CourseWare sd-ca:articole</title>
        <description></description>
        <link>http://ocw.cs.pub.ro/courses/</link>
        <image rdf:resource="http://ocw.cs.pub.ro/courses/lib/tpl/arctic/images/favicon.ico" />
       <dc:date>2016-11-23T11:14:11+02:00</dc:date>
        <items>
            <rdf:Seq>
                <rdf:li rdf:resource="http://ocw.cs.pub.ro/courses/sd-ca/articole/articol-01?rev=1457610169&amp;do=diff"/>
                <rdf:li rdf:resource="http://ocw.cs.pub.ro/courses/sd-ca/articole/articol-02?rev=1456958599&amp;do=diff"/>
                <rdf:li rdf:resource="http://ocw.cs.pub.ro/courses/sd-ca/articole/articol-03?rev=1456382212&amp;do=diff"/>
                <rdf:li rdf:resource="http://ocw.cs.pub.ro/courses/sd-ca/articole/articol-04?rev=1457615922&amp;do=diff"/>
                <rdf:li rdf:resource="http://ocw.cs.pub.ro/courses/sd-ca/articole/articol-05?rev=1457616121&amp;do=diff"/>
                <rdf:li rdf:resource="http://ocw.cs.pub.ro/courses/sd-ca/articole/articol-06?rev=1457616074&amp;do=diff"/>
                <rdf:li rdf:resource="http://ocw.cs.pub.ro/courses/sd-ca/articole/articol-07?rev=1458213070&amp;do=diff"/>
                <rdf:li rdf:resource="http://ocw.cs.pub.ro/courses/sd-ca/articole/articol-08?rev=1461163997&amp;do=diff"/>
                <rdf:li rdf:resource="http://ocw.cs.pub.ro/courses/sd-ca/articole/articol-09?rev=1461343200&amp;do=diff"/>
                <rdf:li rdf:resource="http://ocw.cs.pub.ro/courses/sd-ca/articole/articol-10?rev=1462442870&amp;do=diff"/>
                <rdf:li rdf:resource="http://ocw.cs.pub.ro/courses/sd-ca/articole/articol-11?rev=1462444212&amp;do=diff"/>
                <rdf:li rdf:resource="http://ocw.cs.pub.ro/courses/sd-ca/articole/articol-12?rev=1461343632&amp;do=diff"/>
                <rdf:li rdf:resource="http://ocw.cs.pub.ro/courses/sd-ca/articole/tutorial-01-1?rev=1456313196&amp;do=diff"/>
                <rdf:li rdf:resource="http://ocw.cs.pub.ro/courses/sd-ca/articole/tutorial-02-1?rev=1456959738&amp;do=diff"/>
                <rdf:li rdf:resource="http://ocw.cs.pub.ro/courses/sd-ca/articole/tutorial-03-1?rev=1457560417&amp;do=diff"/>
                <rdf:li rdf:resource="http://ocw.cs.pub.ro/courses/sd-ca/articole/tutorial-04-1?rev=1457608442&amp;do=diff"/>
                <rdf:li rdf:resource="http://ocw.cs.pub.ro/courses/sd-ca/articole/tutorial-04-2?rev=1457611066&amp;do=diff"/>
                <rdf:li rdf:resource="http://ocw.cs.pub.ro/courses/sd-ca/articole/tutorial-04-3?rev=1457610607&amp;do=diff"/>
                <rdf:li rdf:resource="http://ocw.cs.pub.ro/courses/sd-ca/articole/tutorial-05-1?rev=1457609295&amp;do=diff"/>
                <rdf:li rdf:resource="http://ocw.cs.pub.ro/courses/sd-ca/articole/tutorial-05-2?rev=1457613764&amp;do=diff"/>
                <rdf:li rdf:resource="http://ocw.cs.pub.ro/courses/sd-ca/articole/tutorial-05-3?rev=1457610686&amp;do=diff"/>
                <rdf:li rdf:resource="http://ocw.cs.pub.ro/courses/sd-ca/articole/tutorial-06-1?rev=1459319700&amp;do=diff"/>
                <rdf:li rdf:resource="http://ocw.cs.pub.ro/courses/sd-ca/articole/tutorial-06-2?rev=1459319546&amp;do=diff"/>
                <rdf:li rdf:resource="http://ocw.cs.pub.ro/courses/sd-ca/articole/tutorial-07-1?rev=1457636520&amp;do=diff"/>
                <rdf:li rdf:resource="http://ocw.cs.pub.ro/courses/sd-ca/articole/tutorial-11-1?rev=1462454588&amp;do=diff"/>
                <rdf:li rdf:resource="http://ocw.cs.pub.ro/courses/sd-ca/articole/tutorial-11-2?rev=1462467676&amp;do=diff"/>
                <rdf:li rdf:resource="http://ocw.cs.pub.ro/courses/sd-ca/articole/tutorial-11-3?rev=1462455020&amp;do=diff"/>
            </rdf:Seq>
        </items>
    </channel>
    <image rdf:about="http://ocw.cs.pub.ro/courses/lib/tpl/arctic/images/favicon.ico">
        <title>CS Open CourseWare</title>
        <link>http://ocw.cs.pub.ro/courses/</link>
        <url>http://ocw.cs.pub.ro/courses/lib/tpl/arctic/images/favicon.ico</url>
    </image>
    <item rdf:about="http://ocw.cs.pub.ro/courses/sd-ca/articole/articol-01?rev=1457610169&amp;do=diff">
        <dc:format>text/html</dc:format>
        <dc:date>2016-03-10T13:42:49+02:00</dc:date>
        <title>Articol 1 - Introducere in C++</title>
        <link>http://ocw.cs.pub.ro/courses/sd-ca/articole/articol-01?rev=1457610169&amp;do=diff</link>
        <description>În cadrul acestui articol ne propunem să ilustrăm conceptele din C++ cu care veți lucra pe parcursul acestui semestru.

Într-un mod extrem de simplist spus, C++ este un superset al limbajului C, iar tot ceea ce ați învățat în C la  PC se poate compila cu un compilator pentru limbajul C++, funcționalitatea rămânând aceeași.</description>
    </item>
    <item rdf:about="http://ocw.cs.pub.ro/courses/sd-ca/articole/articol-02?rev=1456958599&amp;do=diff">
        <dc:format>text/html</dc:format>
        <dc:date>2016-03-03T00:43:19+02:00</dc:date>
        <title>Articol 02 - Struct vs. Class. Constructori</title>
        <link>http://ocw.cs.pub.ro/courses/sd-ca/articole/articol-02?rev=1456958599&amp;do=diff</link>
        <description>Obiective

În urma parcurgerii acestui articol studentul va: 

	*  învăța ce înseamnă o clasă
	*  învăța ce înseamnă constructor / destructor
	*  afla funcționalitățile claselor / funcțiilor prietene
	*  realiza supraîncărcarea operatorilor din C++
	*  înțelege conceptul de copy constructor
	*  înțelege conceptul de rule of three</description>
    </item>
    <item rdf:about="http://ocw.cs.pub.ro/courses/sd-ca/articole/articol-03?rev=1456382212&amp;do=diff">
        <dc:format>text/html</dc:format>
        <dc:date>2016-02-25T08:36:52+02:00</dc:date>
        <title>Articol 03 - Templates in C++</title>
        <link>http://ocw.cs.pub.ro/courses/sd-ca/articole/articol-03?rev=1456382212&amp;do=diff</link>
        <description>Obiective

În urma parcurgerii acestui articol studentul va:

	*  înțelege conceptul de template

Templates

Motivul principal pentru care folosim C++ în cadrul SD este datorită funcționalității oferite de template-uri.

Acestea permit generalizarea tipurilor de date folosite în interiorul funcțiilor și claselor.</description>
    </item>
    <item rdf:about="http://ocw.cs.pub.ro/courses/sd-ca/articole/articol-04?rev=1457615922&amp;do=diff">
        <dc:format>text/html</dc:format>
        <dc:date>2016-03-10T15:18:42+02:00</dc:date>
        <title>Articol 4 - Stive</title>
        <link>http://ocw.cs.pub.ro/courses/sd-ca/articole/articol-04?rev=1457615922&amp;do=diff</link>
        <description>Obiective

În urma parcurgerii acestui articol studentul va fi capabil să:

	* înțeleagă principiul de funcționare al unei stive
	* implementeze o stivă folosind un vector pentru stocarea elementelor

Ce este o stivă?

O stivă este o instanță a unui tip de date abstract ce formalizează conceptul de colecţie cu acces restricționat. Restricția respectă regula LIFO (Last In, First Out).</description>
    </item>
    <item rdf:about="http://ocw.cs.pub.ro/courses/sd-ca/articole/articol-05?rev=1457616121&amp;do=diff">
        <dc:format>text/html</dc:format>
        <dc:date>2016-03-10T15:22:01+02:00</dc:date>
        <title>Articol 5 - Cozi</title>
        <link>http://ocw.cs.pub.ro/courses/sd-ca/articole/articol-05?rev=1457616121&amp;do=diff</link>
        <description>Obiective

În urma parcurgerii acestui articol studentul va fi capabil să:

	* înțeleagă principiul de funcționare al unei cozi
	* implementeze o coadă folosind un vector pentru stocarea elementelor
	* implementeze algoritmul de sortare Radix Sort</description>
    </item>
    <item rdf:about="http://ocw.cs.pub.ro/courses/sd-ca/articole/articol-06?rev=1457616074&amp;do=diff">
        <dc:format>text/html</dc:format>
        <dc:date>2016-03-10T15:21:14+02:00</dc:date>
        <title>Articol 6 - Liste generice</title>
        <link>http://ocw.cs.pub.ro/courses/sd-ca/articole/articol-06?rev=1457616074&amp;do=diff</link>
        <description>Obiective

În urma parcurgerii acestui articol studentul va fi capabil:

	* să înţeleagă structura tipului de date listă.
	* să descrie şi să folosească diversele implementări ale TAD listă.
	* să folosească în aplicaţii structura de date listă (să descrie soluţia unor aplicaţii ce folosesc liste pentru modelarea datelor utilizate).
	* sa implementeze structurile studiate folosind liste.</description>
    </item>
    <item rdf:about="http://ocw.cs.pub.ro/courses/sd-ca/articole/articol-07?rev=1458213070&amp;do=diff">
        <dc:format>text/html</dc:format>
        <dc:date>2016-03-17T13:11:10+02:00</dc:date>
        <title>Articol 7 - HashTable</title>
        <link>http://ocw.cs.pub.ro/courses/sd-ca/articole/articol-07?rev=1458213070&amp;do=diff</link>
        <description>Obiective

În urma parcurgerii acestui articol studentul va fi capabil să:

	* definească tipul de date dicționar
	* implementeze un dicționar folosind tabele de dispersie
	* prezinte avantaje / dezavataje ale diverselor implementări de dicționare</description>
    </item>
    <item rdf:about="http://ocw.cs.pub.ro/courses/sd-ca/articole/articol-08?rev=1461163997&amp;do=diff">
        <dc:format>text/html</dc:format>
        <dc:date>2016-04-20T17:53:17+02:00</dc:date>
        <title>Articol 08 - Grafuri</title>
        <link>http://ocw.cs.pub.ro/courses/sd-ca/articole/articol-08?rev=1461163997&amp;do=diff</link>
        <description>Obiective

În urma parcurgerii acestui laborator, studentul va fi capabil să:

	*  înțeleagă operațiile de parcurgere a grafurilor și diferențele dintre ele.
	*  implementeze parcurgerile pe grafuri având la dispoziție structurile de date studiate.
	*  evalueze complexitatea parcurgerii grafurilor.
	*  găsească soluțiile unor probleme folosind algoritmii de parcurgere</description>
    </item>
    <item rdf:about="http://ocw.cs.pub.ro/courses/sd-ca/articole/articol-09?rev=1461343200&amp;do=diff">
        <dc:format>text/html</dc:format>
        <dc:date>2016-04-22T19:40:00+02:00</dc:date>
        <title>Articol 09 - Arbori Binari</title>
        <link>http://ocw.cs.pub.ro/courses/sd-ca/articole/articol-09?rev=1461343200&amp;do=diff</link>
        <description>Obiective

În urma parcurgerii articolului, studentul va fi capabil să:

	* înţeleagă noţiunea de arbore şi structura unui arbore binar
	* construiască, în limbajul C++, un arbore binar
	* realizeze o parcurgere a structurii de date prin mai multe moduri
	* citească o expresie matematică şi să-i construiască arborele binar asociat
	* evalueze o expresie matematică dată printr-un arbore binar.</description>
    </item>
    <item rdf:about="http://ocw.cs.pub.ro/courses/sd-ca/articole/articol-10?rev=1462442870&amp;do=diff">
        <dc:format>text/html</dc:format>
        <dc:date>2016-05-05T13:07:50+02:00</dc:date>
        <title>Articol 10 - Arbori Binari de Căutare</title>
        <link>http://ocw.cs.pub.ro/courses/sd-ca/articole/articol-10?rev=1462442870&amp;do=diff</link>
        <description>Obiective

În urma parcurgerii articolului, studentul va fi capabil să:

	* înţeleagă structura şi proprietățile unui arbore binar de căutare
	* construiască, în limbajul C++, un arbore binar de căutare
	* realizeze o parcurgere a structurii de date prin mai multe moduri
	* realizeze diferite operaţii folosind arborii binari de căutare</description>
    </item>
    <item rdf:about="http://ocw.cs.pub.ro/courses/sd-ca/articole/articol-11?rev=1462444212&amp;do=diff">
        <dc:format>text/html</dc:format>
        <dc:date>2016-05-05T13:30:12+02:00</dc:date>
        <title>Articol 11 - Heap-uri</title>
        <link>http://ocw.cs.pub.ro/courses/sd-ca/articole/articol-11?rev=1462444212&amp;do=diff</link>
        <description>Obiective

În urma parcurgerii acestui articol, studentul va fi capabil să:

	*  înţeleagă diferitele moduri de reprezentare a arborilor;
	*  definească proprietăţile structurii de heap;
	*  implementeze operaţii de inserare, ştergere şi căutare care să păstreze proprietatea de heap;
	*  folosească heap-ul pentru a implementa o metodă de sortare eficientă.</description>
    </item>
    <item rdf:about="http://ocw.cs.pub.ro/courses/sd-ca/articole/articol-12?rev=1461343632&amp;do=diff">
        <dc:format>text/html</dc:format>
        <dc:date>2016-04-22T19:47:12+02:00</dc:date>
        <title>Articol 12 - Arbori binari de căutare echilibrați. Treapuri.</title>
        <link>http://ocw.cs.pub.ro/courses/sd-ca/articole/articol-12?rev=1461343632&amp;do=diff</link>
        <description>Obiective

În urma parcurgerii acestui articol studentul va: 

	*  înțelege conceptul unui arbore echilibrat de căutare
	*  exemplifica acest concept pe structura de treap
	*  implementa operațiile de adăugare nod, ștergere nod și rotiri 
	*  face operații mai complexe si parcurgri de treapuri</description>
    </item>
    <item rdf:about="http://ocw.cs.pub.ro/courses/sd-ca/articole/tutorial-01-1?rev=1456313196&amp;do=diff">
        <dc:format>text/html</dc:format>
        <dc:date>2016-02-24T13:26:36+02:00</dc:date>
        <title>Tutorial 1.1 - ResizableArray</title>
        <link>http://ocw.cs.pub.ro/courses/sd-ca/articole/tutorial-01-1?rev=1456313196&amp;do=diff</link>
        <description>In acest tutorial, ne propunem sa construim o structura de tip Array capabil sa se redimensioneze automat atunci cand se umple.

Obiective

Ne dorim:

	*  să construim struct ResizableArray, cu un membru astfel încât să poată reține un vector de elemente de tip int, cu o dimensiune initiala specificata printr-un define
	*  să adaugam lui struct ResizableArray o metodă de adăugare a unui element nou. Dacă vectorul intern este deja plin, se va aloca un nou vector de dimensiune dublă, se va copia c…</description>
    </item>
    <item rdf:about="http://ocw.cs.pub.ro/courses/sd-ca/articole/tutorial-02-1?rev=1456959738&amp;do=diff">
        <dc:format>text/html</dc:format>
        <dc:date>2016-03-03T01:02:18+02:00</dc:date>
        <title>Tutorial 2.1 - Point2D</title>
        <link>http://ocw.cs.pub.ro/courses/sd-ca/articole/tutorial-02-1?rev=1456959738&amp;do=diff</link>
        <description>În acest tutorial, ne propunem să construim o structură de tip Point2D capabil să rețină coordonatele unui punct în plan și să permită anumite prelucrări pe un set de puncte.

Obiective

Ne dorim:

	*  să construim class Point2D, cu doi membri de tip double astfel încât să poată memora cele două coordonate
	*  să adaugam lui class Point2D o metode de tip SETTER/GETTER pentru a putea accesa/modifica coordonatele unui punct
	*  să adaugam si alte functionalitati lui class Point2D, precum posibilit…</description>
    </item>
    <item rdf:about="http://ocw.cs.pub.ro/courses/sd-ca/articole/tutorial-03-1?rev=1457560417&amp;do=diff">
        <dc:format>text/html</dc:format>
        <dc:date>2016-03-09T23:53:37+02:00</dc:date>
        <title>Tutorial 3.1 - Set</title>
        <link>http://ocw.cs.pub.ro/courses/sd-ca/articole/tutorial-03-1?rev=1457560417&amp;do=diff</link>
        <description>In acest tutorial, ne propunem sa construim o structura generica Set (multime in sens matematic) capabil sa se redimensioneze automat atunci cand se umple si sa retina numai elemente unice.

GSoC

Google Summer of Code este un program de vară în care studenții
(indiferent de anul de studiu) sunt implicați în proiecte Open Source
pentru a își dezvolta skill-urile de programare, fiind răsplătiți cu o
bursă în valoare totală de 5500$.
&lt;https://developers.google.com/open-source/gsoc/&gt;
UPB se află în…</description>
    </item>
    <item rdf:about="http://ocw.cs.pub.ro/courses/sd-ca/articole/tutorial-04-1?rev=1457608442&amp;do=diff">
        <dc:format>text/html</dc:format>
        <dc:date>2016-03-10T13:14:02+02:00</dc:date>
        <title>Tutorial 4.1 - std::stack</title>
        <link>http://ocw.cs.pub.ro/courses/sd-ca/articole/tutorial-04-1?rev=1457608442&amp;do=diff</link>
        <description>Obiective

Ne dorim:

	*  să arătăm funcționalitățile unei stive

std::stack

În acest tutorial vom folosi clasa std::stack din STL. Pentru mai multe detalii, vă sugerăm să citiți documentația oficială (stack).

Atenție! Este nevoie să includem biblioteca stack.</description>
    </item>
    <item rdf:about="http://ocw.cs.pub.ro/courses/sd-ca/articole/tutorial-04-2?rev=1457611066&amp;do=diff">
        <dc:format>text/html</dc:format>
        <dc:date>2016-03-10T13:57:46+02:00</dc:date>
        <title>Tutorial 4.2 - Parenthesis pair matching</title>
        <link>http://ocw.cs.pub.ro/courses/sd-ca/articole/tutorial-04-2?rev=1457611066&amp;do=diff</link>
        <description>Obiective

Ne dorim:

	*  să arătăm funcționalitățile unei stive
	*  să verific dacă un șir este corect parantezat

Parenthesis pair matching

Verificati daca un sir format doar din paranteze rotunde este valid (parantezare corecta).

Pentru a rezolva această problemă, propunem implementarea unei funcții valid, care primește un string format doar din paranteze rotunde și returnează true dacă șirul este corect parantezat.</description>
    </item>
    <item rdf:about="http://ocw.cs.pub.ro/courses/sd-ca/articole/tutorial-04-3?rev=1457610607&amp;do=diff">
        <dc:format>text/html</dc:format>
        <dc:date>2016-03-10T13:50:07+02:00</dc:date>
        <title>Tutorial 4.3 - Polish notation</title>
        <link>http://ocw.cs.pub.ro/courses/sd-ca/articole/tutorial-04-3?rev=1457610607&amp;do=diff</link>
        <description>Obiective

În urma parcurgerii acestui articol studentul va fi capabil să:

	* înțeleagă principiul de funcționare al unei stive
	* evalueze o expresie in forma poloneza inversa

Forma poloneză inversă (formă postfixată)

Forma poloneză inversă este o notație matematică în care fiecare operator urmează dupa toți operanzii săi.</description>
    </item>
    <item rdf:about="http://ocw.cs.pub.ro/courses/sd-ca/articole/tutorial-05-1?rev=1457609295&amp;do=diff">
        <dc:format>text/html</dc:format>
        <dc:date>2016-03-10T13:28:15+02:00</dc:date>
        <title>Tutorial 5.1 - std::queue</title>
        <link>http://ocw.cs.pub.ro/courses/sd-ca/articole/tutorial-05-1?rev=1457609295&amp;do=diff</link>
        <description>Obiective

Ne dorim:

	*  să arătăm funcționalitățile unei cozi

std::queue

În acest tutorial vom folosi clasa std::queue din STL. Pentru mai multe detalii, vă sugerăm să citiți documentația oficială (std::queue,std::deque).

Atenție! Este nevoie să includem biblioteca queue.</description>
    </item>
    <item rdf:about="http://ocw.cs.pub.ro/courses/sd-ca/articole/tutorial-05-2?rev=1457613764&amp;do=diff">
        <dc:format>text/html</dc:format>
        <dc:date>2016-03-10T14:42:44+02:00</dc:date>
        <title>Tutorial 5.2 - Radix Sort</title>
        <link>http://ocw.cs.pub.ro/courses/sd-ca/articole/tutorial-05-2?rev=1457613764&amp;do=diff</link>
        <description>Obiective

Ne dorim:

	*  să arătăm funcționalitățile unei cozi
	*  să implementăm algoritmul Radix Sort

Radix Sort

Radix Sort este un algoritm de sortare care ţine cont de cifre individuale ale elementelor sortate. Aceste elemente pot fi nu doar numere, ci orice altceva ce se poate reprezenta prin întregi. Majoritatea calculatoarelor digitale reprezintă datele în memorie sub formă de numere binare, astfel că procesarea cifrelor din această reprezentare se dovedeşte a fi cea mai convenabilă. E…</description>
    </item>
    <item rdf:about="http://ocw.cs.pub.ro/courses/sd-ca/articole/tutorial-05-3?rev=1457610686&amp;do=diff">
        <dc:format>text/html</dc:format>
        <dc:date>2016-03-10T13:51:26+02:00</dc:date>
        <title>Tutorial 5.3 - Palindrome check</title>
        <link>http://ocw.cs.pub.ro/courses/sd-ca/articole/tutorial-05-3?rev=1457610686&amp;do=diff</link>
        <description>Obiective

Ne dorim:

	*  să arătăm funcționalitățile unui deque
	*  să verifice dacă un număr este palindrom

Palindrome check</description>
    </item>
    <item rdf:about="http://ocw.cs.pub.ro/courses/sd-ca/articole/tutorial-06-1?rev=1459319700&amp;do=diff">
        <dc:format>text/html</dc:format>
        <dc:date>2016-03-30T09:35:00+02:00</dc:date>
        <title>Tutorial 6.1 - std::list</title>
        <link>http://ocw.cs.pub.ro/courses/sd-ca/articole/tutorial-06-1?rev=1459319700&amp;do=diff</link>
        <description>Obiective

Ne dorim:

	*  să arătăm funcționalitățile unei liste
	*  să folosim algoritmul InsertionSort pentru a sorta o listă

std::list

În acest tutorial vom folosi clasa std::list din STL. Pentru mai multe detalii, vă sugerăm să citiți documentația oficială (list).</description>
    </item>
    <item rdf:about="http://ocw.cs.pub.ro/courses/sd-ca/articole/tutorial-06-2?rev=1459319546&amp;do=diff">
        <dc:format>text/html</dc:format>
        <dc:date>2016-03-30T09:32:26+02:00</dc:date>
        <title>Tutorial 6.2 - Set</title>
        <link>http://ocw.cs.pub.ro/courses/sd-ca/articole/tutorial-06-2?rev=1459319546&amp;do=diff</link>
        <description>Obiective

Ne dorim:

	*  să implementăm o structură de tip Set folosind std::list

SetList.h

Vom crea o clasă SetList cu următoarele funcționalități:

	*  empty - true dacă set-ul este gol
	*  size - dimensiunea set-ului
	*  add - adaugă un element în set dacă nu este deja adăugat (returnează true dacă elementul va fi adăugat)
	*  remove - elimină un element din set dacă există (returnează true dacă elementul va fi eliminat)
	*  print - afișează lista</description>
    </item>
    <item rdf:about="http://ocw.cs.pub.ro/courses/sd-ca/articole/tutorial-07-1?rev=1457636520&amp;do=diff">
        <dc:format>text/html</dc:format>
        <dc:date>2016-03-10T21:02:00+02:00</dc:date>
        <title>Tutorial 7.1 - Frequency vector</title>
        <link>http://ocw.cs.pub.ro/courses/sd-ca/articole/tutorial-07-1?rev=1457636520&amp;do=diff</link>
        <description>Frequency vector

Ne dorim:

	*  să arătăm funcționalitățile unui HashTable
	*  să simulăm funcționalitățile unui vector de frecvență

Frequency vector

În acest tutorial vom folosi clasa std::map din STL. Pentru mai multe detalii, vă sugerăm să citiți documentația oficială ( std::map).</description>
    </item>
    <item rdf:about="http://ocw.cs.pub.ro/courses/sd-ca/articole/tutorial-11-1?rev=1462454588&amp;do=diff">
        <dc:format>text/html</dc:format>
        <dc:date>2016-05-05T16:23:08+02:00</dc:date>
        <title>Tutorial 11.1 - std::priority_queue</title>
        <link>http://ocw.cs.pub.ro/courses/sd-ca/articole/tutorial-11-1?rev=1462454588&amp;do=diff</link>
        <description>Obiective

Ne dorim:

	*  să arătăm funcționalitățile unui heap binar

std::queue

În acest tutorial vom folosi clasa std::priority_queue din STL. Pentru mai multe detalii, vă sugerăm să citiți documentația oficială (std::priority_queue).</description>
    </item>
    <item rdf:about="http://ocw.cs.pub.ro/courses/sd-ca/articole/tutorial-11-2?rev=1462467676&amp;do=diff">
        <dc:format>text/html</dc:format>
        <dc:date>2016-05-05T20:01:16+02:00</dc:date>
        <title>Tutorial 11.2 - Smallest/Largest K Elements</title>
        <link>http://ocw.cs.pub.ro/courses/sd-ca/articole/tutorial-11-2?rev=1462467676&amp;do=diff</link>
        <description>Obiective

Ne dorim:

	*  să arătăm funcționalitățile unei heap
	*  să găsim cele mai mici/mari k elemente dintr-o mulțime de elemente

Smallest/Largest K Elements

Se consideră un flux (fișier) foarte mare care conține N numere pe 32 biți (N &lt;= 10^9). Se cere să se afișeze pe ecran cele mai mici K elemente din flux (K &lt;= 1000). Se presupune că întotdeauna K &lt;= N. Cele K elemente se pot afișa în orice ordine.</description>
    </item>
    <item rdf:about="http://ocw.cs.pub.ro/courses/sd-ca/articole/tutorial-11-3?rev=1462455020&amp;do=diff">
        <dc:format>text/html</dc:format>
        <dc:date>2016-05-05T16:30:20+02:00</dc:date>
        <title>Tutorial 11.3 - HeapSort</title>
        <link>http://ocw.cs.pub.ro/courses/sd-ca/articole/tutorial-11-3?rev=1462455020&amp;do=diff</link>
        <description>Obiective

Ne dorim:

	*  să arătăm funcționalitățile unei heap
	*  să folosim algoritmul HeapSort pentru a sorta o mulțime de numere

HeapSort

Un algoritm de sortare eficient este HeapSort. Acesta se foloseste de un heap, în care se inserează inițial toate elementele. Ulterior elementele sunt scoase, obținându-se o listă sortată.</description>
    </item>
</rdf:RDF>
